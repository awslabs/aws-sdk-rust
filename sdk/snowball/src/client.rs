// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn cancel_cluster(&self) -> fluent_builders::CancelCluster<C> {
        fluent_builders::CancelCluster::new(self.handle.clone())
    }
    pub fn cancel_job(&self) -> fluent_builders::CancelJob<C> {
        fluent_builders::CancelJob::new(self.handle.clone())
    }
    pub fn create_address(&self) -> fluent_builders::CreateAddress<C> {
        fluent_builders::CreateAddress::new(self.handle.clone())
    }
    pub fn create_cluster(&self) -> fluent_builders::CreateCluster<C> {
        fluent_builders::CreateCluster::new(self.handle.clone())
    }
    pub fn create_job(&self) -> fluent_builders::CreateJob<C> {
        fluent_builders::CreateJob::new(self.handle.clone())
    }
    pub fn create_long_term_pricing(&self) -> fluent_builders::CreateLongTermPricing<C> {
        fluent_builders::CreateLongTermPricing::new(self.handle.clone())
    }
    pub fn create_return_shipping_label(&self) -> fluent_builders::CreateReturnShippingLabel<C> {
        fluent_builders::CreateReturnShippingLabel::new(self.handle.clone())
    }
    pub fn describe_address(&self) -> fluent_builders::DescribeAddress<C> {
        fluent_builders::DescribeAddress::new(self.handle.clone())
    }
    pub fn describe_addresses(&self) -> fluent_builders::DescribeAddresses<C> {
        fluent_builders::DescribeAddresses::new(self.handle.clone())
    }
    pub fn describe_cluster(&self) -> fluent_builders::DescribeCluster<C> {
        fluent_builders::DescribeCluster::new(self.handle.clone())
    }
    pub fn describe_job(&self) -> fluent_builders::DescribeJob<C> {
        fluent_builders::DescribeJob::new(self.handle.clone())
    }
    pub fn describe_return_shipping_label(
        &self,
    ) -> fluent_builders::DescribeReturnShippingLabel<C> {
        fluent_builders::DescribeReturnShippingLabel::new(self.handle.clone())
    }
    pub fn get_job_manifest(&self) -> fluent_builders::GetJobManifest<C> {
        fluent_builders::GetJobManifest::new(self.handle.clone())
    }
    pub fn get_job_unlock_code(&self) -> fluent_builders::GetJobUnlockCode<C> {
        fluent_builders::GetJobUnlockCode::new(self.handle.clone())
    }
    pub fn get_snowball_usage(&self) -> fluent_builders::GetSnowballUsage<C> {
        fluent_builders::GetSnowballUsage::new(self.handle.clone())
    }
    pub fn get_software_updates(&self) -> fluent_builders::GetSoftwareUpdates<C> {
        fluent_builders::GetSoftwareUpdates::new(self.handle.clone())
    }
    pub fn list_cluster_jobs(&self) -> fluent_builders::ListClusterJobs<C> {
        fluent_builders::ListClusterJobs::new(self.handle.clone())
    }
    pub fn list_clusters(&self) -> fluent_builders::ListClusters<C> {
        fluent_builders::ListClusters::new(self.handle.clone())
    }
    pub fn list_compatible_images(&self) -> fluent_builders::ListCompatibleImages<C> {
        fluent_builders::ListCompatibleImages::new(self.handle.clone())
    }
    pub fn list_jobs(&self) -> fluent_builders::ListJobs<C> {
        fluent_builders::ListJobs::new(self.handle.clone())
    }
    pub fn list_long_term_pricing(&self) -> fluent_builders::ListLongTermPricing<C> {
        fluent_builders::ListLongTermPricing::new(self.handle.clone())
    }
    pub fn update_cluster(&self) -> fluent_builders::UpdateCluster<C> {
        fluent_builders::UpdateCluster::new(self.handle.clone())
    }
    pub fn update_job(&self) -> fluent_builders::UpdateJob<C> {
        fluent_builders::UpdateJob::new(self.handle.clone())
    }
    pub fn update_job_shipment_state(&self) -> fluent_builders::UpdateJobShipmentState<C> {
        fluent_builders::UpdateJobShipmentState::new(self.handle.clone())
    }
    pub fn update_long_term_pricing(&self) -> fluent_builders::UpdateLongTermPricing<C> {
        fluent_builders::UpdateLongTermPricing::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CancelCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_cluster_input::Builder,
    }
    impl<C> CancelCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelClusterOutput,
            smithy_http::result::SdkError<crate::error::CancelClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The 39-character ID for the cluster that you want to cancel, for example
        /// <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(input);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_job_input::Builder,
    }
    impl<C> CancelJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelJobOutput,
            smithy_http::result::SdkError<crate::error::CancelJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The 39-character job ID for the job that you want to cancel, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAddress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_address_input::Builder,
    }
    impl<C> CreateAddress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAddressOutput,
            smithy_http::result::SdkError<crate::error::CreateAddressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The address that you want the Snow device shipped to.</p>
        pub fn address(mut self, input: crate::model::Address) -> Self {
            self.inner = self.inner.address(input);
            self
        }
        pub fn set_address(mut self, input: std::option::Option<crate::model::Address>) -> Self {
            self.inner = self.inner.set_address(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_cluster_input::Builder,
    }
    impl<C> CreateCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateClusterOutput,
            smithy_http::result::SdkError<crate::error::CreateClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of job for this cluster. Currently, the only job type supported for clusters
        /// is <code>LOCAL_USE</code>.</p>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn job_type(mut self, input: crate::model::JobType) -> Self {
            self.inner = self.inner.job_type(input);
            self
        }
        pub fn set_job_type(mut self, input: std::option::Option<crate::model::JobType>) -> Self {
            self.inner = self.inner.set_job_type(input);
            self
        }
        /// <p>The resources associated with the cluster job. These resources include Amazon S3
        /// buckets and optional AWS Lambda functions written in the Python language. </p>
        pub fn resources(mut self, input: crate::model::JobResource) -> Self {
            self.inner = self.inner.resources(input);
            self
        }
        pub fn set_resources(
            mut self,
            input: std::option::Option<crate::model::JobResource>,
        ) -> Self {
            self.inner = self.inner.set_resources(input);
            self
        }
        /// <p>Specifies the service or services on the Snow Family device that your
        /// transferred data will be exported from or imported into. AWS Snow Family supports Amazon S3 and NFS (Network File System).</p>
        pub fn on_device_service_configuration(
            mut self,
            input: crate::model::OnDeviceServiceConfiguration,
        ) -> Self {
            self.inner = self.inner.on_device_service_configuration(input);
            self
        }
        pub fn set_on_device_service_configuration(
            mut self,
            input: std::option::Option<crate::model::OnDeviceServiceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_on_device_service_configuration(input);
            self
        }
        /// <p>An optional description of this specific cluster, for example <code>Environmental Data
        /// Cluster-01</code>.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The ID for the address that you want the cluster shipped to.</p>
        pub fn address_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address_id(input);
            self
        }
        pub fn set_address_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_address_id(input);
            self
        }
        /// <p>The <code>KmsKeyARN</code> value that you want to associate with this cluster.
        /// <code>KmsKeyARN</code> values are created by using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> API action in AWS Key
        /// Management Service (AWS KMS). </p>
        pub fn kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_arn(input);
            self
        }
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_arn(input);
            self
        }
        /// <p>The <code>RoleARN</code> that you want to associate with this cluster.
        /// <code>RoleArn</code> values are created by using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> API action in AWS
        /// Identity and Access Management (IAM).</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The type of AWS Snow Family device to use for this cluster.
        /// </p>
        /// <note>
        /// <p>For cluster jobs, AWS Snow Family currently supports only the <code>EDGE</code> device type.</p>
        /// </note>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn snowball_type(mut self, input: crate::model::SnowballType) -> Self {
            self.inner = self.inner.snowball_type(input);
            self
        }
        pub fn set_snowball_type(
            mut self,
            input: std::option::Option<crate::model::SnowballType>,
        ) -> Self {
            self.inner = self.inner.set_snowball_type(input);
            self
        }
        /// <p>The shipping speed for each node in this cluster. This speed doesn't dictate how soon
        /// you'll get each Snowball Edge device, rather it represents how quickly each device moves to
        /// its destination while in transit. Regional shipping speeds are as follows:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>In Australia, you have access to express shipping. Typically, Snow devices shipped
        /// express are delivered in about a day.</p>
        /// </li>
        /// <li>
        /// <p>In the European Union (EU), you have access to express shipping. Typically,
        /// Snow devices shipped express are delivered in about a day. In addition, most countries in the
        /// EU have access to standard shipping, which typically takes less than a week, one
        /// way.</p>
        /// </li>
        /// <li>
        /// <p>In India, Snow devices are delivered in one to seven days.</p>
        /// </li>
        /// <li>
        /// <p>In the United States of America (US), you have access to one-day shipping and
        /// two-day shipping.</p>
        /// </li>
        /// </ul>
        /// <ul>
        /// <li>
        /// <p>In Australia, you have access to express shipping. Typically, devices shipped
        /// express are delivered in about a day.</p>
        /// </li>
        /// <li>
        /// <p>In the European Union (EU), you have access to express shipping. Typically,
        /// Snow devices shipped express are delivered in about a day. In addition, most countries
        /// in the EU have access to standard shipping, which typically takes less than a week, one
        /// way.</p>
        /// </li>
        /// <li>
        /// <p>In India, Snow devices are delivered in one to seven days.</p>
        /// </li>
        /// <li>
        /// <p>In the US, you have access to one-day shipping and two-day shipping.</p>
        /// </li>
        /// </ul>
        pub fn shipping_option(mut self, input: crate::model::ShippingOption) -> Self {
            self.inner = self.inner.shipping_option(input);
            self
        }
        pub fn set_shipping_option(
            mut self,
            input: std::option::Option<crate::model::ShippingOption>,
        ) -> Self {
            self.inner = self.inner.set_shipping_option(input);
            self
        }
        /// <p>The Amazon Simple Notification Service (Amazon SNS) notification settings for this
        /// cluster.</p>
        pub fn notification(mut self, input: crate::model::Notification) -> Self {
            self.inner = self.inner.notification(input);
            self
        }
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::Notification>,
        ) -> Self {
            self.inner = self.inner.set_notification(input);
            self
        }
        /// <p>The forwarding address ID for a cluster. This field is not supported in most
        /// regions.</p>
        pub fn forwarding_address_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.forwarding_address_id(input);
            self
        }
        pub fn set_forwarding_address_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_forwarding_address_id(input);
            self
        }
        /// <p>The tax documents required in your AWS Region.</p>
        pub fn tax_documents(mut self, input: crate::model::TaxDocuments) -> Self {
            self.inner = self.inner.tax_documents(input);
            self
        }
        pub fn set_tax_documents(
            mut self,
            input: std::option::Option<crate::model::TaxDocuments>,
        ) -> Self {
            self.inner = self.inner.set_tax_documents(input);
            self
        }
        /// <p>Allows you to securely operate and manage Snow devices in a cluster remotely from outside
        /// of your internal network. When set to <code>INSTALLED_AUTOSTART</code>, remote management will
        /// automatically be available when the device arrives at your location. Otherwise, you need to
        /// use the Snowball Client to manage the device.</p>
        pub fn remote_management(mut self, input: crate::model::RemoteManagement) -> Self {
            self.inner = self.inner.remote_management(input);
            self
        }
        pub fn set_remote_management(
            mut self,
            input: std::option::Option<crate::model::RemoteManagement>,
        ) -> Self {
            self.inner = self.inner.set_remote_management(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_job_input::Builder,
    }
    impl<C> CreateJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateJobOutput,
            smithy_http::result::SdkError<crate::error::CreateJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Defines the type of job that you're creating.
        /// </p>
        pub fn job_type(mut self, input: crate::model::JobType) -> Self {
            self.inner = self.inner.job_type(input);
            self
        }
        pub fn set_job_type(mut self, input: std::option::Option<crate::model::JobType>) -> Self {
            self.inner = self.inner.set_job_type(input);
            self
        }
        /// <p>Defines the Amazon S3 buckets associated with this job.</p>
        /// <p>With <code>IMPORT</code> jobs, you specify the bucket or buckets that your transferred
        /// data will be imported into.</p>
        /// <p>With <code>EXPORT</code> jobs, you specify the bucket or buckets that your transferred
        /// data will be exported from. Optionally, you can also specify a <code>KeyRange</code> value. If
        /// you choose to export a range, you define the length of the range by providing either an
        /// inclusive <code>BeginMarker</code> value, an inclusive <code>EndMarker</code> value, or both.
        /// Ranges are UTF-8 binary sorted.</p>
        pub fn resources(mut self, input: crate::model::JobResource) -> Self {
            self.inner = self.inner.resources(input);
            self
        }
        pub fn set_resources(
            mut self,
            input: std::option::Option<crate::model::JobResource>,
        ) -> Self {
            self.inner = self.inner.set_resources(input);
            self
        }
        /// <p>Specifies the service or services on the Snow Family device that your
        /// transferred data will be exported from or imported into. AWS Snow Family supports Amazon S3 and NFS (Network File System).</p>
        pub fn on_device_service_configuration(
            mut self,
            input: crate::model::OnDeviceServiceConfiguration,
        ) -> Self {
            self.inner = self.inner.on_device_service_configuration(input);
            self
        }
        pub fn set_on_device_service_configuration(
            mut self,
            input: std::option::Option<crate::model::OnDeviceServiceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_on_device_service_configuration(input);
            self
        }
        /// <p>Defines an optional description of this specific job, for example <code>Important
        /// Photos 2016-08-11</code>.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The ID for the address that you want the Snow device shipped to.</p>
        pub fn address_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address_id(input);
            self
        }
        pub fn set_address_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_address_id(input);
            self
        }
        /// <p>The <code>KmsKeyARN</code> that you want to associate with this job.
        /// <code>KmsKeyARN</code>s are created using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> AWS Key Management
        /// Service (KMS) API action.</p>
        pub fn kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_arn(input);
            self
        }
        pub fn set_kms_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_arn(input);
            self
        }
        /// <p>The <code>RoleARN</code> that you want to associate with this job.
        /// <code>RoleArn</code>s are created using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> AWS Identity and
        /// Access Management (IAM) API action.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>If your job is being created in one of the US regions, you have the option of
        /// specifying what size Snow device you'd like for this job. In all other regions, Snowballs come
        /// with 80 TB in storage capacity.</p>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn snowball_capacity_preference(
            mut self,
            input: crate::model::SnowballCapacity,
        ) -> Self {
            self.inner = self.inner.snowball_capacity_preference(input);
            self
        }
        pub fn set_snowball_capacity_preference(
            mut self,
            input: std::option::Option<crate::model::SnowballCapacity>,
        ) -> Self {
            self.inner = self.inner.set_snowball_capacity_preference(input);
            self
        }
        /// <p>The shipping speed for this job. This speed doesn't dictate how soon you'll get the
        /// Snow device, rather it represents how quickly the Snow device moves to its destination while in
        /// transit. Regional shipping speeds are as follows:</p>
        /// <ul>
        /// <li>
        /// <p>In Australia, you have access to express shipping. Typically, Snow devices shipped
        /// express are delivered in about a day.</p>
        /// </li>
        /// <li>
        /// <p>In the European Union (EU), you have access to express shipping. Typically,
        /// Snow devices shipped express are delivered in about a day. In addition, most countries in the
        /// EU have access to standard shipping, which typically takes less than a week, one
        /// way.</p>
        /// </li>
        /// <li>
        /// <p>In India, Snow devices are delivered in one to seven days.</p>
        /// </li>
        /// <li>
        /// <p>In the US, you have access to one-day shipping and two-day shipping.</p>
        /// </li>
        /// </ul>
        pub fn shipping_option(mut self, input: crate::model::ShippingOption) -> Self {
            self.inner = self.inner.shipping_option(input);
            self
        }
        pub fn set_shipping_option(
            mut self,
            input: std::option::Option<crate::model::ShippingOption>,
        ) -> Self {
            self.inner = self.inner.set_shipping_option(input);
            self
        }
        /// <p>Defines the Amazon Simple Notification Service (Amazon SNS) notification settings for
        /// this job.</p>
        pub fn notification(mut self, input: crate::model::Notification) -> Self {
            self.inner = self.inner.notification(input);
            self
        }
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::Notification>,
        ) -> Self {
            self.inner = self.inner.set_notification(input);
            self
        }
        /// <p>The ID of a cluster. If you're creating a job for a node in a cluster, you need to
        /// provide only this <code>clusterId</code> value. The other job attributes are inherited from
        /// the cluster.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(input);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
        /// <p>The type of AWS Snow Family device to use for this job.
        /// </p>
        /// <note>
        /// <p>For cluster jobs, AWS Snow Family currently supports only the <code>EDGE</code> device type.</p>
        /// </note>
        /// <p>The type of AWS Snow device to use for this job. Currently, the only supported
        /// device type for cluster jobs is <code>EDGE</code>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/snowball/latest/developer-guide/device-differences.html">Snowball Edge Device
        /// Options</a> in the Snowball Edge Developer Guide.</p>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn snowball_type(mut self, input: crate::model::SnowballType) -> Self {
            self.inner = self.inner.snowball_type(input);
            self
        }
        pub fn set_snowball_type(
            mut self,
            input: std::option::Option<crate::model::SnowballType>,
        ) -> Self {
            self.inner = self.inner.set_snowball_type(input);
            self
        }
        /// <p>The forwarding address ID for a job. This field is not supported in most
        /// Regions.</p>
        pub fn forwarding_address_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.forwarding_address_id(input);
            self
        }
        pub fn set_forwarding_address_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_forwarding_address_id(input);
            self
        }
        /// <p>The tax documents required in your AWS Region.</p>
        pub fn tax_documents(mut self, input: crate::model::TaxDocuments) -> Self {
            self.inner = self.inner.tax_documents(input);
            self
        }
        pub fn set_tax_documents(
            mut self,
            input: std::option::Option<crate::model::TaxDocuments>,
        ) -> Self {
            self.inner = self.inner.set_tax_documents(input);
            self
        }
        /// <p>Defines the device configuration for an AWS Snowcone job.</p>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn device_configuration(mut self, input: crate::model::DeviceConfiguration) -> Self {
            self.inner = self.inner.device_configuration(input);
            self
        }
        pub fn set_device_configuration(
            mut self,
            input: std::option::Option<crate::model::DeviceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_device_configuration(input);
            self
        }
        /// <p>Allows you to securely operate and manage Snowcone devices remotely from outside of your
        /// internal network. When set to <code>INSTALLED_AUTOSTART</code>, remote management will
        /// automatically be available when the device arrives at your location. Otherwise, you need to
        /// use the Snowball Client to manage the device.</p>
        pub fn remote_management(mut self, input: crate::model::RemoteManagement) -> Self {
            self.inner = self.inner.remote_management(input);
            self
        }
        pub fn set_remote_management(
            mut self,
            input: std::option::Option<crate::model::RemoteManagement>,
        ) -> Self {
            self.inner = self.inner.set_remote_management(input);
            self
        }
        /// <p>The ID of the long-term pricing type for the device.</p>
        pub fn long_term_pricing_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.long_term_pricing_id(input);
            self
        }
        pub fn set_long_term_pricing_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_long_term_pricing_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLongTermPricing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_long_term_pricing_input::Builder,
    }
    impl<C> CreateLongTermPricing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLongTermPricingOutput,
            smithy_http::result::SdkError<crate::error::CreateLongTermPricingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of long-term pricing option you want for the device, either 1-year or 3-year
        /// long-term pricing.</p>
        pub fn long_term_pricing_type(mut self, input: crate::model::LongTermPricingType) -> Self {
            self.inner = self.inner.long_term_pricing_type(input);
            self
        }
        pub fn set_long_term_pricing_type(
            mut self,
            input: std::option::Option<crate::model::LongTermPricingType>,
        ) -> Self {
            self.inner = self.inner.set_long_term_pricing_type(input);
            self
        }
        /// <p>Specifies whether the current long-term pricing type for the device should be renewed.</p>
        pub fn is_long_term_pricing_auto_renew(mut self, input: bool) -> Self {
            self.inner = self.inner.is_long_term_pricing_auto_renew(input);
            self
        }
        pub fn set_is_long_term_pricing_auto_renew(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_is_long_term_pricing_auto_renew(input);
            self
        }
        /// <p>The type of AWS Snow Family device to use for the long-term pricing job.</p>
        pub fn snowball_type(mut self, input: crate::model::SnowballType) -> Self {
            self.inner = self.inner.snowball_type(input);
            self
        }
        pub fn set_snowball_type(
            mut self,
            input: std::option::Option<crate::model::SnowballType>,
        ) -> Self {
            self.inner = self.inner.set_snowball_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReturnShippingLabel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_return_shipping_label_input::Builder,
    }
    impl<C> CreateReturnShippingLabel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReturnShippingLabelOutput,
            smithy_http::result::SdkError<crate::error::CreateReturnShippingLabelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for a job that you want to create the return shipping label for; for example,
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The shipping speed for a particular job. This speed doesn't dictate how soon the device is returned to AWS.
        /// This speed represents how quickly it moves to its
        /// destination while in transit. Regional shipping speeds are as follows:</p>
        pub fn shipping_option(mut self, input: crate::model::ShippingOption) -> Self {
            self.inner = self.inner.shipping_option(input);
            self
        }
        pub fn set_shipping_option(
            mut self,
            input: std::option::Option<crate::model::ShippingOption>,
        ) -> Self {
            self.inner = self.inner.set_shipping_option(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAddress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_address_input::Builder,
    }
    impl<C> DescribeAddress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAddressOutput,
            smithy_http::result::SdkError<crate::error::DescribeAddressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The automatically generated ID for a specific address.</p>
        pub fn address_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address_id(input);
            self
        }
        pub fn set_address_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_address_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAddresses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_addresses_input::Builder,
    }
    impl<C> DescribeAddresses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAddressesOutput,
            smithy_http::result::SdkError<crate::error::DescribeAddressesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The number of <code>ADDRESS</code> objects to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
        /// <code>ADDRESS</code> objects, you have the option of specifying a value for
        /// <code>NextToken</code> as the starting point for your list of returned addresses.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_cluster_input::Builder,
    }
    impl<C> DescribeCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClusterOutput,
            smithy_http::result::SdkError<crate::error::DescribeClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The automatically generated ID for a cluster.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(input);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_job_input::Builder,
    }
    impl<C> DescribeJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeJobOutput,
            smithy_http::result::SdkError<crate::error::DescribeJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The automatically generated ID for a job, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReturnShippingLabel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_return_shipping_label_input::Builder,
    }
    impl<C> DescribeReturnShippingLabel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReturnShippingLabelOutput,
            smithy_http::result::SdkError<crate::error::DescribeReturnShippingLabelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The automatically generated ID for a job, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJobManifest<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_job_manifest_input::Builder,
    }
    impl<C> GetJobManifest<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobManifestOutput,
            smithy_http::result::SdkError<crate::error::GetJobManifestError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for a job that you want to get the manifest file for, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJobUnlockCode<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_job_unlock_code_input::Builder,
    }
    impl<C> GetJobUnlockCode<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobUnlockCodeOutput,
            smithy_http::result::SdkError<crate::error::GetJobUnlockCodeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for the job that you want to get the <code>UnlockCode</code> value for, for
        /// example <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSnowballUsage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_snowball_usage_input::Builder,
    }
    impl<C> GetSnowballUsage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSnowballUsageOutput,
            smithy_http::result::SdkError<crate::error::GetSnowballUsageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSoftwareUpdates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_software_updates_input::Builder,
    }
    impl<C> GetSoftwareUpdates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSoftwareUpdatesOutput,
            smithy_http::result::SdkError<crate::error::GetSoftwareUpdatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for a job that you want to get the software update file for, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListClusterJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_cluster_jobs_input::Builder,
    }
    impl<C> ListClusterJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListClusterJobsOutput,
            smithy_http::result::SdkError<crate::error::ListClusterJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The 39-character ID for the cluster that you want to list, for example
        /// <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(input);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
        /// <p>The number of <code>JobListEntry</code> objects to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
        /// <code>JobListEntry</code> objects, you have the option of specifying <code>NextToken</code>
        /// as the starting point for your returned list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListClusters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_clusters_input::Builder,
    }
    impl<C> ListClusters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListClustersOutput,
            smithy_http::result::SdkError<crate::error::ListClustersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The number of <code>ClusterListEntry</code> objects to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
        /// <code>ClusterListEntry</code> objects, you have the option of specifying
        /// <code>NextToken</code> as the starting point for your returned list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCompatibleImages<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_compatible_images_input::Builder,
    }
    impl<C> ListCompatibleImages<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCompatibleImagesOutput,
            smithy_http::result::SdkError<crate::error::ListCompatibleImagesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results for the list of compatible images. Currently, a Snowball
        /// Edge device can store 10 AMIs.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
        /// compatible images, you can specify a value for <code>NextToken</code> as the starting point
        /// for your list of returned images.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_jobs_input::Builder,
    }
    impl<C> ListJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListJobsOutput,
            smithy_http::result::SdkError<crate::error::ListJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The number of <code>JobListEntry</code> objects to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
        /// <code>JobListEntry</code> objects, you have the option of specifying <code>NextToken</code>
        /// as the starting point for your returned list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLongTermPricing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_long_term_pricing_input::Builder,
    }
    impl<C> ListLongTermPricing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLongTermPricingOutput,
            smithy_http::result::SdkError<crate::error::ListLongTermPricingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of <code>ListLongTermPricing</code> objects to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Because HTTP requests are stateless, this is the starting point for your next list of
        /// <code>ListLongTermPricing</code> to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_cluster_input::Builder,
    }
    impl<C> UpdateCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateClusterOutput,
            smithy_http::result::SdkError<crate::error::UpdateClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The cluster ID of the cluster that you want to update, for example
        /// <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_id(input);
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_id(input);
            self
        }
        /// <p>The new role Amazon Resource Name (ARN) that you want to associate with this cluster.
        /// To create a role ARN, use the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> API action in AWS
        /// Identity and Access Management (IAM).</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The updated description of this cluster.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The updated arrays of <a>JobResource</a> objects that can include updated
        /// <a>S3Resource</a> objects or <a>LambdaResource</a> objects.</p>
        pub fn resources(mut self, input: crate::model::JobResource) -> Self {
            self.inner = self.inner.resources(input);
            self
        }
        pub fn set_resources(
            mut self,
            input: std::option::Option<crate::model::JobResource>,
        ) -> Self {
            self.inner = self.inner.set_resources(input);
            self
        }
        /// <p>Specifies the service or services on the Snow Family device that your
        /// transferred data will be exported from or imported into. AWS Snow Family supports Amazon S3 and NFS (Network File System).</p>
        pub fn on_device_service_configuration(
            mut self,
            input: crate::model::OnDeviceServiceConfiguration,
        ) -> Self {
            self.inner = self.inner.on_device_service_configuration(input);
            self
        }
        pub fn set_on_device_service_configuration(
            mut self,
            input: std::option::Option<crate::model::OnDeviceServiceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_on_device_service_configuration(input);
            self
        }
        /// <p>The ID of the updated <a>Address</a> object.</p>
        pub fn address_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address_id(input);
            self
        }
        pub fn set_address_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_address_id(input);
            self
        }
        /// <p>The updated shipping option value of this cluster's <a>ShippingDetails</a>
        /// object.</p>
        pub fn shipping_option(mut self, input: crate::model::ShippingOption) -> Self {
            self.inner = self.inner.shipping_option(input);
            self
        }
        pub fn set_shipping_option(
            mut self,
            input: std::option::Option<crate::model::ShippingOption>,
        ) -> Self {
            self.inner = self.inner.set_shipping_option(input);
            self
        }
        /// <p>The new or updated <a>Notification</a> object.</p>
        pub fn notification(mut self, input: crate::model::Notification) -> Self {
            self.inner = self.inner.notification(input);
            self
        }
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::Notification>,
        ) -> Self {
            self.inner = self.inner.set_notification(input);
            self
        }
        /// <p>The updated ID for the forwarding address for a cluster. This field is not
        /// supported in most regions.</p>
        pub fn forwarding_address_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.forwarding_address_id(input);
            self
        }
        pub fn set_forwarding_address_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_forwarding_address_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_job_input::Builder,
    }
    impl<C> UpdateJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateJobOutput,
            smithy_http::result::SdkError<crate::error::UpdateJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The job ID of the job that you want to update, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The new role Amazon Resource Name (ARN) that you want to associate with this job. To
        /// create a role ARN, use the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a>AWS Identity and Access
        /// Management (IAM) API action.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The new or updated <a>Notification</a> object.</p>
        pub fn notification(mut self, input: crate::model::Notification) -> Self {
            self.inner = self.inner.notification(input);
            self
        }
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::Notification>,
        ) -> Self {
            self.inner = self.inner.set_notification(input);
            self
        }
        /// <p>The updated <code>JobResource</code> object, or the updated <a>JobResource</a> object. </p>
        pub fn resources(mut self, input: crate::model::JobResource) -> Self {
            self.inner = self.inner.resources(input);
            self
        }
        pub fn set_resources(
            mut self,
            input: std::option::Option<crate::model::JobResource>,
        ) -> Self {
            self.inner = self.inner.set_resources(input);
            self
        }
        /// <p>Specifies the service or services on the Snow Family device that your
        /// transferred data will be exported from or imported into. AWS Snow Family supports Amazon S3 and NFS (Network File System).</p>
        pub fn on_device_service_configuration(
            mut self,
            input: crate::model::OnDeviceServiceConfiguration,
        ) -> Self {
            self.inner = self.inner.on_device_service_configuration(input);
            self
        }
        pub fn set_on_device_service_configuration(
            mut self,
            input: std::option::Option<crate::model::OnDeviceServiceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_on_device_service_configuration(input);
            self
        }
        /// <p>The ID of the updated <a>Address</a> object.</p>
        pub fn address_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address_id(input);
            self
        }
        pub fn set_address_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_address_id(input);
            self
        }
        /// <p>The updated shipping option value of this job's <a>ShippingDetails</a>
        /// object.</p>
        pub fn shipping_option(mut self, input: crate::model::ShippingOption) -> Self {
            self.inner = self.inner.shipping_option(input);
            self
        }
        pub fn set_shipping_option(
            mut self,
            input: std::option::Option<crate::model::ShippingOption>,
        ) -> Self {
            self.inner = self.inner.set_shipping_option(input);
            self
        }
        /// <p>The updated description of this job's <a>JobMetadata</a> object.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The updated <code>SnowballCapacityPreference</code> of this job's <a>JobMetadata</a> object. The 50 TB Snowballs are only available in the US
        /// regions.</p>
        /// <p>For more information, see
        /// "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        /// "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        /// Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        pub fn snowball_capacity_preference(
            mut self,
            input: crate::model::SnowballCapacity,
        ) -> Self {
            self.inner = self.inner.snowball_capacity_preference(input);
            self
        }
        pub fn set_snowball_capacity_preference(
            mut self,
            input: std::option::Option<crate::model::SnowballCapacity>,
        ) -> Self {
            self.inner = self.inner.set_snowball_capacity_preference(input);
            self
        }
        /// <p>The updated ID for the forwarding address for a job. This field is not
        /// supported in most regions.</p>
        pub fn forwarding_address_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.forwarding_address_id(input);
            self
        }
        pub fn set_forwarding_address_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_forwarding_address_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateJobShipmentState<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_job_shipment_state_input::Builder,
    }
    impl<C> UpdateJobShipmentState<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateJobShipmentStateOutput,
            smithy_http::result::SdkError<crate::error::UpdateJobShipmentStateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The job ID of the job whose shipment date you want to update, for example
        /// <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The state of a device when it is being shipped. </p>
        /// <p>Set to <code>RECEIVED</code> when the device arrives at your location.</p>
        /// <p>Set to <code>RETURNED</code> when you have returned the device to AWS.</p>
        pub fn shipment_state(mut self, input: crate::model::ShipmentState) -> Self {
            self.inner = self.inner.shipment_state(input);
            self
        }
        pub fn set_shipment_state(
            mut self,
            input: std::option::Option<crate::model::ShipmentState>,
        ) -> Self {
            self.inner = self.inner.set_shipment_state(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLongTermPricing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_long_term_pricing_input::Builder,
    }
    impl<C> UpdateLongTermPricing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLongTermPricingOutput,
            smithy_http::result::SdkError<crate::error::UpdateLongTermPricingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the long-term pricing type for the device.</p>
        pub fn long_term_pricing_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.long_term_pricing_id(input);
            self
        }
        pub fn set_long_term_pricing_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_long_term_pricing_id(input);
            self
        }
        /// <p>Specifies that a device that is ordered with long-term pricing should be replaced with a new device.</p>
        pub fn replacement_job(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replacement_job(input);
            self
        }
        pub fn set_replacement_job(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_replacement_job(input);
            self
        }
        /// <p>If set to <code>true</code>, specifies that the current long-term pricing type for the
        /// device should be automatically renewed before the long-term pricing contract expires.</p>
        pub fn is_long_term_pricing_auto_renew(mut self, input: bool) -> Self {
            self.inner = self.inner.is_long_term_pricing_auto_renew(input);
            self
        }
        pub fn set_is_long_term_pricing_auto_renew(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_is_long_term_pricing_auto_renew(input);
            self
        }
    }
}
