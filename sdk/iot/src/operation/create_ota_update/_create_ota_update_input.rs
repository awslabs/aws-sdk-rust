// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateOtaUpdateInput {
    /// <p>The ID of the OTA update to be created.</p>
    pub ota_update_id: ::std::option::Option<::std::string::String>,
    /// <p>The description of the OTA update.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The devices targeted to receive OTA updates.</p>
    pub targets: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.</p>
    pub protocols: ::std::option::Option<::std::vec::Vec<crate::types::Protocol>>,
    /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
    pub target_selection: ::std::option::Option<crate::types::TargetSelection>,
    /// <p>Configuration for the rollout of OTA updates.</p>
    pub aws_job_executions_rollout_config: ::std::option::Option<crate::types::AwsJobExecutionsRolloutConfig>,
    /// <p>Configuration information for pre-signed URLs.</p>
    pub aws_job_presigned_url_config: ::std::option::Option<crate::types::AwsJobPresignedUrlConfig>,
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    pub aws_job_abort_config: ::std::option::Option<crate::types::AwsJobAbortConfig>,
    /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    pub aws_job_timeout_config: ::std::option::Option<crate::types::AwsJobTimeoutConfig>,
    /// <p>The files to be streamed by the OTA update.</p>
    pub files: ::std::option::Option<::std::vec::Vec<crate::types::OtaUpdateFile>>,
    /// <p>The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job.</p>
    pub role_arn: ::std::option::Option<::std::string::String>,
    /// <p>A list of additional OTA update parameters, which are name-value pairs. They won't be sent to devices as a part of the Job document.</p>
    pub additional_parameters: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>Metadata which can be used to manage updates.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl CreateOtaUpdateInput {
    /// <p>The ID of the OTA update to be created.</p>
    pub fn ota_update_id(&self) -> ::std::option::Option<&str> {
        self.ota_update_id.as_deref()
    }
    /// <p>The description of the OTA update.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The devices targeted to receive OTA updates.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.targets.is_none()`.
    pub fn targets(&self) -> &[::std::string::String] {
        self.targets.as_deref().unwrap_or_default()
    }
    /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.protocols.is_none()`.
    pub fn protocols(&self) -> &[crate::types::Protocol] {
        self.protocols.as_deref().unwrap_or_default()
    }
    /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
    pub fn target_selection(&self) -> ::std::option::Option<&crate::types::TargetSelection> {
        self.target_selection.as_ref()
    }
    /// <p>Configuration for the rollout of OTA updates.</p>
    pub fn aws_job_executions_rollout_config(&self) -> ::std::option::Option<&crate::types::AwsJobExecutionsRolloutConfig> {
        self.aws_job_executions_rollout_config.as_ref()
    }
    /// <p>Configuration information for pre-signed URLs.</p>
    pub fn aws_job_presigned_url_config(&self) -> ::std::option::Option<&crate::types::AwsJobPresignedUrlConfig> {
        self.aws_job_presigned_url_config.as_ref()
    }
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    pub fn aws_job_abort_config(&self) -> ::std::option::Option<&crate::types::AwsJobAbortConfig> {
        self.aws_job_abort_config.as_ref()
    }
    /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    pub fn aws_job_timeout_config(&self) -> ::std::option::Option<&crate::types::AwsJobTimeoutConfig> {
        self.aws_job_timeout_config.as_ref()
    }
    /// <p>The files to be streamed by the OTA update.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.files.is_none()`.
    pub fn files(&self) -> &[crate::types::OtaUpdateFile] {
        self.files.as_deref().unwrap_or_default()
    }
    /// <p>The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job.</p>
    pub fn role_arn(&self) -> ::std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>A list of additional OTA update parameters, which are name-value pairs. They won't be sent to devices as a part of the Job document.</p>
    pub fn additional_parameters(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.additional_parameters.as_ref()
    }
    /// <p>Metadata which can be used to manage updates.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
}
impl CreateOtaUpdateInput {
    /// Creates a new builder-style object to manufacture [`CreateOtaUpdateInput`](crate::operation::create_ota_update::CreateOtaUpdateInput).
    pub fn builder() -> crate::operation::create_ota_update::builders::CreateOtaUpdateInputBuilder {
        crate::operation::create_ota_update::builders::CreateOtaUpdateInputBuilder::default()
    }
}

/// A builder for [`CreateOtaUpdateInput`](crate::operation::create_ota_update::CreateOtaUpdateInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct CreateOtaUpdateInputBuilder {
    pub(crate) ota_update_id: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) targets: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) protocols: ::std::option::Option<::std::vec::Vec<crate::types::Protocol>>,
    pub(crate) target_selection: ::std::option::Option<crate::types::TargetSelection>,
    pub(crate) aws_job_executions_rollout_config: ::std::option::Option<crate::types::AwsJobExecutionsRolloutConfig>,
    pub(crate) aws_job_presigned_url_config: ::std::option::Option<crate::types::AwsJobPresignedUrlConfig>,
    pub(crate) aws_job_abort_config: ::std::option::Option<crate::types::AwsJobAbortConfig>,
    pub(crate) aws_job_timeout_config: ::std::option::Option<crate::types::AwsJobTimeoutConfig>,
    pub(crate) files: ::std::option::Option<::std::vec::Vec<crate::types::OtaUpdateFile>>,
    pub(crate) role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) additional_parameters: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl CreateOtaUpdateInputBuilder {
    /// <p>The ID of the OTA update to be created.</p>
    /// This field is required.
    pub fn ota_update_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ota_update_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the OTA update to be created.</p>
    pub fn set_ota_update_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ota_update_id = input;
        self
    }
    /// <p>The ID of the OTA update to be created.</p>
    pub fn get_ota_update_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.ota_update_id
    }
    /// <p>The description of the OTA update.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The description of the OTA update.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The description of the OTA update.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// Appends an item to `targets`.
    ///
    /// To override the contents of this collection use [`set_targets`](Self::set_targets).
    ///
    /// <p>The devices targeted to receive OTA updates.</p>
    pub fn targets(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.targets.unwrap_or_default();
        v.push(input.into());
        self.targets = ::std::option::Option::Some(v);
        self
    }
    /// <p>The devices targeted to receive OTA updates.</p>
    pub fn set_targets(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.targets = input;
        self
    }
    /// <p>The devices targeted to receive OTA updates.</p>
    pub fn get_targets(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.targets
    }
    /// Appends an item to `protocols`.
    ///
    /// To override the contents of this collection use [`set_protocols`](Self::set_protocols).
    ///
    /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.</p>
    pub fn protocols(mut self, input: crate::types::Protocol) -> Self {
        let mut v = self.protocols.unwrap_or_default();
        v.push(input);
        self.protocols = ::std::option::Option::Some(v);
        self
    }
    /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.</p>
    pub fn set_protocols(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Protocol>>) -> Self {
        self.protocols = input;
        self
    }
    /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.</p>
    pub fn get_protocols(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Protocol>> {
        &self.protocols
    }
    /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
    pub fn target_selection(mut self, input: crate::types::TargetSelection) -> Self {
        self.target_selection = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
    pub fn set_target_selection(mut self, input: ::std::option::Option<crate::types::TargetSelection>) -> Self {
        self.target_selection = input;
        self
    }
    /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
    pub fn get_target_selection(&self) -> &::std::option::Option<crate::types::TargetSelection> {
        &self.target_selection
    }
    /// <p>Configuration for the rollout of OTA updates.</p>
    pub fn aws_job_executions_rollout_config(mut self, input: crate::types::AwsJobExecutionsRolloutConfig) -> Self {
        self.aws_job_executions_rollout_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>Configuration for the rollout of OTA updates.</p>
    pub fn set_aws_job_executions_rollout_config(mut self, input: ::std::option::Option<crate::types::AwsJobExecutionsRolloutConfig>) -> Self {
        self.aws_job_executions_rollout_config = input;
        self
    }
    /// <p>Configuration for the rollout of OTA updates.</p>
    pub fn get_aws_job_executions_rollout_config(&self) -> &::std::option::Option<crate::types::AwsJobExecutionsRolloutConfig> {
        &self.aws_job_executions_rollout_config
    }
    /// <p>Configuration information for pre-signed URLs.</p>
    pub fn aws_job_presigned_url_config(mut self, input: crate::types::AwsJobPresignedUrlConfig) -> Self {
        self.aws_job_presigned_url_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>Configuration information for pre-signed URLs.</p>
    pub fn set_aws_job_presigned_url_config(mut self, input: ::std::option::Option<crate::types::AwsJobPresignedUrlConfig>) -> Self {
        self.aws_job_presigned_url_config = input;
        self
    }
    /// <p>Configuration information for pre-signed URLs.</p>
    pub fn get_aws_job_presigned_url_config(&self) -> &::std::option::Option<crate::types::AwsJobPresignedUrlConfig> {
        &self.aws_job_presigned_url_config
    }
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    pub fn aws_job_abort_config(mut self, input: crate::types::AwsJobAbortConfig) -> Self {
        self.aws_job_abort_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    pub fn set_aws_job_abort_config(mut self, input: ::std::option::Option<crate::types::AwsJobAbortConfig>) -> Self {
        self.aws_job_abort_config = input;
        self
    }
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    pub fn get_aws_job_abort_config(&self) -> &::std::option::Option<crate::types::AwsJobAbortConfig> {
        &self.aws_job_abort_config
    }
    /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    pub fn aws_job_timeout_config(mut self, input: crate::types::AwsJobTimeoutConfig) -> Self {
        self.aws_job_timeout_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    pub fn set_aws_job_timeout_config(mut self, input: ::std::option::Option<crate::types::AwsJobTimeoutConfig>) -> Self {
        self.aws_job_timeout_config = input;
        self
    }
    /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    pub fn get_aws_job_timeout_config(&self) -> &::std::option::Option<crate::types::AwsJobTimeoutConfig> {
        &self.aws_job_timeout_config
    }
    /// Appends an item to `files`.
    ///
    /// To override the contents of this collection use [`set_files`](Self::set_files).
    ///
    /// <p>The files to be streamed by the OTA update.</p>
    pub fn files(mut self, input: crate::types::OtaUpdateFile) -> Self {
        let mut v = self.files.unwrap_or_default();
        v.push(input);
        self.files = ::std::option::Option::Some(v);
        self
    }
    /// <p>The files to be streamed by the OTA update.</p>
    pub fn set_files(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::OtaUpdateFile>>) -> Self {
        self.files = input;
        self
    }
    /// <p>The files to be streamed by the OTA update.</p>
    pub fn get_files(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::OtaUpdateFile>> {
        &self.files
    }
    /// <p>The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job.</p>
    /// This field is required.
    pub fn role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job.</p>
    pub fn set_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.role_arn = input;
        self
    }
    /// <p>The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job.</p>
    pub fn get_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.role_arn
    }
    /// Adds a key-value pair to `additional_parameters`.
    ///
    /// To override the contents of this collection use [`set_additional_parameters`](Self::set_additional_parameters).
    ///
    /// <p>A list of additional OTA update parameters, which are name-value pairs. They won't be sent to devices as a part of the Job document.</p>
    pub fn additional_parameters(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        let mut hash_map = self.additional_parameters.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.additional_parameters = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>A list of additional OTA update parameters, which are name-value pairs. They won't be sent to devices as a part of the Job document.</p>
    pub fn set_additional_parameters(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.additional_parameters = input;
        self
    }
    /// <p>A list of additional OTA update parameters, which are name-value pairs. They won't be sent to devices as a part of the Job document.</p>
    pub fn get_additional_parameters(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.additional_parameters
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Metadata which can be used to manage updates.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>Metadata which can be used to manage updates.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>Metadata which can be used to manage updates.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`CreateOtaUpdateInput`](crate::operation::create_ota_update::CreateOtaUpdateInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_ota_update::CreateOtaUpdateInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::create_ota_update::CreateOtaUpdateInput {
            ota_update_id: self.ota_update_id,
            description: self.description,
            targets: self.targets,
            protocols: self.protocols,
            target_selection: self.target_selection,
            aws_job_executions_rollout_config: self.aws_job_executions_rollout_config,
            aws_job_presigned_url_config: self.aws_job_presigned_url_config,
            aws_job_abort_config: self.aws_job_abort_config,
            aws_job_timeout_config: self.aws_job_timeout_config,
            files: self.files,
            role_arn: self.role_arn,
            additional_parameters: self.additional_parameters,
            tags: self.tags,
        })
    }
}
