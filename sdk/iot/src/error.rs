// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AcceptCertificateTransferError {
    pub kind: AcceptCertificateTransferErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptCertificateTransferErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    TransferAlreadyCompletedException(crate::error::TransferAlreadyCompletedException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AcceptCertificateTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AcceptCertificateTransferErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AcceptCertificateTransferErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AcceptCertificateTransferErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AcceptCertificateTransferErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            AcceptCertificateTransferErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AcceptCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                _inner.fmt(f)
            }
            AcceptCertificateTransferErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            AcceptCertificateTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AcceptCertificateTransferError {
    fn code(&self) -> Option<&str> {
        AcceptCertificateTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptCertificateTransferError {
    pub fn new(kind: AcceptCertificateTransferErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AcceptCertificateTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AcceptCertificateTransferErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_transfer_already_completed_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::TransferAlreadyCompletedException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for AcceptCertificateTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AcceptCertificateTransferErrorKind::InternalFailureException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::ThrottlingException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                Some(_inner)
            }
            AcceptCertificateTransferErrorKind::UnauthorizedException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddThingToBillingGroupError {
    pub kind: AddThingToBillingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddThingToBillingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddThingToBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddThingToBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AddThingToBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AddThingToBillingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AddThingToBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AddThingToBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddThingToBillingGroupError {
    fn code(&self) -> Option<&str> {
        AddThingToBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddThingToBillingGroupError {
    pub fn new(kind: AddThingToBillingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddThingToBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddThingToBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToBillingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToBillingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AddThingToBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddThingToBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            AddThingToBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AddThingToBillingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AddThingToBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            AddThingToBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddThingToThingGroupError {
    pub kind: AddThingToThingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddThingToThingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddThingToThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddThingToThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AddThingToThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AddThingToThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AddThingToThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AddThingToThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddThingToThingGroupError {
    fn code(&self) -> Option<&str> {
        AddThingToThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddThingToThingGroupError {
    pub fn new(kind: AddThingToThingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddThingToThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddThingToThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToThingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AddThingToThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddThingToThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            AddThingToThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AddThingToThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AddThingToThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            AddThingToThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateTargetsWithJobError {
    pub kind: AssociateTargetsWithJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateTargetsWithJobErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateTargetsWithJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateTargetsWithJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AssociateTargetsWithJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AssociateTargetsWithJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateTargetsWithJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            AssociateTargetsWithJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateTargetsWithJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateTargetsWithJobError {
    fn code(&self) -> Option<&str> {
        AssociateTargetsWithJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateTargetsWithJobError {
    pub fn new(kind: AssociateTargetsWithJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateTargetsWithJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateTargetsWithJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTargetsWithJobErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTargetsWithJobErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTargetsWithJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTargetsWithJobErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTargetsWithJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AssociateTargetsWithJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateTargetsWithJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AssociateTargetsWithJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            AssociateTargetsWithJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateTargetsWithJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            AssociateTargetsWithJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateTargetsWithJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachPolicyError {
    pub kind: AttachPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachPolicyErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachPolicyError {
    fn code(&self) -> Option<&str> {
        AttachPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachPolicyError {
    pub fn new(kind: AttachPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPolicyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPolicyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, AttachPolicyErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, AttachPolicyErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, AttachPolicyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for AttachPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            AttachPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AttachPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            AttachPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AttachPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            AttachPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            AttachPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            AttachPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachPrincipalPolicyError {
    pub kind: AttachPrincipalPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachPrincipalPolicyErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachPrincipalPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachPrincipalPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachPrincipalPolicyError {
    fn code(&self) -> Option<&str> {
        AttachPrincipalPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachPrincipalPolicyError {
    pub fn new(kind: AttachPrincipalPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachPrincipalPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachPrincipalPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for AttachPrincipalPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachPrincipalPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachSecurityProfileError {
    pub kind: AttachSecurityProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachSecurityProfileErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachSecurityProfileError {
    fn code(&self) -> Option<&str> {
        AttachSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachSecurityProfileError {
    pub fn new(kind: AttachSecurityProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for AttachSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::VersionConflictException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachThingPrincipalError {
    pub kind: AttachThingPrincipalErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachThingPrincipalErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachThingPrincipalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachThingPrincipalErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachThingPrincipalError {
    fn code(&self) -> Option<&str> {
        AttachThingPrincipalError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachThingPrincipalError {
    pub fn new(kind: AttachThingPrincipalErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachThingPrincipalErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachThingPrincipalErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for AttachThingPrincipalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachThingPrincipalErrorKind::InternalFailureException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::ThrottlingException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::UnauthorizedException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelAuditMitigationActionsTaskError {
    pub kind: CancelAuditMitigationActionsTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelAuditMitigationActionsTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelAuditMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            CancelAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            CancelAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CancelAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelAuditMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        CancelAuditMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelAuditMitigationActionsTaskError {
    pub fn new(kind: CancelAuditMitigationActionsTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CancelAuditMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            CancelAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            CancelAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CancelAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelAuditTaskError {
    pub kind: CancelAuditTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelAuditTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelAuditTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelAuditTaskErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CancelAuditTaskErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CancelAuditTaskErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelAuditTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelAuditTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelAuditTaskError {
    fn code(&self) -> Option<&str> {
        CancelAuditTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelAuditTaskError {
    pub fn new(kind: CancelAuditTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelAuditTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelAuditTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CancelAuditTaskErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CancelAuditTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelAuditTaskErrorKind::InternalFailureException(_inner) => Some(_inner),
            CancelAuditTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CancelAuditTaskErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelAuditTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelAuditTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelCertificateTransferError {
    pub kind: CancelCertificateTransferErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelCertificateTransferErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    TransferAlreadyCompletedException(crate::error::TransferAlreadyCompletedException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelCertificateTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelCertificateTransferErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CancelCertificateTransferErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CancelCertificateTransferErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelCertificateTransferErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CancelCertificateTransferErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                _inner.fmt(f)
            }
            CancelCertificateTransferErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CancelCertificateTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelCertificateTransferError {
    fn code(&self) -> Option<&str> {
        CancelCertificateTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelCertificateTransferError {
    pub fn new(kind: CancelCertificateTransferErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelCertificateTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelCertificateTransferErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_transfer_already_completed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::TransferAlreadyCompletedException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CancelCertificateTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelCertificateTransferErrorKind::InternalFailureException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                Some(_inner)
            }
            CancelCertificateTransferErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelDetectMitigationActionsTaskError {
    pub kind: CancelDetectMitigationActionsTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelDetectMitigationActionsTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelDetectMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            CancelDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            CancelDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CancelDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            CancelDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelDetectMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        CancelDetectMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelDetectMitigationActionsTaskError {
    pub fn new(
        kind: CancelDetectMitigationActionsTaskErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDetectMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDetectMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDetectMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CancelDetectMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            CancelDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            CancelDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CancelDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelJobError {
    pub kind: CancelJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelJobErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CancelJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CancelJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelJobError {
    fn code(&self) -> Option<&str> {
        CancelJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelJobError {
    pub fn new(kind: CancelJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, CancelJobErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CancelJobErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CancelJobErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CancelJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CancelJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CancelJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelJobExecutionError {
    pub kind: CancelJobExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelJobExecutionErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    InvalidStateTransitionException(crate::error::InvalidStateTransitionException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelJobExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelJobExecutionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::InvalidStateTransitionException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelJobExecutionError {
    fn code(&self) -> Option<&str> {
        CancelJobExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelJobExecutionError {
    pub fn new(kind: CancelJobExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelJobExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelJobExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_invalid_state_transition_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::InvalidStateTransitionException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for CancelJobExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelJobExecutionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::InvalidStateTransitionException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::VersionConflictException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ClearDefaultAuthorizerError {
    pub kind: ClearDefaultAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ClearDefaultAuthorizerErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ClearDefaultAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ClearDefaultAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ClearDefaultAuthorizerError {
    fn code(&self) -> Option<&str> {
        ClearDefaultAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ClearDefaultAuthorizerError {
    pub fn new(kind: ClearDefaultAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ClearDefaultAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ClearDefaultAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ClearDefaultAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ClearDefaultAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConfirmTopicRuleDestinationError {
    pub kind: ConfirmTopicRuleDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConfirmTopicRuleDestinationErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConfirmTopicRuleDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConfirmTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            ConfirmTopicRuleDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            ConfirmTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ConfirmTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ConfirmTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ConfirmTopicRuleDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConfirmTopicRuleDestinationError {
    fn code(&self) -> Option<&str> {
        ConfirmTopicRuleDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConfirmTopicRuleDestinationError {
    pub fn new(kind: ConfirmTopicRuleDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConfirmTopicRuleDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConfirmTopicRuleDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTopicRuleDestinationErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTopicRuleDestinationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTopicRuleDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTopicRuleDestinationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ConfirmTopicRuleDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConfirmTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            ConfirmTopicRuleDestinationErrorKind::InternalException(_inner) => Some(_inner),
            ConfirmTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ConfirmTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            ConfirmTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ConfirmTopicRuleDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAuditSuppressionError {
    pub kind: CreateAuditSuppressionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAuditSuppressionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAuditSuppressionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAuditSuppressionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateAuditSuppressionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateAuditSuppressionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateAuditSuppressionErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateAuditSuppressionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateAuditSuppressionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAuditSuppressionError {
    fn code(&self) -> Option<&str> {
        CreateAuditSuppressionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAuditSuppressionError {
    pub fn new(kind: CreateAuditSuppressionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAuditSuppressionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAuditSuppressionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuditSuppressionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuditSuppressionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuditSuppressionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuditSuppressionErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuditSuppressionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateAuditSuppressionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAuditSuppressionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateAuditSuppressionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateAuditSuppressionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateAuditSuppressionErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateAuditSuppressionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateAuditSuppressionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAuthorizerError {
    pub kind: CreateAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAuthorizerErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAuthorizerError {
    fn code(&self) -> Option<&str> {
        CreateAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAuthorizerError {
    pub fn new(kind: CreateAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBillingGroupError {
    pub kind: CreateBillingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBillingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateBillingGroupErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBillingGroupError {
    fn code(&self) -> Option<&str> {
        CreateBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBillingGroupError {
    pub fn new(kind: CreateBillingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBillingGroupErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBillingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateBillingGroupErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCertificateFromCsrError {
    pub kind: CreateCertificateFromCsrErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCertificateFromCsrErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCertificateFromCsrError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCertificateFromCsrErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateCertificateFromCsrErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateCertificateFromCsrErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateCertificateFromCsrErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateCertificateFromCsrErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateCertificateFromCsrErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCertificateFromCsrError {
    fn code(&self) -> Option<&str> {
        CreateCertificateFromCsrError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCertificateFromCsrError {
    pub fn new(kind: CreateCertificateFromCsrErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCertificateFromCsrErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCertificateFromCsrErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateFromCsrErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateFromCsrErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateFromCsrErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateFromCsrErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateFromCsrErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateCertificateFromCsrError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCertificateFromCsrErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateCertificateFromCsrErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateCertificateFromCsrErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateCertificateFromCsrErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateCertificateFromCsrErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateCertificateFromCsrErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCustomMetricError {
    pub kind: CreateCustomMetricErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCustomMetricErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCustomMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCustomMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateCustomMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateCustomMetricErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateCustomMetricErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateCustomMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateCustomMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCustomMetricError {
    fn code(&self) -> Option<&str> {
        CreateCustomMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCustomMetricError {
    pub fn new(kind: CreateCustomMetricErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCustomMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCustomMetricErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomMetricErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomMetricErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomMetricErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomMetricErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomMetricErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateCustomMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCustomMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateCustomMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateCustomMetricErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateCustomMetricErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateCustomMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateCustomMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDimensionError {
    pub kind: CreateDimensionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDimensionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDimensionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDimensionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateDimensionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateDimensionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDimensionErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateDimensionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDimensionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDimensionError {
    fn code(&self) -> Option<&str> {
        CreateDimensionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDimensionError {
    pub fn new(kind: CreateDimensionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDimensionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDimensionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDimensionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDimensionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDimensionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDimensionErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateDimensionErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateDimensionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDimensionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateDimensionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateDimensionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDimensionErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateDimensionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDimensionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDomainConfigurationError {
    pub kind: CreateDomainConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDomainConfigurationErrorKind {
    CertificateValidationException(crate::error::CertificateValidationException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDomainConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDomainConfigurationErrorKind::CertificateValidationException(_inner) => {
                _inner.fmt(f)
            }
            CreateDomainConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateDomainConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateDomainConfigurationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDomainConfigurationErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateDomainConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDomainConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateDomainConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDomainConfigurationError {
    fn code(&self) -> Option<&str> {
        CreateDomainConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDomainConfigurationError {
    pub fn new(kind: CreateDomainConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDomainConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDomainConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::CertificateValidationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateDomainConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDomainConfigurationErrorKind::CertificateValidationException(_inner) => {
                Some(_inner)
            }
            CreateDomainConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDynamicThingGroupError {
    pub kind: CreateDynamicThingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDynamicThingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidQueryException(crate::error::InvalidQueryException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDynamicThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDynamicThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateDynamicThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDynamicThingGroupError {
    fn code(&self) -> Option<&str> {
        CreateDynamicThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDynamicThingGroupError {
    pub fn new(kind: CreateDynamicThingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDynamicThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDynamicThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::InvalidQueryException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateDynamicThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDynamicThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::InvalidQueryException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateDynamicThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFleetMetricError {
    pub kind: CreateFleetMetricErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFleetMetricErrorKind {
    IndexNotReadyException(crate::error::IndexNotReadyException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidAggregationException(crate::error::InvalidAggregationException),
    InvalidQueryException(crate::error::InvalidQueryException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFleetMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFleetMetricErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFleetMetricError {
    fn code(&self) -> Option<&str> {
        CreateFleetMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFleetMetricError {
    pub fn new(kind: CreateFleetMetricErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFleetMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFleetMetricErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::IndexNotReadyException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::InvalidAggregationException(_)
        )
    }
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::InvalidQueryException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateFleetMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFleetMetricErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::InvalidQueryException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateJobError {
    pub kind: CreateJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateJobErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateJobError {
    fn code(&self) -> Option<&str> {
        CreateJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateJobError {
    pub fn new(kind: CreateJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::InvalidRequestException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateJobErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateJobTemplateError {
    pub kind: CreateJobTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateJobTemplateErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateJobTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateJobTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateJobTemplateError {
    fn code(&self) -> Option<&str> {
        CreateJobTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateJobTemplateError {
    pub fn new(kind: CreateJobTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateJobTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateJobTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateJobTemplateErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobTemplateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobTemplateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobTemplateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobTemplateErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateJobTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateJobTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateKeysAndCertificateError {
    pub kind: CreateKeysAndCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateKeysAndCertificateErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateKeysAndCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateKeysAndCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateKeysAndCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateKeysAndCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateKeysAndCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateKeysAndCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateKeysAndCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateKeysAndCertificateError {
    fn code(&self) -> Option<&str> {
        CreateKeysAndCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateKeysAndCertificateError {
    pub fn new(kind: CreateKeysAndCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateKeysAndCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateKeysAndCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeysAndCertificateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeysAndCertificateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeysAndCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeysAndCertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeysAndCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateKeysAndCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateKeysAndCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateKeysAndCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateKeysAndCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateKeysAndCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateKeysAndCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateKeysAndCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMitigationActionError {
    pub kind: CreateMitigationActionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMitigationActionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMitigationActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMitigationActionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateMitigationActionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateMitigationActionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateMitigationActionErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateMitigationActionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateMitigationActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMitigationActionError {
    fn code(&self) -> Option<&str> {
        CreateMitigationActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMitigationActionError {
    pub fn new(kind: CreateMitigationActionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMitigationActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMitigationActionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMitigationActionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMitigationActionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMitigationActionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMitigationActionErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMitigationActionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateMitigationActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMitigationActionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateMitigationActionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateMitigationActionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateMitigationActionErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateMitigationActionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateMitigationActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateOTAUpdateError {
    pub kind: CreateOTAUpdateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOTAUpdateErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateOTAUpdateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateOTAUpdateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateOTAUpdateError {
    fn code(&self) -> Option<&str> {
        CreateOTAUpdateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOTAUpdateError {
    pub fn new(kind: CreateOTAUpdateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateOTAUpdateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateOTAUpdateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateOTAUpdateErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateOTAUpdateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateOTAUpdateErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePolicyError {
    pub kind: CreatePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePolicyErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    MalformedPolicyException(crate::error::MalformedPolicyException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::MalformedPolicyException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePolicyError {
    fn code(&self) -> Option<&str> {
        CreatePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePolicyError {
    pub fn new(kind: CreatePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_malformed_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::MalformedPolicyException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreatePolicyErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreatePolicyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreatePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreatePolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreatePolicyErrorKind::MalformedPolicyException(_inner) => Some(_inner),
            CreatePolicyErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreatePolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreatePolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreatePolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreatePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePolicyVersionError {
    pub kind: CreatePolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePolicyVersionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    MalformedPolicyException(crate::error::MalformedPolicyException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    VersionsLimitExceededException(crate::error::VersionsLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePolicyVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::MalformedPolicyException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::VersionsLimitExceededException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePolicyVersionError {
    fn code(&self) -> Option<&str> {
        CreatePolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePolicyVersionError {
    pub fn new(kind: CreatePolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_malformed_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::MalformedPolicyException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::UnauthorizedException(_)
        )
    }
    pub fn is_versions_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::VersionsLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreatePolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePolicyVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::MalformedPolicyException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::VersionsLimitExceededException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProvisioningClaimError {
    pub kind: CreateProvisioningClaimErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProvisioningClaimErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProvisioningClaimError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProvisioningClaimErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateProvisioningClaimError {
    fn code(&self) -> Option<&str> {
        CreateProvisioningClaimError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProvisioningClaimError {
    pub fn new(kind: CreateProvisioningClaimErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProvisioningClaimErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProvisioningClaimErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateProvisioningClaimError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProvisioningClaimErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProvisioningTemplateError {
    pub kind: CreateProvisioningTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProvisioningTemplateErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProvisioningTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProvisioningTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateProvisioningTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateProvisioningTemplateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateProvisioningTemplateErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateProvisioningTemplateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateProvisioningTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateProvisioningTemplateError {
    fn code(&self) -> Option<&str> {
        CreateProvisioningTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProvisioningTemplateError {
    pub fn new(kind: CreateProvisioningTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProvisioningTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProvisioningTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateProvisioningTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProvisioningTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateProvisioningTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateProvisioningTemplateErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateProvisioningTemplateErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateProvisioningTemplateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateProvisioningTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProvisioningTemplateVersionError {
    pub kind: CreateProvisioningTemplateVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProvisioningTemplateVersionErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    VersionsLimitExceededException(crate::error::VersionsLimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProvisioningTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(
                _inner,
            ) => _inner.fmt(f),
            CreateProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::VersionsLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateProvisioningTemplateVersionError {
    fn code(&self) -> Option<&str> {
        CreateProvisioningTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProvisioningTemplateVersionError {
    pub fn new(
        kind: CreateProvisioningTemplateVersionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::UnauthorizedException(_)
        )
    }
    pub fn is_versions_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::VersionsLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateProvisioningTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(
                _inner,
            ) => Some(_inner),
            CreateProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateVersionErrorKind::VersionsLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRoleAliasError {
    pub kind: CreateRoleAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRoleAliasErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRoleAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRoleAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRoleAliasError {
    fn code(&self) -> Option<&str> {
        CreateRoleAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRoleAliasError {
    pub fn new(kind: CreateRoleAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRoleAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRoleAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateRoleAliasErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateRoleAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRoleAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateScheduledAuditError {
    pub kind: CreateScheduledAuditErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateScheduledAuditErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateScheduledAuditError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateScheduledAuditErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateScheduledAuditErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateScheduledAuditErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateScheduledAuditErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateScheduledAuditErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateScheduledAuditErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateScheduledAuditError {
    fn code(&self) -> Option<&str> {
        CreateScheduledAuditError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateScheduledAuditError {
    pub fn new(kind: CreateScheduledAuditErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateScheduledAuditErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateScheduledAuditErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScheduledAuditErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScheduledAuditErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScheduledAuditErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScheduledAuditErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScheduledAuditErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateScheduledAuditError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateScheduledAuditErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateScheduledAuditErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateScheduledAuditErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateScheduledAuditErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateScheduledAuditErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateScheduledAuditErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSecurityProfileError {
    pub kind: CreateSecurityProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSecurityProfileErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateSecurityProfileErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSecurityProfileError {
    fn code(&self) -> Option<&str> {
        CreateSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSecurityProfileError {
    pub fn new(kind: CreateSecurityProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityProfileErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateSecurityProfileErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateStreamError {
    pub kind: CreateStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStreamErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateStreamErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateStreamError {
    fn code(&self) -> Option<&str> {
        CreateStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStreamError {
    pub fn new(kind: CreateStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateStreamErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateStreamErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateStreamErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateStreamErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateStreamErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateStreamErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateStreamErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateStreamErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateStreamErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateStreamErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateStreamErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateThingError {
    pub kind: CreateThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateThingErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateThingError {
    fn code(&self) -> Option<&str> {
        CreateThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateThingError {
    pub fn new(kind: CreateThingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, CreateThingErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateThingErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateThingErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateThingErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateThingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateThingGroupError {
    pub kind: CreateThingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateThingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateThingGroupErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateThingGroupError {
    fn code(&self) -> Option<&str> {
        CreateThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateThingGroupError {
    pub fn new(kind: CreateThingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingGroupErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateThingGroupErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateThingTypeError {
    pub kind: CreateThingTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateThingTypeErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateThingTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateThingTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateThingTypeError {
    fn code(&self) -> Option<&str> {
        CreateThingTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateThingTypeError {
    pub fn new(kind: CreateThingTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateThingTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateThingTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingTypeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingTypeErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingTypeErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingTypeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateThingTypeErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingTypeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateThingTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateThingTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTopicRuleError {
    pub kind: CreateTopicRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTopicRuleErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    SqlParseException(crate::error::SqlParseException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::SqlParseException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTopicRuleError {
    fn code(&self) -> Option<&str> {
        CreateTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTopicRuleError {
    pub fn new(kind: CreateTopicRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateTopicRuleErrorKind::InternalException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_sql_parse_exception(&self) -> bool {
        matches!(&self.kind, CreateTopicRuleErrorKind::SqlParseException(_))
    }
}
impl std::error::Error for CreateTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::SqlParseException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTopicRuleDestinationError {
    pub kind: CreateTopicRuleDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTopicRuleDestinationErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTopicRuleDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            CreateTopicRuleDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateTopicRuleDestinationErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateTopicRuleDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTopicRuleDestinationError {
    fn code(&self) -> Option<&str> {
        CreateTopicRuleDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTopicRuleDestinationError {
    pub fn new(kind: CreateTopicRuleDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTopicRuleDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTopicRuleDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleDestinationErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleDestinationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleDestinationErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateTopicRuleDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            CreateTopicRuleDestinationErrorKind::InternalException(_inner) => Some(_inner),
            CreateTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateTopicRuleDestinationErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateTopicRuleDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccountAuditConfigurationError {
    pub kind: DeleteAccountAuditConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccountAuditConfigurationErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccountAuditConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAccountAuditConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAccountAuditConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteAccountAuditConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAccountAuditConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteAccountAuditConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccountAuditConfigurationError {
    pub fn new(kind: DeleteAccountAuditConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccountAuditConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccountAuditConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAuditConfigurationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAuditConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAuditConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAuditConfigurationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteAccountAuditConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DeleteAccountAuditConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DeleteAccountAuditConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteAccountAuditConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAuditSuppressionError {
    pub kind: DeleteAuditSuppressionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAuditSuppressionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAuditSuppressionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAuditSuppressionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteAuditSuppressionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteAuditSuppressionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteAuditSuppressionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAuditSuppressionError {
    fn code(&self) -> Option<&str> {
        DeleteAuditSuppressionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAuditSuppressionError {
    pub fn new(kind: DeleteAuditSuppressionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAuditSuppressionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAuditSuppressionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuditSuppressionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuditSuppressionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuditSuppressionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteAuditSuppressionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAuditSuppressionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteAuditSuppressionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteAuditSuppressionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteAuditSuppressionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAuthorizerError {
    pub kind: DeleteAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAuthorizerErrorKind {
    DeleteConflictException(crate::error::DeleteConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAuthorizerErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAuthorizerError {
    fn code(&self) -> Option<&str> {
        DeleteAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAuthorizerError {
    pub fn new(kind: DeleteAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAuthorizerErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBillingGroupError {
    pub kind: DeleteBillingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBillingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteBillingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBillingGroupError {
    fn code(&self) -> Option<&str> {
        DeleteBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBillingGroupError {
    pub fn new(kind: DeleteBillingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBillingGroupErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBillingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteBillingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCACertificateError {
    pub kind: DeleteCACertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCACertificateErrorKind {
    CertificateStateException(crate::error::CertificateStateException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCACertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCACertificateErrorKind::CertificateStateException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCACertificateError {
    fn code(&self) -> Option<&str> {
        DeleteCACertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCACertificateError {
    pub fn new(kind: DeleteCACertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCACertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCACertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::CertificateStateException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteCACertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCACertificateErrorKind::CertificateStateException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCertificateError {
    pub kind: DeleteCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCertificateErrorKind {
    CertificateStateException(crate::error::CertificateStateException),
    DeleteConflictException(crate::error::DeleteConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCertificateErrorKind::CertificateStateException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCertificateError {
    fn code(&self) -> Option<&str> {
        DeleteCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCertificateError {
    pub fn new(kind: DeleteCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::CertificateStateException(_)
        )
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCertificateErrorKind::CertificateStateException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCustomMetricError {
    pub kind: DeleteCustomMetricErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCustomMetricErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCustomMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCustomMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteCustomMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteCustomMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteCustomMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCustomMetricError {
    fn code(&self) -> Option<&str> {
        DeleteCustomMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCustomMetricError {
    pub fn new(kind: DeleteCustomMetricErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCustomMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCustomMetricErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomMetricErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomMetricErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomMetricErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteCustomMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCustomMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteCustomMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteCustomMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteCustomMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDimensionError {
    pub kind: DeleteDimensionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDimensionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDimensionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDimensionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteDimensionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteDimensionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDimensionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDimensionError {
    fn code(&self) -> Option<&str> {
        DeleteDimensionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDimensionError {
    pub fn new(kind: DeleteDimensionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDimensionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDimensionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDimensionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDimensionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteDimensionErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteDimensionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDimensionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteDimensionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteDimensionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDimensionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDomainConfigurationError {
    pub kind: DeleteDomainConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDomainConfigurationErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDomainConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDomainConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteDomainConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteDomainConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDomainConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteDomainConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDomainConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteDomainConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDomainConfigurationError {
    pub fn new(kind: DeleteDomainConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDomainConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDomainConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteDomainConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDomainConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDynamicThingGroupError {
    pub kind: DeleteDynamicThingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDynamicThingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDynamicThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDynamicThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteDynamicThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteDynamicThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDynamicThingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteDynamicThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDynamicThingGroupError {
    fn code(&self) -> Option<&str> {
        DeleteDynamicThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDynamicThingGroupError {
    pub fn new(kind: DeleteDynamicThingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDynamicThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDynamicThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDynamicThingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDynamicThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDynamicThingGroupErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDynamicThingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteDynamicThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDynamicThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteDynamicThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteDynamicThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDynamicThingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteDynamicThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFleetMetricError {
    pub kind: DeleteFleetMetricErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFleetMetricErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFleetMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFleetMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFleetMetricError {
    fn code(&self) -> Option<&str> {
        DeleteFleetMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFleetMetricError {
    pub fn new(kind: DeleteFleetMetricErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFleetMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFleetMetricErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::UnauthorizedException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteFleetMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFleetMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteJobError {
    pub kind: DeleteJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteJobErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    InvalidStateTransitionException(crate::error::InvalidStateTransitionException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::InvalidStateTransitionException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteJobError {
    fn code(&self) -> Option<&str> {
        DeleteJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteJobError {
    pub fn new(kind: DeleteJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteJobErrorKind::InvalidRequestException(_))
    }
    pub fn is_invalid_state_transition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobErrorKind::InvalidStateTransitionException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeleteJobErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteJobErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteJobErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteJobErrorKind::InvalidStateTransitionException(_inner) => Some(_inner),
            DeleteJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteJobExecutionError {
    pub kind: DeleteJobExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteJobExecutionErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    InvalidStateTransitionException(crate::error::InvalidStateTransitionException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteJobExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteJobExecutionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteJobExecutionErrorKind::InvalidStateTransitionException(_inner) => _inner.fmt(f),
            DeleteJobExecutionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteJobExecutionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteJobExecutionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteJobExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteJobExecutionError {
    fn code(&self) -> Option<&str> {
        DeleteJobExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteJobExecutionError {
    pub fn new(kind: DeleteJobExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteJobExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteJobExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobExecutionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_invalid_state_transition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobExecutionErrorKind::InvalidStateTransitionException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobExecutionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobExecutionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobExecutionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteJobExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteJobExecutionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteJobExecutionErrorKind::InvalidStateTransitionException(_inner) => Some(_inner),
            DeleteJobExecutionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteJobExecutionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteJobExecutionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteJobExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteJobTemplateError {
    pub kind: DeleteJobTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteJobTemplateErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteJobTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteJobTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteJobTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteJobTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteJobTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteJobTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteJobTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteJobTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteJobTemplateError {
    pub fn new(kind: DeleteJobTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteJobTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteJobTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobTemplateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobTemplateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobTemplateErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteJobTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteJobTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteJobTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteJobTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteJobTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteJobTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMitigationActionError {
    pub kind: DeleteMitigationActionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMitigationActionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMitigationActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMitigationActionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteMitigationActionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteMitigationActionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteMitigationActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMitigationActionError {
    fn code(&self) -> Option<&str> {
        DeleteMitigationActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMitigationActionError {
    pub fn new(kind: DeleteMitigationActionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMitigationActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMitigationActionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMitigationActionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMitigationActionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMitigationActionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteMitigationActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMitigationActionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteMitigationActionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteMitigationActionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteMitigationActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteOTAUpdateError {
    pub kind: DeleteOTAUpdateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOTAUpdateErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteOTAUpdateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteOTAUpdateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteOTAUpdateError {
    fn code(&self) -> Option<&str> {
        DeleteOTAUpdateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOTAUpdateError {
    pub fn new(kind: DeleteOTAUpdateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteOTAUpdateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteOTAUpdateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteOTAUpdateErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::UnauthorizedException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteOTAUpdateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteOTAUpdateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePolicyError {
    pub kind: DeletePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePolicyErrorKind {
    DeleteConflictException(crate::error::DeleteConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePolicyErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePolicyError {
    fn code(&self) -> Option<&str> {
        DeletePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePolicyError {
    pub fn new(kind: DeletePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeletePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePolicyErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeletePolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeletePolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeletePolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeletePolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeletePolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeletePolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeletePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePolicyVersionError {
    pub kind: DeletePolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePolicyVersionErrorKind {
    DeleteConflictException(crate::error::DeleteConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePolicyVersionErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePolicyVersionError {
    fn code(&self) -> Option<&str> {
        DeletePolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePolicyVersionError {
    pub fn new(kind: DeletePolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeletePolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePolicyVersionErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProvisioningTemplateError {
    pub kind: DeleteProvisioningTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProvisioningTemplateErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    DeleteConflictException(crate::error::DeleteConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProvisioningTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteProvisioningTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteProvisioningTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProvisioningTemplateError {
    pub fn new(kind: DeleteProvisioningTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProvisioningTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProvisioningTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteProvisioningTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProvisioningTemplateVersionError {
    pub kind: DeleteProvisioningTemplateVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProvisioningTemplateVersionErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    DeleteConflictException(crate::error::DeleteConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProvisioningTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(
                _inner,
            ) => _inner.fmt(f),
            DeleteProvisioningTemplateVersionErrorKind::DeleteConflictException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteProvisioningTemplateVersionError {
    fn code(&self) -> Option<&str> {
        DeleteProvisioningTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProvisioningTemplateVersionError {
    pub fn new(
        kind: DeleteProvisioningTemplateVersionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteProvisioningTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(
                _inner,
            ) => Some(_inner),
            DeleteProvisioningTemplateVersionErrorKind::DeleteConflictException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRegistrationCodeError {
    pub kind: DeleteRegistrationCodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRegistrationCodeErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRegistrationCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRegistrationCodeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteRegistrationCodeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteRegistrationCodeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteRegistrationCodeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteRegistrationCodeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteRegistrationCodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRegistrationCodeError {
    fn code(&self) -> Option<&str> {
        DeleteRegistrationCodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRegistrationCodeError {
    pub fn new(kind: DeleteRegistrationCodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRegistrationCodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRegistrationCodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistrationCodeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistrationCodeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistrationCodeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistrationCodeErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistrationCodeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteRegistrationCodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRegistrationCodeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteRegistrationCodeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteRegistrationCodeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteRegistrationCodeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteRegistrationCodeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteRegistrationCodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRoleAliasError {
    pub kind: DeleteRoleAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRoleAliasErrorKind {
    DeleteConflictException(crate::error::DeleteConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRoleAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRoleAliasErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRoleAliasError {
    fn code(&self) -> Option<&str> {
        DeleteRoleAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRoleAliasError {
    pub fn new(kind: DeleteRoleAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRoleAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRoleAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteRoleAliasErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteRoleAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRoleAliasErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteScheduledAuditError {
    pub kind: DeleteScheduledAuditErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteScheduledAuditErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteScheduledAuditError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteScheduledAuditErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteScheduledAuditErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteScheduledAuditErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteScheduledAuditErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteScheduledAuditErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteScheduledAuditError {
    fn code(&self) -> Option<&str> {
        DeleteScheduledAuditError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteScheduledAuditError {
    pub fn new(kind: DeleteScheduledAuditErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteScheduledAuditErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteScheduledAuditErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduledAuditErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduledAuditErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduledAuditErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduledAuditErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteScheduledAuditError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteScheduledAuditErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteScheduledAuditErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteScheduledAuditErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteScheduledAuditErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteScheduledAuditErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSecurityProfileError {
    pub kind: DeleteSecurityProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSecurityProfileErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteSecurityProfileErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSecurityProfileError {
    fn code(&self) -> Option<&str> {
        DeleteSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSecurityProfileError {
    pub fn new(kind: DeleteSecurityProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityProfileErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteSecurityProfileErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteStreamError {
    pub kind: DeleteStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStreamErrorKind {
    DeleteConflictException(crate::error::DeleteConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteStreamErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteStreamError {
    fn code(&self) -> Option<&str> {
        DeleteStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteStreamError {
    pub fn new(kind: DeleteStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamErrorKind::DeleteConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteStreamErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteStreamErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeleteStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteStreamErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteStreamErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteStreamErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteStreamErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteStreamErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteStreamErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteStreamErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteThingError {
    pub kind: DeleteThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteThingErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteThingError {
    fn code(&self) -> Option<&str> {
        DeleteThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteThingError {
    pub fn new(kind: DeleteThingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteThingErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteThingErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteThingErrorKind::UnauthorizedException(_))
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteThingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteThingErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteThingGroupError {
    pub kind: DeleteThingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteThingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteThingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteThingGroupError {
    fn code(&self) -> Option<&str> {
        DeleteThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteThingGroupError {
    pub fn new(kind: DeleteThingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingGroupErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteThingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteThingTypeError {
    pub kind: DeleteThingTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteThingTypeErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteThingTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteThingTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteThingTypeError {
    fn code(&self) -> Option<&str> {
        DeleteThingTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteThingTypeError {
    pub fn new(kind: DeleteThingTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteThingTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteThingTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingTypeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingTypeErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingTypeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingTypeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteThingTypeErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingTypeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteThingTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteThingTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTopicRuleError {
    pub kind: DeleteTopicRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTopicRuleErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            DeleteTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteTopicRuleErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTopicRuleError {
    fn code(&self) -> Option<&str> {
        DeleteTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTopicRuleError {
    pub fn new(kind: DeleteTopicRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteTopicRuleErrorKind::InternalException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            DeleteTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            DeleteTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteTopicRuleErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTopicRuleDestinationError {
    pub kind: DeleteTopicRuleDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTopicRuleDestinationErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTopicRuleDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            DeleteTopicRuleDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteTopicRuleDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTopicRuleDestinationError {
    fn code(&self) -> Option<&str> {
        DeleteTopicRuleDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTopicRuleDestinationError {
    pub fn new(kind: DeleteTopicRuleDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTopicRuleDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTopicRuleDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleDestinationErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleDestinationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleDestinationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteTopicRuleDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            DeleteTopicRuleDestinationErrorKind::InternalException(_inner) => Some(_inner),
            DeleteTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteTopicRuleDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteV2LoggingLevelError {
    pub kind: DeleteV2LoggingLevelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteV2LoggingLevelErrorKind {
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteV2LoggingLevelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteV2LoggingLevelErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteV2LoggingLevelErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteV2LoggingLevelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteV2LoggingLevelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteV2LoggingLevelError {
    fn code(&self) -> Option<&str> {
        DeleteV2LoggingLevelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteV2LoggingLevelError {
    pub fn new(kind: DeleteV2LoggingLevelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteV2LoggingLevelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteV2LoggingLevelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteV2LoggingLevelErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteV2LoggingLevelErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteV2LoggingLevelErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteV2LoggingLevelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteV2LoggingLevelErrorKind::InternalException(_inner) => Some(_inner),
            DeleteV2LoggingLevelErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteV2LoggingLevelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteV2LoggingLevelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeprecateThingTypeError {
    pub kind: DeprecateThingTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeprecateThingTypeErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeprecateThingTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeprecateThingTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeprecateThingTypeError {
    fn code(&self) -> Option<&str> {
        DeprecateThingTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeprecateThingTypeError {
    pub fn new(kind: DeprecateThingTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeprecateThingTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeprecateThingTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeprecateThingTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeprecateThingTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAccountAuditConfigurationError {
    pub kind: DescribeAccountAuditConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountAuditConfigurationErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAccountAuditConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAccountAuditConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAccountAuditConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeAccountAuditConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountAuditConfigurationError {
    pub fn new(
        kind: DescribeAccountAuditConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAccountAuditConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAccountAuditConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountAuditConfigurationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountAuditConfigurationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAccountAuditConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAccountAuditConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAuditFindingError {
    pub kind: DescribeAuditFindingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuditFindingErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAuditFindingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAuditFindingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeAuditFindingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeAuditFindingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAuditFindingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAuditFindingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAuditFindingError {
    fn code(&self) -> Option<&str> {
        DescribeAuditFindingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuditFindingError {
    pub fn new(kind: DescribeAuditFindingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAuditFindingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAuditFindingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditFindingErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditFindingErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditFindingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditFindingErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAuditFindingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAuditFindingErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAuditFindingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeAuditFindingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAuditFindingErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAuditFindingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAuditMitigationActionsTaskError {
    pub kind: DescribeAuditMitigationActionsTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuditMitigationActionsTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAuditMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAuditMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        DescribeAuditMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuditMitigationActionsTaskError {
    pub fn new(
        kind: DescribeAuditMitigationActionsTaskErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAuditMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DescribeAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAuditSuppressionError {
    pub kind: DescribeAuditSuppressionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuditSuppressionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAuditSuppressionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAuditSuppressionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeAuditSuppressionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeAuditSuppressionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAuditSuppressionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAuditSuppressionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAuditSuppressionError {
    fn code(&self) -> Option<&str> {
        DescribeAuditSuppressionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuditSuppressionError {
    pub fn new(kind: DescribeAuditSuppressionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAuditSuppressionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAuditSuppressionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditSuppressionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditSuppressionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditSuppressionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditSuppressionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAuditSuppressionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAuditSuppressionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAuditSuppressionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeAuditSuppressionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAuditSuppressionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAuditSuppressionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAuditTaskError {
    pub kind: DescribeAuditTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuditTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAuditTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAuditTaskErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeAuditTaskErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeAuditTaskErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAuditTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAuditTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAuditTaskError {
    fn code(&self) -> Option<&str> {
        DescribeAuditTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuditTaskError {
    pub fn new(kind: DescribeAuditTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAuditTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAuditTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAuditTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAuditTaskErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAuditTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeAuditTaskErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAuditTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAuditTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAuthorizerError {
    pub kind: DescribeAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuthorizerErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAuthorizerError {
    fn code(&self) -> Option<&str> {
        DescribeAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuthorizerError {
    pub fn new(kind: DescribeAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBillingGroupError {
    pub kind: DescribeBillingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBillingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeBillingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBillingGroupError {
    fn code(&self) -> Option<&str> {
        DescribeBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBillingGroupError {
    pub fn new(kind: DescribeBillingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBillingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBillingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeBillingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCACertificateError {
    pub kind: DescribeCACertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCACertificateErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCACertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCACertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCACertificateError {
    fn code(&self) -> Option<&str> {
        DescribeCACertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCACertificateError {
    pub fn new(kind: DescribeCACertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCACertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCACertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeCACertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCACertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCertificateError {
    pub kind: DescribeCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCertificateErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCertificateError {
    fn code(&self) -> Option<&str> {
        DescribeCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCertificateError {
    pub fn new(kind: DescribeCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCustomMetricError {
    pub kind: DescribeCustomMetricErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCustomMetricErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCustomMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCustomMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeCustomMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeCustomMetricErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeCustomMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeCustomMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCustomMetricError {
    fn code(&self) -> Option<&str> {
        DescribeCustomMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCustomMetricError {
    pub fn new(kind: DescribeCustomMetricErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCustomMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCustomMetricErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomMetricErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomMetricErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomMetricErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomMetricErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeCustomMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCustomMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeCustomMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeCustomMetricErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeCustomMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeCustomMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDefaultAuthorizerError {
    pub kind: DescribeDefaultAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDefaultAuthorizerErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDefaultAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDefaultAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDefaultAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeDefaultAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDefaultAuthorizerError {
    fn code(&self) -> Option<&str> {
        DescribeDefaultAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDefaultAuthorizerError {
    pub fn new(kind: DescribeDefaultAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDefaultAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDefaultAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeDefaultAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDefaultAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDetectMitigationActionsTaskError {
    pub kind: DescribeDetectMitigationActionsTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDetectMitigationActionsTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDetectMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDetectMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        DescribeDetectMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDetectMitigationActionsTaskError {
    pub fn new(
        kind: DescribeDetectMitigationActionsTaskErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDetectMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDetectMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDetectMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeDetectMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DescribeDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDimensionError {
    pub kind: DescribeDimensionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDimensionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDimensionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDimensionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeDimensionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeDimensionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDimensionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDimensionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDimensionError {
    fn code(&self) -> Option<&str> {
        DescribeDimensionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDimensionError {
    pub fn new(kind: DescribeDimensionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDimensionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDimensionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDimensionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDimensionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDimensionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDimensionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeDimensionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDimensionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeDimensionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeDimensionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDimensionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDimensionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDomainConfigurationError {
    pub kind: DescribeDomainConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDomainConfigurationErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDomainConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDomainConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeDomainConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDomainConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDomainConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeDomainConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDomainConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeDomainConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDomainConfigurationError {
    pub fn new(kind: DescribeDomainConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDomainConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDomainConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeDomainConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDomainConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeDomainConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DescribeDomainConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDomainConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeDomainConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEndpointError {
    pub kind: DescribeEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEndpointErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEndpointErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeEndpointErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeEndpointErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeEndpointErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEndpointError {
    fn code(&self) -> Option<&str> {
        DescribeEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEndpointError {
    pub fn new(kind: DescribeEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEndpointErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEndpointErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEndpointErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEndpointErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEndpointErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeEndpointErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeEndpointErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeEndpointErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEventConfigurationsError {
    pub kind: DescribeEventConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventConfigurationsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEventConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEventConfigurationsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeEventConfigurationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeEventConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEventConfigurationsError {
    fn code(&self) -> Option<&str> {
        DescribeEventConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventConfigurationsError {
    pub fn new(kind: DescribeEventConfigurationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEventConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEventConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventConfigurationsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventConfigurationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeEventConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEventConfigurationsErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeEventConfigurationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeEventConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFleetMetricError {
    pub kind: DescribeFleetMetricErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFleetMetricErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFleetMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFleetMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFleetMetricError {
    fn code(&self) -> Option<&str> {
        DescribeFleetMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFleetMetricError {
    pub fn new(kind: DescribeFleetMetricErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFleetMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFleetMetricErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeFleetMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFleetMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeIndexError {
    pub kind: DescribeIndexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeIndexErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeIndexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeIndexErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeIndexError {
    fn code(&self) -> Option<&str> {
        DescribeIndexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeIndexError {
    pub fn new(kind: DescribeIndexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeIndexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeIndexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIndexErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIndexErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIndexErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIndexErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeIndexErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DescribeIndexErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DescribeIndexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeIndexErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeIndexErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeIndexErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeIndexErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeIndexErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeIndexErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeIndexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeJobError {
    pub kind: DescribeJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeJobErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeJobError {
    fn code(&self) -> Option<&str> {
        DescribeJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeJobError {
    pub fn new(kind: DescribeJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, DescribeJobErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeJobErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DescribeJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeJobExecutionError {
    pub kind: DescribeJobExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeJobExecutionErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeJobExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeJobExecutionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeJobExecutionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeJobExecutionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeJobExecutionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeJobExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeJobExecutionError {
    fn code(&self) -> Option<&str> {
        DescribeJobExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeJobExecutionError {
    pub fn new(kind: DescribeJobExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeJobExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeJobExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobExecutionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobExecutionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobExecutionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobExecutionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeJobExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeJobExecutionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeJobExecutionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeJobExecutionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeJobExecutionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeJobExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeJobTemplateError {
    pub kind: DescribeJobTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeJobTemplateErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeJobTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeJobTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeJobTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeJobTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeJobTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeJobTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeJobTemplateError {
    fn code(&self) -> Option<&str> {
        DescribeJobTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeJobTemplateError {
    pub fn new(kind: DescribeJobTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeJobTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeJobTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobTemplateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobTemplateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobTemplateErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeJobTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeJobTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeJobTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeJobTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeJobTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeJobTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMitigationActionError {
    pub kind: DescribeMitigationActionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMitigationActionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMitigationActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMitigationActionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeMitigationActionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeMitigationActionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeMitigationActionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeMitigationActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMitigationActionError {
    fn code(&self) -> Option<&str> {
        DescribeMitigationActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMitigationActionError {
    pub fn new(kind: DescribeMitigationActionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMitigationActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMitigationActionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMitigationActionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMitigationActionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMitigationActionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMitigationActionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeMitigationActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMitigationActionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeMitigationActionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeMitigationActionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeMitigationActionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeMitigationActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeProvisioningTemplateError {
    pub kind: DescribeProvisioningTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeProvisioningTemplateErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeProvisioningTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeProvisioningTemplateErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeProvisioningTemplateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeProvisioningTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeProvisioningTemplateError {
    fn code(&self) -> Option<&str> {
        DescribeProvisioningTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeProvisioningTemplateError {
    pub fn new(kind: DescribeProvisioningTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeProvisioningTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeProvisioningTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeProvisioningTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeProvisioningTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeProvisioningTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeProvisioningTemplateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeProvisioningTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeProvisioningTemplateVersionError {
    pub kind: DescribeProvisioningTemplateVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeProvisioningTemplateVersionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeProvisioningTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeProvisioningTemplateVersionError {
    fn code(&self) -> Option<&str> {
        DescribeProvisioningTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeProvisioningTemplateVersionError {
    pub fn new(
        kind: DescribeProvisioningTemplateVersionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateVersionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeProvisioningTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateVersionErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRoleAliasError {
    pub kind: DescribeRoleAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRoleAliasErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRoleAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRoleAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRoleAliasError {
    fn code(&self) -> Option<&str> {
        DescribeRoleAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRoleAliasError {
    pub fn new(kind: DescribeRoleAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRoleAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRoleAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeRoleAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRoleAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeScheduledAuditError {
    pub kind: DescribeScheduledAuditErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeScheduledAuditErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeScheduledAuditError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeScheduledAuditErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeScheduledAuditErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeScheduledAuditErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeScheduledAuditErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeScheduledAuditErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeScheduledAuditError {
    fn code(&self) -> Option<&str> {
        DescribeScheduledAuditError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeScheduledAuditError {
    pub fn new(kind: DescribeScheduledAuditErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeScheduledAuditErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeScheduledAuditErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduledAuditErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduledAuditErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduledAuditErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduledAuditErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeScheduledAuditError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeScheduledAuditErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeScheduledAuditErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeScheduledAuditErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeScheduledAuditErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeScheduledAuditErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSecurityProfileError {
    pub kind: DescribeSecurityProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSecurityProfileErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeSecurityProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSecurityProfileError {
    fn code(&self) -> Option<&str> {
        DescribeSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSecurityProfileError {
    pub fn new(kind: DescribeSecurityProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSecurityProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeSecurityProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStreamError {
    pub kind: DescribeStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStreamErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStreamErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStreamError {
    fn code(&self) -> Option<&str> {
        DescribeStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStreamError {
    pub fn new(kind: DescribeStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeStreamErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStreamErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeStreamErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeStreamErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeStreamErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeStreamErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeStreamErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThingError {
    pub kind: DescribeThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThingErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeThingError {
    fn code(&self) -> Option<&str> {
        DescribeThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThingError {
    pub fn new(kind: DescribeThingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeThingErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DescribeThingErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DescribeThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThingGroupError {
    pub kind: DescribeThingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeThingGroupError {
    fn code(&self) -> Option<&str> {
        DescribeThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThingGroupError {
    pub fn new(kind: DescribeThingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThingRegistrationTaskError {
    pub kind: DescribeThingRegistrationTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThingRegistrationTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThingRegistrationTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThingRegistrationTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeThingRegistrationTaskErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeThingRegistrationTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeThingRegistrationTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeThingRegistrationTaskError {
    fn code(&self) -> Option<&str> {
        DescribeThingRegistrationTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThingRegistrationTaskError {
    pub fn new(kind: DescribeThingRegistrationTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThingRegistrationTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThingRegistrationTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingRegistrationTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingRegistrationTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingRegistrationTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingRegistrationTaskErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingRegistrationTaskErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeThingRegistrationTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThingRegistrationTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeThingRegistrationTaskErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeThingRegistrationTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeThingRegistrationTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThingTypeError {
    pub kind: DescribeThingTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThingTypeErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThingTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThingTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeThingTypeError {
    fn code(&self) -> Option<&str> {
        DescribeThingTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThingTypeError {
    pub fn new(kind: DescribeThingTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThingTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThingTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeThingTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThingTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachPolicyError {
    pub kind: DetachPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachPolicyErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachPolicyError {
    fn code(&self) -> Option<&str> {
        DetachPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachPolicyError {
    pub fn new(kind: DetachPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPolicyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPolicyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DetachPolicyErrorKind::LimitExceededException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DetachPolicyErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DetachPolicyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DetachPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            DetachPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DetachPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DetachPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DetachPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetachPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DetachPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachPrincipalPolicyError {
    pub kind: DetachPrincipalPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachPrincipalPolicyErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachPrincipalPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachPrincipalPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachPrincipalPolicyError {
    fn code(&self) -> Option<&str> {
        DetachPrincipalPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachPrincipalPolicyError {
    pub fn new(kind: DetachPrincipalPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachPrincipalPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachPrincipalPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DetachPrincipalPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachPrincipalPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachSecurityProfileError {
    pub kind: DetachSecurityProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachSecurityProfileErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DetachSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DetachSecurityProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DetachSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetachSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachSecurityProfileError {
    fn code(&self) -> Option<&str> {
        DetachSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachSecurityProfileError {
    pub fn new(kind: DetachSecurityProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachSecurityProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DetachSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            DetachSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DetachSecurityProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DetachSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetachSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachThingPrincipalError {
    pub kind: DetachThingPrincipalErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachThingPrincipalErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachThingPrincipalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachThingPrincipalErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachThingPrincipalError {
    fn code(&self) -> Option<&str> {
        DetachThingPrincipalError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachThingPrincipalError {
    pub fn new(kind: DetachThingPrincipalErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachThingPrincipalErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachThingPrincipalErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DetachThingPrincipalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachThingPrincipalErrorKind::InternalFailureException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableTopicRuleError {
    pub kind: DisableTopicRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableTopicRuleErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            DisableTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            DisableTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DisableTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DisableTopicRuleErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DisableTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableTopicRuleError {
    fn code(&self) -> Option<&str> {
        DisableTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableTopicRuleError {
    pub fn new(kind: DisableTopicRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableTopicRuleErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DisableTopicRuleErrorKind::InternalException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableTopicRuleErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DisableTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            DisableTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            DisableTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DisableTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DisableTopicRuleErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DisableTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableTopicRuleError {
    pub kind: EnableTopicRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableTopicRuleErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            EnableTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            EnableTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            EnableTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            EnableTopicRuleErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            EnableTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableTopicRuleError {
    fn code(&self) -> Option<&str> {
        EnableTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableTopicRuleError {
    pub fn new(kind: EnableTopicRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableTopicRuleErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, EnableTopicRuleErrorKind::InternalException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableTopicRuleErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for EnableTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            EnableTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            EnableTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            EnableTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            EnableTopicRuleErrorKind::UnauthorizedException(_inner) => Some(_inner),
            EnableTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBehaviorModelTrainingSummariesError {
    pub kind: GetBehaviorModelTrainingSummariesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBehaviorModelTrainingSummariesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBehaviorModelTrainingSummariesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBehaviorModelTrainingSummariesErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetBehaviorModelTrainingSummariesErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetBehaviorModelTrainingSummariesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetBehaviorModelTrainingSummariesErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            GetBehaviorModelTrainingSummariesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBehaviorModelTrainingSummariesError {
    fn code(&self) -> Option<&str> {
        GetBehaviorModelTrainingSummariesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBehaviorModelTrainingSummariesError {
    pub fn new(
        kind: GetBehaviorModelTrainingSummariesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBehaviorModelTrainingSummariesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBehaviorModelTrainingSummariesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBehaviorModelTrainingSummariesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBehaviorModelTrainingSummariesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBehaviorModelTrainingSummariesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBehaviorModelTrainingSummariesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetBehaviorModelTrainingSummariesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBehaviorModelTrainingSummariesErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            GetBehaviorModelTrainingSummariesErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            GetBehaviorModelTrainingSummariesErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetBehaviorModelTrainingSummariesErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetBehaviorModelTrainingSummariesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBucketsAggregationError {
    pub kind: GetBucketsAggregationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBucketsAggregationErrorKind {
    IndexNotReadyException(crate::error::IndexNotReadyException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidAggregationException(crate::error::InvalidAggregationException),
    InvalidQueryException(crate::error::InvalidQueryException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBucketsAggregationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBucketsAggregationErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBucketsAggregationError {
    fn code(&self) -> Option<&str> {
        GetBucketsAggregationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBucketsAggregationError {
    pub fn new(kind: GetBucketsAggregationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBucketsAggregationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBucketsAggregationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::IndexNotReadyException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::InvalidAggregationException(_)
        )
    }
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::InvalidQueryException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetBucketsAggregationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBucketsAggregationErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::InvalidQueryException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCardinalityError {
    pub kind: GetCardinalityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCardinalityErrorKind {
    IndexNotReadyException(crate::error::IndexNotReadyException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidAggregationException(crate::error::InvalidAggregationException),
    InvalidQueryException(crate::error::InvalidQueryException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCardinalityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCardinalityErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCardinalityError {
    fn code(&self) -> Option<&str> {
        GetCardinalityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCardinalityError {
    pub fn new(kind: GetCardinalityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCardinalityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCardinalityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::IndexNotReadyException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::InvalidAggregationException(_)
        )
    }
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::InvalidQueryException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetCardinalityErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetCardinalityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCardinalityErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            GetCardinalityErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetCardinalityErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            GetCardinalityErrorKind::InvalidQueryException(_inner) => Some(_inner),
            GetCardinalityErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetCardinalityErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetCardinalityErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetCardinalityErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetCardinalityErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetCardinalityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEffectivePoliciesError {
    pub kind: GetEffectivePoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEffectivePoliciesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEffectivePoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEffectivePoliciesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEffectivePoliciesError {
    fn code(&self) -> Option<&str> {
        GetEffectivePoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEffectivePoliciesError {
    pub fn new(kind: GetEffectivePoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEffectivePoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEffectivePoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetEffectivePoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEffectivePoliciesErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIndexingConfigurationError {
    pub kind: GetIndexingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIndexingConfigurationErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIndexingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetIndexingConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetIndexingConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetIndexingConfigurationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetIndexingConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetIndexingConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetIndexingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetIndexingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetIndexingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetIndexingConfigurationError {
    pub fn new(kind: GetIndexingConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetIndexingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetIndexingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIndexingConfigurationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIndexingConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIndexingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIndexingConfigurationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIndexingConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetIndexingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetIndexingConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetIndexingConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetIndexingConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetIndexingConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetIndexingConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetIndexingConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJobDocumentError {
    pub kind: GetJobDocumentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJobDocumentErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJobDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJobDocumentErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetJobDocumentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetJobDocumentErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetJobDocumentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetJobDocumentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJobDocumentError {
    fn code(&self) -> Option<&str> {
        GetJobDocumentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJobDocumentError {
    pub fn new(kind: GetJobDocumentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJobDocumentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJobDocumentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobDocumentErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobDocumentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobDocumentErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetJobDocumentErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for GetJobDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJobDocumentErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetJobDocumentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetJobDocumentErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetJobDocumentErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetJobDocumentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLoggingOptionsError {
    pub kind: GetLoggingOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLoggingOptionsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLoggingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLoggingOptionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetLoggingOptionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetLoggingOptionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetLoggingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLoggingOptionsError {
    fn code(&self) -> Option<&str> {
        GetLoggingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLoggingOptionsError {
    pub fn new(kind: GetLoggingOptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLoggingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLoggingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, GetLoggingOptionsErrorKind::InternalException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoggingOptionsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoggingOptionsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetLoggingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLoggingOptionsErrorKind::InternalException(_inner) => Some(_inner),
            GetLoggingOptionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetLoggingOptionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetLoggingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOTAUpdateError {
    pub kind: GetOTAUpdateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOTAUpdateErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOTAUpdateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOTAUpdateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOTAUpdateError {
    fn code(&self) -> Option<&str> {
        GetOTAUpdateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOTAUpdateError {
    pub fn new(kind: GetOTAUpdateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOTAUpdateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOTAUpdateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOTAUpdateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOTAUpdateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOTAUpdateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOTAUpdateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetOTAUpdateErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetOTAUpdateErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetOTAUpdateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOTAUpdateErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPercentilesError {
    pub kind: GetPercentilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPercentilesErrorKind {
    IndexNotReadyException(crate::error::IndexNotReadyException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidAggregationException(crate::error::InvalidAggregationException),
    InvalidQueryException(crate::error::InvalidQueryException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPercentilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPercentilesErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPercentilesError {
    fn code(&self) -> Option<&str> {
        GetPercentilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPercentilesError {
    pub fn new(kind: GetPercentilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPercentilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPercentilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::IndexNotReadyException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::InvalidAggregationException(_)
        )
    }
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::InvalidQueryException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetPercentilesErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetPercentilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPercentilesErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            GetPercentilesErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetPercentilesErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            GetPercentilesErrorKind::InvalidQueryException(_inner) => Some(_inner),
            GetPercentilesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetPercentilesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetPercentilesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPercentilesErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetPercentilesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetPercentilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPolicyError {
    pub kind: GetPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPolicyErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPolicyError {
    fn code(&self) -> Option<&str> {
        GetPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPolicyError {
    pub fn new(kind: GetPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::InternalFailureException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPolicyVersionError {
    pub kind: GetPolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPolicyVersionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPolicyVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPolicyVersionError {
    fn code(&self) -> Option<&str> {
        GetPolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPolicyVersionError {
    pub fn new(kind: GetPolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetPolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPolicyVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRegistrationCodeError {
    pub kind: GetRegistrationCodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRegistrationCodeErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRegistrationCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRegistrationCodeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetRegistrationCodeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetRegistrationCodeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetRegistrationCodeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetRegistrationCodeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetRegistrationCodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRegistrationCodeError {
    fn code(&self) -> Option<&str> {
        GetRegistrationCodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRegistrationCodeError {
    pub fn new(kind: GetRegistrationCodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRegistrationCodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRegistrationCodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegistrationCodeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegistrationCodeErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegistrationCodeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegistrationCodeErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegistrationCodeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetRegistrationCodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRegistrationCodeErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetRegistrationCodeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetRegistrationCodeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetRegistrationCodeErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetRegistrationCodeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetRegistrationCodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetStatisticsError {
    pub kind: GetStatisticsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStatisticsErrorKind {
    IndexNotReadyException(crate::error::IndexNotReadyException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidAggregationException(crate::error::InvalidAggregationException),
    InvalidQueryException(crate::error::InvalidQueryException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetStatisticsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetStatisticsErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetStatisticsError {
    fn code(&self) -> Option<&str> {
        GetStatisticsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetStatisticsError {
    pub fn new(kind: GetStatisticsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetStatisticsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetStatisticsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::IndexNotReadyException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::InvalidAggregationException(_)
        )
    }
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(&self.kind, GetStatisticsErrorKind::InvalidQueryException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetStatisticsErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetStatisticsErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetStatisticsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetStatisticsErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            GetStatisticsErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetStatisticsErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            GetStatisticsErrorKind::InvalidQueryException(_inner) => Some(_inner),
            GetStatisticsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetStatisticsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetStatisticsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetStatisticsErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetStatisticsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetStatisticsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTopicRuleError {
    pub kind: GetTopicRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTopicRuleErrorKind {
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetTopicRuleErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTopicRuleError {
    fn code(&self) -> Option<&str> {
        GetTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTopicRuleError {
    pub fn new(kind: GetTopicRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, GetTopicRuleErrorKind::InternalException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetTopicRuleErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            GetTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetTopicRuleErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTopicRuleDestinationError {
    pub kind: GetTopicRuleDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTopicRuleDestinationErrorKind {
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTopicRuleDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTopicRuleDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetTopicRuleDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTopicRuleDestinationError {
    fn code(&self) -> Option<&str> {
        GetTopicRuleDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTopicRuleDestinationError {
    pub fn new(kind: GetTopicRuleDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTopicRuleDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTopicRuleDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleDestinationErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleDestinationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleDestinationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetTopicRuleDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTopicRuleDestinationErrorKind::InternalException(_inner) => Some(_inner),
            GetTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetTopicRuleDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetV2LoggingOptionsError {
    pub kind: GetV2LoggingOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetV2LoggingOptionsErrorKind {
    InternalException(crate::error::InternalException),
    NotConfiguredException(crate::error::NotConfiguredException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetV2LoggingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetV2LoggingOptionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetV2LoggingOptionsErrorKind::NotConfiguredException(_inner) => _inner.fmt(f),
            GetV2LoggingOptionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetV2LoggingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetV2LoggingOptionsError {
    fn code(&self) -> Option<&str> {
        GetV2LoggingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetV2LoggingOptionsError {
    pub fn new(kind: GetV2LoggingOptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetV2LoggingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetV2LoggingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetV2LoggingOptionsErrorKind::InternalException(_)
        )
    }
    pub fn is_not_configured_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetV2LoggingOptionsErrorKind::NotConfiguredException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetV2LoggingOptionsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetV2LoggingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetV2LoggingOptionsErrorKind::InternalException(_inner) => Some(_inner),
            GetV2LoggingOptionsErrorKind::NotConfiguredException(_inner) => Some(_inner),
            GetV2LoggingOptionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetV2LoggingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListActiveViolationsError {
    pub kind: ListActiveViolationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListActiveViolationsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListActiveViolationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListActiveViolationsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListActiveViolationsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListActiveViolationsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListActiveViolationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListActiveViolationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListActiveViolationsError {
    fn code(&self) -> Option<&str> {
        ListActiveViolationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListActiveViolationsError {
    pub fn new(kind: ListActiveViolationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListActiveViolationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListActiveViolationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListActiveViolationsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListActiveViolationsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListActiveViolationsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListActiveViolationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListActiveViolationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListActiveViolationsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListActiveViolationsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListActiveViolationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListActiveViolationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListActiveViolationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttachedPoliciesError {
    pub kind: ListAttachedPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttachedPoliciesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttachedPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttachedPoliciesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAttachedPoliciesError {
    fn code(&self) -> Option<&str> {
        ListAttachedPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttachedPoliciesError {
    pub fn new(kind: ListAttachedPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttachedPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttachedPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListAttachedPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttachedPoliciesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuditFindingsError {
    pub kind: ListAuditFindingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuditFindingsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuditFindingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuditFindingsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListAuditFindingsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListAuditFindingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAuditFindingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAuditFindingsError {
    fn code(&self) -> Option<&str> {
        ListAuditFindingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuditFindingsError {
    pub fn new(kind: ListAuditFindingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuditFindingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuditFindingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditFindingsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditFindingsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditFindingsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListAuditFindingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuditFindingsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListAuditFindingsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListAuditFindingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAuditFindingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuditMitigationActionsExecutionsError {
    pub kind: ListAuditMitigationActionsExecutionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuditMitigationActionsExecutionsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuditMitigationActionsExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuditMitigationActionsExecutionsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListAuditMitigationActionsExecutionsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListAuditMitigationActionsExecutionsErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            ListAuditMitigationActionsExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAuditMitigationActionsExecutionsError {
    fn code(&self) -> Option<&str> {
        ListAuditMitigationActionsExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuditMitigationActionsExecutionsError {
    pub fn new(
        kind: ListAuditMitigationActionsExecutionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuditMitigationActionsExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuditMitigationActionsExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsExecutionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsExecutionsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsExecutionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListAuditMitigationActionsExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuditMitigationActionsExecutionsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListAuditMitigationActionsExecutionsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListAuditMitigationActionsExecutionsErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            ListAuditMitigationActionsExecutionsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuditMitigationActionsTasksError {
    pub kind: ListAuditMitigationActionsTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuditMitigationActionsTasksErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuditMitigationActionsTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuditMitigationActionsTasksErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListAuditMitigationActionsTasksErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListAuditMitigationActionsTasksErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAuditMitigationActionsTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAuditMitigationActionsTasksError {
    fn code(&self) -> Option<&str> {
        ListAuditMitigationActionsTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuditMitigationActionsTasksError {
    pub fn new(kind: ListAuditMitigationActionsTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuditMitigationActionsTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuditMitigationActionsTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsTasksErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsTasksErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsTasksErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListAuditMitigationActionsTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuditMitigationActionsTasksErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListAuditMitigationActionsTasksErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListAuditMitigationActionsTasksErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAuditMitigationActionsTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuditSuppressionsError {
    pub kind: ListAuditSuppressionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuditSuppressionsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuditSuppressionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuditSuppressionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListAuditSuppressionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListAuditSuppressionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAuditSuppressionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAuditSuppressionsError {
    fn code(&self) -> Option<&str> {
        ListAuditSuppressionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuditSuppressionsError {
    pub fn new(kind: ListAuditSuppressionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuditSuppressionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuditSuppressionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditSuppressionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditSuppressionsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditSuppressionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListAuditSuppressionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuditSuppressionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListAuditSuppressionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListAuditSuppressionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAuditSuppressionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuditTasksError {
    pub kind: ListAuditTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuditTasksErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuditTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuditTasksErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListAuditTasksErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListAuditTasksErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAuditTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAuditTasksError {
    fn code(&self) -> Option<&str> {
        ListAuditTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuditTasksError {
    pub fn new(kind: ListAuditTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuditTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuditTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditTasksErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditTasksErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListAuditTasksErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListAuditTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuditTasksErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListAuditTasksErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListAuditTasksErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAuditTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuthorizersError {
    pub kind: ListAuthorizersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuthorizersErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuthorizersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuthorizersErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListAuthorizersErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListAuthorizersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAuthorizersErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAuthorizersErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListAuthorizersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAuthorizersError {
    fn code(&self) -> Option<&str> {
        ListAuthorizersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuthorizersError {
    pub fn new(kind: ListAuthorizersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuthorizersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuthorizersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuthorizersErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuthorizersErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuthorizersErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListAuthorizersErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuthorizersErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListAuthorizersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuthorizersErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListAuthorizersErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListAuthorizersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAuthorizersErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAuthorizersErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListAuthorizersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBillingGroupsError {
    pub kind: ListBillingGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBillingGroupsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBillingGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBillingGroupsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListBillingGroupsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListBillingGroupsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListBillingGroupsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListBillingGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBillingGroupsError {
    fn code(&self) -> Option<&str> {
        ListBillingGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBillingGroupsError {
    pub fn new(kind: ListBillingGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBillingGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBillingGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBillingGroupsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBillingGroupsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBillingGroupsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBillingGroupsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListBillingGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBillingGroupsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListBillingGroupsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListBillingGroupsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListBillingGroupsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListBillingGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCACertificatesError {
    pub kind: ListCACertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCACertificatesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCACertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCACertificatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListCACertificatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListCACertificatesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListCACertificatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListCACertificatesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListCACertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCACertificatesError {
    fn code(&self) -> Option<&str> {
        ListCACertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCACertificatesError {
    pub fn new(kind: ListCACertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCACertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCACertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCACertificatesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCACertificatesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCACertificatesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCACertificatesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCACertificatesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListCACertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCACertificatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListCACertificatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListCACertificatesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListCACertificatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListCACertificatesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListCACertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCertificatesError {
    pub kind: ListCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCertificatesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCertificatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListCertificatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListCertificatesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListCertificatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListCertificatesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCertificatesError {
    fn code(&self) -> Option<&str> {
        ListCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCertificatesError {
    pub fn new(kind: ListCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCertificatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListCertificatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListCertificatesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListCertificatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListCertificatesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCertificatesByCAError {
    pub kind: ListCertificatesByCAErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCertificatesByCAErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCertificatesByCAError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCertificatesByCAErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListCertificatesByCAErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListCertificatesByCAErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListCertificatesByCAErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListCertificatesByCAErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListCertificatesByCAErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCertificatesByCAError {
    fn code(&self) -> Option<&str> {
        ListCertificatesByCAError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCertificatesByCAError {
    pub fn new(kind: ListCertificatesByCAErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCertificatesByCAErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCertificatesByCAErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesByCAErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesByCAErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesByCAErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesByCAErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesByCAErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListCertificatesByCAError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCertificatesByCAErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListCertificatesByCAErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListCertificatesByCAErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListCertificatesByCAErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListCertificatesByCAErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListCertificatesByCAErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCustomMetricsError {
    pub kind: ListCustomMetricsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCustomMetricsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCustomMetricsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCustomMetricsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListCustomMetricsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListCustomMetricsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListCustomMetricsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCustomMetricsError {
    fn code(&self) -> Option<&str> {
        ListCustomMetricsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCustomMetricsError {
    pub fn new(kind: ListCustomMetricsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCustomMetricsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCustomMetricsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomMetricsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomMetricsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomMetricsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListCustomMetricsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCustomMetricsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListCustomMetricsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListCustomMetricsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListCustomMetricsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDetectMitigationActionsExecutionsError {
    pub kind: ListDetectMitigationActionsExecutionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDetectMitigationActionsExecutionsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDetectMitigationActionsExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDetectMitigationActionsExecutionsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListDetectMitigationActionsExecutionsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListDetectMitigationActionsExecutionsErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            ListDetectMitigationActionsExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDetectMitigationActionsExecutionsError {
    fn code(&self) -> Option<&str> {
        ListDetectMitigationActionsExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDetectMitigationActionsExecutionsError {
    pub fn new(
        kind: ListDetectMitigationActionsExecutionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDetectMitigationActionsExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDetectMitigationActionsExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsExecutionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsExecutionsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsExecutionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListDetectMitigationActionsExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDetectMitigationActionsExecutionsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListDetectMitigationActionsExecutionsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListDetectMitigationActionsExecutionsErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            ListDetectMitigationActionsExecutionsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDetectMitigationActionsTasksError {
    pub kind: ListDetectMitigationActionsTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDetectMitigationActionsTasksErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDetectMitigationActionsTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDetectMitigationActionsTasksErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListDetectMitigationActionsTasksErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListDetectMitigationActionsTasksErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDetectMitigationActionsTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDetectMitigationActionsTasksError {
    fn code(&self) -> Option<&str> {
        ListDetectMitigationActionsTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDetectMitigationActionsTasksError {
    pub fn new(kind: ListDetectMitigationActionsTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDetectMitigationActionsTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDetectMitigationActionsTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsTasksErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsTasksErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsTasksErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListDetectMitigationActionsTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDetectMitigationActionsTasksErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListDetectMitigationActionsTasksErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListDetectMitigationActionsTasksErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDetectMitigationActionsTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDimensionsError {
    pub kind: ListDimensionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDimensionsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDimensionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDimensionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListDimensionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListDimensionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDimensionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDimensionsError {
    fn code(&self) -> Option<&str> {
        ListDimensionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDimensionsError {
    pub fn new(kind: ListDimensionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDimensionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDimensionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDimensionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDimensionsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListDimensionsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListDimensionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDimensionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListDimensionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListDimensionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDimensionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDomainConfigurationsError {
    pub kind: ListDomainConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDomainConfigurationsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDomainConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDomainConfigurationsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListDomainConfigurationsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListDomainConfigurationsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListDomainConfigurationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDomainConfigurationsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListDomainConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDomainConfigurationsError {
    fn code(&self) -> Option<&str> {
        ListDomainConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDomainConfigurationsError {
    pub fn new(kind: ListDomainConfigurationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDomainConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDomainConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainConfigurationsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainConfigurationsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainConfigurationsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainConfigurationsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainConfigurationsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListDomainConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDomainConfigurationsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListDomainConfigurationsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListDomainConfigurationsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListDomainConfigurationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDomainConfigurationsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListDomainConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFleetMetricsError {
    pub kind: ListFleetMetricsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFleetMetricsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFleetMetricsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFleetMetricsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListFleetMetricsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListFleetMetricsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListFleetMetricsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFleetMetricsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListFleetMetricsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFleetMetricsError {
    fn code(&self) -> Option<&str> {
        ListFleetMetricsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFleetMetricsError {
    pub fn new(kind: ListFleetMetricsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFleetMetricsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFleetMetricsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetMetricsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetMetricsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetMetricsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetMetricsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetMetricsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListFleetMetricsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFleetMetricsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListFleetMetricsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListFleetMetricsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListFleetMetricsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFleetMetricsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListFleetMetricsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListIndicesError {
    pub kind: ListIndicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIndicesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListIndicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListIndicesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListIndicesError {
    fn code(&self) -> Option<&str> {
        ListIndicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIndicesError {
    pub fn new(kind: ListIndicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListIndicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListIndicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIndicesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListIndicesErrorKind::InvalidRequestException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIndicesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListIndicesErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListIndicesErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListIndicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListIndicesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListIndicesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListIndicesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListIndicesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListIndicesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListIndicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobExecutionsForJobError {
    pub kind: ListJobExecutionsForJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobExecutionsForJobErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobExecutionsForJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobExecutionsForJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListJobExecutionsForJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListJobExecutionsForJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListJobExecutionsForJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListJobExecutionsForJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListJobExecutionsForJobError {
    fn code(&self) -> Option<&str> {
        ListJobExecutionsForJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobExecutionsForJobError {
    pub fn new(kind: ListJobExecutionsForJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobExecutionsForJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobExecutionsForJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForJobErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForJobErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListJobExecutionsForJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobExecutionsForJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListJobExecutionsForJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListJobExecutionsForJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListJobExecutionsForJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListJobExecutionsForJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobExecutionsForThingError {
    pub kind: ListJobExecutionsForThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobExecutionsForThingErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobExecutionsForThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobExecutionsForThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListJobExecutionsForThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListJobExecutionsForThingErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ListJobExecutionsForThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListJobExecutionsForThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListJobExecutionsForThingError {
    fn code(&self) -> Option<&str> {
        ListJobExecutionsForThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobExecutionsForThingError {
    pub fn new(kind: ListJobExecutionsForThingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobExecutionsForThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobExecutionsForThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForThingErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForThingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForThingErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForThingErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListJobExecutionsForThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobExecutionsForThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListJobExecutionsForThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListJobExecutionsForThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListJobExecutionsForThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListJobExecutionsForThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobsError {
    pub kind: ListJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobsErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListJobsError {
    fn code(&self) -> Option<&str> {
        ListJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobsError {
    pub fn new(kind: ListJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListJobsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListJobsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListJobsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobTemplatesError {
    pub kind: ListJobTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobTemplatesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobTemplatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListJobTemplatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListJobTemplatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListJobTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListJobTemplatesError {
    fn code(&self) -> Option<&str> {
        ListJobTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobTemplatesError {
    pub fn new(kind: ListJobTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobTemplatesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobTemplatesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobTemplatesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListJobTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobTemplatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListJobTemplatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListJobTemplatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListJobTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMitigationActionsError {
    pub kind: ListMitigationActionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMitigationActionsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMitigationActionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMitigationActionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListMitigationActionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListMitigationActionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListMitigationActionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMitigationActionsError {
    fn code(&self) -> Option<&str> {
        ListMitigationActionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMitigationActionsError {
    pub fn new(kind: ListMitigationActionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMitigationActionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMitigationActionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMitigationActionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMitigationActionsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMitigationActionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListMitigationActionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMitigationActionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListMitigationActionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListMitigationActionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListMitigationActionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOTAUpdatesError {
    pub kind: ListOTAUpdatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOTAUpdatesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOTAUpdatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOTAUpdatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListOTAUpdatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListOTAUpdatesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListOTAUpdatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListOTAUpdatesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListOTAUpdatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOTAUpdatesError {
    fn code(&self) -> Option<&str> {
        ListOTAUpdatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOTAUpdatesError {
    pub fn new(kind: ListOTAUpdatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOTAUpdatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOTAUpdatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOTAUpdatesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOTAUpdatesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOTAUpdatesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListOTAUpdatesErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOTAUpdatesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListOTAUpdatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOTAUpdatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListOTAUpdatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListOTAUpdatesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListOTAUpdatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListOTAUpdatesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListOTAUpdatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOutgoingCertificatesError {
    pub kind: ListOutgoingCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOutgoingCertificatesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOutgoingCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOutgoingCertificatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListOutgoingCertificatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListOutgoingCertificatesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListOutgoingCertificatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListOutgoingCertificatesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListOutgoingCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOutgoingCertificatesError {
    fn code(&self) -> Option<&str> {
        ListOutgoingCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOutgoingCertificatesError {
    pub fn new(kind: ListOutgoingCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOutgoingCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOutgoingCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOutgoingCertificatesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOutgoingCertificatesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOutgoingCertificatesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOutgoingCertificatesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOutgoingCertificatesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListOutgoingCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOutgoingCertificatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListOutgoingCertificatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListOutgoingCertificatesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListOutgoingCertificatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListOutgoingCertificatesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListOutgoingCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPoliciesError {
    pub kind: ListPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPoliciesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPoliciesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPoliciesError {
    fn code(&self) -> Option<&str> {
        ListPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPoliciesError {
    pub fn new(kind: ListPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPoliciesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPoliciesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPoliciesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListPoliciesErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListPoliciesErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPoliciesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListPoliciesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPoliciesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPoliciesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPoliciesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPolicyPrincipalsError {
    pub kind: ListPolicyPrincipalsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPolicyPrincipalsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPolicyPrincipalsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPolicyPrincipalsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPolicyPrincipalsError {
    fn code(&self) -> Option<&str> {
        ListPolicyPrincipalsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPolicyPrincipalsError {
    pub fn new(kind: ListPolicyPrincipalsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPolicyPrincipalsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPolicyPrincipalsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListPolicyPrincipalsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPolicyPrincipalsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPolicyVersionsError {
    pub kind: ListPolicyVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPolicyVersionsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPolicyVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPolicyVersionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPolicyVersionsError {
    fn code(&self) -> Option<&str> {
        ListPolicyVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPolicyVersionsError {
    pub fn new(kind: ListPolicyVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPolicyVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPolicyVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListPolicyVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPolicyVersionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPrincipalPoliciesError {
    pub kind: ListPrincipalPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPrincipalPoliciesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPrincipalPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPrincipalPoliciesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPrincipalPoliciesError {
    fn code(&self) -> Option<&str> {
        ListPrincipalPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPrincipalPoliciesError {
    pub fn new(kind: ListPrincipalPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPrincipalPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPrincipalPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListPrincipalPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPrincipalPoliciesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPrincipalThingsError {
    pub kind: ListPrincipalThingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPrincipalThingsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPrincipalThingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPrincipalThingsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPrincipalThingsError {
    fn code(&self) -> Option<&str> {
        ListPrincipalThingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPrincipalThingsError {
    pub fn new(kind: ListPrincipalThingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPrincipalThingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPrincipalThingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListPrincipalThingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPrincipalThingsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProvisioningTemplatesError {
    pub kind: ListProvisioningTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProvisioningTemplatesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListProvisioningTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProvisioningTemplatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListProvisioningTemplatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListProvisioningTemplatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListProvisioningTemplatesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListProvisioningTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListProvisioningTemplatesError {
    fn code(&self) -> Option<&str> {
        ListProvisioningTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProvisioningTemplatesError {
    pub fn new(kind: ListProvisioningTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProvisioningTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProvisioningTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplatesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplatesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplatesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplatesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListProvisioningTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProvisioningTemplatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListProvisioningTemplatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListProvisioningTemplatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListProvisioningTemplatesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListProvisioningTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProvisioningTemplateVersionsError {
    pub kind: ListProvisioningTemplateVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProvisioningTemplateVersionsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListProvisioningTemplateVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProvisioningTemplateVersionsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListProvisioningTemplateVersionsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListProvisioningTemplateVersionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListProvisioningTemplateVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListProvisioningTemplateVersionsErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            ListProvisioningTemplateVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListProvisioningTemplateVersionsError {
    fn code(&self) -> Option<&str> {
        ListProvisioningTemplateVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProvisioningTemplateVersionsError {
    pub fn new(kind: ListProvisioningTemplateVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProvisioningTemplateVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProvisioningTemplateVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplateVersionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplateVersionsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplateVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplateVersionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplateVersionsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListProvisioningTemplateVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProvisioningTemplateVersionsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListProvisioningTemplateVersionsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListProvisioningTemplateVersionsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListProvisioningTemplateVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListProvisioningTemplateVersionsErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            ListProvisioningTemplateVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRoleAliasesError {
    pub kind: ListRoleAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRoleAliasesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRoleAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRoleAliasesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListRoleAliasesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListRoleAliasesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListRoleAliasesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListRoleAliasesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListRoleAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRoleAliasesError {
    fn code(&self) -> Option<&str> {
        ListRoleAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRoleAliasesError {
    pub fn new(kind: ListRoleAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRoleAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRoleAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoleAliasesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoleAliasesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoleAliasesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListRoleAliasesErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoleAliasesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListRoleAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRoleAliasesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListRoleAliasesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListRoleAliasesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListRoleAliasesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListRoleAliasesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListRoleAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListScheduledAuditsError {
    pub kind: ListScheduledAuditsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListScheduledAuditsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListScheduledAuditsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListScheduledAuditsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListScheduledAuditsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListScheduledAuditsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListScheduledAuditsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListScheduledAuditsError {
    fn code(&self) -> Option<&str> {
        ListScheduledAuditsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListScheduledAuditsError {
    pub fn new(kind: ListScheduledAuditsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListScheduledAuditsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListScheduledAuditsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListScheduledAuditsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListScheduledAuditsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListScheduledAuditsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListScheduledAuditsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListScheduledAuditsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListScheduledAuditsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListScheduledAuditsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListScheduledAuditsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSecurityProfilesError {
    pub kind: ListSecurityProfilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSecurityProfilesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSecurityProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSecurityProfilesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSecurityProfilesError {
    fn code(&self) -> Option<&str> {
        ListSecurityProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSecurityProfilesError {
    pub fn new(kind: ListSecurityProfilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSecurityProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSecurityProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListSecurityProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSecurityProfilesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSecurityProfilesForTargetError {
    pub kind: ListSecurityProfilesForTargetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSecurityProfilesForTargetErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSecurityProfilesForTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSecurityProfilesForTargetErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListSecurityProfilesForTargetErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListSecurityProfilesForTargetErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListSecurityProfilesForTargetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSecurityProfilesForTargetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSecurityProfilesForTargetError {
    fn code(&self) -> Option<&str> {
        ListSecurityProfilesForTargetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSecurityProfilesForTargetError {
    pub fn new(kind: ListSecurityProfilesForTargetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSecurityProfilesForTargetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSecurityProfilesForTargetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesForTargetErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesForTargetErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesForTargetErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesForTargetErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListSecurityProfilesForTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSecurityProfilesForTargetErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListSecurityProfilesForTargetErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListSecurityProfilesForTargetErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListSecurityProfilesForTargetErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSecurityProfilesForTargetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListStreamsError {
    pub kind: ListStreamsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStreamsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListStreamsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListStreamsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListStreamsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListStreamsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListStreamsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListStreamsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListStreamsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListStreamsError {
    fn code(&self) -> Option<&str> {
        ListStreamsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStreamsError {
    pub fn new(kind: ListStreamsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListStreamsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListStreamsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListStreamsErrorKind::InvalidRequestException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListStreamsErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListStreamsErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListStreamsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListStreamsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListStreamsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListStreamsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListStreamsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListStreamsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListStreamsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTargetsForPolicyError {
    pub kind: ListTargetsForPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTargetsForPolicyErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTargetsForPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTargetsForPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTargetsForPolicyError {
    fn code(&self) -> Option<&str> {
        ListTargetsForPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTargetsForPolicyError {
    pub fn new(kind: ListTargetsForPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTargetsForPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTargetsForPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListTargetsForPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTargetsForPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTargetsForSecurityProfileError {
    pub kind: ListTargetsForSecurityProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTargetsForSecurityProfileErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTargetsForSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTargetsForSecurityProfileErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListTargetsForSecurityProfileErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListTargetsForSecurityProfileErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListTargetsForSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTargetsForSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTargetsForSecurityProfileError {
    fn code(&self) -> Option<&str> {
        ListTargetsForSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTargetsForSecurityProfileError {
    pub fn new(kind: ListTargetsForSecurityProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTargetsForSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTargetsForSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForSecurityProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListTargetsForSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTargetsForSecurityProfileErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListTargetsForSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTargetsForSecurityProfileErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListTargetsForSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTargetsForSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingGroupsError {
    pub kind: ListThingGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingGroupsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingGroupsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingGroupsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingGroupsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThingGroupsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThingGroupsError {
    fn code(&self) -> Option<&str> {
        ListThingGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingGroupsError {
    pub fn new(kind: ListThingGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListThingGroupsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListThingGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingGroupsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingGroupsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingGroupsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThingGroupsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingGroupsForThingError {
    pub kind: ListThingGroupsForThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingGroupsForThingErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingGroupsForThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingGroupsForThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingGroupsForThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingGroupsForThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThingGroupsForThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingGroupsForThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThingGroupsForThingError {
    fn code(&self) -> Option<&str> {
        ListThingGroupsForThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingGroupsForThingError {
    pub fn new(kind: ListThingGroupsForThingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingGroupsForThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingGroupsForThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsForThingErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsForThingErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsForThingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsForThingErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListThingGroupsForThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingGroupsForThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingGroupsForThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingGroupsForThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThingGroupsForThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingGroupsForThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingPrincipalsError {
    pub kind: ListThingPrincipalsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingPrincipalsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingPrincipalsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingPrincipalsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThingPrincipalsError {
    fn code(&self) -> Option<&str> {
        ListThingPrincipalsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingPrincipalsError {
    pub fn new(kind: ListThingPrincipalsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingPrincipalsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingPrincipalsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListThingPrincipalsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingPrincipalsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingRegistrationTaskReportsError {
    pub kind: ListThingRegistrationTaskReportsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingRegistrationTaskReportsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingRegistrationTaskReportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingRegistrationTaskReportsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListThingRegistrationTaskReportsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListThingRegistrationTaskReportsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingRegistrationTaskReportsErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            ListThingRegistrationTaskReportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThingRegistrationTaskReportsError {
    fn code(&self) -> Option<&str> {
        ListThingRegistrationTaskReportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingRegistrationTaskReportsError {
    pub fn new(kind: ListThingRegistrationTaskReportsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingRegistrationTaskReportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingRegistrationTaskReportsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTaskReportsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTaskReportsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTaskReportsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTaskReportsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListThingRegistrationTaskReportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingRegistrationTaskReportsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListThingRegistrationTaskReportsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListThingRegistrationTaskReportsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingRegistrationTaskReportsErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            ListThingRegistrationTaskReportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingRegistrationTasksError {
    pub kind: ListThingRegistrationTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingRegistrationTasksErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingRegistrationTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingRegistrationTasksErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingRegistrationTasksErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingRegistrationTasksErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingRegistrationTasksErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListThingRegistrationTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThingRegistrationTasksError {
    fn code(&self) -> Option<&str> {
        ListThingRegistrationTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingRegistrationTasksError {
    pub fn new(kind: ListThingRegistrationTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingRegistrationTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingRegistrationTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTasksErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTasksErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTasksErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTasksErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListThingRegistrationTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingRegistrationTasksErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingRegistrationTasksErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingRegistrationTasksErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingRegistrationTasksErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListThingRegistrationTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingsError {
    pub kind: ListThingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListThingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListThingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThingsError {
    fn code(&self) -> Option<&str> {
        ListThingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingsError {
    pub fn new(kind: ListThingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, ListThingsErrorKind::InternalFailureException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListThingsErrorKind::InvalidRequestException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListThingsErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListThingsErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListThingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListThingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListThingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingsInBillingGroupError {
    pub kind: ListThingsInBillingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingsInBillingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingsInBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingsInBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingsInBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingsInBillingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThingsInBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingsInBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThingsInBillingGroupError {
    fn code(&self) -> Option<&str> {
        ListThingsInBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingsInBillingGroupError {
    pub fn new(kind: ListThingsInBillingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingsInBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingsInBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInBillingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInBillingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListThingsInBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingsInBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingsInBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingsInBillingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThingsInBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingsInBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingsInThingGroupError {
    pub kind: ListThingsInThingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingsInThingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingsInThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingsInThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingsInThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingsInThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThingsInThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingsInThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThingsInThingGroupError {
    fn code(&self) -> Option<&str> {
        ListThingsInThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingsInThingGroupError {
    pub fn new(kind: ListThingsInThingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingsInThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingsInThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInThingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListThingsInThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingsInThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingsInThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingsInThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThingsInThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingsInThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingTypesError {
    pub kind: ListThingTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingTypesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingTypesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingTypesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingTypesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListThingTypesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingTypesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListThingTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThingTypesError {
    fn code(&self) -> Option<&str> {
        ListThingTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingTypesError {
    pub fn new(kind: ListThingTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingTypesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingTypesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingTypesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListThingTypesErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingTypesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListThingTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingTypesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingTypesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingTypesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListThingTypesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingTypesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListThingTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTopicRuleDestinationsError {
    pub kind: ListTopicRuleDestinationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTopicRuleDestinationsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTopicRuleDestinationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTopicRuleDestinationsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListTopicRuleDestinationsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListTopicRuleDestinationsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ListTopicRuleDestinationsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListTopicRuleDestinationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTopicRuleDestinationsError {
    fn code(&self) -> Option<&str> {
        ListTopicRuleDestinationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTopicRuleDestinationsError {
    pub fn new(kind: ListTopicRuleDestinationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTopicRuleDestinationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTopicRuleDestinationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRuleDestinationsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRuleDestinationsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRuleDestinationsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRuleDestinationsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListTopicRuleDestinationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTopicRuleDestinationsErrorKind::InternalException(_inner) => Some(_inner),
            ListTopicRuleDestinationsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTopicRuleDestinationsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListTopicRuleDestinationsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListTopicRuleDestinationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTopicRulesError {
    pub kind: ListTopicRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTopicRulesErrorKind {
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTopicRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTopicRulesErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListTopicRulesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListTopicRulesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListTopicRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTopicRulesError {
    fn code(&self) -> Option<&str> {
        ListTopicRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTopicRulesError {
    pub fn new(kind: ListTopicRulesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTopicRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTopicRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListTopicRulesErrorKind::InternalException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRulesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRulesErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListTopicRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTopicRulesErrorKind::InternalException(_inner) => Some(_inner),
            ListTopicRulesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTopicRulesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListTopicRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListV2LoggingLevelsError {
    pub kind: ListV2LoggingLevelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListV2LoggingLevelsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    NotConfiguredException(crate::error::NotConfiguredException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListV2LoggingLevelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListV2LoggingLevelsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListV2LoggingLevelsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListV2LoggingLevelsErrorKind::NotConfiguredException(_inner) => _inner.fmt(f),
            ListV2LoggingLevelsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListV2LoggingLevelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListV2LoggingLevelsError {
    fn code(&self) -> Option<&str> {
        ListV2LoggingLevelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListV2LoggingLevelsError {
    pub fn new(kind: ListV2LoggingLevelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListV2LoggingLevelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListV2LoggingLevelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListV2LoggingLevelsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListV2LoggingLevelsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_not_configured_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListV2LoggingLevelsErrorKind::NotConfiguredException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListV2LoggingLevelsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListV2LoggingLevelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListV2LoggingLevelsErrorKind::InternalException(_inner) => Some(_inner),
            ListV2LoggingLevelsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListV2LoggingLevelsErrorKind::NotConfiguredException(_inner) => Some(_inner),
            ListV2LoggingLevelsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListV2LoggingLevelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListViolationEventsError {
    pub kind: ListViolationEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListViolationEventsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListViolationEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListViolationEventsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListViolationEventsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListViolationEventsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListViolationEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListViolationEventsError {
    fn code(&self) -> Option<&str> {
        ListViolationEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListViolationEventsError {
    pub fn new(kind: ListViolationEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListViolationEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListViolationEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListViolationEventsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListViolationEventsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListViolationEventsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListViolationEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListViolationEventsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListViolationEventsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListViolationEventsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListViolationEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVerificationStateOnViolationError {
    pub kind: PutVerificationStateOnViolationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVerificationStateOnViolationErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutVerificationStateOnViolationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVerificationStateOnViolationErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            PutVerificationStateOnViolationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutVerificationStateOnViolationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            PutVerificationStateOnViolationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutVerificationStateOnViolationError {
    fn code(&self) -> Option<&str> {
        PutVerificationStateOnViolationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVerificationStateOnViolationError {
    pub fn new(kind: PutVerificationStateOnViolationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVerificationStateOnViolationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVerificationStateOnViolationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVerificationStateOnViolationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVerificationStateOnViolationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVerificationStateOnViolationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for PutVerificationStateOnViolationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVerificationStateOnViolationErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            PutVerificationStateOnViolationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            PutVerificationStateOnViolationErrorKind::ThrottlingException(_inner) => Some(_inner),
            PutVerificationStateOnViolationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterCACertificateError {
    pub kind: RegisterCACertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterCACertificateErrorKind {
    CertificateValidationException(crate::error::CertificateValidationException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    RegistrationCodeValidationException(crate::error::RegistrationCodeValidationException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterCACertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterCACertificateErrorKind::CertificateValidationException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::RegistrationCodeValidationException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCACertificateErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterCACertificateError {
    fn code(&self) -> Option<&str> {
        RegisterCACertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterCACertificateError {
    pub fn new(kind: RegisterCACertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterCACertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterCACertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::CertificateValidationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_registration_code_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::RegistrationCodeValidationException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for RegisterCACertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterCACertificateErrorKind::CertificateValidationException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::RegistrationCodeValidationException(_inner) => {
                Some(_inner)
            }
            RegisterCACertificateErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterCertificateError {
    pub kind: RegisterCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterCertificateErrorKind {
    CertificateConflictException(crate::error::CertificateConflictException),
    CertificateStateException(crate::error::CertificateStateException),
    CertificateValidationException(crate::error::CertificateValidationException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterCertificateErrorKind::CertificateConflictException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::CertificateStateException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::CertificateValidationException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterCertificateError {
    fn code(&self) -> Option<&str> {
        RegisterCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterCertificateError {
    pub fn new(kind: RegisterCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::CertificateConflictException(_)
        )
    }
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::CertificateStateException(_)
        )
    }
    pub fn is_certificate_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::CertificateValidationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for RegisterCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterCertificateErrorKind::CertificateConflictException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::CertificateStateException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::CertificateValidationException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterCertificateWithoutCAError {
    pub kind: RegisterCertificateWithoutCAErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterCertificateWithoutCAErrorKind {
    CertificateStateException(crate::error::CertificateStateException),
    CertificateValidationException(crate::error::CertificateValidationException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterCertificateWithoutCAError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterCertificateWithoutCAErrorKind::CertificateStateException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCertificateWithoutCAErrorKind::CertificateValidationException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCertificateWithoutCAErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCertificateWithoutCAErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RegisterCertificateWithoutCAErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCertificateWithoutCAErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCertificateWithoutCAErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RegisterCertificateWithoutCAErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RegisterCertificateWithoutCAErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterCertificateWithoutCAError {
    fn code(&self) -> Option<&str> {
        RegisterCertificateWithoutCAError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterCertificateWithoutCAError {
    pub fn new(kind: RegisterCertificateWithoutCAErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterCertificateWithoutCAErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterCertificateWithoutCAErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::CertificateStateException(_)
        )
    }
    pub fn is_certificate_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::CertificateValidationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for RegisterCertificateWithoutCAError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterCertificateWithoutCAErrorKind::CertificateStateException(_inner) => {
                Some(_inner)
            }
            RegisterCertificateWithoutCAErrorKind::CertificateValidationException(_inner) => {
                Some(_inner)
            }
            RegisterCertificateWithoutCAErrorKind::InternalFailureException(_inner) => Some(_inner),
            RegisterCertificateWithoutCAErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RegisterCertificateWithoutCAErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            RegisterCertificateWithoutCAErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            RegisterCertificateWithoutCAErrorKind::ThrottlingException(_inner) => Some(_inner),
            RegisterCertificateWithoutCAErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RegisterCertificateWithoutCAErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterThingError {
    pub kind: RegisterThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterThingErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceRegistrationFailureException(crate::error::ResourceRegistrationFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterThingErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::ResourceRegistrationFailureException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterThingError {
    fn code(&self) -> Option<&str> {
        RegisterThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterThingError {
    pub fn new(kind: RegisterThingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterThingErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterThingErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterThingErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_registration_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterThingErrorKind::ResourceRegistrationFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterThingErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, RegisterThingErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, RegisterThingErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for RegisterThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterThingErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            RegisterThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            RegisterThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RegisterThingErrorKind::ResourceRegistrationFailureException(_inner) => Some(_inner),
            RegisterThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RegisterThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            RegisterThingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RegisterThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RejectCertificateTransferError {
    pub kind: RejectCertificateTransferErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectCertificateTransferErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    TransferAlreadyCompletedException(crate::error::TransferAlreadyCompletedException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RejectCertificateTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RejectCertificateTransferErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RejectCertificateTransferErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RejectCertificateTransferErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RejectCertificateTransferErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            RejectCertificateTransferErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RejectCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                _inner.fmt(f)
            }
            RejectCertificateTransferErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RejectCertificateTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RejectCertificateTransferError {
    fn code(&self) -> Option<&str> {
        RejectCertificateTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RejectCertificateTransferError {
    pub fn new(kind: RejectCertificateTransferErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RejectCertificateTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RejectCertificateTransferErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_transfer_already_completed_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::TransferAlreadyCompletedException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for RejectCertificateTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RejectCertificateTransferErrorKind::InternalFailureException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::ThrottlingException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                Some(_inner)
            }
            RejectCertificateTransferErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveThingFromBillingGroupError {
    pub kind: RemoveThingFromBillingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveThingFromBillingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveThingFromBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveThingFromBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RemoveThingFromBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RemoveThingFromBillingGroupErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            RemoveThingFromBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RemoveThingFromBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveThingFromBillingGroupError {
    fn code(&self) -> Option<&str> {
        RemoveThingFromBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveThingFromBillingGroupError {
    pub fn new(kind: RemoveThingFromBillingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveThingFromBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveThingFromBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromBillingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromBillingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for RemoveThingFromBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveThingFromBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            RemoveThingFromBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RemoveThingFromBillingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RemoveThingFromBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            RemoveThingFromBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveThingFromThingGroupError {
    pub kind: RemoveThingFromThingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveThingFromThingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveThingFromThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveThingFromThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RemoveThingFromThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RemoveThingFromThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RemoveThingFromThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RemoveThingFromThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveThingFromThingGroupError {
    fn code(&self) -> Option<&str> {
        RemoveThingFromThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveThingFromThingGroupError {
    pub fn new(kind: RemoveThingFromThingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveThingFromThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveThingFromThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromThingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for RemoveThingFromThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveThingFromThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            RemoveThingFromThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RemoveThingFromThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RemoveThingFromThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            RemoveThingFromThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ReplaceTopicRuleError {
    pub kind: ReplaceTopicRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ReplaceTopicRuleErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    SqlParseException(crate::error::SqlParseException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ReplaceTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ReplaceTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::SqlParseException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ReplaceTopicRuleError {
    fn code(&self) -> Option<&str> {
        ReplaceTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ReplaceTopicRuleError {
    pub fn new(kind: ReplaceTopicRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ReplaceTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ReplaceTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReplaceTopicRuleErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ReplaceTopicRuleErrorKind::InternalException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReplaceTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReplaceTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_sql_parse_exception(&self) -> bool {
        matches!(&self.kind, ReplaceTopicRuleErrorKind::SqlParseException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReplaceTopicRuleErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ReplaceTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ReplaceTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::SqlParseException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchIndexError {
    pub kind: SearchIndexErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchIndexErrorKind {
    IndexNotReadyException(crate::error::IndexNotReadyException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidQueryException(crate::error::InvalidQueryException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchIndexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchIndexErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SearchIndexError {
    fn code(&self) -> Option<&str> {
        SearchIndexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchIndexError {
    pub fn new(kind: SearchIndexErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchIndexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchIndexErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(&self.kind, SearchIndexErrorKind::IndexNotReadyException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchIndexErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(&self.kind, SearchIndexErrorKind::InvalidQueryException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, SearchIndexErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchIndexErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchIndexErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, SearchIndexErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, SearchIndexErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for SearchIndexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchIndexErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            SearchIndexErrorKind::InternalFailureException(_inner) => Some(_inner),
            SearchIndexErrorKind::InvalidQueryException(_inner) => Some(_inner),
            SearchIndexErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SearchIndexErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SearchIndexErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SearchIndexErrorKind::ThrottlingException(_inner) => Some(_inner),
            SearchIndexErrorKind::UnauthorizedException(_inner) => Some(_inner),
            SearchIndexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetDefaultAuthorizerError {
    pub kind: SetDefaultAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetDefaultAuthorizerErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetDefaultAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetDefaultAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetDefaultAuthorizerError {
    fn code(&self) -> Option<&str> {
        SetDefaultAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetDefaultAuthorizerError {
    pub fn new(kind: SetDefaultAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetDefaultAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetDefaultAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for SetDefaultAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetDefaultAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetDefaultPolicyVersionError {
    pub kind: SetDefaultPolicyVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetDefaultPolicyVersionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetDefaultPolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetDefaultPolicyVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetDefaultPolicyVersionError {
    fn code(&self) -> Option<&str> {
        SetDefaultPolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetDefaultPolicyVersionError {
    pub fn new(kind: SetDefaultPolicyVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetDefaultPolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetDefaultPolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for SetDefaultPolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetDefaultPolicyVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetLoggingOptionsError {
    pub kind: SetLoggingOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetLoggingOptionsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetLoggingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetLoggingOptionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            SetLoggingOptionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetLoggingOptionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SetLoggingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetLoggingOptionsError {
    fn code(&self) -> Option<&str> {
        SetLoggingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetLoggingOptionsError {
    pub fn new(kind: SetLoggingOptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetLoggingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetLoggingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, SetLoggingOptionsErrorKind::InternalException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetLoggingOptionsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetLoggingOptionsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for SetLoggingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetLoggingOptionsErrorKind::InternalException(_inner) => Some(_inner),
            SetLoggingOptionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetLoggingOptionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SetLoggingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetV2LoggingLevelError {
    pub kind: SetV2LoggingLevelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetV2LoggingLevelErrorKind {
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    NotConfiguredException(crate::error::NotConfiguredException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetV2LoggingLevelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetV2LoggingLevelErrorKind::InternalException(_inner) => _inner.fmt(f),
            SetV2LoggingLevelErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetV2LoggingLevelErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            SetV2LoggingLevelErrorKind::NotConfiguredException(_inner) => _inner.fmt(f),
            SetV2LoggingLevelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SetV2LoggingLevelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetV2LoggingLevelError {
    fn code(&self) -> Option<&str> {
        SetV2LoggingLevelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetV2LoggingLevelError {
    pub fn new(kind: SetV2LoggingLevelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetV2LoggingLevelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetV2LoggingLevelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, SetV2LoggingLevelErrorKind::InternalException(_))
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingLevelErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingLevelErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_configured_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingLevelErrorKind::NotConfiguredException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingLevelErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for SetV2LoggingLevelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetV2LoggingLevelErrorKind::InternalException(_inner) => Some(_inner),
            SetV2LoggingLevelErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetV2LoggingLevelErrorKind::LimitExceededException(_inner) => Some(_inner),
            SetV2LoggingLevelErrorKind::NotConfiguredException(_inner) => Some(_inner),
            SetV2LoggingLevelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SetV2LoggingLevelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetV2LoggingOptionsError {
    pub kind: SetV2LoggingOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetV2LoggingOptionsErrorKind {
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetV2LoggingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetV2LoggingOptionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            SetV2LoggingOptionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetV2LoggingOptionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SetV2LoggingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetV2LoggingOptionsError {
    fn code(&self) -> Option<&str> {
        SetV2LoggingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetV2LoggingOptionsError {
    pub fn new(kind: SetV2LoggingOptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetV2LoggingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetV2LoggingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingOptionsErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingOptionsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingOptionsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for SetV2LoggingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetV2LoggingOptionsErrorKind::InternalException(_inner) => Some(_inner),
            SetV2LoggingOptionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetV2LoggingOptionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SetV2LoggingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartAuditMitigationActionsTaskError {
    pub kind: StartAuditMitigationActionsTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartAuditMitigationActionsTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    TaskAlreadyExistsException(crate::error::TaskAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartAuditMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            StartAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            StartAuditMitigationActionsTaskErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartAuditMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            StartAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartAuditMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        StartAuditMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartAuditMitigationActionsTaskError {
    pub fn new(kind: StartAuditMitigationActionsTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAuditMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAuditMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAuditMitigationActionsTaskErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_task_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAuditMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAuditMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartAuditMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            StartAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            StartAuditMitigationActionsTaskErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            StartAuditMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            StartAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartDetectMitigationActionsTaskError {
    pub kind: StartDetectMitigationActionsTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartDetectMitigationActionsTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    TaskAlreadyExistsException(crate::error::TaskAlreadyExistsException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartDetectMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            StartDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            StartDetectMitigationActionsTaskErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartDetectMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            StartDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartDetectMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        StartDetectMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartDetectMitigationActionsTaskError {
    pub fn new(kind: StartDetectMitigationActionsTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDetectMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDetectMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDetectMitigationActionsTaskErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_task_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDetectMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDetectMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartDetectMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            StartDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            StartDetectMitigationActionsTaskErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            StartDetectMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            StartDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartOnDemandAuditTaskError {
    pub kind: StartOnDemandAuditTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartOnDemandAuditTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartOnDemandAuditTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartOnDemandAuditTaskErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StartOnDemandAuditTaskErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StartOnDemandAuditTaskErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartOnDemandAuditTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartOnDemandAuditTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartOnDemandAuditTaskError {
    fn code(&self) -> Option<&str> {
        StartOnDemandAuditTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartOnDemandAuditTaskError {
    pub fn new(kind: StartOnDemandAuditTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartOnDemandAuditTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartOnDemandAuditTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOnDemandAuditTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOnDemandAuditTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOnDemandAuditTaskErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOnDemandAuditTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartOnDemandAuditTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartOnDemandAuditTaskErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartOnDemandAuditTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StartOnDemandAuditTaskErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartOnDemandAuditTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartOnDemandAuditTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartThingRegistrationTaskError {
    pub kind: StartThingRegistrationTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartThingRegistrationTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartThingRegistrationTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartThingRegistrationTaskErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StartThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StartThingRegistrationTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            StartThingRegistrationTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartThingRegistrationTaskError {
    fn code(&self) -> Option<&str> {
        StartThingRegistrationTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartThingRegistrationTaskError {
    pub fn new(kind: StartThingRegistrationTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartThingRegistrationTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartThingRegistrationTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartThingRegistrationTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartThingRegistrationTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartThingRegistrationTaskErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartThingRegistrationTaskErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for StartThingRegistrationTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartThingRegistrationTaskErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StartThingRegistrationTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => Some(_inner),
            StartThingRegistrationTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopThingRegistrationTaskError {
    pub kind: StopThingRegistrationTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopThingRegistrationTaskErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopThingRegistrationTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopThingRegistrationTaskErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StopThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StopThingRegistrationTaskErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopThingRegistrationTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StopThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            StopThingRegistrationTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopThingRegistrationTaskError {
    fn code(&self) -> Option<&str> {
        StopThingRegistrationTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopThingRegistrationTaskError {
    pub fn new(kind: StopThingRegistrationTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopThingRegistrationTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopThingRegistrationTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopThingRegistrationTaskErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopThingRegistrationTaskErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopThingRegistrationTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopThingRegistrationTaskErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopThingRegistrationTaskErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for StopThingRegistrationTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopThingRegistrationTaskErrorKind::InternalFailureException(_inner) => Some(_inner),
            StopThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StopThingRegistrationTaskErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopThingRegistrationTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            StopThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => Some(_inner),
            StopThingRegistrationTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidRequestException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestAuthorizationError {
    pub kind: TestAuthorizationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestAuthorizationErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestAuthorizationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestAuthorizationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestAuthorizationError {
    fn code(&self) -> Option<&str> {
        TestAuthorizationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestAuthorizationError {
    pub fn new(kind: TestAuthorizationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestAuthorizationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestAuthorizationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for TestAuthorizationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestAuthorizationErrorKind::InternalFailureException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::LimitExceededException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::ThrottlingException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestInvokeAuthorizerError {
    pub kind: TestInvokeAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestInvokeAuthorizerErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    InvalidResponseException(crate::error::InvalidResponseException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestInvokeAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestInvokeAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::InvalidResponseException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestInvokeAuthorizerError {
    fn code(&self) -> Option<&str> {
        TestInvokeAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestInvokeAuthorizerError {
    pub fn new(kind: TestInvokeAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestInvokeAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestInvokeAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_invalid_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::InvalidResponseException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for TestInvokeAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestInvokeAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::InvalidResponseException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TransferCertificateError {
    pub kind: TransferCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TransferCertificateErrorKind {
    CertificateStateException(crate::error::CertificateStateException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    TransferConflictException(crate::error::TransferConflictException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TransferCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TransferCertificateErrorKind::CertificateStateException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::TransferConflictException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TransferCertificateError {
    fn code(&self) -> Option<&str> {
        TransferCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TransferCertificateError {
    pub fn new(kind: TransferCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TransferCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TransferCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::CertificateStateException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_transfer_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::TransferConflictException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for TransferCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TransferCertificateErrorKind::CertificateStateException(_inner) => Some(_inner),
            TransferCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            TransferCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            TransferCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TransferCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TransferCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            TransferCertificateErrorKind::TransferConflictException(_inner) => Some(_inner),
            TransferCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            TransferCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccountAuditConfigurationError {
    pub kind: UpdateAccountAuditConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccountAuditConfigurationErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccountAuditConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAccountAuditConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAccountAuditConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccountAuditConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateAccountAuditConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAccountAuditConfigurationError {
    pub fn new(kind: UpdateAccountAuditConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccountAuditConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccountAuditConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountAuditConfigurationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountAuditConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountAuditConfigurationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateAccountAuditConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            UpdateAccountAuditConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            UpdateAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAccountAuditConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAuditSuppressionError {
    pub kind: UpdateAuditSuppressionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAuditSuppressionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAuditSuppressionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAuditSuppressionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateAuditSuppressionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateAuditSuppressionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAuditSuppressionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAuditSuppressionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAuditSuppressionError {
    fn code(&self) -> Option<&str> {
        UpdateAuditSuppressionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAuditSuppressionError {
    pub fn new(kind: UpdateAuditSuppressionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAuditSuppressionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAuditSuppressionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditSuppressionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditSuppressionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditSuppressionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditSuppressionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateAuditSuppressionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAuditSuppressionErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateAuditSuppressionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateAuditSuppressionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAuditSuppressionErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAuditSuppressionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAuthorizerError {
    pub kind: UpdateAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAuthorizerErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAuthorizerError {
    fn code(&self) -> Option<&str> {
        UpdateAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAuthorizerError {
    pub fn new(kind: UpdateAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBillingGroupError {
    pub kind: UpdateBillingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBillingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateBillingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateBillingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBillingGroupError {
    fn code(&self) -> Option<&str> {
        UpdateBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBillingGroupError {
    pub fn new(kind: UpdateBillingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBillingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBillingGroupErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBillingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateBillingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateBillingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCACertificateError {
    pub kind: UpdateCACertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCACertificateErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCACertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCACertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCACertificateError {
    fn code(&self) -> Option<&str> {
        UpdateCACertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCACertificateError {
    pub fn new(kind: UpdateCACertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCACertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCACertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateCACertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCACertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCertificateError {
    pub kind: UpdateCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCertificateErrorKind {
    CertificateStateException(crate::error::CertificateStateException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCertificateErrorKind::CertificateStateException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCertificateError {
    fn code(&self) -> Option<&str> {
        UpdateCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCertificateError {
    pub fn new(kind: UpdateCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::CertificateStateException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCertificateErrorKind::CertificateStateException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCustomMetricError {
    pub kind: UpdateCustomMetricErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCustomMetricErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCustomMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCustomMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateCustomMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateCustomMetricErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateCustomMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateCustomMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCustomMetricError {
    fn code(&self) -> Option<&str> {
        UpdateCustomMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCustomMetricError {
    pub fn new(kind: UpdateCustomMetricErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCustomMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCustomMetricErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomMetricErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomMetricErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomMetricErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomMetricErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateCustomMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCustomMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateCustomMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateCustomMetricErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateCustomMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateCustomMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDimensionError {
    pub kind: UpdateDimensionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDimensionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDimensionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDimensionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDimensionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateDimensionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDimensionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDimensionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDimensionError {
    fn code(&self) -> Option<&str> {
        UpdateDimensionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDimensionError {
    pub fn new(kind: UpdateDimensionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDimensionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDimensionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDimensionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDimensionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDimensionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateDimensionErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UpdateDimensionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDimensionErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDimensionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateDimensionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDimensionErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDimensionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDomainConfigurationError {
    pub kind: UpdateDomainConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDomainConfigurationErrorKind {
    CertificateValidationException(crate::error::CertificateValidationException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDomainConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDomainConfigurationErrorKind::CertificateValidationException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDomainConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDomainConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDomainConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDomainConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateDomainConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDomainConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateDomainConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDomainConfigurationError {
    pub fn new(kind: UpdateDomainConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDomainConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDomainConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_certificate_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::CertificateValidationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateDomainConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDomainConfigurationErrorKind::CertificateValidationException(_inner) => {
                Some(_inner)
            }
            UpdateDomainConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDynamicThingGroupError {
    pub kind: UpdateDynamicThingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDynamicThingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidQueryException(crate::error::InvalidQueryException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDynamicThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDynamicThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDynamicThingGroupError {
    fn code(&self) -> Option<&str> {
        UpdateDynamicThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDynamicThingGroupError {
    pub fn new(kind: UpdateDynamicThingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDynamicThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDynamicThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::InvalidQueryException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateDynamicThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDynamicThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::InvalidQueryException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEventConfigurationsError {
    pub kind: UpdateEventConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEventConfigurationsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEventConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEventConfigurationsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateEventConfigurationsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateEventConfigurationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateEventConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEventConfigurationsError {
    fn code(&self) -> Option<&str> {
        UpdateEventConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateEventConfigurationsError {
    pub fn new(kind: UpdateEventConfigurationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEventConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEventConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventConfigurationsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventConfigurationsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventConfigurationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateEventConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEventConfigurationsErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateEventConfigurationsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateEventConfigurationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateEventConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFleetMetricError {
    pub kind: UpdateFleetMetricErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFleetMetricErrorKind {
    IndexNotReadyException(crate::error::IndexNotReadyException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidAggregationException(crate::error::InvalidAggregationException),
    InvalidQueryException(crate::error::InvalidQueryException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFleetMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFleetMetricErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFleetMetricError {
    fn code(&self) -> Option<&str> {
        UpdateFleetMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFleetMetricError {
    pub fn new(kind: UpdateFleetMetricErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFleetMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFleetMetricErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::IndexNotReadyException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::InvalidAggregationException(_)
        )
    }
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::InvalidQueryException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::UnauthorizedException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateFleetMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFleetMetricErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::InvalidQueryException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIndexingConfigurationError {
    pub kind: UpdateIndexingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIndexingConfigurationErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIndexingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIndexingConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateIndexingConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateIndexingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateIndexingConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateIndexingConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateIndexingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateIndexingConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateIndexingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIndexingConfigurationError {
    pub fn new(kind: UpdateIndexingConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIndexingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIndexingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexingConfigurationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexingConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexingConfigurationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexingConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateIndexingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIndexingConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateIndexingConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateIndexingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateIndexingConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateIndexingConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateIndexingConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateJobError {
    pub kind: UpdateJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateJobErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateJobError {
    fn code(&self) -> Option<&str> {
        UpdateJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateJobError {
    pub fn new(kind: UpdateJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJobErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UpdateJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMitigationActionError {
    pub kind: UpdateMitigationActionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMitigationActionErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMitigationActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMitigationActionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateMitigationActionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateMitigationActionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateMitigationActionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateMitigationActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMitigationActionError {
    fn code(&self) -> Option<&str> {
        UpdateMitigationActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMitigationActionError {
    pub fn new(kind: UpdateMitigationActionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMitigationActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMitigationActionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMitigationActionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMitigationActionErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMitigationActionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMitigationActionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateMitigationActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMitigationActionErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateMitigationActionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateMitigationActionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateMitigationActionErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateMitigationActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateProvisioningTemplateError {
    pub kind: UpdateProvisioningTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateProvisioningTemplateErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateProvisioningTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            UpdateProvisioningTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateProvisioningTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateProvisioningTemplateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateProvisioningTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateProvisioningTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateProvisioningTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateProvisioningTemplateError {
    pub fn new(kind: UpdateProvisioningTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateProvisioningTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateProvisioningTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProvisioningTemplateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProvisioningTemplateErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProvisioningTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProvisioningTemplateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateProvisioningTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            UpdateProvisioningTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateProvisioningTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateProvisioningTemplateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateProvisioningTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoleAliasError {
    pub kind: UpdateRoleAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoleAliasErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoleAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoleAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRoleAliasError {
    fn code(&self) -> Option<&str> {
        UpdateRoleAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoleAliasError {
    pub fn new(kind: UpdateRoleAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoleAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoleAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleAliasErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleAliasErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateRoleAliasErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleAliasErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateRoleAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoleAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateScheduledAuditError {
    pub kind: UpdateScheduledAuditErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateScheduledAuditErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateScheduledAuditError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateScheduledAuditErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateScheduledAuditErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateScheduledAuditErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateScheduledAuditErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateScheduledAuditErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateScheduledAuditError {
    fn code(&self) -> Option<&str> {
        UpdateScheduledAuditError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateScheduledAuditError {
    pub fn new(kind: UpdateScheduledAuditErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateScheduledAuditErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateScheduledAuditErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateScheduledAuditErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateScheduledAuditErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateScheduledAuditErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateScheduledAuditErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateScheduledAuditError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateScheduledAuditErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateScheduledAuditErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateScheduledAuditErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateScheduledAuditErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateScheduledAuditErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSecurityProfileError {
    pub kind: UpdateSecurityProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSecurityProfileErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateSecurityProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateSecurityProfileErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSecurityProfileError {
    fn code(&self) -> Option<&str> {
        UpdateSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSecurityProfileError {
    pub fn new(kind: UpdateSecurityProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityProfileErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateSecurityProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateSecurityProfileErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateStreamError {
    pub kind: UpdateStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateStreamErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateStreamErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateStreamError {
    fn code(&self) -> Option<&str> {
        UpdateStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateStreamError {
    pub fn new(kind: UpdateStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStreamErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStreamErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStreamErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStreamErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateStreamErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateStreamErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateStreamErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateStreamErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateStreamErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateStreamErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateStreamErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateStreamErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateThingError {
    pub kind: UpdateThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateThingErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    UnauthorizedException(crate::error::UnauthorizedException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateThingError {
    fn code(&self) -> Option<&str> {
        UpdateThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateThingError {
    pub fn new(kind: UpdateThingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateThingErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateThingErrorKind::ThrottlingException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateThingErrorKind::UnauthorizedException(_))
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateThingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateThingErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateThingGroupError {
    pub kind: UpdateThingGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateThingGroupErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateThingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateThingGroupError {
    fn code(&self) -> Option<&str> {
        UpdateThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateThingGroupError {
    pub fn new(kind: UpdateThingGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateThingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateThingGroupsForThingError {
    pub kind: UpdateThingGroupsForThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateThingGroupsForThingErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateThingGroupsForThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateThingGroupsForThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateThingGroupsForThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateThingGroupsForThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateThingGroupsForThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateThingGroupsForThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateThingGroupsForThingError {
    fn code(&self) -> Option<&str> {
        UpdateThingGroupsForThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateThingGroupsForThingError {
    pub fn new(kind: UpdateThingGroupsForThingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateThingGroupsForThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateThingGroupsForThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupsForThingErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupsForThingErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupsForThingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupsForThingErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateThingGroupsForThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateThingGroupsForThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateThingGroupsForThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateThingGroupsForThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateThingGroupsForThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateThingGroupsForThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTopicRuleDestinationError {
    pub kind: UpdateTopicRuleDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTopicRuleDestinationErrorKind {
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    InternalException(crate::error::InternalException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTopicRuleDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            UpdateTopicRuleDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateTopicRuleDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTopicRuleDestinationError {
    fn code(&self) -> Option<&str> {
        UpdateTopicRuleDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTopicRuleDestinationError {
    pub fn new(kind: UpdateTopicRuleDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTopicRuleDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTopicRuleDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTopicRuleDestinationErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTopicRuleDestinationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTopicRuleDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTopicRuleDestinationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateTopicRuleDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            UpdateTopicRuleDestinationErrorKind::InternalException(_inner) => Some(_inner),
            UpdateTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateTopicRuleDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateSecurityProfileBehaviorsError {
    pub kind: ValidateSecurityProfileBehaviorsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateSecurityProfileBehaviorsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateSecurityProfileBehaviorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ValidateSecurityProfileBehaviorsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ValidateSecurityProfileBehaviorsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ValidateSecurityProfileBehaviorsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ValidateSecurityProfileBehaviorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ValidateSecurityProfileBehaviorsError {
    fn code(&self) -> Option<&str> {
        ValidateSecurityProfileBehaviorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ValidateSecurityProfileBehaviorsError {
    pub fn new(kind: ValidateSecurityProfileBehaviorsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ValidateSecurityProfileBehaviorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ValidateSecurityProfileBehaviorsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateSecurityProfileBehaviorsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateSecurityProfileBehaviorsErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateSecurityProfileBehaviorsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ValidateSecurityProfileBehaviorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ValidateSecurityProfileBehaviorsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ValidateSecurityProfileBehaviorsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ValidateSecurityProfileBehaviorsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ValidateSecurityProfileBehaviorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The rate exceeds the limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottlingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>The request is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequestException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequestException {}
/// See [`InvalidRequestException`](crate::error::InvalidRequestException)
pub mod invalid_request_exception {
    /// A builder for [`InvalidRequestException`](crate::error::InvalidRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestException`](crate::error::InvalidRequestException)
        pub fn build(self) -> crate::error::InvalidRequestException {
            crate::error::InvalidRequestException {
                message: self.message,
            }
        }
    }
}
impl InvalidRequestException {
    /// Creates a new builder-style object to manufacture [`InvalidRequestException`](crate::error::InvalidRequestException)
    pub fn builder() -> crate::error::invalid_request_exception::Builder {
        crate::error::invalid_request_exception::Builder::default()
    }
}

/// <p>An unexpected error has occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalFailureException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalFailureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalFailureException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalFailureException {}
/// See [`InternalFailureException`](crate::error::InternalFailureException)
pub mod internal_failure_exception {
    /// A builder for [`InternalFailureException`](crate::error::InternalFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalFailureException`](crate::error::InternalFailureException)
        pub fn build(self) -> crate::error::InternalFailureException {
            crate::error::InternalFailureException {
                message: self.message,
            }
        }
    }
}
impl InternalFailureException {
    /// Creates a new builder-style object to manufacture [`InternalFailureException`](crate::error::InternalFailureException)
    pub fn builder() -> crate::error::internal_failure_exception::Builder {
        crate::error::internal_failure_exception::Builder::default()
    }
}

/// <p>You are not authorized to perform this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedException {}
/// See [`UnauthorizedException`](crate::error::UnauthorizedException)
pub mod unauthorized_exception {
    /// A builder for [`UnauthorizedException`](crate::error::UnauthorizedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedException`](crate::error::UnauthorizedException)
        pub fn build(self) -> crate::error::UnauthorizedException {
            crate::error::UnauthorizedException {
                message: self.message,
            }
        }
    }
}
impl UnauthorizedException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedException`](crate::error::UnauthorizedException)
    pub fn builder() -> crate::error::unauthorized_exception::Builder {
        crate::error::unauthorized_exception::Builder::default()
    }
}

/// <p>The service is temporarily unavailable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// <p>An unexpected error has occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalException {}
/// See [`InternalException`](crate::error::InternalException)
pub mod internal_exception {
    /// A builder for [`InternalException`](crate::error::InternalException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalException`](crate::error::InternalException)
        pub fn build(self) -> crate::error::InternalException {
            crate::error::InternalException {
                message: self.message,
            }
        }
    }
}
impl InternalException {
    /// Creates a new builder-style object to manufacture [`InternalException`](crate::error::InternalException)
    pub fn builder() -> crate::error::internal_exception::Builder {
        crate::error::internal_exception::Builder::default()
    }
}

/// <p>A conflicting resource update exception. This exception is thrown when two pending
/// updates cause a conflict.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictingResourceUpdateException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictingResourceUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictingResourceUpdateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictingResourceUpdateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictingResourceUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictingResourceUpdateException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictingResourceUpdateException {}
/// See [`ConflictingResourceUpdateException`](crate::error::ConflictingResourceUpdateException)
pub mod conflicting_resource_update_exception {
    /// A builder for [`ConflictingResourceUpdateException`](crate::error::ConflictingResourceUpdateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictingResourceUpdateException`](crate::error::ConflictingResourceUpdateException)
        pub fn build(self) -> crate::error::ConflictingResourceUpdateException {
            crate::error::ConflictingResourceUpdateException {
                message: self.message,
            }
        }
    }
}
impl ConflictingResourceUpdateException {
    /// Creates a new builder-style object to manufacture [`ConflictingResourceUpdateException`](crate::error::ConflictingResourceUpdateException)
    pub fn builder() -> crate::error::conflicting_resource_update_exception::Builder {
        crate::error::conflicting_resource_update_exception::Builder::default()
    }
}

/// <p>The specified resource does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>An exception thrown when the version of an entity specified with the
/// <code>expectedVersion</code> parameter does not match the latest version in the
/// system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VersionConflictException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VersionConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VersionConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl VersionConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for VersionConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "VersionConflictException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for VersionConflictException {}
/// See [`VersionConflictException`](crate::error::VersionConflictException)
pub mod version_conflict_exception {
    /// A builder for [`VersionConflictException`](crate::error::VersionConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`VersionConflictException`](crate::error::VersionConflictException)
        pub fn build(self) -> crate::error::VersionConflictException {
            crate::error::VersionConflictException {
                message: self.message,
            }
        }
    }
}
impl VersionConflictException {
    /// Creates a new builder-style object to manufacture [`VersionConflictException`](crate::error::VersionConflictException)
    pub fn builder() -> crate::error::version_conflict_exception::Builder {
        crate::error::version_conflict_exception::Builder::default()
    }
}

/// <p>The query is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidQueryException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidQueryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidQueryException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidQueryException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidQueryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidQueryException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidQueryException {}
/// See [`InvalidQueryException`](crate::error::InvalidQueryException)
pub mod invalid_query_exception {
    /// A builder for [`InvalidQueryException`](crate::error::InvalidQueryException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidQueryException`](crate::error::InvalidQueryException)
        pub fn build(self) -> crate::error::InvalidQueryException {
            crate::error::InvalidQueryException {
                message: self.message,
            }
        }
    }
}
impl InvalidQueryException {
    /// Creates a new builder-style object to manufacture [`InvalidQueryException`](crate::error::InvalidQueryException)
    pub fn builder() -> crate::error::invalid_query_exception::Builder {
        crate::error::invalid_query_exception::Builder::default()
    }
}

/// <p>The aggregation is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAggregationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAggregationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAggregationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAggregationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAggregationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAggregationException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAggregationException {}
/// See [`InvalidAggregationException`](crate::error::InvalidAggregationException)
pub mod invalid_aggregation_exception {
    /// A builder for [`InvalidAggregationException`](crate::error::InvalidAggregationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAggregationException`](crate::error::InvalidAggregationException)
        pub fn build(self) -> crate::error::InvalidAggregationException {
            crate::error::InvalidAggregationException {
                message: self.message,
            }
        }
    }
}
impl InvalidAggregationException {
    /// Creates a new builder-style object to manufacture [`InvalidAggregationException`](crate::error::InvalidAggregationException)
    pub fn builder() -> crate::error::invalid_aggregation_exception::Builder {
        crate::error::invalid_aggregation_exception::Builder::default()
    }
}

/// <p>The index is not ready.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IndexNotReadyException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IndexNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IndexNotReadyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IndexNotReadyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IndexNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IndexNotReadyException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for IndexNotReadyException {}
/// See [`IndexNotReadyException`](crate::error::IndexNotReadyException)
pub mod index_not_ready_exception {
    /// A builder for [`IndexNotReadyException`](crate::error::IndexNotReadyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IndexNotReadyException`](crate::error::IndexNotReadyException)
        pub fn build(self) -> crate::error::IndexNotReadyException {
            crate::error::IndexNotReadyException {
                message: self.message,
            }
        }
    }
}
impl IndexNotReadyException {
    /// Creates a new builder-style object to manufacture [`IndexNotReadyException`](crate::error::IndexNotReadyException)
    pub fn builder() -> crate::error::index_not_ready_exception::Builder {
        crate::error::index_not_ready_exception::Builder::default()
    }
}

/// <p>The certificate is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CertificateValidationException {
    /// <p>Additional information about the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CertificateValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CertificateValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CertificateValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateValidationException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for CertificateValidationException {}
/// See [`CertificateValidationException`](crate::error::CertificateValidationException)
pub mod certificate_validation_exception {
    /// A builder for [`CertificateValidationException`](crate::error::CertificateValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Additional information about the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateValidationException`](crate::error::CertificateValidationException)
        pub fn build(self) -> crate::error::CertificateValidationException {
            crate::error::CertificateValidationException {
                message: self.message,
            }
        }
    }
}
impl CertificateValidationException {
    /// Creates a new builder-style object to manufacture [`CertificateValidationException`](crate::error::CertificateValidationException)
    pub fn builder() -> crate::error::certificate_validation_exception::Builder {
        crate::error::certificate_validation_exception::Builder::default()
    }
}

/// <p>The certificate operation is not allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CertificateStateException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CertificateStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CertificateStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CertificateStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateStateException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for CertificateStateException {}
/// See [`CertificateStateException`](crate::error::CertificateStateException)
pub mod certificate_state_exception {
    /// A builder for [`CertificateStateException`](crate::error::CertificateStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateStateException`](crate::error::CertificateStateException)
        pub fn build(self) -> crate::error::CertificateStateException {
            crate::error::CertificateStateException {
                message: self.message,
            }
        }
    }
}
impl CertificateStateException {
    /// Creates a new builder-style object to manufacture [`CertificateStateException`](crate::error::CertificateStateException)
    pub fn builder() -> crate::error::certificate_state_exception::Builder {
        crate::error::certificate_state_exception::Builder::default()
    }
}

/// <p>A limit has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>You can't transfer the certificate because authorization policies are still
/// attached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransferConflictException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransferConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransferConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TransferConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TransferConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransferConflictException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for TransferConflictException {}
/// See [`TransferConflictException`](crate::error::TransferConflictException)
pub mod transfer_conflict_exception {
    /// A builder for [`TransferConflictException`](crate::error::TransferConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TransferConflictException`](crate::error::TransferConflictException)
        pub fn build(self) -> crate::error::TransferConflictException {
            crate::error::TransferConflictException {
                message: self.message,
            }
        }
    }
}
impl TransferConflictException {
    /// Creates a new builder-style object to manufacture [`TransferConflictException`](crate::error::TransferConflictException)
    pub fn builder() -> crate::error::transfer_conflict_exception::Builder {
        crate::error::transfer_conflict_exception::Builder::default()
    }
}

/// <p>The response is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResponseException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidResponseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResponseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidResponseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResponseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResponseException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResponseException {}
/// See [`InvalidResponseException`](crate::error::InvalidResponseException)
pub mod invalid_response_exception {
    /// A builder for [`InvalidResponseException`](crate::error::InvalidResponseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResponseException`](crate::error::InvalidResponseException)
        pub fn build(self) -> crate::error::InvalidResponseException {
            crate::error::InvalidResponseException {
                message: self.message,
            }
        }
    }
}
impl InvalidResponseException {
    /// Creates a new builder-style object to manufacture [`InvalidResponseException`](crate::error::InvalidResponseException)
    pub fn builder() -> crate::error::invalid_response_exception::Builder {
        crate::error::invalid_response_exception::Builder::default()
    }
}

/// <p>
/// This exception occurs if you attempt to start a task with the same task-id as an existing task but with a different clientRequestToken.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TaskAlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TaskAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaskAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TaskAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TaskAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TaskAlreadyExistsException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for TaskAlreadyExistsException {}
/// See [`TaskAlreadyExistsException`](crate::error::TaskAlreadyExistsException)
pub mod task_already_exists_exception {
    /// A builder for [`TaskAlreadyExistsException`](crate::error::TaskAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskAlreadyExistsException`](crate::error::TaskAlreadyExistsException)
        pub fn build(self) -> crate::error::TaskAlreadyExistsException {
            crate::error::TaskAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl TaskAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`TaskAlreadyExistsException`](crate::error::TaskAlreadyExistsException)
    pub fn builder() -> crate::error::task_already_exists_exception::Builder {
        crate::error::task_already_exists_exception::Builder::default()
    }
}

/// <p>The resource is not configured.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotConfiguredException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotConfiguredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotConfiguredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotConfiguredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotConfiguredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotConfiguredException")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotConfiguredException {}
/// See [`NotConfiguredException`](crate::error::NotConfiguredException)
pub mod not_configured_exception {
    /// A builder for [`NotConfiguredException`](crate::error::NotConfiguredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotConfiguredException`](crate::error::NotConfiguredException)
        pub fn build(self) -> crate::error::NotConfiguredException {
            crate::error::NotConfiguredException {
                message: self.message,
            }
        }
    }
}
impl NotConfiguredException {
    /// Creates a new builder-style object to manufacture [`NotConfiguredException`](crate::error::NotConfiguredException)
    pub fn builder() -> crate::error::not_configured_exception::Builder {
        crate::error::not_configured_exception::Builder::default()
    }
}

/// <p>The resource already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAlreadyExistsException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The ID of the resource that caused the exception.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource that caused the exception.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
impl ResourceAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistsException")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsException {}
/// See [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
pub mod resource_already_exists_exception {
    /// A builder for [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The ID of the resource that caused the exception.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The ARN of the resource that caused the exception.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
        pub fn build(self) -> crate::error::ResourceAlreadyExistsException {
            crate::error::ResourceAlreadyExistsException {
                message: self.message,
                resource_id: self.resource_id,
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl ResourceAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    pub fn builder() -> crate::error::resource_already_exists_exception::Builder {
        crate::error::resource_already_exists_exception::Builder::default()
    }
}

/// <p>The Rule-SQL expression can't be parsed correctly.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SqlParseException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SqlParseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SqlParseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SqlParseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SqlParseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SqlParseException")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for SqlParseException {}
/// See [`SqlParseException`](crate::error::SqlParseException)
pub mod sql_parse_exception {
    /// A builder for [`SqlParseException`](crate::error::SqlParseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SqlParseException`](crate::error::SqlParseException)
        pub fn build(self) -> crate::error::SqlParseException {
            crate::error::SqlParseException {
                message: self.message,
            }
        }
    }
}
impl SqlParseException {
    /// Creates a new builder-style object to manufacture [`SqlParseException`](crate::error::SqlParseException)
    pub fn builder() -> crate::error::sql_parse_exception::Builder {
        crate::error::sql_parse_exception::Builder::default()
    }
}

/// <p>You can't revert the certificate transfer because the transfer is already
/// complete.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransferAlreadyCompletedException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransferAlreadyCompletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransferAlreadyCompletedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TransferAlreadyCompletedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TransferAlreadyCompletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransferAlreadyCompletedException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for TransferAlreadyCompletedException {}
/// See [`TransferAlreadyCompletedException`](crate::error::TransferAlreadyCompletedException)
pub mod transfer_already_completed_exception {
    /// A builder for [`TransferAlreadyCompletedException`](crate::error::TransferAlreadyCompletedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TransferAlreadyCompletedException`](crate::error::TransferAlreadyCompletedException)
        pub fn build(self) -> crate::error::TransferAlreadyCompletedException {
            crate::error::TransferAlreadyCompletedException {
                message: self.message,
            }
        }
    }
}
impl TransferAlreadyCompletedException {
    /// Creates a new builder-style object to manufacture [`TransferAlreadyCompletedException`](crate::error::TransferAlreadyCompletedException)
    pub fn builder() -> crate::error::transfer_already_completed_exception::Builder {
        crate::error::transfer_already_completed_exception::Builder::default()
    }
}

/// <p>The resource registration failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceRegistrationFailureException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceRegistrationFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceRegistrationFailureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceRegistrationFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceRegistrationFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceRegistrationFailureException")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceRegistrationFailureException {}
/// See [`ResourceRegistrationFailureException`](crate::error::ResourceRegistrationFailureException)
pub mod resource_registration_failure_exception {
    /// A builder for [`ResourceRegistrationFailureException`](crate::error::ResourceRegistrationFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceRegistrationFailureException`](crate::error::ResourceRegistrationFailureException)
        pub fn build(self) -> crate::error::ResourceRegistrationFailureException {
            crate::error::ResourceRegistrationFailureException {
                message: self.message,
            }
        }
    }
}
impl ResourceRegistrationFailureException {
    /// Creates a new builder-style object to manufacture [`ResourceRegistrationFailureException`](crate::error::ResourceRegistrationFailureException)
    pub fn builder() -> crate::error::resource_registration_failure_exception::Builder {
        crate::error::resource_registration_failure_exception::Builder::default()
    }
}

/// <p>Unable to verify the CA certificate used to sign the device certificate you are
/// attempting to register. This is happens when you have registered more than one CA
/// certificate that has the same subject field and public key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CertificateConflictException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CertificateConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CertificateConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CertificateConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateConflictException")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for CertificateConflictException {}
/// See [`CertificateConflictException`](crate::error::CertificateConflictException)
pub mod certificate_conflict_exception {
    /// A builder for [`CertificateConflictException`](crate::error::CertificateConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateConflictException`](crate::error::CertificateConflictException)
        pub fn build(self) -> crate::error::CertificateConflictException {
            crate::error::CertificateConflictException {
                message: self.message,
            }
        }
    }
}
impl CertificateConflictException {
    /// Creates a new builder-style object to manufacture [`CertificateConflictException`](crate::error::CertificateConflictException)
    pub fn builder() -> crate::error::certificate_conflict_exception::Builder {
        crate::error::certificate_conflict_exception::Builder::default()
    }
}

/// <p>The registration code is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegistrationCodeValidationException {
    /// <p>Additional information about the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RegistrationCodeValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegistrationCodeValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RegistrationCodeValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RegistrationCodeValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RegistrationCodeValidationException")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for RegistrationCodeValidationException {}
/// See [`RegistrationCodeValidationException`](crate::error::RegistrationCodeValidationException)
pub mod registration_code_validation_exception {
    /// A builder for [`RegistrationCodeValidationException`](crate::error::RegistrationCodeValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Additional information about the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RegistrationCodeValidationException`](crate::error::RegistrationCodeValidationException)
        pub fn build(self) -> crate::error::RegistrationCodeValidationException {
            crate::error::RegistrationCodeValidationException {
                message: self.message,
            }
        }
    }
}
impl RegistrationCodeValidationException {
    /// Creates a new builder-style object to manufacture [`RegistrationCodeValidationException`](crate::error::RegistrationCodeValidationException)
    pub fn builder() -> crate::error::registration_code_validation_exception::Builder {
        crate::error::registration_code_validation_exception::Builder::default()
    }
}

/// <p>You can't delete the resource because it is attached to one or more
/// resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteConflictException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DeleteConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeleteConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeleteConflictException")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for DeleteConflictException {}
/// See [`DeleteConflictException`](crate::error::DeleteConflictException)
pub mod delete_conflict_exception {
    /// A builder for [`DeleteConflictException`](crate::error::DeleteConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteConflictException`](crate::error::DeleteConflictException)
        pub fn build(self) -> crate::error::DeleteConflictException {
            crate::error::DeleteConflictException {
                message: self.message,
            }
        }
    }
}
impl DeleteConflictException {
    /// Creates a new builder-style object to manufacture [`DeleteConflictException`](crate::error::DeleteConflictException)
    pub fn builder() -> crate::error::delete_conflict_exception::Builder {
        crate::error::delete_conflict_exception::Builder::default()
    }
}

/// <p>An attempt was made to change to an invalid state, for example by deleting a job or a
/// job execution which is "IN_PROGRESS" without setting the <code>force</code>
/// parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidStateTransitionException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidStateTransitionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidStateTransitionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidStateTransitionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidStateTransitionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidStateTransitionException")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidStateTransitionException {}
/// See [`InvalidStateTransitionException`](crate::error::InvalidStateTransitionException)
pub mod invalid_state_transition_exception {
    /// A builder for [`InvalidStateTransitionException`](crate::error::InvalidStateTransitionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidStateTransitionException`](crate::error::InvalidStateTransitionException)
        pub fn build(self) -> crate::error::InvalidStateTransitionException {
            crate::error::InvalidStateTransitionException {
                message: self.message,
            }
        }
    }
}
impl InvalidStateTransitionException {
    /// Creates a new builder-style object to manufacture [`InvalidStateTransitionException`](crate::error::InvalidStateTransitionException)
    pub fn builder() -> crate::error::invalid_state_transition_exception::Builder {
        crate::error::invalid_state_transition_exception::Builder::default()
    }
}

/// <p>The number of policy versions exceeds the limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VersionsLimitExceededException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VersionsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VersionsLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl VersionsLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for VersionsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "VersionsLimitExceededException")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for VersionsLimitExceededException {}
/// See [`VersionsLimitExceededException`](crate::error::VersionsLimitExceededException)
pub mod versions_limit_exceeded_exception {
    /// A builder for [`VersionsLimitExceededException`](crate::error::VersionsLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`VersionsLimitExceededException`](crate::error::VersionsLimitExceededException)
        pub fn build(self) -> crate::error::VersionsLimitExceededException {
            crate::error::VersionsLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl VersionsLimitExceededException {
    /// Creates a new builder-style object to manufacture [`VersionsLimitExceededException`](crate::error::VersionsLimitExceededException)
    pub fn builder() -> crate::error::versions_limit_exceeded_exception::Builder {
        crate::error::versions_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The policy documentation is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedPolicyException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedPolicyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedPolicyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MalformedPolicyException")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedPolicyException {}
/// See [`MalformedPolicyException`](crate::error::MalformedPolicyException)
pub mod malformed_policy_exception {
    /// A builder for [`MalformedPolicyException`](crate::error::MalformedPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedPolicyException`](crate::error::MalformedPolicyException)
        pub fn build(self) -> crate::error::MalformedPolicyException {
            crate::error::MalformedPolicyException {
                message: self.message,
            }
        }
    }
}
impl MalformedPolicyException {
    /// Creates a new builder-style object to manufacture [`MalformedPolicyException`](crate::error::MalformedPolicyException)
    pub fn builder() -> crate::error::malformed_policy_exception::Builder {
        crate::error::malformed_policy_exception::Builder::default()
    }
}

/// <p>A resource with the same name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}
