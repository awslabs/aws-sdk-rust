// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `AcceptCertificateTransfer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AcceptCertificateTransferError {
    /// Kind of error that occurred.
    pub kind: AcceptCertificateTransferErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AcceptCertificateTransfer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptCertificateTransferErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You can't revert the certificate transfer because the transfer is already
    /// complete.</p>
    TransferAlreadyCompletedException(crate::error::TransferAlreadyCompletedException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AcceptCertificateTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AcceptCertificateTransferErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AcceptCertificateTransferErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AcceptCertificateTransferErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AcceptCertificateTransferErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            AcceptCertificateTransferErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AcceptCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                _inner.fmt(f)
            }
            AcceptCertificateTransferErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            AcceptCertificateTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AcceptCertificateTransferError {
    fn code(&self) -> Option<&str> {
        AcceptCertificateTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptCertificateTransferError {
    /// Creates a new `AcceptCertificateTransferError`.
    pub fn new(kind: AcceptCertificateTransferErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AcceptCertificateTransferError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AcceptCertificateTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AcceptCertificateTransferError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AcceptCertificateTransferErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AcceptCertificateTransferErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `AcceptCertificateTransferErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `AcceptCertificateTransferErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AcceptCertificateTransferErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `AcceptCertificateTransferErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `AcceptCertificateTransferErrorKind::TransferAlreadyCompletedException`.
    pub fn is_transfer_already_completed_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::TransferAlreadyCompletedException(_)
        )
    }
    /// Returns `true` if the error kind is `AcceptCertificateTransferErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptCertificateTransferErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for AcceptCertificateTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AcceptCertificateTransferErrorKind::InternalFailureException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::ThrottlingException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                Some(_inner)
            }
            AcceptCertificateTransferErrorKind::UnauthorizedException(_inner) => Some(_inner),
            AcceptCertificateTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `AddThingToBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddThingToBillingGroupError {
    /// Kind of error that occurred.
    pub kind: AddThingToBillingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AddThingToBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddThingToBillingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddThingToBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddThingToBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AddThingToBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AddThingToBillingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AddThingToBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AddThingToBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddThingToBillingGroupError {
    fn code(&self) -> Option<&str> {
        AddThingToBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddThingToBillingGroupError {
    /// Creates a new `AddThingToBillingGroupError`.
    pub fn new(kind: AddThingToBillingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AddThingToBillingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddThingToBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AddThingToBillingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddThingToBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AddThingToBillingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `AddThingToBillingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `AddThingToBillingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToBillingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AddThingToBillingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToBillingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AddThingToBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddThingToBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            AddThingToBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AddThingToBillingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AddThingToBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            AddThingToBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `AddThingToThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddThingToThingGroupError {
    /// Kind of error that occurred.
    pub kind: AddThingToThingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AddThingToThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddThingToThingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddThingToThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddThingToThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AddThingToThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AddThingToThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AddThingToThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AddThingToThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddThingToThingGroupError {
    fn code(&self) -> Option<&str> {
        AddThingToThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddThingToThingGroupError {
    /// Creates a new `AddThingToThingGroupError`.
    pub fn new(kind: AddThingToThingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AddThingToThingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddThingToThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AddThingToThingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddThingToThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AddThingToThingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToThingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `AddThingToThingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `AddThingToThingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AddThingToThingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddThingToThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AddThingToThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddThingToThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            AddThingToThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AddThingToThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AddThingToThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            AddThingToThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `AssociateTargetsWithJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateTargetsWithJobError {
    /// Kind of error that occurred.
    pub kind: AssociateTargetsWithJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AssociateTargetsWithJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateTargetsWithJobErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateTargetsWithJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateTargetsWithJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AssociateTargetsWithJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AssociateTargetsWithJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateTargetsWithJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            AssociateTargetsWithJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateTargetsWithJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AssociateTargetsWithJobError {
    fn code(&self) -> Option<&str> {
        AssociateTargetsWithJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateTargetsWithJobError {
    /// Creates a new `AssociateTargetsWithJobError`.
    pub fn new(kind: AssociateTargetsWithJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AssociateTargetsWithJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateTargetsWithJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AssociateTargetsWithJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateTargetsWithJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AssociateTargetsWithJobErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTargetsWithJobErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociateTargetsWithJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTargetsWithJobErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociateTargetsWithJobErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTargetsWithJobErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociateTargetsWithJobErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTargetsWithJobErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociateTargetsWithJobErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTargetsWithJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for AssociateTargetsWithJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateTargetsWithJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AssociateTargetsWithJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            AssociateTargetsWithJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateTargetsWithJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            AssociateTargetsWithJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateTargetsWithJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `AttachPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachPolicyError {
    /// Kind of error that occurred.
    pub kind: AttachPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AttachPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachPolicyErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            AttachPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AttachPolicyError {
    fn code(&self) -> Option<&str> {
        AttachPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachPolicyError {
    /// Creates a new `AttachPolicyError`.
    pub fn new(kind: AttachPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AttachPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AttachPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AttachPolicyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPolicyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachPolicyErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPolicyErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachPolicyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, AttachPolicyErrorKind::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `AttachPolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachPolicyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachPolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, AttachPolicyErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `AttachPolicyErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, AttachPolicyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for AttachPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            AttachPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AttachPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            AttachPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AttachPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            AttachPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            AttachPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            AttachPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `AttachPrincipalPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachPrincipalPolicyError {
    /// Kind of error that occurred.
    pub kind: AttachPrincipalPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AttachPrincipalPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachPrincipalPolicyErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachPrincipalPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachPrincipalPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            AttachPrincipalPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AttachPrincipalPolicyError {
    fn code(&self) -> Option<&str> {
        AttachPrincipalPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachPrincipalPolicyError {
    /// Creates a new `AttachPrincipalPolicyError`.
    pub fn new(kind: AttachPrincipalPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AttachPrincipalPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachPrincipalPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AttachPrincipalPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachPrincipalPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AttachPrincipalPolicyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachPrincipalPolicyErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachPrincipalPolicyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachPrincipalPolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachPrincipalPolicyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachPrincipalPolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachPrincipalPolicyErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachPrincipalPolicyErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for AttachPrincipalPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachPrincipalPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            AttachPrincipalPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `AttachSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachSecurityProfileError {
    /// Kind of error that occurred.
    pub kind: AttachSecurityProfileErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AttachSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachSecurityProfileErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            AttachSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AttachSecurityProfileError {
    fn code(&self) -> Option<&str> {
        AttachSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachSecurityProfileError {
    /// Creates a new `AttachSecurityProfileError`.
    pub fn new(kind: AttachSecurityProfileErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AttachSecurityProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AttachSecurityProfileError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AttachSecurityProfileErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachSecurityProfileErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachSecurityProfileErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachSecurityProfileErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachSecurityProfileErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachSecurityProfileErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachSecurityProfileErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for AttachSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::VersionConflictException(_inner) => Some(_inner),
            AttachSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `AttachThingPrincipal` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachThingPrincipalError {
    /// Kind of error that occurred.
    pub kind: AttachThingPrincipalErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AttachThingPrincipal` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachThingPrincipalErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachThingPrincipalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachThingPrincipalErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            AttachThingPrincipalErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AttachThingPrincipalError {
    fn code(&self) -> Option<&str> {
        AttachThingPrincipalError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachThingPrincipalError {
    /// Creates a new `AttachThingPrincipalError`.
    pub fn new(kind: AttachThingPrincipalErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AttachThingPrincipalError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachThingPrincipalErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AttachThingPrincipalError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachThingPrincipalErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AttachThingPrincipalErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachThingPrincipalErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachThingPrincipalErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachThingPrincipalErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachThingPrincipalErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `AttachThingPrincipalErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachThingPrincipalErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for AttachThingPrincipalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachThingPrincipalErrorKind::InternalFailureException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::ThrottlingException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::UnauthorizedException(_inner) => Some(_inner),
            AttachThingPrincipalErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CancelAuditMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelAuditMitigationActionsTaskError {
    /// Kind of error that occurred.
    pub kind: CancelAuditMitigationActionsTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CancelAuditMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelAuditMitigationActionsTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelAuditMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            CancelAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            CancelAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CancelAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CancelAuditMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        CancelAuditMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelAuditMitigationActionsTaskError {
    /// Creates a new `CancelAuditMitigationActionsTaskError`.
    pub fn new(
        kind: CancelAuditMitigationActionsTaskErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CancelAuditMitigationActionsTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CancelAuditMitigationActionsTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CancelAuditMitigationActionsTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelAuditMitigationActionsTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelAuditMitigationActionsTaskErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelAuditMitigationActionsTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CancelAuditMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            CancelAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            CancelAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CancelAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CancelAuditTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelAuditTaskError {
    /// Kind of error that occurred.
    pub kind: CancelAuditTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CancelAuditTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelAuditTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelAuditTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelAuditTaskErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CancelAuditTaskErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CancelAuditTaskErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelAuditTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelAuditTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CancelAuditTaskError {
    fn code(&self) -> Option<&str> {
        CancelAuditTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelAuditTaskError {
    /// Creates a new `CancelAuditTaskError`.
    pub fn new(kind: CancelAuditTaskErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CancelAuditTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelAuditTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CancelAuditTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelAuditTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CancelAuditTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelAuditTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelAuditTaskErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelAuditTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelAuditTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CancelAuditTaskErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CancelAuditTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelAuditTaskErrorKind::InternalFailureException(_inner) => Some(_inner),
            CancelAuditTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CancelAuditTaskErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelAuditTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelAuditTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CancelCertificateTransfer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelCertificateTransferError {
    /// Kind of error that occurred.
    pub kind: CancelCertificateTransferErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CancelCertificateTransfer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelCertificateTransferErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You can't revert the certificate transfer because the transfer is already
    /// complete.</p>
    TransferAlreadyCompletedException(crate::error::TransferAlreadyCompletedException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelCertificateTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelCertificateTransferErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CancelCertificateTransferErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CancelCertificateTransferErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelCertificateTransferErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CancelCertificateTransferErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                _inner.fmt(f)
            }
            CancelCertificateTransferErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CancelCertificateTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CancelCertificateTransferError {
    fn code(&self) -> Option<&str> {
        CancelCertificateTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelCertificateTransferError {
    /// Creates a new `CancelCertificateTransferError`.
    pub fn new(kind: CancelCertificateTransferErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CancelCertificateTransferError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelCertificateTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CancelCertificateTransferError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelCertificateTransferErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CancelCertificateTransferErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelCertificateTransferErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelCertificateTransferErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelCertificateTransferErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelCertificateTransferErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelCertificateTransferErrorKind::TransferAlreadyCompletedException`.
    pub fn is_transfer_already_completed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::TransferAlreadyCompletedException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelCertificateTransferErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelCertificateTransferErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CancelCertificateTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelCertificateTransferErrorKind::InternalFailureException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                Some(_inner)
            }
            CancelCertificateTransferErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CancelCertificateTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CancelDetectMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelDetectMitigationActionsTaskError {
    /// Kind of error that occurred.
    pub kind: CancelDetectMitigationActionsTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CancelDetectMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelDetectMitigationActionsTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelDetectMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            CancelDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            CancelDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CancelDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            CancelDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CancelDetectMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        CancelDetectMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelDetectMitigationActionsTaskError {
    /// Creates a new `CancelDetectMitigationActionsTaskError`.
    pub fn new(
        kind: CancelDetectMitigationActionsTaskErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CancelDetectMitigationActionsTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CancelDetectMitigationActionsTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CancelDetectMitigationActionsTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDetectMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelDetectMitigationActionsTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDetectMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelDetectMitigationActionsTaskErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelDetectMitigationActionsTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelDetectMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CancelDetectMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            CancelDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            CancelDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CancelDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CancelJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelJobError {
    /// Kind of error that occurred.
    pub kind: CancelJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CancelJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelJobErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CancelJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CancelJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CancelJobError {
    fn code(&self) -> Option<&str> {
        CancelJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelJobError {
    /// Creates a new `CancelJobError`.
    pub fn new(kind: CancelJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CancelJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CancelJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CancelJobErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, CancelJobErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `CancelJobErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CancelJobErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CancelJobErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelJobErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CancelJobErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CancelJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CancelJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CancelJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CancelJobExecution` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelJobExecutionError {
    /// Kind of error that occurred.
    pub kind: CancelJobExecutionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CancelJobExecution` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelJobExecutionErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>An attempt was made to change to an invalid state, for example by deleting a job or a
    /// job execution which is "IN_PROGRESS" without setting the <code>force</code>
    /// parameter.</p>
    InvalidStateTransitionException(crate::error::InvalidStateTransitionException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelJobExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelJobExecutionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::InvalidStateTransitionException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            CancelJobExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CancelJobExecutionError {
    fn code(&self) -> Option<&str> {
        CancelJobExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelJobExecutionError {
    /// Creates a new `CancelJobExecutionError`.
    pub fn new(kind: CancelJobExecutionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CancelJobExecutionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelJobExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CancelJobExecutionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelJobExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CancelJobExecutionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelJobExecutionErrorKind::InvalidStateTransitionException`.
    pub fn is_invalid_state_transition_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::InvalidStateTransitionException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelJobExecutionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelJobExecutionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelJobExecutionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CancelJobExecutionErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelJobExecutionErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for CancelJobExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelJobExecutionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::InvalidStateTransitionException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::VersionConflictException(_inner) => Some(_inner),
            CancelJobExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ClearDefaultAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ClearDefaultAuthorizerError {
    /// Kind of error that occurred.
    pub kind: ClearDefaultAuthorizerErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ClearDefaultAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ClearDefaultAuthorizerErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ClearDefaultAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ClearDefaultAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ClearDefaultAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ClearDefaultAuthorizerError {
    fn code(&self) -> Option<&str> {
        ClearDefaultAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ClearDefaultAuthorizerError {
    /// Creates a new `ClearDefaultAuthorizerError`.
    pub fn new(kind: ClearDefaultAuthorizerErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ClearDefaultAuthorizerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ClearDefaultAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ClearDefaultAuthorizerError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ClearDefaultAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ClearDefaultAuthorizerErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ClearDefaultAuthorizerErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ClearDefaultAuthorizerErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ClearDefaultAuthorizerErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ClearDefaultAuthorizerErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ClearDefaultAuthorizerErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ClearDefaultAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ClearDefaultAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ClearDefaultAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ClearDefaultAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ConfirmTopicRuleDestination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConfirmTopicRuleDestinationError {
    /// Kind of error that occurred.
    pub kind: ConfirmTopicRuleDestinationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ConfirmTopicRuleDestination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConfirmTopicRuleDestinationErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConfirmTopicRuleDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConfirmTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            ConfirmTopicRuleDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            ConfirmTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ConfirmTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ConfirmTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ConfirmTopicRuleDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ConfirmTopicRuleDestinationError {
    fn code(&self) -> Option<&str> {
        ConfirmTopicRuleDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConfirmTopicRuleDestinationError {
    /// Creates a new `ConfirmTopicRuleDestinationError`.
    pub fn new(kind: ConfirmTopicRuleDestinationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ConfirmTopicRuleDestinationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConfirmTopicRuleDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ConfirmTopicRuleDestinationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConfirmTopicRuleDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ConfirmTopicRuleDestinationErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `ConfirmTopicRuleDestinationErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTopicRuleDestinationErrorKind::InternalException(_)
        )
    }
    /// Returns `true` if the error kind is `ConfirmTopicRuleDestinationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTopicRuleDestinationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ConfirmTopicRuleDestinationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTopicRuleDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ConfirmTopicRuleDestinationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTopicRuleDestinationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ConfirmTopicRuleDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConfirmTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            ConfirmTopicRuleDestinationErrorKind::InternalException(_inner) => Some(_inner),
            ConfirmTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ConfirmTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            ConfirmTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ConfirmTopicRuleDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateAuditSuppression` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAuditSuppressionError {
    /// Kind of error that occurred.
    pub kind: CreateAuditSuppressionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateAuditSuppression` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAuditSuppressionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAuditSuppressionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAuditSuppressionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateAuditSuppressionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateAuditSuppressionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateAuditSuppressionErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateAuditSuppressionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateAuditSuppressionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateAuditSuppressionError {
    fn code(&self) -> Option<&str> {
        CreateAuditSuppressionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAuditSuppressionError {
    /// Creates a new `CreateAuditSuppressionError`.
    pub fn new(kind: CreateAuditSuppressionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateAuditSuppressionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAuditSuppressionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateAuditSuppressionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAuditSuppressionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateAuditSuppressionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuditSuppressionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateAuditSuppressionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuditSuppressionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateAuditSuppressionErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuditSuppressionErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateAuditSuppressionErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuditSuppressionErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateAuditSuppressionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuditSuppressionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateAuditSuppressionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAuditSuppressionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateAuditSuppressionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateAuditSuppressionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateAuditSuppressionErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateAuditSuppressionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateAuditSuppressionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAuthorizerError {
    /// Kind of error that occurred.
    pub kind: CreateAuthorizerErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAuthorizerErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateAuthorizerError {
    fn code(&self) -> Option<&str> {
        CreateAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAuthorizerError {
    /// Creates a new `CreateAuthorizerError`.
    pub fn new(kind: CreateAuthorizerErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateAuthorizerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateAuthorizerError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateAuthorizerErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateAuthorizerErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateAuthorizerErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateAuthorizerErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateAuthorizerErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateAuthorizerErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateAuthorizerErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBillingGroupError {
    /// Kind of error that occurred.
    pub kind: CreateBillingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBillingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateBillingGroupErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateBillingGroupError {
    fn code(&self) -> Option<&str> {
        CreateBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBillingGroupError {
    /// Creates a new `CreateBillingGroupError`.
    pub fn new(kind: CreateBillingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateBillingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateBillingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateBillingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBillingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBillingGroupErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBillingGroupErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBillingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBillingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateBillingGroupErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateCertificateFromCsr` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCertificateFromCsrError {
    /// Kind of error that occurred.
    pub kind: CreateCertificateFromCsrErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateCertificateFromCsr` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCertificateFromCsrErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCertificateFromCsrError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCertificateFromCsrErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateCertificateFromCsrErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateCertificateFromCsrErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateCertificateFromCsrErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateCertificateFromCsrErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateCertificateFromCsrErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCertificateFromCsrError {
    fn code(&self) -> Option<&str> {
        CreateCertificateFromCsrError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCertificateFromCsrError {
    /// Creates a new `CreateCertificateFromCsrError`.
    pub fn new(kind: CreateCertificateFromCsrErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateCertificateFromCsrError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCertificateFromCsrErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateCertificateFromCsrError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCertificateFromCsrErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateCertificateFromCsrErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateFromCsrErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCertificateFromCsrErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateFromCsrErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCertificateFromCsrErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateFromCsrErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCertificateFromCsrErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateFromCsrErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCertificateFromCsrErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateFromCsrErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateCertificateFromCsrError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCertificateFromCsrErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateCertificateFromCsrErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateCertificateFromCsrErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateCertificateFromCsrErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateCertificateFromCsrErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateCertificateFromCsrErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateCustomMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCustomMetricError {
    /// Kind of error that occurred.
    pub kind: CreateCustomMetricErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateCustomMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCustomMetricErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCustomMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCustomMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateCustomMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateCustomMetricErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateCustomMetricErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateCustomMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateCustomMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCustomMetricError {
    fn code(&self) -> Option<&str> {
        CreateCustomMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCustomMetricError {
    /// Creates a new `CreateCustomMetricError`.
    pub fn new(kind: CreateCustomMetricErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateCustomMetricError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCustomMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateCustomMetricError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCustomMetricErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateCustomMetricErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomMetricErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCustomMetricErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomMetricErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCustomMetricErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomMetricErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCustomMetricErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomMetricErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCustomMetricErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomMetricErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateCustomMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCustomMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateCustomMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateCustomMetricErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateCustomMetricErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateCustomMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateCustomMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateDimension` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDimensionError {
    /// Kind of error that occurred.
    pub kind: CreateDimensionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateDimension` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDimensionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDimensionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDimensionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateDimensionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateDimensionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDimensionErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateDimensionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDimensionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDimensionError {
    fn code(&self) -> Option<&str> {
        CreateDimensionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDimensionError {
    /// Creates a new `CreateDimensionError`.
    pub fn new(kind: CreateDimensionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateDimensionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDimensionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateDimensionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDimensionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateDimensionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDimensionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDimensionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDimensionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDimensionErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDimensionErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDimensionErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDimensionErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDimensionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateDimensionErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateDimensionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDimensionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateDimensionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateDimensionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDimensionErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateDimensionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDimensionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateDomainConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDomainConfigurationError {
    /// Kind of error that occurred.
    pub kind: CreateDomainConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateDomainConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDomainConfigurationErrorKind {
    /// <p>The certificate is invalid.</p>
    CertificateValidationException(crate::error::CertificateValidationException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDomainConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDomainConfigurationErrorKind::CertificateValidationException(_inner) => {
                _inner.fmt(f)
            }
            CreateDomainConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateDomainConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateDomainConfigurationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDomainConfigurationErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateDomainConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDomainConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateDomainConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDomainConfigurationError {
    fn code(&self) -> Option<&str> {
        CreateDomainConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDomainConfigurationError {
    /// Creates a new `CreateDomainConfigurationError`.
    pub fn new(kind: CreateDomainConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateDomainConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDomainConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateDomainConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDomainConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateDomainConfigurationErrorKind::CertificateValidationException`.
    pub fn is_certificate_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::CertificateValidationException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDomainConfigurationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDomainConfigurationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDomainConfigurationErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDomainConfigurationErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDomainConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDomainConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDomainConfigurationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateDomainConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDomainConfigurationErrorKind::CertificateValidationException(_inner) => {
                Some(_inner)
            }
            CreateDomainConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateDomainConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateDynamicThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDynamicThingGroupError {
    /// Kind of error that occurred.
    pub kind: CreateDynamicThingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateDynamicThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDynamicThingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The query is invalid.</p>
    InvalidQueryException(crate::error::InvalidQueryException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDynamicThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDynamicThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateDynamicThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDynamicThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDynamicThingGroupError {
    fn code(&self) -> Option<&str> {
        CreateDynamicThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDynamicThingGroupError {
    /// Creates a new `CreateDynamicThingGroupError`.
    pub fn new(kind: CreateDynamicThingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateDynamicThingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDynamicThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateDynamicThingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDynamicThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateDynamicThingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDynamicThingGroupErrorKind::InvalidQueryException`.
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::InvalidQueryException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDynamicThingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDynamicThingGroupErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDynamicThingGroupErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDynamicThingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDynamicThingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDynamicThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateDynamicThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDynamicThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::InvalidQueryException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateDynamicThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDynamicThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateFleetMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFleetMetricError {
    /// Kind of error that occurred.
    pub kind: CreateFleetMetricErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateFleetMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFleetMetricErrorKind {
    /// <p>The index is not ready.</p>
    IndexNotReadyException(crate::error::IndexNotReadyException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The aggregation is invalid.</p>
    InvalidAggregationException(crate::error::InvalidAggregationException),
    /// <p>The query is invalid.</p>
    InvalidQueryException(crate::error::InvalidQueryException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFleetMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFleetMetricErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateFleetMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateFleetMetricError {
    fn code(&self) -> Option<&str> {
        CreateFleetMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFleetMetricError {
    /// Creates a new `CreateFleetMetricError`.
    pub fn new(kind: CreateFleetMetricErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateFleetMetricError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFleetMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateFleetMetricError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFleetMetricErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateFleetMetricErrorKind::IndexNotReadyException`.
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::IndexNotReadyException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateFleetMetricErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateFleetMetricErrorKind::InvalidAggregationException`.
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::InvalidAggregationException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateFleetMetricErrorKind::InvalidQueryException`.
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::InvalidQueryException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateFleetMetricErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateFleetMetricErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateFleetMetricErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateFleetMetricErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateFleetMetricErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateFleetMetricErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateFleetMetricErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetMetricErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateFleetMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFleetMetricErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::InvalidQueryException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateFleetMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateJobError {
    /// Kind of error that occurred.
    pub kind: CreateJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateJobErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateJobError {
    fn code(&self) -> Option<&str> {
        CreateJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateJobError {
    /// Creates a new `CreateJobError`.
    pub fn new(kind: CreateJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateJobErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateJobErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateJobErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateJobErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateJobErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateJobErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateJobErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateJobTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateJobTemplateError {
    /// Kind of error that occurred.
    pub kind: CreateJobTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateJobTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateJobTemplateErrorKind {
    /// <p>A resource with the same name already exists.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateJobTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateJobTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateJobTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateJobTemplateError {
    fn code(&self) -> Option<&str> {
        CreateJobTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateJobTemplateError {
    /// Creates a new `CreateJobTemplateError`.
    pub fn new(kind: CreateJobTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateJobTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateJobTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateJobTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateJobTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateJobTemplateErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateJobTemplateErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateJobTemplateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobTemplateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateJobTemplateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobTemplateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateJobTemplateErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobTemplateErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateJobTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateJobTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJobTemplateErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateJobTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateJobTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateJobTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateKeysAndCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateKeysAndCertificateError {
    /// Kind of error that occurred.
    pub kind: CreateKeysAndCertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateKeysAndCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateKeysAndCertificateErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateKeysAndCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateKeysAndCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateKeysAndCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateKeysAndCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateKeysAndCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateKeysAndCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateKeysAndCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateKeysAndCertificateError {
    fn code(&self) -> Option<&str> {
        CreateKeysAndCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateKeysAndCertificateError {
    /// Creates a new `CreateKeysAndCertificateError`.
    pub fn new(kind: CreateKeysAndCertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateKeysAndCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateKeysAndCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateKeysAndCertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateKeysAndCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateKeysAndCertificateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeysAndCertificateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateKeysAndCertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeysAndCertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateKeysAndCertificateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeysAndCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateKeysAndCertificateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeysAndCertificateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateKeysAndCertificateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeysAndCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateKeysAndCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateKeysAndCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateKeysAndCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateKeysAndCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateKeysAndCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateKeysAndCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateKeysAndCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateMitigationAction` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMitigationActionError {
    /// Kind of error that occurred.
    pub kind: CreateMitigationActionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateMitigationAction` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMitigationActionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMitigationActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMitigationActionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateMitigationActionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateMitigationActionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateMitigationActionErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateMitigationActionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateMitigationActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateMitigationActionError {
    fn code(&self) -> Option<&str> {
        CreateMitigationActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMitigationActionError {
    /// Creates a new `CreateMitigationActionError`.
    pub fn new(kind: CreateMitigationActionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateMitigationActionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMitigationActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateMitigationActionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMitigationActionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateMitigationActionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMitigationActionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateMitigationActionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMitigationActionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateMitigationActionErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMitigationActionErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateMitigationActionErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMitigationActionErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateMitigationActionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMitigationActionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateMitigationActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMitigationActionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateMitigationActionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateMitigationActionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateMitigationActionErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateMitigationActionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateMitigationActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateOTAUpdate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateOTAUpdateError {
    /// Kind of error that occurred.
    pub kind: CreateOTAUpdateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateOTAUpdate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOTAUpdateErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateOTAUpdateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateOTAUpdateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateOTAUpdateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateOTAUpdateError {
    fn code(&self) -> Option<&str> {
        CreateOTAUpdateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOTAUpdateError {
    /// Creates a new `CreateOTAUpdateError`.
    pub fn new(kind: CreateOTAUpdateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateOTAUpdateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateOTAUpdateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateOTAUpdateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateOTAUpdateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateOTAUpdateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateOTAUpdateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateOTAUpdateErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateOTAUpdateErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateOTAUpdateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateOTAUpdateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateOTAUpdateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateOTAUpdateErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateOTAUpdateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateOTAUpdateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateOTAUpdateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateOTAUpdateErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateOTAUpdateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreatePolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePolicyError {
    /// Kind of error that occurred.
    pub kind: CreatePolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreatePolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePolicyErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The policy documentation is not valid.</p>
    MalformedPolicyException(crate::error::MalformedPolicyException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::MalformedPolicyException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreatePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreatePolicyError {
    fn code(&self) -> Option<&str> {
        CreatePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePolicyError {
    /// Creates a new `CreatePolicyError`.
    pub fn new(kind: CreatePolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreatePolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreatePolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreatePolicyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyErrorKind::MalformedPolicyException`.
    pub fn is_malformed_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::MalformedPolicyException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreatePolicyErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreatePolicyErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreatePolicyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreatePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreatePolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreatePolicyErrorKind::MalformedPolicyException(_inner) => Some(_inner),
            CreatePolicyErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreatePolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreatePolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreatePolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreatePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreatePolicyVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePolicyVersionError {
    /// Kind of error that occurred.
    pub kind: CreatePolicyVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreatePolicyVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePolicyVersionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The policy documentation is not valid.</p>
    MalformedPolicyException(crate::error::MalformedPolicyException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// <p>The number of policy versions exceeds the limit.</p>
    VersionsLimitExceededException(crate::error::VersionsLimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePolicyVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::MalformedPolicyException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::VersionsLimitExceededException(_inner) => _inner.fmt(f),
            CreatePolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreatePolicyVersionError {
    fn code(&self) -> Option<&str> {
        CreatePolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePolicyVersionError {
    /// Creates a new `CreatePolicyVersionError`.
    pub fn new(kind: CreatePolicyVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreatePolicyVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreatePolicyVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreatePolicyVersionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyVersionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyVersionErrorKind::MalformedPolicyException`.
    pub fn is_malformed_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::MalformedPolicyException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyVersionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyVersionErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::UnauthorizedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePolicyVersionErrorKind::VersionsLimitExceededException`.
    pub fn is_versions_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePolicyVersionErrorKind::VersionsLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreatePolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePolicyVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::MalformedPolicyException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::VersionsLimitExceededException(_inner) => Some(_inner),
            CreatePolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateProvisioningClaim` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProvisioningClaimError {
    /// Kind of error that occurred.
    pub kind: CreateProvisioningClaimErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateProvisioningClaim` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProvisioningClaimErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProvisioningClaimError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProvisioningClaimErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateProvisioningClaimErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateProvisioningClaimError {
    fn code(&self) -> Option<&str> {
        CreateProvisioningClaimError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProvisioningClaimError {
    /// Creates a new `CreateProvisioningClaimError`.
    pub fn new(kind: CreateProvisioningClaimErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateProvisioningClaimError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProvisioningClaimErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateProvisioningClaimError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProvisioningClaimErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateProvisioningClaimErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningClaimErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningClaimErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningClaimErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningClaimErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningClaimErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningClaimErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateProvisioningClaimError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProvisioningClaimErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateProvisioningClaimErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateProvisioningTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProvisioningTemplateError {
    /// Kind of error that occurred.
    pub kind: CreateProvisioningTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateProvisioningTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProvisioningTemplateErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProvisioningTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProvisioningTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateProvisioningTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateProvisioningTemplateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateProvisioningTemplateErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateProvisioningTemplateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateProvisioningTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateProvisioningTemplateError {
    fn code(&self) -> Option<&str> {
        CreateProvisioningTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProvisioningTemplateError {
    /// Creates a new `CreateProvisioningTemplateError`.
    pub fn new(kind: CreateProvisioningTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateProvisioningTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProvisioningTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateProvisioningTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProvisioningTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateProvisioningTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProvisioningTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateProvisioningTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateProvisioningTemplateErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateProvisioningTemplateErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateProvisioningTemplateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateProvisioningTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateProvisioningTemplateVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProvisioningTemplateVersionError {
    /// Kind of error that occurred.
    pub kind: CreateProvisioningTemplateVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateProvisioningTemplateVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProvisioningTemplateVersionErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// <p>The number of policy versions exceeds the limit.</p>
    VersionsLimitExceededException(crate::error::VersionsLimitExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProvisioningTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(
                _inner,
            ) => _inner.fmt(f),
            CreateProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::VersionsLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateProvisioningTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateProvisioningTemplateVersionError {
    fn code(&self) -> Option<&str> {
        CreateProvisioningTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProvisioningTemplateVersionError {
    /// Creates a new `CreateProvisioningTemplateVersionError`.
    pub fn new(
        kind: CreateProvisioningTemplateVersionErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateProvisioningTemplateVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateProvisioningTemplateVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateVersionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateVersionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateVersionErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::UnauthorizedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProvisioningTemplateVersionErrorKind::VersionsLimitExceededException`.
    pub fn is_versions_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProvisioningTemplateVersionErrorKind::VersionsLimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateProvisioningTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(
                _inner,
            ) => Some(_inner),
            CreateProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateVersionErrorKind::VersionsLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateProvisioningTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateRoleAlias` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRoleAliasError {
    /// Kind of error that occurred.
    pub kind: CreateRoleAliasErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateRoleAlias` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRoleAliasErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRoleAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRoleAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateRoleAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateRoleAliasError {
    fn code(&self) -> Option<&str> {
        CreateRoleAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRoleAliasError {
    /// Creates a new `CreateRoleAliasError`.
    pub fn new(kind: CreateRoleAliasErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateRoleAliasError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRoleAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateRoleAliasError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRoleAliasErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateRoleAliasErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRoleAliasErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRoleAliasErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRoleAliasErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRoleAliasErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRoleAliasErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateRoleAliasErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateRoleAliasErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoleAliasErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateRoleAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRoleAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateRoleAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateScheduledAudit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateScheduledAuditError {
    /// Kind of error that occurred.
    pub kind: CreateScheduledAuditErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateScheduledAudit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateScheduledAuditErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateScheduledAuditError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateScheduledAuditErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateScheduledAuditErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateScheduledAuditErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateScheduledAuditErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateScheduledAuditErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateScheduledAuditErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateScheduledAuditError {
    fn code(&self) -> Option<&str> {
        CreateScheduledAuditError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateScheduledAuditError {
    /// Creates a new `CreateScheduledAuditError`.
    pub fn new(kind: CreateScheduledAuditErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateScheduledAuditError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateScheduledAuditErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateScheduledAuditError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateScheduledAuditErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateScheduledAuditErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScheduledAuditErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateScheduledAuditErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScheduledAuditErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateScheduledAuditErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScheduledAuditErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateScheduledAuditErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScheduledAuditErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateScheduledAuditErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateScheduledAuditErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateScheduledAuditError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateScheduledAuditErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateScheduledAuditErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateScheduledAuditErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateScheduledAuditErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateScheduledAuditErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateScheduledAuditErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSecurityProfileError {
    /// Kind of error that occurred.
    pub kind: CreateSecurityProfileErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSecurityProfileErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateSecurityProfileErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSecurityProfileError {
    fn code(&self) -> Option<&str> {
        CreateSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSecurityProfileError {
    /// Creates a new `CreateSecurityProfileError`.
    pub fn new(kind: CreateSecurityProfileErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateSecurityProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateSecurityProfileError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateSecurityProfileErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSecurityProfileErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSecurityProfileErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityProfileErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSecurityProfileErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateSecurityProfileErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateStream` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateStreamError {
    /// Kind of error that occurred.
    pub kind: CreateStreamErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateStream` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStreamErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateStreamErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateStreamError {
    fn code(&self) -> Option<&str> {
        CreateStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStreamError {
    /// Creates a new `CreateStreamError`.
    pub fn new(kind: CreateStreamErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateStreamError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateStreamError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateStreamErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateStreamErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateStreamErrorKind::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateStreamErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStreamErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateStreamErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateStreamErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateStreamErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateStreamErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateStreamErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateStreamErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateStreamErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateStreamErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateStreamErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateStreamErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateStreamErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateStreamErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateThingError {
    /// Kind of error that occurred.
    pub kind: CreateThingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateThingErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateThingError {
    fn code(&self) -> Option<&str> {
        CreateThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateThingError {
    /// Creates a new `CreateThingError`.
    pub fn new(kind: CreateThingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateThingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateThingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateThingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateThingErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateThingErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, CreateThingErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateThingErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateThingErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateThingErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateThingErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateThingErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateThingErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateThingErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateThingErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateThingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateThingGroupError {
    /// Kind of error that occurred.
    pub kind: CreateThingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateThingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateThingGroupErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateThingGroupError {
    fn code(&self) -> Option<&str> {
        CreateThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateThingGroupError {
    /// Creates a new `CreateThingGroupError`.
    pub fn new(kind: CreateThingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateThingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateThingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateThingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateThingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateThingGroupErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingGroupErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateThingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateThingGroupErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateThingType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateThingTypeError {
    /// Kind of error that occurred.
    pub kind: CreateThingTypeErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateThingType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateThingTypeErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateThingTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateThingTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateThingTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateThingTypeError {
    fn code(&self) -> Option<&str> {
        CreateThingTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateThingTypeError {
    /// Creates a new `CreateThingTypeError`.
    pub fn new(kind: CreateThingTypeErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateThingTypeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateThingTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateThingTypeError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateThingTypeErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateThingTypeErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingTypeErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateThingTypeErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingTypeErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateThingTypeErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingTypeErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateThingTypeErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingTypeErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateThingTypeErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateThingTypeErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateThingTypeErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThingTypeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateThingTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateThingTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateThingTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTopicRuleError {
    /// Kind of error that occurred.
    pub kind: CreateTopicRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTopicRuleErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The Rule-SQL expression can't be parsed correctly.</p>
    SqlParseException(crate::error::SqlParseException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::SqlParseException(_inner) => _inner.fmt(f),
            CreateTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateTopicRuleError {
    fn code(&self) -> Option<&str> {
        CreateTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTopicRuleError {
    /// Creates a new `CreateTopicRuleError`.
    pub fn new(kind: CreateTopicRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateTopicRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateTopicRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateTopicRuleErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateTopicRuleErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateTopicRuleErrorKind::InternalException(_))
    }
    /// Returns `true` if the error kind is `CreateTopicRuleErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateTopicRuleErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateTopicRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateTopicRuleErrorKind::SqlParseException`.
    pub fn is_sql_parse_exception(&self) -> bool {
        matches!(&self.kind, CreateTopicRuleErrorKind::SqlParseException(_))
    }
}
impl std::error::Error for CreateTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::SqlParseException(_inner) => Some(_inner),
            CreateTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateTopicRuleDestination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTopicRuleDestinationError {
    /// Kind of error that occurred.
    pub kind: CreateTopicRuleDestinationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateTopicRuleDestination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTopicRuleDestinationErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTopicRuleDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            CreateTopicRuleDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateTopicRuleDestinationErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateTopicRuleDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateTopicRuleDestinationError {
    fn code(&self) -> Option<&str> {
        CreateTopicRuleDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTopicRuleDestinationError {
    /// Creates a new `CreateTopicRuleDestinationError`.
    pub fn new(kind: CreateTopicRuleDestinationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateTopicRuleDestinationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTopicRuleDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateTopicRuleDestinationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTopicRuleDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateTopicRuleDestinationErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleDestinationErrorKind::InternalException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateTopicRuleDestinationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleDestinationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateTopicRuleDestinationErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleDestinationErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateTopicRuleDestinationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTopicRuleDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateTopicRuleDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            CreateTopicRuleDestinationErrorKind::InternalException(_inner) => Some(_inner),
            CreateTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateTopicRuleDestinationErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateTopicRuleDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteAccountAuditConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccountAuditConfigurationError {
    /// Kind of error that occurred.
    pub kind: DeleteAccountAuditConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteAccountAuditConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccountAuditConfigurationErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccountAuditConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAccountAuditConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAccountAuditConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteAccountAuditConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteAccountAuditConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteAccountAuditConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccountAuditConfigurationError {
    /// Creates a new `DeleteAccountAuditConfigurationError`.
    pub fn new(
        kind: DeleteAccountAuditConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteAccountAuditConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccountAuditConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteAccountAuditConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccountAuditConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteAccountAuditConfigurationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAuditConfigurationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAccountAuditConfigurationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAuditConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAccountAuditConfigurationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAuditConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAccountAuditConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountAuditConfigurationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteAccountAuditConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DeleteAccountAuditConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DeleteAccountAuditConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteAccountAuditConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteAuditSuppression` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAuditSuppressionError {
    /// Kind of error that occurred.
    pub kind: DeleteAuditSuppressionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteAuditSuppression` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAuditSuppressionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAuditSuppressionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAuditSuppressionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteAuditSuppressionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteAuditSuppressionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteAuditSuppressionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteAuditSuppressionError {
    fn code(&self) -> Option<&str> {
        DeleteAuditSuppressionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAuditSuppressionError {
    /// Creates a new `DeleteAuditSuppressionError`.
    pub fn new(kind: DeleteAuditSuppressionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteAuditSuppressionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAuditSuppressionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteAuditSuppressionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAuditSuppressionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteAuditSuppressionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuditSuppressionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAuditSuppressionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuditSuppressionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAuditSuppressionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuditSuppressionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteAuditSuppressionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAuditSuppressionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteAuditSuppressionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteAuditSuppressionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteAuditSuppressionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAuthorizerError {
    /// Kind of error that occurred.
    pub kind: DeleteAuthorizerErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAuthorizerErrorKind {
    /// <p>You can't delete the resource because it is attached to one or more
    /// resources.</p>
    DeleteConflictException(crate::error::DeleteConflictException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAuthorizerErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteAuthorizerError {
    fn code(&self) -> Option<&str> {
        DeleteAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAuthorizerError {
    /// Creates a new `DeleteAuthorizerError`.
    pub fn new(kind: DeleteAuthorizerErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteAuthorizerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteAuthorizerError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteAuthorizerErrorKind::DeleteConflictException`.
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::DeleteConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAuthorizerErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAuthorizerErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAuthorizerErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAuthorizerErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAuthorizerErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteAuthorizerErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAuthorizerErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBillingGroupError {
    /// Kind of error that occurred.
    pub kind: DeleteBillingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBillingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteBillingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteBillingGroupError {
    fn code(&self) -> Option<&str> {
        DeleteBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBillingGroupError {
    /// Creates a new `DeleteBillingGroupError`.
    pub fn new(kind: DeleteBillingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteBillingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteBillingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteBillingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBillingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBillingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBillingGroupErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBillingGroupErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBillingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteBillingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteCACertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCACertificateError {
    /// Kind of error that occurred.
    pub kind: DeleteCACertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteCACertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCACertificateErrorKind {
    /// <p>The certificate operation is not allowed.</p>
    CertificateStateException(crate::error::CertificateStateException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCACertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCACertificateErrorKind::CertificateStateException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteCACertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCACertificateError {
    fn code(&self) -> Option<&str> {
        DeleteCACertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCACertificateError {
    /// Creates a new `DeleteCACertificateError`.
    pub fn new(kind: DeleteCACertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteCACertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCACertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteCACertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCACertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteCACertificateErrorKind::CertificateStateException`.
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::CertificateStateException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCACertificateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCACertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCACertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCACertificateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCACertificateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCACertificateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCACertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteCACertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCACertificateErrorKind::CertificateStateException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteCACertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCertificateError {
    /// Kind of error that occurred.
    pub kind: DeleteCertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCertificateErrorKind {
    /// <p>The certificate operation is not allowed.</p>
    CertificateStateException(crate::error::CertificateStateException),
    /// <p>You can't delete the resource because it is attached to one or more
    /// resources.</p>
    DeleteConflictException(crate::error::DeleteConflictException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCertificateErrorKind::CertificateStateException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCertificateError {
    fn code(&self) -> Option<&str> {
        DeleteCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCertificateError {
    /// Creates a new `DeleteCertificateError`.
    pub fn new(kind: DeleteCertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteCertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteCertificateErrorKind::CertificateStateException`.
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::CertificateStateException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCertificateErrorKind::DeleteConflictException`.
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::DeleteConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCertificateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCertificateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCertificateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCertificateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCertificateErrorKind::CertificateStateException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteCustomMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCustomMetricError {
    /// Kind of error that occurred.
    pub kind: DeleteCustomMetricErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteCustomMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCustomMetricErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCustomMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCustomMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteCustomMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteCustomMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteCustomMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCustomMetricError {
    fn code(&self) -> Option<&str> {
        DeleteCustomMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCustomMetricError {
    /// Creates a new `DeleteCustomMetricError`.
    pub fn new(kind: DeleteCustomMetricErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteCustomMetricError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCustomMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteCustomMetricError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCustomMetricErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteCustomMetricErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomMetricErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCustomMetricErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomMetricErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCustomMetricErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomMetricErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteCustomMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCustomMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteCustomMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteCustomMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteCustomMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteDimension` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDimensionError {
    /// Kind of error that occurred.
    pub kind: DeleteDimensionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteDimension` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDimensionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDimensionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDimensionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteDimensionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteDimensionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDimensionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDimensionError {
    fn code(&self) -> Option<&str> {
        DeleteDimensionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDimensionError {
    /// Creates a new `DeleteDimensionError`.
    pub fn new(kind: DeleteDimensionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteDimensionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDimensionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteDimensionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDimensionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteDimensionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDimensionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDimensionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDimensionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDimensionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteDimensionErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteDimensionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDimensionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteDimensionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteDimensionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDimensionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteDomainConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDomainConfigurationError {
    /// Kind of error that occurred.
    pub kind: DeleteDomainConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteDomainConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDomainConfigurationErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDomainConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDomainConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteDomainConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteDomainConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDomainConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteDomainConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDomainConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteDomainConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDomainConfigurationError {
    /// Creates a new `DeleteDomainConfigurationError`.
    pub fn new(kind: DeleteDomainConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteDomainConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDomainConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteDomainConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDomainConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteDomainConfigurationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDomainConfigurationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDomainConfigurationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDomainConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDomainConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDomainConfigurationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteDomainConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDomainConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteDomainConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteDynamicThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDynamicThingGroupError {
    /// Kind of error that occurred.
    pub kind: DeleteDynamicThingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteDynamicThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDynamicThingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDynamicThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDynamicThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteDynamicThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteDynamicThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDynamicThingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteDynamicThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDynamicThingGroupError {
    fn code(&self) -> Option<&str> {
        DeleteDynamicThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDynamicThingGroupError {
    /// Creates a new `DeleteDynamicThingGroupError`.
    pub fn new(kind: DeleteDynamicThingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteDynamicThingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDynamicThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteDynamicThingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDynamicThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteDynamicThingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDynamicThingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDynamicThingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDynamicThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDynamicThingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDynamicThingGroupErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteDynamicThingGroupErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDynamicThingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteDynamicThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDynamicThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteDynamicThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteDynamicThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDynamicThingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteDynamicThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteFleetMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFleetMetricError {
    /// Kind of error that occurred.
    pub kind: DeleteFleetMetricErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteFleetMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFleetMetricErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFleetMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFleetMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteFleetMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFleetMetricError {
    fn code(&self) -> Option<&str> {
        DeleteFleetMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFleetMetricError {
    /// Creates a new `DeleteFleetMetricError`.
    pub fn new(kind: DeleteFleetMetricErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteFleetMetricError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFleetMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteFleetMetricError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFleetMetricErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteFleetMetricErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFleetMetricErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFleetMetricErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFleetMetricErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFleetMetricErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::UnauthorizedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFleetMetricErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetMetricErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteFleetMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFleetMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteFleetMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteJobError {
    /// Kind of error that occurred.
    pub kind: DeleteJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteJobErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>An attempt was made to change to an invalid state, for example by deleting a job or a
    /// job execution which is "IN_PROGRESS" without setting the <code>force</code>
    /// parameter.</p>
    InvalidStateTransitionException(crate::error::InvalidStateTransitionException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::InvalidStateTransitionException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteJobError {
    fn code(&self) -> Option<&str> {
        DeleteJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteJobError {
    /// Creates a new `DeleteJobError`.
    pub fn new(kind: DeleteJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteJobErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteJobErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteJobErrorKind::InvalidStateTransitionException`.
    pub fn is_invalid_state_transition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobErrorKind::InvalidStateTransitionException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteJobErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeleteJobErrorKind::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `DeleteJobErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteJobErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteJobErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteJobErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteJobErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteJobErrorKind::InvalidStateTransitionException(_inner) => Some(_inner),
            DeleteJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteJobExecution` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteJobExecutionError {
    /// Kind of error that occurred.
    pub kind: DeleteJobExecutionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteJobExecution` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteJobExecutionErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>An attempt was made to change to an invalid state, for example by deleting a job or a
    /// job execution which is "IN_PROGRESS" without setting the <code>force</code>
    /// parameter.</p>
    InvalidStateTransitionException(crate::error::InvalidStateTransitionException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteJobExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteJobExecutionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteJobExecutionErrorKind::InvalidStateTransitionException(_inner) => _inner.fmt(f),
            DeleteJobExecutionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteJobExecutionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteJobExecutionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteJobExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteJobExecutionError {
    fn code(&self) -> Option<&str> {
        DeleteJobExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteJobExecutionError {
    /// Creates a new `DeleteJobExecutionError`.
    pub fn new(kind: DeleteJobExecutionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteJobExecutionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteJobExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteJobExecutionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteJobExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteJobExecutionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobExecutionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteJobExecutionErrorKind::InvalidStateTransitionException`.
    pub fn is_invalid_state_transition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobExecutionErrorKind::InvalidStateTransitionException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteJobExecutionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobExecutionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteJobExecutionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobExecutionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteJobExecutionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobExecutionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteJobExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteJobExecutionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteJobExecutionErrorKind::InvalidStateTransitionException(_inner) => Some(_inner),
            DeleteJobExecutionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteJobExecutionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteJobExecutionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteJobExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteJobTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteJobTemplateError {
    /// Kind of error that occurred.
    pub kind: DeleteJobTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteJobTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteJobTemplateErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteJobTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteJobTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteJobTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteJobTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteJobTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteJobTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteJobTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteJobTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteJobTemplateError {
    /// Creates a new `DeleteJobTemplateError`.
    pub fn new(kind: DeleteJobTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteJobTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteJobTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteJobTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteJobTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteJobTemplateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobTemplateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteJobTemplateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobTemplateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteJobTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteJobTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJobTemplateErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteJobTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteJobTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteJobTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteJobTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteJobTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteJobTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteMitigationAction` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMitigationActionError {
    /// Kind of error that occurred.
    pub kind: DeleteMitigationActionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteMitigationAction` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMitigationActionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMitigationActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMitigationActionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteMitigationActionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteMitigationActionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteMitigationActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteMitigationActionError {
    fn code(&self) -> Option<&str> {
        DeleteMitigationActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMitigationActionError {
    /// Creates a new `DeleteMitigationActionError`.
    pub fn new(kind: DeleteMitigationActionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteMitigationActionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMitigationActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteMitigationActionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMitigationActionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteMitigationActionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMitigationActionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteMitigationActionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMitigationActionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteMitigationActionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMitigationActionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteMitigationActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMitigationActionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteMitigationActionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteMitigationActionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteMitigationActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteOTAUpdate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteOTAUpdateError {
    /// Kind of error that occurred.
    pub kind: DeleteOTAUpdateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteOTAUpdate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOTAUpdateErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteOTAUpdateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteOTAUpdateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteOTAUpdateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteOTAUpdateError {
    fn code(&self) -> Option<&str> {
        DeleteOTAUpdateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOTAUpdateError {
    /// Creates a new `DeleteOTAUpdateError`.
    pub fn new(kind: DeleteOTAUpdateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteOTAUpdateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteOTAUpdateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteOTAUpdateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteOTAUpdateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteOTAUpdateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteOTAUpdateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteOTAUpdateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteOTAUpdateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteOTAUpdateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteOTAUpdateErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteOTAUpdateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::UnauthorizedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteOTAUpdateErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteOTAUpdateErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteOTAUpdateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteOTAUpdateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteOTAUpdateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeletePolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePolicyError {
    /// Kind of error that occurred.
    pub kind: DeletePolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeletePolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePolicyErrorKind {
    /// <p>You can't delete the resource because it is attached to one or more
    /// resources.</p>
    DeleteConflictException(crate::error::DeleteConflictException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePolicyErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePolicyError {
    fn code(&self) -> Option<&str> {
        DeletePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePolicyError {
    /// Creates a new `DeletePolicyError`.
    pub fn new(kind: DeletePolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeletePolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeletePolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeletePolicyErrorKind::DeleteConflictException`.
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::DeleteConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePolicyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePolicyErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePolicyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeletePolicyErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeletePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePolicyErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeletePolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeletePolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeletePolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeletePolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeletePolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeletePolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeletePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeletePolicyVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePolicyVersionError {
    /// Kind of error that occurred.
    pub kind: DeletePolicyVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeletePolicyVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePolicyVersionErrorKind {
    /// <p>You can't delete the resource because it is attached to one or more
    /// resources.</p>
    DeleteConflictException(crate::error::DeleteConflictException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePolicyVersionErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeletePolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePolicyVersionError {
    fn code(&self) -> Option<&str> {
        DeletePolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePolicyVersionError {
    /// Creates a new `DeletePolicyVersionError`.
    pub fn new(kind: DeletePolicyVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeletePolicyVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeletePolicyVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeletePolicyVersionErrorKind::DeleteConflictException`.
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::DeleteConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePolicyVersionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePolicyVersionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePolicyVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePolicyVersionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePolicyVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePolicyVersionErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeletePolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePolicyVersionErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeletePolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteProvisioningTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProvisioningTemplateError {
    /// Kind of error that occurred.
    pub kind: DeleteProvisioningTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteProvisioningTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProvisioningTemplateErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>You can't delete the resource because it is attached to one or more
    /// resources.</p>
    DeleteConflictException(crate::error::DeleteConflictException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProvisioningTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteProvisioningTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteProvisioningTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteProvisioningTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProvisioningTemplateError {
    /// Creates a new `DeleteProvisioningTemplateError`.
    pub fn new(kind: DeleteProvisioningTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteProvisioningTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProvisioningTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteProvisioningTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProvisioningTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateErrorKind::DeleteConflictException`.
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::DeleteConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteProvisioningTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteProvisioningTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteProvisioningTemplateVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProvisioningTemplateVersionError {
    /// Kind of error that occurred.
    pub kind: DeleteProvisioningTemplateVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteProvisioningTemplateVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProvisioningTemplateVersionErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>You can't delete the resource because it is attached to one or more
    /// resources.</p>
    DeleteConflictException(crate::error::DeleteConflictException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProvisioningTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(
                _inner,
            ) => _inner.fmt(f),
            DeleteProvisioningTemplateVersionErrorKind::DeleteConflictException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteProvisioningTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteProvisioningTemplateVersionError {
    fn code(&self) -> Option<&str> {
        DeleteProvisioningTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProvisioningTemplateVersionError {
    /// Creates a new `DeleteProvisioningTemplateVersionError`.
    pub fn new(
        kind: DeleteProvisioningTemplateVersionErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteProvisioningTemplateVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteProvisioningTemplateVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateVersionErrorKind::DeleteConflictException`.
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::DeleteConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateVersionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateVersionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProvisioningTemplateVersionErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProvisioningTemplateVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteProvisioningTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProvisioningTemplateVersionErrorKind::ConflictingResourceUpdateException(
                _inner,
            ) => Some(_inner),
            DeleteProvisioningTemplateVersionErrorKind::DeleteConflictException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            DeleteProvisioningTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteRegistrationCode` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRegistrationCodeError {
    /// Kind of error that occurred.
    pub kind: DeleteRegistrationCodeErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteRegistrationCode` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRegistrationCodeErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRegistrationCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRegistrationCodeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteRegistrationCodeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteRegistrationCodeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteRegistrationCodeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteRegistrationCodeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteRegistrationCodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteRegistrationCodeError {
    fn code(&self) -> Option<&str> {
        DeleteRegistrationCodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRegistrationCodeError {
    /// Creates a new `DeleteRegistrationCodeError`.
    pub fn new(kind: DeleteRegistrationCodeErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteRegistrationCodeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRegistrationCodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteRegistrationCodeError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRegistrationCodeErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteRegistrationCodeErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistrationCodeErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRegistrationCodeErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistrationCodeErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRegistrationCodeErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistrationCodeErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRegistrationCodeErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistrationCodeErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRegistrationCodeErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRegistrationCodeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteRegistrationCodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRegistrationCodeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteRegistrationCodeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteRegistrationCodeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteRegistrationCodeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteRegistrationCodeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteRegistrationCodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteRoleAlias` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRoleAliasError {
    /// Kind of error that occurred.
    pub kind: DeleteRoleAliasErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteRoleAlias` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRoleAliasErrorKind {
    /// <p>You can't delete the resource because it is attached to one or more
    /// resources.</p>
    DeleteConflictException(crate::error::DeleteConflictException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRoleAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRoleAliasErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteRoleAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteRoleAliasError {
    fn code(&self) -> Option<&str> {
        DeleteRoleAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRoleAliasError {
    /// Creates a new `DeleteRoleAliasError`.
    pub fn new(kind: DeleteRoleAliasErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteRoleAliasError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRoleAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteRoleAliasError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRoleAliasErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteRoleAliasErrorKind::DeleteConflictException`.
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::DeleteConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRoleAliasErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRoleAliasErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRoleAliasErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRoleAliasErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRoleAliasErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteRoleAliasErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteRoleAliasErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoleAliasErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteRoleAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRoleAliasErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteRoleAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteScheduledAudit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteScheduledAuditError {
    /// Kind of error that occurred.
    pub kind: DeleteScheduledAuditErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteScheduledAudit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteScheduledAuditErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteScheduledAuditError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteScheduledAuditErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteScheduledAuditErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteScheduledAuditErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteScheduledAuditErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteScheduledAuditErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteScheduledAuditError {
    fn code(&self) -> Option<&str> {
        DeleteScheduledAuditError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteScheduledAuditError {
    /// Creates a new `DeleteScheduledAuditError`.
    pub fn new(kind: DeleteScheduledAuditErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteScheduledAuditError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteScheduledAuditErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteScheduledAuditError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteScheduledAuditErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteScheduledAuditErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduledAuditErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteScheduledAuditErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduledAuditErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteScheduledAuditErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduledAuditErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteScheduledAuditErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteScheduledAuditErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteScheduledAuditError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteScheduledAuditErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteScheduledAuditErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteScheduledAuditErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteScheduledAuditErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteScheduledAuditErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSecurityProfileError {
    /// Kind of error that occurred.
    pub kind: DeleteSecurityProfileErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSecurityProfileErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteSecurityProfileErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSecurityProfileError {
    fn code(&self) -> Option<&str> {
        DeleteSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSecurityProfileError {
    /// Creates a new `DeleteSecurityProfileError`.
    pub fn new(kind: DeleteSecurityProfileErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteSecurityProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteSecurityProfileError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteSecurityProfileErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSecurityProfileErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSecurityProfileErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSecurityProfileErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSecurityProfileErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteSecurityProfileErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteStream` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteStreamError {
    /// Kind of error that occurred.
    pub kind: DeleteStreamErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteStream` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStreamErrorKind {
    /// <p>You can't delete the resource because it is attached to one or more
    /// resources.</p>
    DeleteConflictException(crate::error::DeleteConflictException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteStreamErrorKind::DeleteConflictException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteStreamError {
    fn code(&self) -> Option<&str> {
        DeleteStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteStreamError {
    /// Creates a new `DeleteStreamError`.
    pub fn new(kind: DeleteStreamErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteStreamError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteStreamError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteStreamErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteStreamErrorKind::DeleteConflictException`.
    pub fn is_delete_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamErrorKind::DeleteConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteStreamErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteStreamErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteStreamErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteStreamErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStreamErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteStreamErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteStreamErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteStreamErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteStreamErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeleteStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteStreamErrorKind::DeleteConflictException(_inner) => Some(_inner),
            DeleteStreamErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteStreamErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteStreamErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteStreamErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteStreamErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteStreamErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteThingError {
    /// Kind of error that occurred.
    pub kind: DeleteThingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteThingErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteThingError {
    fn code(&self) -> Option<&str> {
        DeleteThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteThingError {
    /// Creates a new `DeleteThingError`.
    pub fn new(kind: DeleteThingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteThingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteThingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteThingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteThingErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteThingErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteThingErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteThingErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteThingErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteThingErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteThingErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteThingErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteThingErrorKind::UnauthorizedException(_))
    }
    /// Returns `true` if the error kind is `DeleteThingErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteThingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteThingErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteThingGroupError {
    /// Kind of error that occurred.
    pub kind: DeleteThingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteThingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteThingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            DeleteThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteThingGroupError {
    fn code(&self) -> Option<&str> {
        DeleteThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteThingGroupError {
    /// Creates a new `DeleteThingGroupError`.
    pub fn new(kind: DeleteThingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteThingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteThingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteThingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteThingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteThingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingGroupErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteThingGroupErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for DeleteThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteThingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            DeleteThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteThingType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteThingTypeError {
    /// Kind of error that occurred.
    pub kind: DeleteThingTypeErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteThingType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteThingTypeErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteThingTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteThingTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteThingTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteThingTypeError {
    fn code(&self) -> Option<&str> {
        DeleteThingTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteThingTypeError {
    /// Creates a new `DeleteThingTypeError`.
    pub fn new(kind: DeleteThingTypeErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteThingTypeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteThingTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteThingTypeError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteThingTypeErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteThingTypeErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingTypeErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteThingTypeErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingTypeErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteThingTypeErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingTypeErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteThingTypeErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingTypeErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteThingTypeErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteThingTypeErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DeleteThingTypeErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThingTypeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteThingTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteThingTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteThingTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTopicRuleError {
    /// Kind of error that occurred.
    pub kind: DeleteTopicRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTopicRuleErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            DeleteTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteTopicRuleErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteTopicRuleError {
    fn code(&self) -> Option<&str> {
        DeleteTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTopicRuleError {
    /// Creates a new `DeleteTopicRuleError`.
    pub fn new(kind: DeleteTopicRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteTopicRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteTopicRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteTopicRuleErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteTopicRuleErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteTopicRuleErrorKind::InternalException(_))
    }
    /// Returns `true` if the error kind is `DeleteTopicRuleErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteTopicRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteTopicRuleErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            DeleteTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            DeleteTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteTopicRuleErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteTopicRuleDestination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTopicRuleDestinationError {
    /// Kind of error that occurred.
    pub kind: DeleteTopicRuleDestinationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteTopicRuleDestination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTopicRuleDestinationErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTopicRuleDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            DeleteTopicRuleDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteTopicRuleDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteTopicRuleDestinationError {
    fn code(&self) -> Option<&str> {
        DeleteTopicRuleDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTopicRuleDestinationError {
    /// Creates a new `DeleteTopicRuleDestinationError`.
    pub fn new(kind: DeleteTopicRuleDestinationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteTopicRuleDestinationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTopicRuleDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteTopicRuleDestinationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTopicRuleDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteTopicRuleDestinationErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteTopicRuleDestinationErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleDestinationErrorKind::InternalException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteTopicRuleDestinationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleDestinationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteTopicRuleDestinationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteTopicRuleDestinationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTopicRuleDestinationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteTopicRuleDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            DeleteTopicRuleDestinationErrorKind::InternalException(_inner) => Some(_inner),
            DeleteTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteTopicRuleDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteV2LoggingLevel` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteV2LoggingLevelError {
    /// Kind of error that occurred.
    pub kind: DeleteV2LoggingLevelErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteV2LoggingLevel` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteV2LoggingLevelErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteV2LoggingLevelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteV2LoggingLevelErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteV2LoggingLevelErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteV2LoggingLevelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteV2LoggingLevelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteV2LoggingLevelError {
    fn code(&self) -> Option<&str> {
        DeleteV2LoggingLevelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteV2LoggingLevelError {
    /// Creates a new `DeleteV2LoggingLevelError`.
    pub fn new(kind: DeleteV2LoggingLevelErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteV2LoggingLevelError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteV2LoggingLevelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteV2LoggingLevelError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteV2LoggingLevelErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteV2LoggingLevelErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteV2LoggingLevelErrorKind::InternalException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteV2LoggingLevelErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteV2LoggingLevelErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteV2LoggingLevelErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteV2LoggingLevelErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteV2LoggingLevelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteV2LoggingLevelErrorKind::InternalException(_inner) => Some(_inner),
            DeleteV2LoggingLevelErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteV2LoggingLevelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteV2LoggingLevelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeprecateThingType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeprecateThingTypeError {
    /// Kind of error that occurred.
    pub kind: DeprecateThingTypeErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeprecateThingType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeprecateThingTypeErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeprecateThingTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeprecateThingTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeprecateThingTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeprecateThingTypeError {
    fn code(&self) -> Option<&str> {
        DeprecateThingTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeprecateThingTypeError {
    /// Creates a new `DeprecateThingTypeError`.
    pub fn new(kind: DeprecateThingTypeErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeprecateThingTypeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeprecateThingTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeprecateThingTypeError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeprecateThingTypeErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeprecateThingTypeErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeprecateThingTypeErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeprecateThingTypeErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeprecateThingTypeErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeprecateThingTypeErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DeprecateThingTypeErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateThingTypeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeprecateThingTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeprecateThingTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeprecateThingTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeAccountAuditConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAccountAuditConfigurationError {
    /// Kind of error that occurred.
    pub kind: DescribeAccountAuditConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeAccountAuditConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountAuditConfigurationErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAccountAuditConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAccountAuditConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAccountAuditConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeAccountAuditConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountAuditConfigurationError {
    /// Creates a new `DescribeAccountAuditConfigurationError`.
    pub fn new(
        kind: DescribeAccountAuditConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeAccountAuditConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAccountAuditConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeAccountAuditConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAccountAuditConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeAccountAuditConfigurationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountAuditConfigurationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAccountAuditConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountAuditConfigurationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAccountAuditConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAccountAuditConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeAuditFinding` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAuditFindingError {
    /// Kind of error that occurred.
    pub kind: DescribeAuditFindingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeAuditFinding` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuditFindingErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAuditFindingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAuditFindingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeAuditFindingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeAuditFindingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAuditFindingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAuditFindingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAuditFindingError {
    fn code(&self) -> Option<&str> {
        DescribeAuditFindingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuditFindingError {
    /// Creates a new `DescribeAuditFindingError`.
    pub fn new(kind: DescribeAuditFindingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeAuditFindingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAuditFindingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeAuditFindingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAuditFindingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeAuditFindingErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditFindingErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditFindingErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditFindingErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditFindingErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditFindingErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditFindingErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditFindingErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAuditFindingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAuditFindingErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAuditFindingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeAuditFindingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAuditFindingErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAuditFindingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeAuditMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAuditMitigationActionsTaskError {
    /// Kind of error that occurred.
    pub kind: DescribeAuditMitigationActionsTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeAuditMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuditMitigationActionsTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAuditMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAuditMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        DescribeAuditMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuditMitigationActionsTaskError {
    /// Creates a new `DescribeAuditMitigationActionsTaskError`.
    pub fn new(
        kind: DescribeAuditMitigationActionsTaskErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeAuditMitigationActionsTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeAuditMitigationActionsTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeAuditMitigationActionsTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditMitigationActionsTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditMitigationActionsTaskErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditMitigationActionsTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAuditMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeAuditMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DescribeAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeAuditSuppression` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAuditSuppressionError {
    /// Kind of error that occurred.
    pub kind: DescribeAuditSuppressionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeAuditSuppression` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuditSuppressionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAuditSuppressionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAuditSuppressionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeAuditSuppressionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeAuditSuppressionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAuditSuppressionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAuditSuppressionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAuditSuppressionError {
    fn code(&self) -> Option<&str> {
        DescribeAuditSuppressionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuditSuppressionError {
    /// Creates a new `DescribeAuditSuppressionError`.
    pub fn new(kind: DescribeAuditSuppressionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeAuditSuppressionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAuditSuppressionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeAuditSuppressionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAuditSuppressionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeAuditSuppressionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditSuppressionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditSuppressionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditSuppressionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditSuppressionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditSuppressionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditSuppressionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditSuppressionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAuditSuppressionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAuditSuppressionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAuditSuppressionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeAuditSuppressionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAuditSuppressionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAuditSuppressionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeAuditTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAuditTaskError {
    /// Kind of error that occurred.
    pub kind: DescribeAuditTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeAuditTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuditTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAuditTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAuditTaskErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeAuditTaskErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeAuditTaskErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAuditTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAuditTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAuditTaskError {
    fn code(&self) -> Option<&str> {
        DescribeAuditTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuditTaskError {
    /// Creates a new `DescribeAuditTaskError`.
    pub fn new(kind: DescribeAuditTaskErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeAuditTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAuditTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeAuditTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAuditTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeAuditTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditTaskErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuditTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAuditTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAuditTaskErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAuditTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeAuditTaskErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAuditTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAuditTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAuthorizerError {
    /// Kind of error that occurred.
    pub kind: DescribeAuthorizerErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuthorizerErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAuthorizerError {
    fn code(&self) -> Option<&str> {
        DescribeAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuthorizerError {
    /// Creates a new `DescribeAuthorizerError`.
    pub fn new(kind: DescribeAuthorizerErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeAuthorizerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeAuthorizerError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeAuthorizerErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuthorizerErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuthorizerErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuthorizerErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuthorizerErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeAuthorizerErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBillingGroupError {
    /// Kind of error that occurred.
    pub kind: DescribeBillingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBillingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeBillingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeBillingGroupError {
    fn code(&self) -> Option<&str> {
        DescribeBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBillingGroupError {
    /// Creates a new `DescribeBillingGroupError`.
    pub fn new(kind: DescribeBillingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeBillingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeBillingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeBillingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeBillingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeBillingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBillingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeBillingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBillingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeBillingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeCACertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCACertificateError {
    /// Kind of error that occurred.
    pub kind: DescribeCACertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeCACertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCACertificateErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCACertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCACertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeCACertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeCACertificateError {
    fn code(&self) -> Option<&str> {
        DescribeCACertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCACertificateError {
    /// Creates a new `DescribeCACertificateError`.
    pub fn new(kind: DescribeCACertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeCACertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCACertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeCACertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCACertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeCACertificateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCACertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCACertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCACertificateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCACertificateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCACertificateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCACertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeCACertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCACertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeCACertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCertificateError {
    /// Kind of error that occurred.
    pub kind: DescribeCertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCertificateErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeCertificateError {
    fn code(&self) -> Option<&str> {
        DescribeCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCertificateError {
    /// Creates a new `DescribeCertificateError`.
    pub fn new(kind: DescribeCertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeCertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeCertificateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCertificateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCertificateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCertificateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeCustomMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCustomMetricError {
    /// Kind of error that occurred.
    pub kind: DescribeCustomMetricErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeCustomMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCustomMetricErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCustomMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCustomMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeCustomMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeCustomMetricErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeCustomMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeCustomMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeCustomMetricError {
    fn code(&self) -> Option<&str> {
        DescribeCustomMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCustomMetricError {
    /// Creates a new `DescribeCustomMetricError`.
    pub fn new(kind: DescribeCustomMetricErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeCustomMetricError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCustomMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeCustomMetricError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCustomMetricErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeCustomMetricErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomMetricErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCustomMetricErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomMetricErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCustomMetricErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomMetricErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeCustomMetricErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomMetricErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeCustomMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCustomMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeCustomMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeCustomMetricErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeCustomMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeCustomMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeDefaultAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDefaultAuthorizerError {
    /// Kind of error that occurred.
    pub kind: DescribeDefaultAuthorizerErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeDefaultAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDefaultAuthorizerErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDefaultAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDefaultAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDefaultAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeDefaultAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDefaultAuthorizerError {
    fn code(&self) -> Option<&str> {
        DescribeDefaultAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDefaultAuthorizerError {
    /// Creates a new `DescribeDefaultAuthorizerError`.
    pub fn new(kind: DescribeDefaultAuthorizerErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeDefaultAuthorizerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDefaultAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeDefaultAuthorizerError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDefaultAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeDefaultAuthorizerErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDefaultAuthorizerErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDefaultAuthorizerErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDefaultAuthorizerErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDefaultAuthorizerErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDefaultAuthorizerErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDefaultAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeDefaultAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDefaultAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeDefaultAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeDetectMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDetectMitigationActionsTaskError {
    /// Kind of error that occurred.
    pub kind: DescribeDetectMitigationActionsTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeDetectMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDetectMitigationActionsTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDetectMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDetectMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        DescribeDetectMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDetectMitigationActionsTaskError {
    /// Creates a new `DescribeDetectMitigationActionsTaskError`.
    pub fn new(
        kind: DescribeDetectMitigationActionsTaskErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeDetectMitigationActionsTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeDetectMitigationActionsTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeDetectMitigationActionsTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDetectMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDetectMitigationActionsTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDetectMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDetectMitigationActionsTaskErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDetectMitigationActionsTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDetectMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeDetectMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeDetectMitigationActionsTaskErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DescribeDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `DescribeDimension` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDimensionError {
    /// Kind of error that occurred.
    pub kind: DescribeDimensionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeDimension` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDimensionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDimensionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDimensionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeDimensionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeDimensionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDimensionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDimensionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDimensionError {
    fn code(&self) -> Option<&str> {
        DescribeDimensionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDimensionError {
    /// Creates a new `DescribeDimensionError`.
    pub fn new(kind: DescribeDimensionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeDimensionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDimensionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeDimensionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDimensionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeDimensionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDimensionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDimensionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDimensionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDimensionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDimensionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDimensionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDimensionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeDimensionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDimensionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeDimensionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeDimensionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDimensionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDimensionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeDomainConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDomainConfigurationError {
    /// Kind of error that occurred.
    pub kind: DescribeDomainConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeDomainConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDomainConfigurationErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDomainConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDomainConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeDomainConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDomainConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDomainConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeDomainConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDomainConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeDomainConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDomainConfigurationError {
    /// Creates a new `DescribeDomainConfigurationError`.
    pub fn new(kind: DescribeDomainConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeDomainConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDomainConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeDomainConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDomainConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeDomainConfigurationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDomainConfigurationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDomainConfigurationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDomainConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDomainConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeDomainConfigurationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeDomainConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDomainConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeDomainConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DescribeDomainConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDomainConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeDomainConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeEndpoint` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEndpointError {
    /// Kind of error that occurred.
    pub kind: DescribeEndpointErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeEndpoint` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEndpointErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEndpointErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeEndpointErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeEndpointErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeEndpointErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEndpointError {
    fn code(&self) -> Option<&str> {
        DescribeEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEndpointError {
    /// Creates a new `DescribeEndpointError`.
    pub fn new(kind: DescribeEndpointErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeEndpointError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeEndpointError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeEndpointErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEndpointErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeEndpointErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEndpointErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeEndpointErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEndpointErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeEndpointErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEndpointErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEndpointErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeEndpointErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeEndpointErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeEndpointErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeEventConfigurations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEventConfigurationsError {
    /// Kind of error that occurred.
    pub kind: DescribeEventConfigurationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeEventConfigurations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventConfigurationsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEventConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEventConfigurationsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeEventConfigurationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeEventConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEventConfigurationsError {
    fn code(&self) -> Option<&str> {
        DescribeEventConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventConfigurationsError {
    /// Creates a new `DescribeEventConfigurationsError`.
    pub fn new(kind: DescribeEventConfigurationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeEventConfigurationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEventConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeEventConfigurationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEventConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeEventConfigurationsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventConfigurationsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeEventConfigurationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventConfigurationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeEventConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEventConfigurationsErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeEventConfigurationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeEventConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeFleetMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFleetMetricError {
    /// Kind of error that occurred.
    pub kind: DescribeFleetMetricErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeFleetMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFleetMetricErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFleetMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFleetMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeFleetMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeFleetMetricError {
    fn code(&self) -> Option<&str> {
        DescribeFleetMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFleetMetricError {
    /// Creates a new `DescribeFleetMetricError`.
    pub fn new(kind: DescribeFleetMetricErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeFleetMetricError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFleetMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeFleetMetricError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFleetMetricErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeFleetMetricErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeFleetMetricErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeFleetMetricErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeFleetMetricErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeFleetMetricErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeFleetMetricErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetricErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeFleetMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFleetMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeFleetMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeIndex` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeIndexError {
    /// Kind of error that occurred.
    pub kind: DescribeIndexErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeIndex` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeIndexErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeIndexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeIndexErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeIndexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeIndexError {
    fn code(&self) -> Option<&str> {
        DescribeIndexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeIndexError {
    /// Creates a new `DescribeIndexError`.
    pub fn new(kind: DescribeIndexErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeIndexError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeIndexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeIndexError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeIndexErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeIndexErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIndexErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeIndexErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIndexErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeIndexErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIndexErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeIndexErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIndexErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeIndexErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeIndexErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DescribeIndexErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DescribeIndexErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DescribeIndexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeIndexErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeIndexErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeIndexErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeIndexErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeIndexErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeIndexErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeIndexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeJobError {
    /// Kind of error that occurred.
    pub kind: DescribeJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeJobErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeJobError {
    fn code(&self) -> Option<&str> {
        DescribeJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeJobError {
    /// Creates a new `DescribeJobError`.
    pub fn new(kind: DescribeJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeJobErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, DescribeJobErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `DescribeJobErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeJobErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeJobErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeJobErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DescribeJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeJobExecution` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeJobExecutionError {
    /// Kind of error that occurred.
    pub kind: DescribeJobExecutionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeJobExecution` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeJobExecutionErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeJobExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeJobExecutionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeJobExecutionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeJobExecutionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeJobExecutionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeJobExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeJobExecutionError {
    fn code(&self) -> Option<&str> {
        DescribeJobExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeJobExecutionError {
    /// Creates a new `DescribeJobExecutionError`.
    pub fn new(kind: DescribeJobExecutionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeJobExecutionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeJobExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeJobExecutionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeJobExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeJobExecutionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobExecutionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeJobExecutionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobExecutionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeJobExecutionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobExecutionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeJobExecutionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobExecutionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeJobExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeJobExecutionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeJobExecutionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeJobExecutionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeJobExecutionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeJobExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeJobTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeJobTemplateError {
    /// Kind of error that occurred.
    pub kind: DescribeJobTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeJobTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeJobTemplateErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeJobTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeJobTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeJobTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeJobTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeJobTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeJobTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeJobTemplateError {
    fn code(&self) -> Option<&str> {
        DescribeJobTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeJobTemplateError {
    /// Creates a new `DescribeJobTemplateError`.
    pub fn new(kind: DescribeJobTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeJobTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeJobTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeJobTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeJobTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeJobTemplateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobTemplateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeJobTemplateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobTemplateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeJobTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeJobTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeJobTemplateErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeJobTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeJobTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeJobTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeJobTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeJobTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeJobTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeMitigationAction` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMitigationActionError {
    /// Kind of error that occurred.
    pub kind: DescribeMitigationActionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeMitigationAction` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMitigationActionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMitigationActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMitigationActionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeMitigationActionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeMitigationActionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeMitigationActionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeMitigationActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeMitigationActionError {
    fn code(&self) -> Option<&str> {
        DescribeMitigationActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMitigationActionError {
    /// Creates a new `DescribeMitigationActionError`.
    pub fn new(kind: DescribeMitigationActionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeMitigationActionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMitigationActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeMitigationActionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMitigationActionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeMitigationActionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMitigationActionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMitigationActionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMitigationActionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMitigationActionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMitigationActionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMitigationActionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMitigationActionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeMitigationActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMitigationActionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeMitigationActionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeMitigationActionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeMitigationActionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeMitigationActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeProvisioningTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeProvisioningTemplateError {
    /// Kind of error that occurred.
    pub kind: DescribeProvisioningTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeProvisioningTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeProvisioningTemplateErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeProvisioningTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeProvisioningTemplateErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeProvisioningTemplateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeProvisioningTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeProvisioningTemplateError {
    fn code(&self) -> Option<&str> {
        DescribeProvisioningTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeProvisioningTemplateError {
    /// Creates a new `DescribeProvisioningTemplateError`.
    pub fn new(kind: DescribeProvisioningTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeProvisioningTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeProvisioningTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeProvisioningTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeProvisioningTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeProvisioningTemplateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProvisioningTemplateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProvisioningTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProvisioningTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProvisioningTemplateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeProvisioningTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeProvisioningTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeProvisioningTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeProvisioningTemplateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeProvisioningTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeProvisioningTemplateVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeProvisioningTemplateVersionError {
    /// Kind of error that occurred.
    pub kind: DescribeProvisioningTemplateVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeProvisioningTemplateVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeProvisioningTemplateVersionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeProvisioningTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeProvisioningTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeProvisioningTemplateVersionError {
    fn code(&self) -> Option<&str> {
        DescribeProvisioningTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeProvisioningTemplateVersionError {
    /// Creates a new `DescribeProvisioningTemplateVersionError`.
    pub fn new(
        kind: DescribeProvisioningTemplateVersionErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeProvisioningTemplateVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeProvisioningTemplateVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeProvisioningTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeProvisioningTemplateVersionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateVersionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProvisioningTemplateVersionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateVersionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProvisioningTemplateVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProvisioningTemplateVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeProvisioningTemplateVersionErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProvisioningTemplateVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeProvisioningTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeProvisioningTemplateVersionErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateVersionErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateVersionErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateVersionErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            DescribeProvisioningTemplateVersionErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `DescribeRoleAlias` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRoleAliasError {
    /// Kind of error that occurred.
    pub kind: DescribeRoleAliasErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeRoleAlias` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRoleAliasErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRoleAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRoleAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeRoleAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeRoleAliasError {
    fn code(&self) -> Option<&str> {
        DescribeRoleAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRoleAliasError {
    /// Creates a new `DescribeRoleAliasError`.
    pub fn new(kind: DescribeRoleAliasErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeRoleAliasError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRoleAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeRoleAliasError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRoleAliasErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeRoleAliasErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeRoleAliasErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeRoleAliasErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeRoleAliasErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeRoleAliasErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeRoleAliasErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRoleAliasErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeRoleAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRoleAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeRoleAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeScheduledAudit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeScheduledAuditError {
    /// Kind of error that occurred.
    pub kind: DescribeScheduledAuditErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeScheduledAudit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeScheduledAuditErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeScheduledAuditError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeScheduledAuditErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeScheduledAuditErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeScheduledAuditErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeScheduledAuditErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeScheduledAuditErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeScheduledAuditError {
    fn code(&self) -> Option<&str> {
        DescribeScheduledAuditError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeScheduledAuditError {
    /// Creates a new `DescribeScheduledAuditError`.
    pub fn new(kind: DescribeScheduledAuditErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeScheduledAuditError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeScheduledAuditErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeScheduledAuditError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeScheduledAuditErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeScheduledAuditErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduledAuditErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeScheduledAuditErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduledAuditErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeScheduledAuditErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduledAuditErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeScheduledAuditErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeScheduledAuditErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeScheduledAuditError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeScheduledAuditErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeScheduledAuditErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeScheduledAuditErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeScheduledAuditErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeScheduledAuditErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSecurityProfileError {
    /// Kind of error that occurred.
    pub kind: DescribeSecurityProfileErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSecurityProfileErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeSecurityProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeSecurityProfileError {
    fn code(&self) -> Option<&str> {
        DescribeSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSecurityProfileError {
    /// Creates a new `DescribeSecurityProfileError`.
    pub fn new(kind: DescribeSecurityProfileErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeSecurityProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeSecurityProfileError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeSecurityProfileErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeSecurityProfileErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeSecurityProfileErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSecurityProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeSecurityProfileErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeSecurityProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeStream` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStreamError {
    /// Kind of error that occurred.
    pub kind: DescribeStreamErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeStream` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStreamErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStreamErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeStreamError {
    fn code(&self) -> Option<&str> {
        DescribeStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStreamError {
    /// Creates a new `DescribeStreamError`.
    pub fn new(kind: DescribeStreamErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeStreamError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeStreamError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStreamErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeStreamErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeStreamErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeStreamErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeStreamErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeStreamErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeStreamErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DescribeStreamErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStreamErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStreamErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeStreamErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeStreamErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeStreamErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeStreamErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeStreamErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThingError {
    /// Kind of error that occurred.
    pub kind: DescribeThingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThingErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeThingError {
    fn code(&self) -> Option<&str> {
        DescribeThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThingError {
    /// Creates a new `DescribeThingError`.
    pub fn new(kind: DescribeThingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeThingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeThingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeThingErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeThingErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DescribeThingErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DescribeThingErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DescribeThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThingGroupError {
    /// Kind of error that occurred.
    pub kind: DescribeThingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeThingGroupError {
    fn code(&self) -> Option<&str> {
        DescribeThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThingGroupError {
    /// Creates a new `DescribeThingGroupError`.
    pub fn new(kind: DescribeThingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeThingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeThingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeThingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeThingRegistrationTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThingRegistrationTaskError {
    /// Kind of error that occurred.
    pub kind: DescribeThingRegistrationTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeThingRegistrationTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThingRegistrationTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThingRegistrationTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThingRegistrationTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeThingRegistrationTaskErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeThingRegistrationTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeThingRegistrationTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeThingRegistrationTaskError {
    fn code(&self) -> Option<&str> {
        DescribeThingRegistrationTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThingRegistrationTaskError {
    /// Creates a new `DescribeThingRegistrationTaskError`.
    pub fn new(
        kind: DescribeThingRegistrationTaskErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeThingRegistrationTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThingRegistrationTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeThingRegistrationTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThingRegistrationTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeThingRegistrationTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingRegistrationTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingRegistrationTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingRegistrationTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingRegistrationTaskErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingRegistrationTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingRegistrationTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingRegistrationTaskErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingRegistrationTaskErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingRegistrationTaskErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeThingRegistrationTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThingRegistrationTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeThingRegistrationTaskErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeThingRegistrationTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeThingRegistrationTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeThingType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThingTypeError {
    /// Kind of error that occurred.
    pub kind: DescribeThingTypeErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeThingType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThingTypeErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThingTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThingTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeThingTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeThingTypeError {
    fn code(&self) -> Option<&str> {
        DescribeThingTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThingTypeError {
    /// Creates a new `DescribeThingTypeError`.
    pub fn new(kind: DescribeThingTypeErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeThingTypeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThingTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeThingTypeError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThingTypeErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeThingTypeErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingTypeErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingTypeErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingTypeErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingTypeErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeThingTypeErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThingTypeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeThingTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThingTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeThingTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DetachPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachPolicyError {
    /// Kind of error that occurred.
    pub kind: DetachPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DetachPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachPolicyErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DetachPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetachPolicyError {
    fn code(&self) -> Option<&str> {
        DetachPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachPolicyError {
    /// Creates a new `DetachPolicyError`.
    pub fn new(kind: DetachPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DetachPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DetachPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DetachPolicyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPolicyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachPolicyErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPolicyErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachPolicyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DetachPolicyErrorKind::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `DetachPolicyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachPolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DetachPolicyErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `DetachPolicyErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DetachPolicyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DetachPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            DetachPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DetachPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DetachPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DetachPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetachPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DetachPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DetachPrincipalPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachPrincipalPolicyError {
    /// Kind of error that occurred.
    pub kind: DetachPrincipalPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DetachPrincipalPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachPrincipalPolicyErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachPrincipalPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachPrincipalPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DetachPrincipalPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetachPrincipalPolicyError {
    fn code(&self) -> Option<&str> {
        DetachPrincipalPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachPrincipalPolicyError {
    /// Creates a new `DetachPrincipalPolicyError`.
    pub fn new(kind: DetachPrincipalPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DetachPrincipalPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachPrincipalPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DetachPrincipalPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachPrincipalPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DetachPrincipalPolicyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachPrincipalPolicyErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachPrincipalPolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachPrincipalPolicyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachPrincipalPolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachPrincipalPolicyErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachPrincipalPolicyErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DetachPrincipalPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachPrincipalPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DetachPrincipalPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DetachSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachSecurityProfileError {
    /// Kind of error that occurred.
    pub kind: DetachSecurityProfileErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DetachSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachSecurityProfileErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DetachSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DetachSecurityProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DetachSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetachSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetachSecurityProfileError {
    fn code(&self) -> Option<&str> {
        DetachSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachSecurityProfileError {
    /// Creates a new `DetachSecurityProfileError`.
    pub fn new(kind: DetachSecurityProfileErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DetachSecurityProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DetachSecurityProfileError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DetachSecurityProfileErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachSecurityProfileErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachSecurityProfileErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachSecurityProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachSecurityProfileErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DetachSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            DetachSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DetachSecurityProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DetachSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetachSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DetachThingPrincipal` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachThingPrincipalError {
    /// Kind of error that occurred.
    pub kind: DetachThingPrincipalErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DetachThingPrincipal` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachThingPrincipalErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachThingPrincipalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachThingPrincipalErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DetachThingPrincipalErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DetachThingPrincipalError {
    fn code(&self) -> Option<&str> {
        DetachThingPrincipalError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachThingPrincipalError {
    /// Creates a new `DetachThingPrincipalError`.
    pub fn new(kind: DetachThingPrincipalErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DetachThingPrincipalError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachThingPrincipalErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DetachThingPrincipalError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachThingPrincipalErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DetachThingPrincipalErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachThingPrincipalErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachThingPrincipalErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachThingPrincipalErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachThingPrincipalErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `DetachThingPrincipalErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachThingPrincipalErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DetachThingPrincipalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachThingPrincipalErrorKind::InternalFailureException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::ThrottlingException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DetachThingPrincipalErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DisableTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableTopicRuleError {
    /// Kind of error that occurred.
    pub kind: DisableTopicRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DisableTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableTopicRuleErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            DisableTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            DisableTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DisableTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DisableTopicRuleErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DisableTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisableTopicRuleError {
    fn code(&self) -> Option<&str> {
        DisableTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableTopicRuleError {
    /// Creates a new `DisableTopicRuleError`.
    pub fn new(kind: DisableTopicRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DisableTopicRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DisableTopicRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DisableTopicRuleErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableTopicRuleErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `DisableTopicRuleErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DisableTopicRuleErrorKind::InternalException(_))
    }
    /// Returns `true` if the error kind is `DisableTopicRuleErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DisableTopicRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DisableTopicRuleErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableTopicRuleErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DisableTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            DisableTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            DisableTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DisableTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DisableTopicRuleErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DisableTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `EnableTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableTopicRuleError {
    /// Kind of error that occurred.
    pub kind: EnableTopicRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `EnableTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableTopicRuleErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            EnableTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            EnableTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            EnableTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            EnableTopicRuleErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            EnableTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for EnableTopicRuleError {
    fn code(&self) -> Option<&str> {
        EnableTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableTopicRuleError {
    /// Creates a new `EnableTopicRuleError`.
    pub fn new(kind: EnableTopicRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `EnableTopicRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `EnableTopicRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `EnableTopicRuleErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableTopicRuleErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `EnableTopicRuleErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, EnableTopicRuleErrorKind::InternalException(_))
    }
    /// Returns `true` if the error kind is `EnableTopicRuleErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `EnableTopicRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `EnableTopicRuleErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableTopicRuleErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for EnableTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            EnableTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            EnableTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            EnableTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            EnableTopicRuleErrorKind::UnauthorizedException(_inner) => Some(_inner),
            EnableTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetBehaviorModelTrainingSummaries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBehaviorModelTrainingSummariesError {
    /// Kind of error that occurred.
    pub kind: GetBehaviorModelTrainingSummariesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetBehaviorModelTrainingSummaries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBehaviorModelTrainingSummariesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBehaviorModelTrainingSummariesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBehaviorModelTrainingSummariesErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetBehaviorModelTrainingSummariesErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetBehaviorModelTrainingSummariesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetBehaviorModelTrainingSummariesErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            GetBehaviorModelTrainingSummariesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetBehaviorModelTrainingSummariesError {
    fn code(&self) -> Option<&str> {
        GetBehaviorModelTrainingSummariesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBehaviorModelTrainingSummariesError {
    /// Creates a new `GetBehaviorModelTrainingSummariesError`.
    pub fn new(
        kind: GetBehaviorModelTrainingSummariesErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetBehaviorModelTrainingSummariesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBehaviorModelTrainingSummariesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetBehaviorModelTrainingSummariesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBehaviorModelTrainingSummariesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetBehaviorModelTrainingSummariesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBehaviorModelTrainingSummariesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBehaviorModelTrainingSummariesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBehaviorModelTrainingSummariesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBehaviorModelTrainingSummariesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBehaviorModelTrainingSummariesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBehaviorModelTrainingSummariesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBehaviorModelTrainingSummariesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for GetBehaviorModelTrainingSummariesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBehaviorModelTrainingSummariesErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            GetBehaviorModelTrainingSummariesErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            GetBehaviorModelTrainingSummariesErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetBehaviorModelTrainingSummariesErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetBehaviorModelTrainingSummariesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetBucketsAggregation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBucketsAggregationError {
    /// Kind of error that occurred.
    pub kind: GetBucketsAggregationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetBucketsAggregation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBucketsAggregationErrorKind {
    /// <p>The index is not ready.</p>
    IndexNotReadyException(crate::error::IndexNotReadyException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The aggregation is invalid.</p>
    InvalidAggregationException(crate::error::InvalidAggregationException),
    /// <p>The query is invalid.</p>
    InvalidQueryException(crate::error::InvalidQueryException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBucketsAggregationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBucketsAggregationErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetBucketsAggregationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetBucketsAggregationError {
    fn code(&self) -> Option<&str> {
        GetBucketsAggregationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBucketsAggregationError {
    /// Creates a new `GetBucketsAggregationError`.
    pub fn new(kind: GetBucketsAggregationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetBucketsAggregationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBucketsAggregationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetBucketsAggregationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBucketsAggregationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetBucketsAggregationErrorKind::IndexNotReadyException`.
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::IndexNotReadyException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBucketsAggregationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBucketsAggregationErrorKind::InvalidAggregationException`.
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::InvalidAggregationException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBucketsAggregationErrorKind::InvalidQueryException`.
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::InvalidQueryException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBucketsAggregationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBucketsAggregationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBucketsAggregationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBucketsAggregationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBucketsAggregationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBucketsAggregationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetBucketsAggregationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBucketsAggregationErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::InvalidQueryException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetBucketsAggregationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCardinality` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCardinalityError {
    /// Kind of error that occurred.
    pub kind: GetCardinalityErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCardinality` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCardinalityErrorKind {
    /// <p>The index is not ready.</p>
    IndexNotReadyException(crate::error::IndexNotReadyException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The aggregation is invalid.</p>
    InvalidAggregationException(crate::error::InvalidAggregationException),
    /// <p>The query is invalid.</p>
    InvalidQueryException(crate::error::InvalidQueryException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCardinalityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCardinalityErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetCardinalityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCardinalityError {
    fn code(&self) -> Option<&str> {
        GetCardinalityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCardinalityError {
    /// Creates a new `GetCardinalityError`.
    pub fn new(kind: GetCardinalityErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCardinalityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCardinalityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCardinalityError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCardinalityErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetCardinalityErrorKind::IndexNotReadyException`.
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::IndexNotReadyException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCardinalityErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCardinalityErrorKind::InvalidAggregationException`.
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::InvalidAggregationException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCardinalityErrorKind::InvalidQueryException`.
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::InvalidQueryException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCardinalityErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCardinalityErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCardinalityErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCardinalityErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetCardinalityErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetCardinalityErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCardinalityErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetCardinalityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCardinalityErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            GetCardinalityErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetCardinalityErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            GetCardinalityErrorKind::InvalidQueryException(_inner) => Some(_inner),
            GetCardinalityErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetCardinalityErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetCardinalityErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetCardinalityErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetCardinalityErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetCardinalityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetEffectivePolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEffectivePoliciesError {
    /// Kind of error that occurred.
    pub kind: GetEffectivePoliciesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetEffectivePolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEffectivePoliciesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEffectivePoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEffectivePoliciesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetEffectivePoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetEffectivePoliciesError {
    fn code(&self) -> Option<&str> {
        GetEffectivePoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEffectivePoliciesError {
    /// Creates a new `GetEffectivePoliciesError`.
    pub fn new(kind: GetEffectivePoliciesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetEffectivePoliciesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEffectivePoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetEffectivePoliciesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEffectivePoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetEffectivePoliciesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetEffectivePoliciesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetEffectivePoliciesErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetEffectivePoliciesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetEffectivePoliciesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetEffectivePoliciesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `GetEffectivePoliciesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEffectivePoliciesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetEffectivePoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEffectivePoliciesErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetEffectivePoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetIndexingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIndexingConfigurationError {
    /// Kind of error that occurred.
    pub kind: GetIndexingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetIndexingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIndexingConfigurationErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIndexingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetIndexingConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetIndexingConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetIndexingConfigurationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetIndexingConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetIndexingConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetIndexingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetIndexingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetIndexingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetIndexingConfigurationError {
    /// Creates a new `GetIndexingConfigurationError`.
    pub fn new(kind: GetIndexingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetIndexingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetIndexingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetIndexingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetIndexingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetIndexingConfigurationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIndexingConfigurationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetIndexingConfigurationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIndexingConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetIndexingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIndexingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetIndexingConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIndexingConfigurationErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `GetIndexingConfigurationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIndexingConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetIndexingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetIndexingConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetIndexingConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetIndexingConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetIndexingConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetIndexingConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetIndexingConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetJobDocument` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJobDocumentError {
    /// Kind of error that occurred.
    pub kind: GetJobDocumentErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetJobDocument` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJobDocumentErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJobDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJobDocumentErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetJobDocumentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetJobDocumentErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetJobDocumentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetJobDocumentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetJobDocumentError {
    fn code(&self) -> Option<&str> {
        GetJobDocumentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJobDocumentError {
    /// Creates a new `GetJobDocumentError`.
    pub fn new(kind: GetJobDocumentErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetJobDocumentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJobDocumentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetJobDocumentError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJobDocumentErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetJobDocumentErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobDocumentErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetJobDocumentErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobDocumentErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetJobDocumentErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJobDocumentErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetJobDocumentErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetJobDocumentErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for GetJobDocumentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJobDocumentErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetJobDocumentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetJobDocumentErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetJobDocumentErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetJobDocumentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetLoggingOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLoggingOptionsError {
    /// Kind of error that occurred.
    pub kind: GetLoggingOptionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetLoggingOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLoggingOptionsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLoggingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLoggingOptionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetLoggingOptionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetLoggingOptionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetLoggingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetLoggingOptionsError {
    fn code(&self) -> Option<&str> {
        GetLoggingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLoggingOptionsError {
    /// Creates a new `GetLoggingOptionsError`.
    pub fn new(kind: GetLoggingOptionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetLoggingOptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLoggingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetLoggingOptionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLoggingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetLoggingOptionsErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, GetLoggingOptionsErrorKind::InternalException(_))
    }
    /// Returns `true` if the error kind is `GetLoggingOptionsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoggingOptionsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetLoggingOptionsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoggingOptionsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetLoggingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLoggingOptionsErrorKind::InternalException(_inner) => Some(_inner),
            GetLoggingOptionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetLoggingOptionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetLoggingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetOTAUpdate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOTAUpdateError {
    /// Kind of error that occurred.
    pub kind: GetOTAUpdateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetOTAUpdate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOTAUpdateErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOTAUpdateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOTAUpdateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetOTAUpdateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetOTAUpdateError {
    fn code(&self) -> Option<&str> {
        GetOTAUpdateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOTAUpdateError {
    /// Creates a new `GetOTAUpdateError`.
    pub fn new(kind: GetOTAUpdateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetOTAUpdateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOTAUpdateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetOTAUpdateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOTAUpdateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetOTAUpdateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOTAUpdateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetOTAUpdateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOTAUpdateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetOTAUpdateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOTAUpdateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetOTAUpdateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOTAUpdateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetOTAUpdateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetOTAUpdateErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetOTAUpdateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetOTAUpdateErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetOTAUpdateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOTAUpdateErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetOTAUpdateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetPercentiles` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPercentilesError {
    /// Kind of error that occurred.
    pub kind: GetPercentilesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetPercentiles` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPercentilesErrorKind {
    /// <p>The index is not ready.</p>
    IndexNotReadyException(crate::error::IndexNotReadyException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The aggregation is invalid.</p>
    InvalidAggregationException(crate::error::InvalidAggregationException),
    /// <p>The query is invalid.</p>
    InvalidQueryException(crate::error::InvalidQueryException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPercentilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPercentilesErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetPercentilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPercentilesError {
    fn code(&self) -> Option<&str> {
        GetPercentilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPercentilesError {
    /// Creates a new `GetPercentilesError`.
    pub fn new(kind: GetPercentilesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPercentilesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPercentilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPercentilesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPercentilesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetPercentilesErrorKind::IndexNotReadyException`.
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::IndexNotReadyException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPercentilesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPercentilesErrorKind::InvalidAggregationException`.
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::InvalidAggregationException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPercentilesErrorKind::InvalidQueryException`.
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::InvalidQueryException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPercentilesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPercentilesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPercentilesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPercentilesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetPercentilesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetPercentilesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPercentilesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetPercentilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPercentilesErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            GetPercentilesErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetPercentilesErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            GetPercentilesErrorKind::InvalidQueryException(_inner) => Some(_inner),
            GetPercentilesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetPercentilesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetPercentilesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPercentilesErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetPercentilesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetPercentilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPolicyError {
    /// Kind of error that occurred.
    pub kind: GetPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPolicyErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPolicyError {
    fn code(&self) -> Option<&str> {
        GetPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPolicyError {
    /// Creates a new `GetPolicyError`.
    pub fn new(kind: GetPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetPolicyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::InternalFailureException(_))
    }
    /// Returns `true` if the error kind is `GetPolicyErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `GetPolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetPolicyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetPolicyErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetPolicyVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPolicyVersionError {
    /// Kind of error that occurred.
    pub kind: GetPolicyVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetPolicyVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPolicyVersionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPolicyVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetPolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPolicyVersionError {
    fn code(&self) -> Option<&str> {
        GetPolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPolicyVersionError {
    /// Creates a new `GetPolicyVersionError`.
    pub fn new(kind: GetPolicyVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPolicyVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPolicyVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetPolicyVersionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPolicyVersionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPolicyVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPolicyVersionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPolicyVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPolicyVersionErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPolicyVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetPolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPolicyVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetPolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetRegistrationCode` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRegistrationCodeError {
    /// Kind of error that occurred.
    pub kind: GetRegistrationCodeErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetRegistrationCode` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRegistrationCodeErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRegistrationCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRegistrationCodeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetRegistrationCodeErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetRegistrationCodeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetRegistrationCodeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetRegistrationCodeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetRegistrationCodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRegistrationCodeError {
    fn code(&self) -> Option<&str> {
        GetRegistrationCodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRegistrationCodeError {
    /// Creates a new `GetRegistrationCodeError`.
    pub fn new(kind: GetRegistrationCodeErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetRegistrationCodeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRegistrationCodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetRegistrationCodeError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRegistrationCodeErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetRegistrationCodeErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegistrationCodeErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRegistrationCodeErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegistrationCodeErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRegistrationCodeErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegistrationCodeErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRegistrationCodeErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegistrationCodeErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRegistrationCodeErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegistrationCodeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetRegistrationCodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRegistrationCodeErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetRegistrationCodeErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetRegistrationCodeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetRegistrationCodeErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetRegistrationCodeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetRegistrationCodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetStatistics` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetStatisticsError {
    /// Kind of error that occurred.
    pub kind: GetStatisticsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetStatistics` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStatisticsErrorKind {
    /// <p>The index is not ready.</p>
    IndexNotReadyException(crate::error::IndexNotReadyException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The aggregation is invalid.</p>
    InvalidAggregationException(crate::error::InvalidAggregationException),
    /// <p>The query is invalid.</p>
    InvalidQueryException(crate::error::InvalidQueryException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetStatisticsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetStatisticsErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetStatisticsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetStatisticsError {
    fn code(&self) -> Option<&str> {
        GetStatisticsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetStatisticsError {
    /// Creates a new `GetStatisticsError`.
    pub fn new(kind: GetStatisticsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetStatisticsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetStatisticsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetStatisticsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetStatisticsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetStatisticsErrorKind::IndexNotReadyException`.
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::IndexNotReadyException(_)
        )
    }
    /// Returns `true` if the error kind is `GetStatisticsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetStatisticsErrorKind::InvalidAggregationException`.
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::InvalidAggregationException(_)
        )
    }
    /// Returns `true` if the error kind is `GetStatisticsErrorKind::InvalidQueryException`.
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(&self.kind, GetStatisticsErrorKind::InvalidQueryException(_))
    }
    /// Returns `true` if the error kind is `GetStatisticsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetStatisticsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetStatisticsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStatisticsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetStatisticsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetStatisticsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetStatisticsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetStatisticsErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetStatisticsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetStatisticsErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            GetStatisticsErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetStatisticsErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            GetStatisticsErrorKind::InvalidQueryException(_inner) => Some(_inner),
            GetStatisticsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetStatisticsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetStatisticsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetStatisticsErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetStatisticsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetStatisticsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTopicRuleError {
    /// Kind of error that occurred.
    pub kind: GetTopicRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTopicRuleErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetTopicRuleErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetTopicRuleError {
    fn code(&self) -> Option<&str> {
        GetTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTopicRuleError {
    /// Creates a new `GetTopicRuleError`.
    pub fn new(kind: GetTopicRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetTopicRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetTopicRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetTopicRuleErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, GetTopicRuleErrorKind::InternalException(_))
    }
    /// Returns `true` if the error kind is `GetTopicRuleErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTopicRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTopicRuleErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetTopicRuleErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            GetTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetTopicRuleErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetTopicRuleDestination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTopicRuleDestinationError {
    /// Kind of error that occurred.
    pub kind: GetTopicRuleDestinationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetTopicRuleDestination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTopicRuleDestinationErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTopicRuleDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTopicRuleDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            GetTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetTopicRuleDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetTopicRuleDestinationError {
    fn code(&self) -> Option<&str> {
        GetTopicRuleDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTopicRuleDestinationError {
    /// Creates a new `GetTopicRuleDestinationError`.
    pub fn new(kind: GetTopicRuleDestinationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetTopicRuleDestinationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTopicRuleDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetTopicRuleDestinationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTopicRuleDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetTopicRuleDestinationErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleDestinationErrorKind::InternalException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTopicRuleDestinationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleDestinationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTopicRuleDestinationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetTopicRuleDestinationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTopicRuleDestinationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetTopicRuleDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTopicRuleDestinationErrorKind::InternalException(_inner) => Some(_inner),
            GetTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            GetTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetTopicRuleDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetV2LoggingOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetV2LoggingOptionsError {
    /// Kind of error that occurred.
    pub kind: GetV2LoggingOptionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetV2LoggingOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetV2LoggingOptionsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The resource is not configured.</p>
    NotConfiguredException(crate::error::NotConfiguredException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetV2LoggingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetV2LoggingOptionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            GetV2LoggingOptionsErrorKind::NotConfiguredException(_inner) => _inner.fmt(f),
            GetV2LoggingOptionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetV2LoggingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetV2LoggingOptionsError {
    fn code(&self) -> Option<&str> {
        GetV2LoggingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetV2LoggingOptionsError {
    /// Creates a new `GetV2LoggingOptionsError`.
    pub fn new(kind: GetV2LoggingOptionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetV2LoggingOptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetV2LoggingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetV2LoggingOptionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetV2LoggingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetV2LoggingOptionsErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetV2LoggingOptionsErrorKind::InternalException(_)
        )
    }
    /// Returns `true` if the error kind is `GetV2LoggingOptionsErrorKind::NotConfiguredException`.
    pub fn is_not_configured_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetV2LoggingOptionsErrorKind::NotConfiguredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetV2LoggingOptionsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetV2LoggingOptionsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetV2LoggingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetV2LoggingOptionsErrorKind::InternalException(_inner) => Some(_inner),
            GetV2LoggingOptionsErrorKind::NotConfiguredException(_inner) => Some(_inner),
            GetV2LoggingOptionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetV2LoggingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListActiveViolations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListActiveViolationsError {
    /// Kind of error that occurred.
    pub kind: ListActiveViolationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListActiveViolations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListActiveViolationsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListActiveViolationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListActiveViolationsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListActiveViolationsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListActiveViolationsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListActiveViolationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListActiveViolationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListActiveViolationsError {
    fn code(&self) -> Option<&str> {
        ListActiveViolationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListActiveViolationsError {
    /// Creates a new `ListActiveViolationsError`.
    pub fn new(kind: ListActiveViolationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListActiveViolationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListActiveViolationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListActiveViolationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListActiveViolationsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListActiveViolationsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListActiveViolationsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListActiveViolationsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListActiveViolationsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListActiveViolationsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListActiveViolationsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListActiveViolationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListActiveViolationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListActiveViolationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListActiveViolationsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListActiveViolationsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListActiveViolationsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListActiveViolationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListActiveViolationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAttachedPolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttachedPoliciesError {
    /// Kind of error that occurred.
    pub kind: ListAttachedPoliciesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAttachedPolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttachedPoliciesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttachedPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttachedPoliciesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListAttachedPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAttachedPoliciesError {
    fn code(&self) -> Option<&str> {
        ListAttachedPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttachedPoliciesError {
    /// Creates a new `ListAttachedPoliciesError`.
    pub fn new(kind: ListAttachedPoliciesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAttachedPoliciesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttachedPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAttachedPoliciesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttachedPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAttachedPoliciesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAttachedPoliciesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAttachedPoliciesErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAttachedPoliciesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAttachedPoliciesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAttachedPoliciesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAttachedPoliciesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttachedPoliciesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListAttachedPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttachedPoliciesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListAttachedPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAuditFindings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuditFindingsError {
    /// Kind of error that occurred.
    pub kind: ListAuditFindingsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAuditFindings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuditFindingsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuditFindingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuditFindingsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListAuditFindingsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListAuditFindingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAuditFindingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAuditFindingsError {
    fn code(&self) -> Option<&str> {
        ListAuditFindingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuditFindingsError {
    /// Creates a new `ListAuditFindingsError`.
    pub fn new(kind: ListAuditFindingsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAuditFindingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuditFindingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAuditFindingsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuditFindingsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAuditFindingsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditFindingsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuditFindingsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditFindingsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuditFindingsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditFindingsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListAuditFindingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuditFindingsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListAuditFindingsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListAuditFindingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAuditFindingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAuditMitigationActionsExecutions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuditMitigationActionsExecutionsError {
    /// Kind of error that occurred.
    pub kind: ListAuditMitigationActionsExecutionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAuditMitigationActionsExecutions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuditMitigationActionsExecutionsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuditMitigationActionsExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuditMitigationActionsExecutionsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListAuditMitigationActionsExecutionsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListAuditMitigationActionsExecutionsErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            ListAuditMitigationActionsExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAuditMitigationActionsExecutionsError {
    fn code(&self) -> Option<&str> {
        ListAuditMitigationActionsExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuditMitigationActionsExecutionsError {
    /// Creates a new `ListAuditMitigationActionsExecutionsError`.
    pub fn new(
        kind: ListAuditMitigationActionsExecutionsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAuditMitigationActionsExecutionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuditMitigationActionsExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAuditMitigationActionsExecutionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuditMitigationActionsExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAuditMitigationActionsExecutionsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsExecutionsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuditMitigationActionsExecutionsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsExecutionsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuditMitigationActionsExecutionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsExecutionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListAuditMitigationActionsExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuditMitigationActionsExecutionsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListAuditMitigationActionsExecutionsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListAuditMitigationActionsExecutionsErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            ListAuditMitigationActionsExecutionsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `ListAuditMitigationActionsTasks` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuditMitigationActionsTasksError {
    /// Kind of error that occurred.
    pub kind: ListAuditMitigationActionsTasksErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAuditMitigationActionsTasks` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuditMitigationActionsTasksErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuditMitigationActionsTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuditMitigationActionsTasksErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListAuditMitigationActionsTasksErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListAuditMitigationActionsTasksErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAuditMitigationActionsTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAuditMitigationActionsTasksError {
    fn code(&self) -> Option<&str> {
        ListAuditMitigationActionsTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuditMitigationActionsTasksError {
    /// Creates a new `ListAuditMitigationActionsTasksError`.
    pub fn new(
        kind: ListAuditMitigationActionsTasksErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAuditMitigationActionsTasksError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuditMitigationActionsTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAuditMitigationActionsTasksError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuditMitigationActionsTasksErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAuditMitigationActionsTasksErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsTasksErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuditMitigationActionsTasksErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsTasksErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuditMitigationActionsTasksErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditMitigationActionsTasksErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListAuditMitigationActionsTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuditMitigationActionsTasksErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListAuditMitigationActionsTasksErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListAuditMitigationActionsTasksErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAuditMitigationActionsTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAuditSuppressions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuditSuppressionsError {
    /// Kind of error that occurred.
    pub kind: ListAuditSuppressionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAuditSuppressions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuditSuppressionsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuditSuppressionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuditSuppressionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListAuditSuppressionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListAuditSuppressionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAuditSuppressionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAuditSuppressionsError {
    fn code(&self) -> Option<&str> {
        ListAuditSuppressionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuditSuppressionsError {
    /// Creates a new `ListAuditSuppressionsError`.
    pub fn new(kind: ListAuditSuppressionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAuditSuppressionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuditSuppressionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAuditSuppressionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuditSuppressionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAuditSuppressionsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditSuppressionsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuditSuppressionsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditSuppressionsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuditSuppressionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditSuppressionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListAuditSuppressionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuditSuppressionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListAuditSuppressionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListAuditSuppressionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAuditSuppressionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAuditTasks` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuditTasksError {
    /// Kind of error that occurred.
    pub kind: ListAuditTasksErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAuditTasks` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuditTasksErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuditTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuditTasksErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListAuditTasksErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListAuditTasksErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAuditTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAuditTasksError {
    fn code(&self) -> Option<&str> {
        ListAuditTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuditTasksError {
    /// Creates a new `ListAuditTasksError`.
    pub fn new(kind: ListAuditTasksErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAuditTasksError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuditTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAuditTasksError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuditTasksErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAuditTasksErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditTasksErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuditTasksErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuditTasksErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuditTasksErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListAuditTasksErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListAuditTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuditTasksErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListAuditTasksErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListAuditTasksErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAuditTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAuthorizers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAuthorizersError {
    /// Kind of error that occurred.
    pub kind: ListAuthorizersErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAuthorizers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAuthorizersErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAuthorizersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAuthorizersErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListAuthorizersErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListAuthorizersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAuthorizersErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAuthorizersErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListAuthorizersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAuthorizersError {
    fn code(&self) -> Option<&str> {
        ListAuthorizersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAuthorizersError {
    /// Creates a new `ListAuthorizersError`.
    pub fn new(kind: ListAuthorizersErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAuthorizersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAuthorizersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAuthorizersError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAuthorizersErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAuthorizersErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuthorizersErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuthorizersErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuthorizersErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuthorizersErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuthorizersErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAuthorizersErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListAuthorizersErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListAuthorizersErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAuthorizersErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListAuthorizersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAuthorizersErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListAuthorizersErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListAuthorizersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAuthorizersErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAuthorizersErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListAuthorizersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListBillingGroups` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBillingGroupsError {
    /// Kind of error that occurred.
    pub kind: ListBillingGroupsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListBillingGroups` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBillingGroupsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBillingGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBillingGroupsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListBillingGroupsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListBillingGroupsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListBillingGroupsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListBillingGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListBillingGroupsError {
    fn code(&self) -> Option<&str> {
        ListBillingGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBillingGroupsError {
    /// Creates a new `ListBillingGroupsError`.
    pub fn new(kind: ListBillingGroupsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListBillingGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBillingGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListBillingGroupsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBillingGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListBillingGroupsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBillingGroupsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListBillingGroupsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBillingGroupsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListBillingGroupsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBillingGroupsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListBillingGroupsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBillingGroupsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListBillingGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBillingGroupsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListBillingGroupsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListBillingGroupsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListBillingGroupsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListBillingGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListCACertificates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCACertificatesError {
    /// Kind of error that occurred.
    pub kind: ListCACertificatesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListCACertificates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCACertificatesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCACertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCACertificatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListCACertificatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListCACertificatesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListCACertificatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListCACertificatesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListCACertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCACertificatesError {
    fn code(&self) -> Option<&str> {
        ListCACertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCACertificatesError {
    /// Creates a new `ListCACertificatesError`.
    pub fn new(kind: ListCACertificatesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListCACertificatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCACertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListCACertificatesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCACertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListCACertificatesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCACertificatesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCACertificatesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCACertificatesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCACertificatesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCACertificatesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCACertificatesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCACertificatesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCACertificatesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCACertificatesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListCACertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCACertificatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListCACertificatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListCACertificatesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListCACertificatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListCACertificatesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListCACertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListCertificates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCertificatesError {
    /// Kind of error that occurred.
    pub kind: ListCertificatesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListCertificates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCertificatesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCertificatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListCertificatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListCertificatesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListCertificatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListCertificatesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCertificatesError {
    fn code(&self) -> Option<&str> {
        ListCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCertificatesError {
    /// Creates a new `ListCertificatesError`.
    pub fn new(kind: ListCertificatesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListCertificatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListCertificatesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListCertificatesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCertificatesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCertificatesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCertificatesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCertificatesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCertificatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListCertificatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListCertificatesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListCertificatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListCertificatesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListCertificatesByCA` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCertificatesByCAError {
    /// Kind of error that occurred.
    pub kind: ListCertificatesByCAErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListCertificatesByCA` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCertificatesByCAErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCertificatesByCAError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCertificatesByCAErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListCertificatesByCAErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListCertificatesByCAErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListCertificatesByCAErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListCertificatesByCAErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListCertificatesByCAErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCertificatesByCAError {
    fn code(&self) -> Option<&str> {
        ListCertificatesByCAError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCertificatesByCAError {
    /// Creates a new `ListCertificatesByCAError`.
    pub fn new(kind: ListCertificatesByCAErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListCertificatesByCAError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCertificatesByCAErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListCertificatesByCAError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCertificatesByCAErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListCertificatesByCAErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesByCAErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCertificatesByCAErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesByCAErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCertificatesByCAErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesByCAErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCertificatesByCAErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesByCAErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCertificatesByCAErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificatesByCAErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListCertificatesByCAError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCertificatesByCAErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListCertificatesByCAErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListCertificatesByCAErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListCertificatesByCAErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListCertificatesByCAErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListCertificatesByCAErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListCustomMetrics` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCustomMetricsError {
    /// Kind of error that occurred.
    pub kind: ListCustomMetricsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListCustomMetrics` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCustomMetricsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCustomMetricsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCustomMetricsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListCustomMetricsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListCustomMetricsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListCustomMetricsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCustomMetricsError {
    fn code(&self) -> Option<&str> {
        ListCustomMetricsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCustomMetricsError {
    /// Creates a new `ListCustomMetricsError`.
    pub fn new(kind: ListCustomMetricsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListCustomMetricsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCustomMetricsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListCustomMetricsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCustomMetricsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListCustomMetricsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomMetricsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCustomMetricsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomMetricsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListCustomMetricsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomMetricsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListCustomMetricsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCustomMetricsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListCustomMetricsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListCustomMetricsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListCustomMetricsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListDetectMitigationActionsExecutions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDetectMitigationActionsExecutionsError {
    /// Kind of error that occurred.
    pub kind: ListDetectMitigationActionsExecutionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListDetectMitigationActionsExecutions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDetectMitigationActionsExecutionsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDetectMitigationActionsExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDetectMitigationActionsExecutionsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListDetectMitigationActionsExecutionsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListDetectMitigationActionsExecutionsErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            ListDetectMitigationActionsExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDetectMitigationActionsExecutionsError {
    fn code(&self) -> Option<&str> {
        ListDetectMitigationActionsExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDetectMitigationActionsExecutionsError {
    /// Creates a new `ListDetectMitigationActionsExecutionsError`.
    pub fn new(
        kind: ListDetectMitigationActionsExecutionsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListDetectMitigationActionsExecutionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDetectMitigationActionsExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListDetectMitigationActionsExecutionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDetectMitigationActionsExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListDetectMitigationActionsExecutionsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsExecutionsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDetectMitigationActionsExecutionsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsExecutionsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDetectMitigationActionsExecutionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsExecutionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListDetectMitigationActionsExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDetectMitigationActionsExecutionsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListDetectMitigationActionsExecutionsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListDetectMitigationActionsExecutionsErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            ListDetectMitigationActionsExecutionsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `ListDetectMitigationActionsTasks` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDetectMitigationActionsTasksError {
    /// Kind of error that occurred.
    pub kind: ListDetectMitigationActionsTasksErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListDetectMitigationActionsTasks` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDetectMitigationActionsTasksErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDetectMitigationActionsTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDetectMitigationActionsTasksErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListDetectMitigationActionsTasksErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListDetectMitigationActionsTasksErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDetectMitigationActionsTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDetectMitigationActionsTasksError {
    fn code(&self) -> Option<&str> {
        ListDetectMitigationActionsTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDetectMitigationActionsTasksError {
    /// Creates a new `ListDetectMitigationActionsTasksError`.
    pub fn new(
        kind: ListDetectMitigationActionsTasksErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListDetectMitigationActionsTasksError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDetectMitigationActionsTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListDetectMitigationActionsTasksError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDetectMitigationActionsTasksErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListDetectMitigationActionsTasksErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsTasksErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDetectMitigationActionsTasksErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsTasksErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDetectMitigationActionsTasksErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDetectMitigationActionsTasksErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListDetectMitigationActionsTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDetectMitigationActionsTasksErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListDetectMitigationActionsTasksErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListDetectMitigationActionsTasksErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDetectMitigationActionsTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListDimensions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDimensionsError {
    /// Kind of error that occurred.
    pub kind: ListDimensionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListDimensions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDimensionsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDimensionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDimensionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListDimensionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListDimensionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDimensionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDimensionsError {
    fn code(&self) -> Option<&str> {
        ListDimensionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDimensionsError {
    /// Creates a new `ListDimensionsError`.
    pub fn new(kind: ListDimensionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListDimensionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDimensionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListDimensionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDimensionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListDimensionsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDimensionsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDimensionsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDimensionsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDimensionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListDimensionsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListDimensionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDimensionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListDimensionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListDimensionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDimensionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListDomainConfigurations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDomainConfigurationsError {
    /// Kind of error that occurred.
    pub kind: ListDomainConfigurationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListDomainConfigurations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDomainConfigurationsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDomainConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDomainConfigurationsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListDomainConfigurationsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListDomainConfigurationsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListDomainConfigurationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDomainConfigurationsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListDomainConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDomainConfigurationsError {
    fn code(&self) -> Option<&str> {
        ListDomainConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDomainConfigurationsError {
    /// Creates a new `ListDomainConfigurationsError`.
    pub fn new(kind: ListDomainConfigurationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListDomainConfigurationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDomainConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListDomainConfigurationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDomainConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListDomainConfigurationsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainConfigurationsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDomainConfigurationsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainConfigurationsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDomainConfigurationsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainConfigurationsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDomainConfigurationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainConfigurationsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListDomainConfigurationsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainConfigurationsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListDomainConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDomainConfigurationsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListDomainConfigurationsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListDomainConfigurationsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListDomainConfigurationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDomainConfigurationsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListDomainConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListFleetMetrics` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFleetMetricsError {
    /// Kind of error that occurred.
    pub kind: ListFleetMetricsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListFleetMetrics` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFleetMetricsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFleetMetricsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFleetMetricsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListFleetMetricsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListFleetMetricsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListFleetMetricsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFleetMetricsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListFleetMetricsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListFleetMetricsError {
    fn code(&self) -> Option<&str> {
        ListFleetMetricsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFleetMetricsError {
    /// Creates a new `ListFleetMetricsError`.
    pub fn new(kind: ListFleetMetricsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListFleetMetricsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFleetMetricsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListFleetMetricsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFleetMetricsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListFleetMetricsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetMetricsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListFleetMetricsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetMetricsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListFleetMetricsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetMetricsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListFleetMetricsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetMetricsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListFleetMetricsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetMetricsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListFleetMetricsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFleetMetricsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListFleetMetricsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListFleetMetricsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListFleetMetricsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFleetMetricsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListFleetMetricsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListIndices` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListIndicesError {
    /// Kind of error that occurred.
    pub kind: ListIndicesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListIndices` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIndicesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListIndicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListIndicesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListIndicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListIndicesError {
    fn code(&self) -> Option<&str> {
        ListIndicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIndicesError {
    /// Creates a new `ListIndicesError`.
    pub fn new(kind: ListIndicesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListIndicesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListIndicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListIndicesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListIndicesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListIndicesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIndicesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListIndicesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListIndicesErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `ListIndicesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIndicesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListIndicesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListIndicesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListIndicesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListIndicesErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListIndicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListIndicesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListIndicesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListIndicesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListIndicesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListIndicesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListIndicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListJobExecutionsForJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobExecutionsForJobError {
    /// Kind of error that occurred.
    pub kind: ListJobExecutionsForJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListJobExecutionsForJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobExecutionsForJobErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobExecutionsForJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobExecutionsForJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListJobExecutionsForJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListJobExecutionsForJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListJobExecutionsForJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListJobExecutionsForJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListJobExecutionsForJobError {
    fn code(&self) -> Option<&str> {
        ListJobExecutionsForJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobExecutionsForJobError {
    /// Creates a new `ListJobExecutionsForJobError`.
    pub fn new(kind: ListJobExecutionsForJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListJobExecutionsForJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobExecutionsForJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListJobExecutionsForJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobExecutionsForJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListJobExecutionsForJobErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForJobErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListJobExecutionsForJobErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForJobErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListJobExecutionsForJobErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForJobErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListJobExecutionsForJobErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForJobErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListJobExecutionsForJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobExecutionsForJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListJobExecutionsForJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListJobExecutionsForJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListJobExecutionsForJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListJobExecutionsForJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListJobExecutionsForThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobExecutionsForThingError {
    /// Kind of error that occurred.
    pub kind: ListJobExecutionsForThingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListJobExecutionsForThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobExecutionsForThingErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobExecutionsForThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobExecutionsForThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListJobExecutionsForThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListJobExecutionsForThingErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ListJobExecutionsForThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListJobExecutionsForThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListJobExecutionsForThingError {
    fn code(&self) -> Option<&str> {
        ListJobExecutionsForThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobExecutionsForThingError {
    /// Creates a new `ListJobExecutionsForThingError`.
    pub fn new(kind: ListJobExecutionsForThingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListJobExecutionsForThingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobExecutionsForThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListJobExecutionsForThingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobExecutionsForThingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListJobExecutionsForThingErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForThingErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListJobExecutionsForThingErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForThingErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListJobExecutionsForThingErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForThingErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListJobExecutionsForThingErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobExecutionsForThingErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListJobExecutionsForThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobExecutionsForThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListJobExecutionsForThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListJobExecutionsForThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListJobExecutionsForThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListJobExecutionsForThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListJobs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobsError {
    /// Kind of error that occurred.
    pub kind: ListJobsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListJobs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobsErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListJobsError {
    fn code(&self) -> Option<&str> {
        ListJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobsError {
    /// Creates a new `ListJobsError`.
    pub fn new(kind: ListJobsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListJobsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListJobsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListJobsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `ListJobsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListJobsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListJobsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListJobsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListJobsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListJobsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListJobTemplates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobTemplatesError {
    /// Kind of error that occurred.
    pub kind: ListJobTemplatesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListJobTemplates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobTemplatesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobTemplatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListJobTemplatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListJobTemplatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListJobTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListJobTemplatesError {
    fn code(&self) -> Option<&str> {
        ListJobTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobTemplatesError {
    /// Creates a new `ListJobTemplatesError`.
    pub fn new(kind: ListJobTemplatesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListJobTemplatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListJobTemplatesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListJobTemplatesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobTemplatesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListJobTemplatesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobTemplatesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListJobTemplatesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJobTemplatesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListJobTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobTemplatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListJobTemplatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListJobTemplatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListJobTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListMitigationActions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMitigationActionsError {
    /// Kind of error that occurred.
    pub kind: ListMitigationActionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListMitigationActions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMitigationActionsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMitigationActionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMitigationActionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListMitigationActionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListMitigationActionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListMitigationActionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListMitigationActionsError {
    fn code(&self) -> Option<&str> {
        ListMitigationActionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMitigationActionsError {
    /// Creates a new `ListMitigationActionsError`.
    pub fn new(kind: ListMitigationActionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListMitigationActionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMitigationActionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListMitigationActionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMitigationActionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListMitigationActionsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMitigationActionsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListMitigationActionsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMitigationActionsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListMitigationActionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMitigationActionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListMitigationActionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMitigationActionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListMitigationActionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListMitigationActionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListMitigationActionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListOTAUpdates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOTAUpdatesError {
    /// Kind of error that occurred.
    pub kind: ListOTAUpdatesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListOTAUpdates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOTAUpdatesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOTAUpdatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOTAUpdatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListOTAUpdatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListOTAUpdatesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListOTAUpdatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListOTAUpdatesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListOTAUpdatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListOTAUpdatesError {
    fn code(&self) -> Option<&str> {
        ListOTAUpdatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOTAUpdatesError {
    /// Creates a new `ListOTAUpdatesError`.
    pub fn new(kind: ListOTAUpdatesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListOTAUpdatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOTAUpdatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListOTAUpdatesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOTAUpdatesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListOTAUpdatesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOTAUpdatesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListOTAUpdatesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOTAUpdatesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListOTAUpdatesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOTAUpdatesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListOTAUpdatesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListOTAUpdatesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListOTAUpdatesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOTAUpdatesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListOTAUpdatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOTAUpdatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListOTAUpdatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListOTAUpdatesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListOTAUpdatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListOTAUpdatesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListOTAUpdatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListOutgoingCertificates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOutgoingCertificatesError {
    /// Kind of error that occurred.
    pub kind: ListOutgoingCertificatesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListOutgoingCertificates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOutgoingCertificatesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOutgoingCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOutgoingCertificatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListOutgoingCertificatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListOutgoingCertificatesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListOutgoingCertificatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListOutgoingCertificatesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListOutgoingCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListOutgoingCertificatesError {
    fn code(&self) -> Option<&str> {
        ListOutgoingCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOutgoingCertificatesError {
    /// Creates a new `ListOutgoingCertificatesError`.
    pub fn new(kind: ListOutgoingCertificatesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListOutgoingCertificatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOutgoingCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListOutgoingCertificatesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOutgoingCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListOutgoingCertificatesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOutgoingCertificatesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListOutgoingCertificatesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOutgoingCertificatesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListOutgoingCertificatesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOutgoingCertificatesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListOutgoingCertificatesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOutgoingCertificatesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListOutgoingCertificatesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOutgoingCertificatesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListOutgoingCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOutgoingCertificatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListOutgoingCertificatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListOutgoingCertificatesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListOutgoingCertificatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListOutgoingCertificatesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListOutgoingCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListPolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPoliciesError {
    /// Kind of error that occurred.
    pub kind: ListPoliciesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListPolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPoliciesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPoliciesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPoliciesError {
    fn code(&self) -> Option<&str> {
        ListPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPoliciesError {
    /// Creates a new `ListPoliciesError`.
    pub fn new(kind: ListPoliciesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListPoliciesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListPoliciesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListPoliciesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPoliciesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPoliciesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPoliciesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPoliciesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPoliciesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPoliciesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListPoliciesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListPoliciesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListPoliciesErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPoliciesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListPoliciesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPoliciesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPoliciesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPoliciesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListPolicyPrincipals` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPolicyPrincipalsError {
    /// Kind of error that occurred.
    pub kind: ListPolicyPrincipalsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListPolicyPrincipals` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPolicyPrincipalsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPolicyPrincipalsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPolicyPrincipalsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListPolicyPrincipalsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPolicyPrincipalsError {
    fn code(&self) -> Option<&str> {
        ListPolicyPrincipalsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPolicyPrincipalsError {
    /// Creates a new `ListPolicyPrincipalsError`.
    pub fn new(kind: ListPolicyPrincipalsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListPolicyPrincipalsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPolicyPrincipalsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListPolicyPrincipalsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPolicyPrincipalsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListPolicyPrincipalsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPolicyPrincipalsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPolicyPrincipalsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPolicyPrincipalsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPolicyPrincipalsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPolicyPrincipalsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyPrincipalsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListPolicyPrincipalsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPolicyPrincipalsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListPolicyPrincipalsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListPolicyVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPolicyVersionsError {
    /// Kind of error that occurred.
    pub kind: ListPolicyVersionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListPolicyVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPolicyVersionsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPolicyVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPolicyVersionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListPolicyVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPolicyVersionsError {
    fn code(&self) -> Option<&str> {
        ListPolicyVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPolicyVersionsError {
    /// Creates a new `ListPolicyVersionsError`.
    pub fn new(kind: ListPolicyVersionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListPolicyVersionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPolicyVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListPolicyVersionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPolicyVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListPolicyVersionsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPolicyVersionsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPolicyVersionsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPolicyVersionsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPolicyVersionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPolicyVersionsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPolicyVersionsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListPolicyVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPolicyVersionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListPolicyVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListPrincipalPolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPrincipalPoliciesError {
    /// Kind of error that occurred.
    pub kind: ListPrincipalPoliciesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListPrincipalPolicies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPrincipalPoliciesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPrincipalPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPrincipalPoliciesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListPrincipalPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPrincipalPoliciesError {
    fn code(&self) -> Option<&str> {
        ListPrincipalPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPrincipalPoliciesError {
    /// Creates a new `ListPrincipalPoliciesError`.
    pub fn new(kind: ListPrincipalPoliciesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListPrincipalPoliciesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPrincipalPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListPrincipalPoliciesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPrincipalPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListPrincipalPoliciesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPrincipalPoliciesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPrincipalPoliciesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPrincipalPoliciesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPrincipalPoliciesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPrincipalPoliciesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalPoliciesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListPrincipalPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPrincipalPoliciesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListPrincipalPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListPrincipalThings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPrincipalThingsError {
    /// Kind of error that occurred.
    pub kind: ListPrincipalThingsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListPrincipalThings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPrincipalThingsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPrincipalThingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPrincipalThingsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListPrincipalThingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPrincipalThingsError {
    fn code(&self) -> Option<&str> {
        ListPrincipalThingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPrincipalThingsError {
    /// Creates a new `ListPrincipalThingsError`.
    pub fn new(kind: ListPrincipalThingsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListPrincipalThingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPrincipalThingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListPrincipalThingsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPrincipalThingsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListPrincipalThingsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPrincipalThingsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPrincipalThingsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPrincipalThingsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPrincipalThingsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPrincipalThingsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPrincipalThingsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListPrincipalThingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPrincipalThingsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListPrincipalThingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListProvisioningTemplates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProvisioningTemplatesError {
    /// Kind of error that occurred.
    pub kind: ListProvisioningTemplatesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListProvisioningTemplates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProvisioningTemplatesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListProvisioningTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProvisioningTemplatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListProvisioningTemplatesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListProvisioningTemplatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListProvisioningTemplatesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListProvisioningTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListProvisioningTemplatesError {
    fn code(&self) -> Option<&str> {
        ListProvisioningTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProvisioningTemplatesError {
    /// Creates a new `ListProvisioningTemplatesError`.
    pub fn new(kind: ListProvisioningTemplatesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListProvisioningTemplatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProvisioningTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListProvisioningTemplatesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProvisioningTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListProvisioningTemplatesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplatesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProvisioningTemplatesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplatesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProvisioningTemplatesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplatesErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProvisioningTemplatesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplatesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListProvisioningTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProvisioningTemplatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListProvisioningTemplatesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListProvisioningTemplatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListProvisioningTemplatesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListProvisioningTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListProvisioningTemplateVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProvisioningTemplateVersionsError {
    /// Kind of error that occurred.
    pub kind: ListProvisioningTemplateVersionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListProvisioningTemplateVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProvisioningTemplateVersionsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListProvisioningTemplateVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProvisioningTemplateVersionsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListProvisioningTemplateVersionsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListProvisioningTemplateVersionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListProvisioningTemplateVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListProvisioningTemplateVersionsErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            ListProvisioningTemplateVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListProvisioningTemplateVersionsError {
    fn code(&self) -> Option<&str> {
        ListProvisioningTemplateVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProvisioningTemplateVersionsError {
    /// Creates a new `ListProvisioningTemplateVersionsError`.
    pub fn new(
        kind: ListProvisioningTemplateVersionsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListProvisioningTemplateVersionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProvisioningTemplateVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListProvisioningTemplateVersionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProvisioningTemplateVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListProvisioningTemplateVersionsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplateVersionsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProvisioningTemplateVersionsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplateVersionsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProvisioningTemplateVersionsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplateVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProvisioningTemplateVersionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplateVersionsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProvisioningTemplateVersionsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProvisioningTemplateVersionsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListProvisioningTemplateVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProvisioningTemplateVersionsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListProvisioningTemplateVersionsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListProvisioningTemplateVersionsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListProvisioningTemplateVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListProvisioningTemplateVersionsErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            ListProvisioningTemplateVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListRoleAliases` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRoleAliasesError {
    /// Kind of error that occurred.
    pub kind: ListRoleAliasesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListRoleAliases` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRoleAliasesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRoleAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRoleAliasesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListRoleAliasesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListRoleAliasesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListRoleAliasesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListRoleAliasesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListRoleAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRoleAliasesError {
    fn code(&self) -> Option<&str> {
        ListRoleAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRoleAliasesError {
    /// Creates a new `ListRoleAliasesError`.
    pub fn new(kind: ListRoleAliasesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListRoleAliasesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRoleAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListRoleAliasesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRoleAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListRoleAliasesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoleAliasesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRoleAliasesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoleAliasesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRoleAliasesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoleAliasesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRoleAliasesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListRoleAliasesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListRoleAliasesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoleAliasesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListRoleAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRoleAliasesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListRoleAliasesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListRoleAliasesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListRoleAliasesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListRoleAliasesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListRoleAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListScheduledAudits` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListScheduledAuditsError {
    /// Kind of error that occurred.
    pub kind: ListScheduledAuditsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListScheduledAudits` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListScheduledAuditsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListScheduledAuditsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListScheduledAuditsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListScheduledAuditsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListScheduledAuditsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListScheduledAuditsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListScheduledAuditsError {
    fn code(&self) -> Option<&str> {
        ListScheduledAuditsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListScheduledAuditsError {
    /// Creates a new `ListScheduledAuditsError`.
    pub fn new(kind: ListScheduledAuditsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListScheduledAuditsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListScheduledAuditsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListScheduledAuditsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListScheduledAuditsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListScheduledAuditsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListScheduledAuditsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListScheduledAuditsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListScheduledAuditsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListScheduledAuditsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListScheduledAuditsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListScheduledAuditsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListScheduledAuditsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListScheduledAuditsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListScheduledAuditsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListScheduledAuditsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListSecurityProfiles` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSecurityProfilesError {
    /// Kind of error that occurred.
    pub kind: ListSecurityProfilesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListSecurityProfiles` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSecurityProfilesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSecurityProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSecurityProfilesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSecurityProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSecurityProfilesError {
    fn code(&self) -> Option<&str> {
        ListSecurityProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSecurityProfilesError {
    /// Creates a new `ListSecurityProfilesError`.
    pub fn new(kind: ListSecurityProfilesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListSecurityProfilesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSecurityProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListSecurityProfilesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSecurityProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListSecurityProfilesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSecurityProfilesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSecurityProfilesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSecurityProfilesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListSecurityProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSecurityProfilesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSecurityProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListSecurityProfilesForTarget` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSecurityProfilesForTargetError {
    /// Kind of error that occurred.
    pub kind: ListSecurityProfilesForTargetErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListSecurityProfilesForTarget` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSecurityProfilesForTargetErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSecurityProfilesForTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSecurityProfilesForTargetErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListSecurityProfilesForTargetErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListSecurityProfilesForTargetErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListSecurityProfilesForTargetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListSecurityProfilesForTargetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSecurityProfilesForTargetError {
    fn code(&self) -> Option<&str> {
        ListSecurityProfilesForTargetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSecurityProfilesForTargetError {
    /// Creates a new `ListSecurityProfilesForTargetError`.
    pub fn new(
        kind: ListSecurityProfilesForTargetErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListSecurityProfilesForTargetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSecurityProfilesForTargetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListSecurityProfilesForTargetError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSecurityProfilesForTargetErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListSecurityProfilesForTargetErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesForTargetErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSecurityProfilesForTargetErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesForTargetErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSecurityProfilesForTargetErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesForTargetErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSecurityProfilesForTargetErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSecurityProfilesForTargetErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListSecurityProfilesForTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSecurityProfilesForTargetErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListSecurityProfilesForTargetErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListSecurityProfilesForTargetErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListSecurityProfilesForTargetErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListSecurityProfilesForTargetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListStreams` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListStreamsError {
    /// Kind of error that occurred.
    pub kind: ListStreamsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListStreams` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStreamsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListStreamsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListStreamsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListStreamsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListStreamsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListStreamsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListStreamsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListStreamsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListStreamsError {
    fn code(&self) -> Option<&str> {
        ListStreamsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStreamsError {
    /// Creates a new `ListStreamsError`.
    pub fn new(kind: ListStreamsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListStreamsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListStreamsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListStreamsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListStreamsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListStreamsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListStreamsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListStreamsErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `ListStreamsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListStreamsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListStreamsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListStreamsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListStreamsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListStreamsErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListStreamsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListStreamsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListStreamsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListStreamsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListStreamsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListStreamsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListStreamsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    /// Kind of error that occurred.
    pub kind: ListTagsForResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates a new `ListTagsForResourceError`.
    pub fn new(kind: ListTagsForResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTargetsForPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTargetsForPolicyError {
    /// Kind of error that occurred.
    pub kind: ListTargetsForPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTargetsForPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTargetsForPolicyErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTargetsForPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTargetsForPolicyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListTargetsForPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTargetsForPolicyError {
    fn code(&self) -> Option<&str> {
        ListTargetsForPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTargetsForPolicyError {
    /// Creates a new `ListTargetsForPolicyError`.
    pub fn new(kind: ListTargetsForPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTargetsForPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTargetsForPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTargetsForPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTargetsForPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTargetsForPolicyErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTargetsForPolicyErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTargetsForPolicyErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTargetsForPolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTargetsForPolicyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTargetsForPolicyErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTargetsForPolicyErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForPolicyErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListTargetsForPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTargetsForPolicyErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListTargetsForPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTargetsForSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTargetsForSecurityProfileError {
    /// Kind of error that occurred.
    pub kind: ListTargetsForSecurityProfileErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTargetsForSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTargetsForSecurityProfileErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTargetsForSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTargetsForSecurityProfileErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListTargetsForSecurityProfileErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListTargetsForSecurityProfileErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListTargetsForSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTargetsForSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTargetsForSecurityProfileError {
    fn code(&self) -> Option<&str> {
        ListTargetsForSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTargetsForSecurityProfileError {
    /// Creates a new `ListTargetsForSecurityProfileError`.
    pub fn new(
        kind: ListTargetsForSecurityProfileErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTargetsForSecurityProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTargetsForSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTargetsForSecurityProfileError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTargetsForSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTargetsForSecurityProfileErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTargetsForSecurityProfileErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTargetsForSecurityProfileErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForSecurityProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTargetsForSecurityProfileErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsForSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListTargetsForSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTargetsForSecurityProfileErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListTargetsForSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTargetsForSecurityProfileErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListTargetsForSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTargetsForSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListThingGroups` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingGroupsError {
    /// Kind of error that occurred.
    pub kind: ListThingGroupsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListThingGroups` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingGroupsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingGroupsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingGroupsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingGroupsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThingGroupsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListThingGroupsError {
    fn code(&self) -> Option<&str> {
        ListThingGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingGroupsError {
    /// Creates a new `ListThingGroupsError`.
    pub fn new(kind: ListThingGroupsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListThingGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListThingGroupsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListThingGroupsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingGroupsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingGroupsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingGroupsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListThingGroupsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListThingGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingGroupsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingGroupsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingGroupsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThingGroupsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListThingGroupsForThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingGroupsForThingError {
    /// Kind of error that occurred.
    pub kind: ListThingGroupsForThingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListThingGroupsForThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingGroupsForThingErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingGroupsForThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingGroupsForThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingGroupsForThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingGroupsForThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThingGroupsForThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingGroupsForThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListThingGroupsForThingError {
    fn code(&self) -> Option<&str> {
        ListThingGroupsForThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingGroupsForThingError {
    /// Creates a new `ListThingGroupsForThingError`.
    pub fn new(kind: ListThingGroupsForThingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListThingGroupsForThingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingGroupsForThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListThingGroupsForThingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingGroupsForThingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListThingGroupsForThingErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsForThingErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingGroupsForThingErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsForThingErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingGroupsForThingErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsForThingErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingGroupsForThingErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingGroupsForThingErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListThingGroupsForThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingGroupsForThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingGroupsForThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingGroupsForThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThingGroupsForThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingGroupsForThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListThingPrincipals` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingPrincipalsError {
    /// Kind of error that occurred.
    pub kind: ListThingPrincipalsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListThingPrincipals` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingPrincipalsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingPrincipalsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingPrincipalsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListThingPrincipalsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListThingPrincipalsError {
    fn code(&self) -> Option<&str> {
        ListThingPrincipalsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingPrincipalsError {
    /// Creates a new `ListThingPrincipalsError`.
    pub fn new(kind: ListThingPrincipalsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListThingPrincipalsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingPrincipalsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListThingPrincipalsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingPrincipalsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListThingPrincipalsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingPrincipalsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingPrincipalsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingPrincipalsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingPrincipalsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingPrincipalsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingPrincipalsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListThingPrincipalsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingPrincipalsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListThingPrincipalsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListThingRegistrationTaskReports` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingRegistrationTaskReportsError {
    /// Kind of error that occurred.
    pub kind: ListThingRegistrationTaskReportsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListThingRegistrationTaskReports` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingRegistrationTaskReportsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingRegistrationTaskReportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingRegistrationTaskReportsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListThingRegistrationTaskReportsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListThingRegistrationTaskReportsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingRegistrationTaskReportsErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            ListThingRegistrationTaskReportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListThingRegistrationTaskReportsError {
    fn code(&self) -> Option<&str> {
        ListThingRegistrationTaskReportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingRegistrationTaskReportsError {
    /// Creates a new `ListThingRegistrationTaskReportsError`.
    pub fn new(
        kind: ListThingRegistrationTaskReportsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListThingRegistrationTaskReportsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingRegistrationTaskReportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListThingRegistrationTaskReportsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingRegistrationTaskReportsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListThingRegistrationTaskReportsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTaskReportsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingRegistrationTaskReportsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTaskReportsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingRegistrationTaskReportsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTaskReportsErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingRegistrationTaskReportsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTaskReportsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListThingRegistrationTaskReportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingRegistrationTaskReportsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListThingRegistrationTaskReportsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListThingRegistrationTaskReportsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingRegistrationTaskReportsErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            ListThingRegistrationTaskReportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListThingRegistrationTasks` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingRegistrationTasksError {
    /// Kind of error that occurred.
    pub kind: ListThingRegistrationTasksErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListThingRegistrationTasks` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingRegistrationTasksErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingRegistrationTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingRegistrationTasksErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingRegistrationTasksErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingRegistrationTasksErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingRegistrationTasksErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListThingRegistrationTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListThingRegistrationTasksError {
    fn code(&self) -> Option<&str> {
        ListThingRegistrationTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingRegistrationTasksError {
    /// Creates a new `ListThingRegistrationTasksError`.
    pub fn new(kind: ListThingRegistrationTasksErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListThingRegistrationTasksError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingRegistrationTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListThingRegistrationTasksError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingRegistrationTasksErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListThingRegistrationTasksErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTasksErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingRegistrationTasksErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTasksErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingRegistrationTasksErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTasksErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingRegistrationTasksErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingRegistrationTasksErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListThingRegistrationTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingRegistrationTasksErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingRegistrationTasksErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingRegistrationTasksErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingRegistrationTasksErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListThingRegistrationTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListThings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingsError {
    /// Kind of error that occurred.
    pub kind: ListThingsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListThings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListThingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListThingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListThingsError {
    fn code(&self) -> Option<&str> {
        ListThingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingsError {
    /// Creates a new `ListThingsError`.
    pub fn new(kind: ListThingsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListThingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListThingsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListThingsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, ListThingsErrorKind::InternalFailureException(_))
    }
    /// Returns `true` if the error kind is `ListThingsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListThingsErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `ListThingsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListThingsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListThingsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListThingsErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListThingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListThingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListThingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListThingsInBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingsInBillingGroupError {
    /// Kind of error that occurred.
    pub kind: ListThingsInBillingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListThingsInBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingsInBillingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingsInBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingsInBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingsInBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingsInBillingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThingsInBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingsInBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListThingsInBillingGroupError {
    fn code(&self) -> Option<&str> {
        ListThingsInBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingsInBillingGroupError {
    /// Creates a new `ListThingsInBillingGroupError`.
    pub fn new(kind: ListThingsInBillingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListThingsInBillingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingsInBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListThingsInBillingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingsInBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListThingsInBillingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingsInBillingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingsInBillingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInBillingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingsInBillingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInBillingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListThingsInBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingsInBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingsInBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingsInBillingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThingsInBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingsInBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListThingsInThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingsInThingGroupError {
    /// Kind of error that occurred.
    pub kind: ListThingsInThingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListThingsInThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingsInThingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingsInThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingsInThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingsInThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingsInThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThingsInThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingsInThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListThingsInThingGroupError {
    fn code(&self) -> Option<&str> {
        ListThingsInThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingsInThingGroupError {
    /// Creates a new `ListThingsInThingGroupError`.
    pub fn new(kind: ListThingsInThingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListThingsInThingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingsInThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListThingsInThingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingsInThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListThingsInThingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInThingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingsInThingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingsInThingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingsInThingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingsInThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListThingsInThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingsInThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingsInThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingsInThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThingsInThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingsInThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListThingTypes` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThingTypesError {
    /// Kind of error that occurred.
    pub kind: ListThingTypesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListThingTypes` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThingTypesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThingTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThingTypesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThingTypesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListThingTypesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListThingTypesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThingTypesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListThingTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListThingTypesError {
    fn code(&self) -> Option<&str> {
        ListThingTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThingTypesError {
    /// Creates a new `ListThingTypesError`.
    pub fn new(kind: ListThingTypesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListThingTypesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThingTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListThingTypesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThingTypesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListThingTypesErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingTypesErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingTypesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingTypesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingTypesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingTypesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListThingTypesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListThingTypesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListThingTypesErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThingTypesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListThingTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThingTypesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThingTypesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListThingTypesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListThingTypesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThingTypesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListThingTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTopicRuleDestinations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTopicRuleDestinationsError {
    /// Kind of error that occurred.
    pub kind: ListTopicRuleDestinationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTopicRuleDestinations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTopicRuleDestinationsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTopicRuleDestinationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTopicRuleDestinationsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListTopicRuleDestinationsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListTopicRuleDestinationsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ListTopicRuleDestinationsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListTopicRuleDestinationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTopicRuleDestinationsError {
    fn code(&self) -> Option<&str> {
        ListTopicRuleDestinationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTopicRuleDestinationsError {
    /// Creates a new `ListTopicRuleDestinationsError`.
    pub fn new(kind: ListTopicRuleDestinationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTopicRuleDestinationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTopicRuleDestinationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTopicRuleDestinationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTopicRuleDestinationsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTopicRuleDestinationsErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRuleDestinationsErrorKind::InternalException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTopicRuleDestinationsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRuleDestinationsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTopicRuleDestinationsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRuleDestinationsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTopicRuleDestinationsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRuleDestinationsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListTopicRuleDestinationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTopicRuleDestinationsErrorKind::InternalException(_inner) => Some(_inner),
            ListTopicRuleDestinationsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTopicRuleDestinationsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListTopicRuleDestinationsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListTopicRuleDestinationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTopicRules` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTopicRulesError {
    /// Kind of error that occurred.
    pub kind: ListTopicRulesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTopicRules` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTopicRulesErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTopicRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTopicRulesErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListTopicRulesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListTopicRulesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListTopicRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTopicRulesError {
    fn code(&self) -> Option<&str> {
        ListTopicRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTopicRulesError {
    /// Creates a new `ListTopicRulesError`.
    pub fn new(kind: ListTopicRulesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTopicRulesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTopicRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTopicRulesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTopicRulesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTopicRulesErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListTopicRulesErrorKind::InternalException(_))
    }
    /// Returns `true` if the error kind is `ListTopicRulesErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRulesErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTopicRulesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTopicRulesErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListTopicRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTopicRulesErrorKind::InternalException(_inner) => Some(_inner),
            ListTopicRulesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTopicRulesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListTopicRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListV2LoggingLevels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListV2LoggingLevelsError {
    /// Kind of error that occurred.
    pub kind: ListV2LoggingLevelsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListV2LoggingLevels` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListV2LoggingLevelsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource is not configured.</p>
    NotConfiguredException(crate::error::NotConfiguredException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListV2LoggingLevelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListV2LoggingLevelsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListV2LoggingLevelsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListV2LoggingLevelsErrorKind::NotConfiguredException(_inner) => _inner.fmt(f),
            ListV2LoggingLevelsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListV2LoggingLevelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListV2LoggingLevelsError {
    fn code(&self) -> Option<&str> {
        ListV2LoggingLevelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListV2LoggingLevelsError {
    /// Creates a new `ListV2LoggingLevelsError`.
    pub fn new(kind: ListV2LoggingLevelsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListV2LoggingLevelsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListV2LoggingLevelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListV2LoggingLevelsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListV2LoggingLevelsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListV2LoggingLevelsErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListV2LoggingLevelsErrorKind::InternalException(_)
        )
    }
    /// Returns `true` if the error kind is `ListV2LoggingLevelsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListV2LoggingLevelsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListV2LoggingLevelsErrorKind::NotConfiguredException`.
    pub fn is_not_configured_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListV2LoggingLevelsErrorKind::NotConfiguredException(_)
        )
    }
    /// Returns `true` if the error kind is `ListV2LoggingLevelsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListV2LoggingLevelsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListV2LoggingLevelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListV2LoggingLevelsErrorKind::InternalException(_inner) => Some(_inner),
            ListV2LoggingLevelsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListV2LoggingLevelsErrorKind::NotConfiguredException(_inner) => Some(_inner),
            ListV2LoggingLevelsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListV2LoggingLevelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListViolationEvents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListViolationEventsError {
    /// Kind of error that occurred.
    pub kind: ListViolationEventsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListViolationEvents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListViolationEventsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListViolationEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListViolationEventsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListViolationEventsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListViolationEventsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListViolationEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListViolationEventsError {
    fn code(&self) -> Option<&str> {
        ListViolationEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListViolationEventsError {
    /// Creates a new `ListViolationEventsError`.
    pub fn new(kind: ListViolationEventsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListViolationEventsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListViolationEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListViolationEventsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListViolationEventsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListViolationEventsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListViolationEventsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListViolationEventsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListViolationEventsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListViolationEventsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListViolationEventsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListViolationEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListViolationEventsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListViolationEventsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListViolationEventsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListViolationEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `PutVerificationStateOnViolation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVerificationStateOnViolationError {
    /// Kind of error that occurred.
    pub kind: PutVerificationStateOnViolationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PutVerificationStateOnViolation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVerificationStateOnViolationErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutVerificationStateOnViolationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVerificationStateOnViolationErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            PutVerificationStateOnViolationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutVerificationStateOnViolationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            PutVerificationStateOnViolationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVerificationStateOnViolationError {
    fn code(&self) -> Option<&str> {
        PutVerificationStateOnViolationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVerificationStateOnViolationError {
    /// Creates a new `PutVerificationStateOnViolationError`.
    pub fn new(
        kind: PutVerificationStateOnViolationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutVerificationStateOnViolationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVerificationStateOnViolationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PutVerificationStateOnViolationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVerificationStateOnViolationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutVerificationStateOnViolationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVerificationStateOnViolationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVerificationStateOnViolationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVerificationStateOnViolationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVerificationStateOnViolationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVerificationStateOnViolationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for PutVerificationStateOnViolationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVerificationStateOnViolationErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            PutVerificationStateOnViolationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            PutVerificationStateOnViolationErrorKind::ThrottlingException(_inner) => Some(_inner),
            PutVerificationStateOnViolationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RegisterCACertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterCACertificateError {
    /// Kind of error that occurred.
    pub kind: RegisterCACertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RegisterCACertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterCACertificateErrorKind {
    /// <p>The certificate is invalid.</p>
    CertificateValidationException(crate::error::CertificateValidationException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The registration code is invalid.</p>
    RegistrationCodeValidationException(crate::error::RegistrationCodeValidationException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterCACertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterCACertificateErrorKind::CertificateValidationException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::RegistrationCodeValidationException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCACertificateErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RegisterCACertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RegisterCACertificateError {
    fn code(&self) -> Option<&str> {
        RegisterCACertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterCACertificateError {
    /// Creates a new `RegisterCACertificateError`.
    pub fn new(kind: RegisterCACertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RegisterCACertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterCACertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RegisterCACertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterCACertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RegisterCACertificateErrorKind::CertificateValidationException`.
    pub fn is_certificate_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::CertificateValidationException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCACertificateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCACertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCACertificateErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCACertificateErrorKind::RegistrationCodeValidationException`.
    pub fn is_registration_code_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::RegistrationCodeValidationException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCACertificateErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCACertificateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCACertificateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCACertificateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCACertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for RegisterCACertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterCACertificateErrorKind::CertificateValidationException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::RegistrationCodeValidationException(_inner) => {
                Some(_inner)
            }
            RegisterCACertificateErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RegisterCACertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RegisterCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterCertificateError {
    /// Kind of error that occurred.
    pub kind: RegisterCertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RegisterCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterCertificateErrorKind {
    /// <p>Unable to verify the CA certificate used to sign the device certificate you are
    /// attempting to register. This is happens when you have registered more than one CA
    /// certificate that has the same subject field and public key.</p>
    CertificateConflictException(crate::error::CertificateConflictException),
    /// <p>The certificate operation is not allowed.</p>
    CertificateStateException(crate::error::CertificateStateException),
    /// <p>The certificate is invalid.</p>
    CertificateValidationException(crate::error::CertificateValidationException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterCertificateErrorKind::CertificateConflictException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::CertificateStateException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::CertificateValidationException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RegisterCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RegisterCertificateError {
    fn code(&self) -> Option<&str> {
        RegisterCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterCertificateError {
    /// Creates a new `RegisterCertificateError`.
    pub fn new(kind: RegisterCertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RegisterCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RegisterCertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RegisterCertificateErrorKind::CertificateConflictException`.
    pub fn is_certificate_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::CertificateConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateErrorKind::CertificateStateException`.
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::CertificateStateException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateErrorKind::CertificateValidationException`.
    pub fn is_certificate_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::CertificateValidationException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for RegisterCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterCertificateErrorKind::CertificateConflictException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::CertificateStateException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::CertificateValidationException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RegisterCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RegisterCertificateWithoutCA` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterCertificateWithoutCAError {
    /// Kind of error that occurred.
    pub kind: RegisterCertificateWithoutCAErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RegisterCertificateWithoutCA` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterCertificateWithoutCAErrorKind {
    /// <p>The certificate operation is not allowed.</p>
    CertificateStateException(crate::error::CertificateStateException),
    /// <p>The certificate is invalid.</p>
    CertificateValidationException(crate::error::CertificateValidationException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterCertificateWithoutCAError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterCertificateWithoutCAErrorKind::CertificateStateException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCertificateWithoutCAErrorKind::CertificateValidationException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCertificateWithoutCAErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCertificateWithoutCAErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RegisterCertificateWithoutCAErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCertificateWithoutCAErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            RegisterCertificateWithoutCAErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RegisterCertificateWithoutCAErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RegisterCertificateWithoutCAErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RegisterCertificateWithoutCAError {
    fn code(&self) -> Option<&str> {
        RegisterCertificateWithoutCAError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterCertificateWithoutCAError {
    /// Creates a new `RegisterCertificateWithoutCAError`.
    pub fn new(kind: RegisterCertificateWithoutCAErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RegisterCertificateWithoutCAError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterCertificateWithoutCAErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RegisterCertificateWithoutCAError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterCertificateWithoutCAErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RegisterCertificateWithoutCAErrorKind::CertificateStateException`.
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::CertificateStateException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateWithoutCAErrorKind::CertificateValidationException`.
    pub fn is_certificate_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::CertificateValidationException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateWithoutCAErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateWithoutCAErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateWithoutCAErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateWithoutCAErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateWithoutCAErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterCertificateWithoutCAErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterCertificateWithoutCAErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for RegisterCertificateWithoutCAError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterCertificateWithoutCAErrorKind::CertificateStateException(_inner) => {
                Some(_inner)
            }
            RegisterCertificateWithoutCAErrorKind::CertificateValidationException(_inner) => {
                Some(_inner)
            }
            RegisterCertificateWithoutCAErrorKind::InternalFailureException(_inner) => Some(_inner),
            RegisterCertificateWithoutCAErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RegisterCertificateWithoutCAErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            RegisterCertificateWithoutCAErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            RegisterCertificateWithoutCAErrorKind::ThrottlingException(_inner) => Some(_inner),
            RegisterCertificateWithoutCAErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RegisterCertificateWithoutCAErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RegisterThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterThingError {
    /// Kind of error that occurred.
    pub kind: RegisterThingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RegisterThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterThingErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource registration failed.</p>
    ResourceRegistrationFailureException(crate::error::ResourceRegistrationFailureException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterThingErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::ResourceRegistrationFailureException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RegisterThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RegisterThingError {
    fn code(&self) -> Option<&str> {
        RegisterThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterThingError {
    /// Creates a new `RegisterThingError`.
    pub fn new(kind: RegisterThingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RegisterThingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RegisterThingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterThingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RegisterThingErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterThingErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterThingErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterThingErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterThingErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterThingErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterThingErrorKind::ResourceRegistrationFailureException`.
    pub fn is_resource_registration_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterThingErrorKind::ResourceRegistrationFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterThingErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterThingErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `RegisterThingErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, RegisterThingErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `RegisterThingErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, RegisterThingErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for RegisterThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterThingErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            RegisterThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            RegisterThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RegisterThingErrorKind::ResourceRegistrationFailureException(_inner) => Some(_inner),
            RegisterThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RegisterThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            RegisterThingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RegisterThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RejectCertificateTransfer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RejectCertificateTransferError {
    /// Kind of error that occurred.
    pub kind: RejectCertificateTransferErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RejectCertificateTransfer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectCertificateTransferErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You can't revert the certificate transfer because the transfer is already
    /// complete.</p>
    TransferAlreadyCompletedException(crate::error::TransferAlreadyCompletedException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RejectCertificateTransferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RejectCertificateTransferErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RejectCertificateTransferErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RejectCertificateTransferErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RejectCertificateTransferErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            RejectCertificateTransferErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RejectCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                _inner.fmt(f)
            }
            RejectCertificateTransferErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RejectCertificateTransferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RejectCertificateTransferError {
    fn code(&self) -> Option<&str> {
        RejectCertificateTransferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RejectCertificateTransferError {
    /// Creates a new `RejectCertificateTransferError`.
    pub fn new(kind: RejectCertificateTransferErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RejectCertificateTransferError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RejectCertificateTransferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RejectCertificateTransferError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RejectCertificateTransferErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RejectCertificateTransferErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `RejectCertificateTransferErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `RejectCertificateTransferErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `RejectCertificateTransferErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `RejectCertificateTransferErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `RejectCertificateTransferErrorKind::TransferAlreadyCompletedException`.
    pub fn is_transfer_already_completed_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::TransferAlreadyCompletedException(_)
        )
    }
    /// Returns `true` if the error kind is `RejectCertificateTransferErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectCertificateTransferErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for RejectCertificateTransferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RejectCertificateTransferErrorKind::InternalFailureException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::ThrottlingException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::TransferAlreadyCompletedException(_inner) => {
                Some(_inner)
            }
            RejectCertificateTransferErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RejectCertificateTransferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RemoveThingFromBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveThingFromBillingGroupError {
    /// Kind of error that occurred.
    pub kind: RemoveThingFromBillingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RemoveThingFromBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveThingFromBillingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveThingFromBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveThingFromBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RemoveThingFromBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RemoveThingFromBillingGroupErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            RemoveThingFromBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RemoveThingFromBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveThingFromBillingGroupError {
    fn code(&self) -> Option<&str> {
        RemoveThingFromBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveThingFromBillingGroupError {
    /// Creates a new `RemoveThingFromBillingGroupError`.
    pub fn new(kind: RemoveThingFromBillingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RemoveThingFromBillingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveThingFromBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RemoveThingFromBillingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveThingFromBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RemoveThingFromBillingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `RemoveThingFromBillingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `RemoveThingFromBillingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromBillingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `RemoveThingFromBillingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromBillingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for RemoveThingFromBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveThingFromBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            RemoveThingFromBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RemoveThingFromBillingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RemoveThingFromBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            RemoveThingFromBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RemoveThingFromThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveThingFromThingGroupError {
    /// Kind of error that occurred.
    pub kind: RemoveThingFromThingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RemoveThingFromThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveThingFromThingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveThingFromThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveThingFromThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RemoveThingFromThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RemoveThingFromThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RemoveThingFromThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RemoveThingFromThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveThingFromThingGroupError {
    fn code(&self) -> Option<&str> {
        RemoveThingFromThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveThingFromThingGroupError {
    /// Creates a new `RemoveThingFromThingGroupError`.
    pub fn new(kind: RemoveThingFromThingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RemoveThingFromThingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveThingFromThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RemoveThingFromThingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveThingFromThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RemoveThingFromThingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromThingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `RemoveThingFromThingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `RemoveThingFromThingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `RemoveThingFromThingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveThingFromThingGroupErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for RemoveThingFromThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveThingFromThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            RemoveThingFromThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RemoveThingFromThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RemoveThingFromThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            RemoveThingFromThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ReplaceTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ReplaceTopicRuleError {
    /// Kind of error that occurred.
    pub kind: ReplaceTopicRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ReplaceTopicRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ReplaceTopicRuleErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The Rule-SQL expression can't be parsed correctly.</p>
    SqlParseException(crate::error::SqlParseException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ReplaceTopicRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ReplaceTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::SqlParseException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ReplaceTopicRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ReplaceTopicRuleError {
    fn code(&self) -> Option<&str> {
        ReplaceTopicRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ReplaceTopicRuleError {
    /// Creates a new `ReplaceTopicRuleError`.
    pub fn new(kind: ReplaceTopicRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ReplaceTopicRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ReplaceTopicRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ReplaceTopicRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ReplaceTopicRuleErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ReplaceTopicRuleErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReplaceTopicRuleErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `ReplaceTopicRuleErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ReplaceTopicRuleErrorKind::InternalException(_))
    }
    /// Returns `true` if the error kind is `ReplaceTopicRuleErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReplaceTopicRuleErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ReplaceTopicRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReplaceTopicRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ReplaceTopicRuleErrorKind::SqlParseException`.
    pub fn is_sql_parse_exception(&self) -> bool {
        matches!(&self.kind, ReplaceTopicRuleErrorKind::SqlParseException(_))
    }
    /// Returns `true` if the error kind is `ReplaceTopicRuleErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReplaceTopicRuleErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ReplaceTopicRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ReplaceTopicRuleErrorKind::ConflictingResourceUpdateException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::InternalException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::SqlParseException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ReplaceTopicRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `SearchIndex` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchIndexError {
    /// Kind of error that occurred.
    pub kind: SearchIndexErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SearchIndex` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchIndexErrorKind {
    /// <p>The index is not ready.</p>
    IndexNotReadyException(crate::error::IndexNotReadyException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The query is invalid.</p>
    InvalidQueryException(crate::error::InvalidQueryException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchIndexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchIndexErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            SearchIndexErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SearchIndexError {
    fn code(&self) -> Option<&str> {
        SearchIndexError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchIndexError {
    /// Creates a new `SearchIndexError`.
    pub fn new(kind: SearchIndexErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `SearchIndexError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchIndexErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `SearchIndexError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchIndexErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `SearchIndexErrorKind::IndexNotReadyException`.
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(&self.kind, SearchIndexErrorKind::IndexNotReadyException(_))
    }
    /// Returns `true` if the error kind is `SearchIndexErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchIndexErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchIndexErrorKind::InvalidQueryException`.
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(&self.kind, SearchIndexErrorKind::InvalidQueryException(_))
    }
    /// Returns `true` if the error kind is `SearchIndexErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, SearchIndexErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `SearchIndexErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchIndexErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchIndexErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchIndexErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchIndexErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, SearchIndexErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `SearchIndexErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, SearchIndexErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for SearchIndexError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchIndexErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            SearchIndexErrorKind::InternalFailureException(_inner) => Some(_inner),
            SearchIndexErrorKind::InvalidQueryException(_inner) => Some(_inner),
            SearchIndexErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SearchIndexErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SearchIndexErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SearchIndexErrorKind::ThrottlingException(_inner) => Some(_inner),
            SearchIndexErrorKind::UnauthorizedException(_inner) => Some(_inner),
            SearchIndexErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `SetDefaultAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetDefaultAuthorizerError {
    /// Kind of error that occurred.
    pub kind: SetDefaultAuthorizerErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetDefaultAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetDefaultAuthorizerErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetDefaultAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetDefaultAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            SetDefaultAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SetDefaultAuthorizerError {
    fn code(&self) -> Option<&str> {
        SetDefaultAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetDefaultAuthorizerError {
    /// Creates a new `SetDefaultAuthorizerError`.
    pub fn new(kind: SetDefaultAuthorizerErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `SetDefaultAuthorizerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetDefaultAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `SetDefaultAuthorizerError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetDefaultAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `SetDefaultAuthorizerErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `SetDefaultAuthorizerErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `SetDefaultAuthorizerErrorKind::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `SetDefaultAuthorizerErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `SetDefaultAuthorizerErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `SetDefaultAuthorizerErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `SetDefaultAuthorizerErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for SetDefaultAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetDefaultAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            SetDefaultAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `SetDefaultPolicyVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetDefaultPolicyVersionError {
    /// Kind of error that occurred.
    pub kind: SetDefaultPolicyVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetDefaultPolicyVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetDefaultPolicyVersionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetDefaultPolicyVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetDefaultPolicyVersionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            SetDefaultPolicyVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SetDefaultPolicyVersionError {
    fn code(&self) -> Option<&str> {
        SetDefaultPolicyVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetDefaultPolicyVersionError {
    /// Creates a new `SetDefaultPolicyVersionError`.
    pub fn new(kind: SetDefaultPolicyVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `SetDefaultPolicyVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetDefaultPolicyVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `SetDefaultPolicyVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetDefaultPolicyVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `SetDefaultPolicyVersionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `SetDefaultPolicyVersionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `SetDefaultPolicyVersionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `SetDefaultPolicyVersionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `SetDefaultPolicyVersionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `SetDefaultPolicyVersionErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetDefaultPolicyVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for SetDefaultPolicyVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetDefaultPolicyVersionErrorKind::InternalFailureException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            SetDefaultPolicyVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `SetLoggingOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetLoggingOptionsError {
    /// Kind of error that occurred.
    pub kind: SetLoggingOptionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetLoggingOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetLoggingOptionsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetLoggingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetLoggingOptionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            SetLoggingOptionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetLoggingOptionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SetLoggingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SetLoggingOptionsError {
    fn code(&self) -> Option<&str> {
        SetLoggingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetLoggingOptionsError {
    /// Creates a new `SetLoggingOptionsError`.
    pub fn new(kind: SetLoggingOptionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `SetLoggingOptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetLoggingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `SetLoggingOptionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetLoggingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `SetLoggingOptionsErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, SetLoggingOptionsErrorKind::InternalException(_))
    }
    /// Returns `true` if the error kind is `SetLoggingOptionsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetLoggingOptionsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `SetLoggingOptionsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetLoggingOptionsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for SetLoggingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetLoggingOptionsErrorKind::InternalException(_inner) => Some(_inner),
            SetLoggingOptionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetLoggingOptionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SetLoggingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `SetV2LoggingLevel` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetV2LoggingLevelError {
    /// Kind of error that occurred.
    pub kind: SetV2LoggingLevelErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetV2LoggingLevel` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetV2LoggingLevelErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The resource is not configured.</p>
    NotConfiguredException(crate::error::NotConfiguredException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetV2LoggingLevelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetV2LoggingLevelErrorKind::InternalException(_inner) => _inner.fmt(f),
            SetV2LoggingLevelErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetV2LoggingLevelErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            SetV2LoggingLevelErrorKind::NotConfiguredException(_inner) => _inner.fmt(f),
            SetV2LoggingLevelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SetV2LoggingLevelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SetV2LoggingLevelError {
    fn code(&self) -> Option<&str> {
        SetV2LoggingLevelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetV2LoggingLevelError {
    /// Creates a new `SetV2LoggingLevelError`.
    pub fn new(kind: SetV2LoggingLevelErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `SetV2LoggingLevelError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetV2LoggingLevelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `SetV2LoggingLevelError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetV2LoggingLevelErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `SetV2LoggingLevelErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, SetV2LoggingLevelErrorKind::InternalException(_))
    }
    /// Returns `true` if the error kind is `SetV2LoggingLevelErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingLevelErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `SetV2LoggingLevelErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingLevelErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `SetV2LoggingLevelErrorKind::NotConfiguredException`.
    pub fn is_not_configured_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingLevelErrorKind::NotConfiguredException(_)
        )
    }
    /// Returns `true` if the error kind is `SetV2LoggingLevelErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingLevelErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for SetV2LoggingLevelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetV2LoggingLevelErrorKind::InternalException(_inner) => Some(_inner),
            SetV2LoggingLevelErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetV2LoggingLevelErrorKind::LimitExceededException(_inner) => Some(_inner),
            SetV2LoggingLevelErrorKind::NotConfiguredException(_inner) => Some(_inner),
            SetV2LoggingLevelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SetV2LoggingLevelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `SetV2LoggingOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetV2LoggingOptionsError {
    /// Kind of error that occurred.
    pub kind: SetV2LoggingOptionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetV2LoggingOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetV2LoggingOptionsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetV2LoggingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetV2LoggingOptionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            SetV2LoggingOptionsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SetV2LoggingOptionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SetV2LoggingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SetV2LoggingOptionsError {
    fn code(&self) -> Option<&str> {
        SetV2LoggingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetV2LoggingOptionsError {
    /// Creates a new `SetV2LoggingOptionsError`.
    pub fn new(kind: SetV2LoggingOptionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `SetV2LoggingOptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetV2LoggingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `SetV2LoggingOptionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetV2LoggingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `SetV2LoggingOptionsErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingOptionsErrorKind::InternalException(_)
        )
    }
    /// Returns `true` if the error kind is `SetV2LoggingOptionsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingOptionsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `SetV2LoggingOptionsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetV2LoggingOptionsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for SetV2LoggingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetV2LoggingOptionsErrorKind::InternalException(_inner) => Some(_inner),
            SetV2LoggingOptionsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SetV2LoggingOptionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SetV2LoggingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartAuditMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartAuditMitigationActionsTaskError {
    /// Kind of error that occurred.
    pub kind: StartAuditMitigationActionsTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartAuditMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartAuditMitigationActionsTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>
    /// This exception occurs if you attempt to start a task with the same task-id as an existing task but with a different clientRequestToken.
    /// </p>
    TaskAlreadyExistsException(crate::error::TaskAlreadyExistsException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartAuditMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            StartAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            StartAuditMitigationActionsTaskErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartAuditMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            StartAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartAuditMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        StartAuditMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartAuditMitigationActionsTaskError {
    /// Creates a new `StartAuditMitigationActionsTaskError`.
    pub fn new(
        kind: StartAuditMitigationActionsTaskErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartAuditMitigationActionsTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartAuditMitigationActionsTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartAuditMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartAuditMitigationActionsTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAuditMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `StartAuditMitigationActionsTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAuditMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `StartAuditMitigationActionsTaskErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAuditMitigationActionsTaskErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartAuditMitigationActionsTaskErrorKind::TaskAlreadyExistsException`.
    pub fn is_task_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAuditMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `StartAuditMitigationActionsTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAuditMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartAuditMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartAuditMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            StartAuditMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            StartAuditMitigationActionsTaskErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            StartAuditMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            StartAuditMitigationActionsTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartAuditMitigationActionsTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartDetectMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartDetectMitigationActionsTaskError {
    /// Kind of error that occurred.
    pub kind: StartDetectMitigationActionsTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartDetectMitigationActionsTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartDetectMitigationActionsTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>
    /// This exception occurs if you attempt to start a task with the same task-id as an existing task but with a different clientRequestToken.
    /// </p>
    TaskAlreadyExistsException(crate::error::TaskAlreadyExistsException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartDetectMitigationActionsTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            StartDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            StartDetectMitigationActionsTaskErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartDetectMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            StartDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartDetectMitigationActionsTaskError {
    fn code(&self) -> Option<&str> {
        StartDetectMitigationActionsTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartDetectMitigationActionsTaskError {
    /// Creates a new `StartDetectMitigationActionsTaskError`.
    pub fn new(
        kind: StartDetectMitigationActionsTaskErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartDetectMitigationActionsTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartDetectMitigationActionsTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartDetectMitigationActionsTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartDetectMitigationActionsTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDetectMitigationActionsTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `StartDetectMitigationActionsTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDetectMitigationActionsTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `StartDetectMitigationActionsTaskErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDetectMitigationActionsTaskErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartDetectMitigationActionsTaskErrorKind::TaskAlreadyExistsException`.
    pub fn is_task_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDetectMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `StartDetectMitigationActionsTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartDetectMitigationActionsTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartDetectMitigationActionsTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartDetectMitigationActionsTaskErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            StartDetectMitigationActionsTaskErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            StartDetectMitigationActionsTaskErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            StartDetectMitigationActionsTaskErrorKind::TaskAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            StartDetectMitigationActionsTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartDetectMitigationActionsTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartOnDemandAuditTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartOnDemandAuditTaskError {
    /// Kind of error that occurred.
    pub kind: StartOnDemandAuditTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartOnDemandAuditTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartOnDemandAuditTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartOnDemandAuditTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartOnDemandAuditTaskErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StartOnDemandAuditTaskErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StartOnDemandAuditTaskErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartOnDemandAuditTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartOnDemandAuditTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartOnDemandAuditTaskError {
    fn code(&self) -> Option<&str> {
        StartOnDemandAuditTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartOnDemandAuditTaskError {
    /// Creates a new `StartOnDemandAuditTaskError`.
    pub fn new(kind: StartOnDemandAuditTaskErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartOnDemandAuditTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartOnDemandAuditTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartOnDemandAuditTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartOnDemandAuditTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartOnDemandAuditTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOnDemandAuditTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `StartOnDemandAuditTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOnDemandAuditTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `StartOnDemandAuditTaskErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOnDemandAuditTaskErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `StartOnDemandAuditTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartOnDemandAuditTaskErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for StartOnDemandAuditTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartOnDemandAuditTaskErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartOnDemandAuditTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StartOnDemandAuditTaskErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartOnDemandAuditTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartOnDemandAuditTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartThingRegistrationTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartThingRegistrationTaskError {
    /// Kind of error that occurred.
    pub kind: StartThingRegistrationTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartThingRegistrationTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartThingRegistrationTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartThingRegistrationTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartThingRegistrationTaskErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StartThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StartThingRegistrationTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StartThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            StartThingRegistrationTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartThingRegistrationTaskError {
    fn code(&self) -> Option<&str> {
        StartThingRegistrationTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartThingRegistrationTaskError {
    /// Creates a new `StartThingRegistrationTaskError`.
    pub fn new(kind: StartThingRegistrationTaskErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartThingRegistrationTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartThingRegistrationTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartThingRegistrationTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartThingRegistrationTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StartThingRegistrationTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartThingRegistrationTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `StartThingRegistrationTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartThingRegistrationTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `StartThingRegistrationTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartThingRegistrationTaskErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StartThingRegistrationTaskErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartThingRegistrationTaskErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for StartThingRegistrationTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartThingRegistrationTaskErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StartThingRegistrationTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            StartThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => Some(_inner),
            StartThingRegistrationTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StopThingRegistrationTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopThingRegistrationTaskError {
    /// Kind of error that occurred.
    pub kind: StopThingRegistrationTaskErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StopThingRegistrationTask` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopThingRegistrationTaskErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopThingRegistrationTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopThingRegistrationTaskErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StopThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            StopThingRegistrationTaskErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopThingRegistrationTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            StopThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            StopThingRegistrationTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StopThingRegistrationTaskError {
    fn code(&self) -> Option<&str> {
        StopThingRegistrationTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopThingRegistrationTaskError {
    /// Creates a new `StopThingRegistrationTaskError`.
    pub fn new(kind: StopThingRegistrationTaskErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StopThingRegistrationTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopThingRegistrationTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StopThingRegistrationTaskError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopThingRegistrationTaskErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `StopThingRegistrationTaskErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopThingRegistrationTaskErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `StopThingRegistrationTaskErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopThingRegistrationTaskErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `StopThingRegistrationTaskErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopThingRegistrationTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `StopThingRegistrationTaskErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopThingRegistrationTaskErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `StopThingRegistrationTaskErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopThingRegistrationTaskErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for StopThingRegistrationTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopThingRegistrationTaskErrorKind::InternalFailureException(_inner) => Some(_inner),
            StopThingRegistrationTaskErrorKind::InvalidRequestException(_inner) => Some(_inner),
            StopThingRegistrationTaskErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopThingRegistrationTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            StopThingRegistrationTaskErrorKind::UnauthorizedException(_inner) => Some(_inner),
            StopThingRegistrationTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    /// Kind of error that occurred.
    pub kind: TagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates a new `TagResourceError`.
    pub fn new(kind: TagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `TestAuthorization` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestAuthorizationError {
    /// Kind of error that occurred.
    pub kind: TestAuthorizationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TestAuthorization` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestAuthorizationErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestAuthorizationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestAuthorizationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            TestAuthorizationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TestAuthorizationError {
    fn code(&self) -> Option<&str> {
        TestAuthorizationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestAuthorizationError {
    /// Creates a new `TestAuthorizationError`.
    pub fn new(kind: TestAuthorizationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `TestAuthorizationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestAuthorizationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `TestAuthorizationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestAuthorizationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `TestAuthorizationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `TestAuthorizationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `TestAuthorizationErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `TestAuthorizationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `TestAuthorizationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `TestAuthorizationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `TestAuthorizationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestAuthorizationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for TestAuthorizationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestAuthorizationErrorKind::InternalFailureException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::LimitExceededException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::ThrottlingException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            TestAuthorizationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `TestInvokeAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestInvokeAuthorizerError {
    /// Kind of error that occurred.
    pub kind: TestInvokeAuthorizerErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TestInvokeAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestInvokeAuthorizerErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The response is invalid.</p>
    InvalidResponseException(crate::error::InvalidResponseException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestInvokeAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestInvokeAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::InvalidResponseException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TestInvokeAuthorizerError {
    fn code(&self) -> Option<&str> {
        TestInvokeAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestInvokeAuthorizerError {
    /// Creates a new `TestInvokeAuthorizerError`.
    pub fn new(kind: TestInvokeAuthorizerErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `TestInvokeAuthorizerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestInvokeAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `TestInvokeAuthorizerError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestInvokeAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `TestInvokeAuthorizerErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `TestInvokeAuthorizerErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `TestInvokeAuthorizerErrorKind::InvalidResponseException`.
    pub fn is_invalid_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::InvalidResponseException(_)
        )
    }
    /// Returns `true` if the error kind is `TestInvokeAuthorizerErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `TestInvokeAuthorizerErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `TestInvokeAuthorizerErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `TestInvokeAuthorizerErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for TestInvokeAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestInvokeAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::InvalidResponseException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `TransferCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TransferCertificateError {
    /// Kind of error that occurred.
    pub kind: TransferCertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TransferCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TransferCertificateErrorKind {
    /// <p>The certificate operation is not allowed.</p>
    CertificateStateException(crate::error::CertificateStateException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You can't transfer the certificate because authorization policies are still
    /// attached.</p>
    TransferConflictException(crate::error::TransferConflictException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TransferCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TransferCertificateErrorKind::CertificateStateException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::TransferConflictException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            TransferCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TransferCertificateError {
    fn code(&self) -> Option<&str> {
        TransferCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TransferCertificateError {
    /// Creates a new `TransferCertificateError`.
    pub fn new(kind: TransferCertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `TransferCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TransferCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `TransferCertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TransferCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `TransferCertificateErrorKind::CertificateStateException`.
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::CertificateStateException(_)
        )
    }
    /// Returns `true` if the error kind is `TransferCertificateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `TransferCertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `TransferCertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `TransferCertificateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `TransferCertificateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `TransferCertificateErrorKind::TransferConflictException`.
    pub fn is_transfer_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::TransferConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `TransferCertificateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            TransferCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for TransferCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TransferCertificateErrorKind::CertificateStateException(_inner) => Some(_inner),
            TransferCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            TransferCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            TransferCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TransferCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TransferCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            TransferCertificateErrorKind::TransferConflictException(_inner) => Some(_inner),
            TransferCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            TransferCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    /// Kind of error that occurred.
    pub kind: UntagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates a new `UntagResourceError`.
    pub fn new(kind: UntagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateAccountAuditConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccountAuditConfigurationError {
    /// Kind of error that occurred.
    pub kind: UpdateAccountAuditConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateAccountAuditConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccountAuditConfigurationErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccountAuditConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAccountAuditConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAccountAuditConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateAccountAuditConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateAccountAuditConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAccountAuditConfigurationError {
    /// Creates a new `UpdateAccountAuditConfigurationError`.
    pub fn new(
        kind: UpdateAccountAuditConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateAccountAuditConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccountAuditConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateAccountAuditConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccountAuditConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateAccountAuditConfigurationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountAuditConfigurationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateAccountAuditConfigurationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountAuditConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateAccountAuditConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountAuditConfigurationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateAccountAuditConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccountAuditConfigurationErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            UpdateAccountAuditConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            UpdateAccountAuditConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAccountAuditConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateAuditSuppression` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAuditSuppressionError {
    /// Kind of error that occurred.
    pub kind: UpdateAuditSuppressionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateAuditSuppression` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAuditSuppressionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAuditSuppressionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAuditSuppressionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateAuditSuppressionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateAuditSuppressionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAuditSuppressionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAuditSuppressionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateAuditSuppressionError {
    fn code(&self) -> Option<&str> {
        UpdateAuditSuppressionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAuditSuppressionError {
    /// Creates a new `UpdateAuditSuppressionError`.
    pub fn new(kind: UpdateAuditSuppressionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateAuditSuppressionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAuditSuppressionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateAuditSuppressionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAuditSuppressionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateAuditSuppressionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditSuppressionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateAuditSuppressionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditSuppressionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateAuditSuppressionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditSuppressionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateAuditSuppressionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditSuppressionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateAuditSuppressionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAuditSuppressionErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateAuditSuppressionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateAuditSuppressionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAuditSuppressionErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAuditSuppressionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAuthorizerError {
    /// Kind of error that occurred.
    pub kind: UpdateAuthorizerErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateAuthorizer` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAuthorizerErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>A limit has been exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAuthorizerErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateAuthorizerError {
    fn code(&self) -> Option<&str> {
        UpdateAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAuthorizerError {
    /// Creates a new `UpdateAuthorizerError`.
    pub fn new(kind: UpdateAuthorizerErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateAuthorizerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateAuthorizerError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateAuthorizerErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateAuthorizerErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateAuthorizerErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::LimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateAuthorizerErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateAuthorizerErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateAuthorizerErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateAuthorizerErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAuthorizerErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBillingGroupError {
    /// Kind of error that occurred.
    pub kind: UpdateBillingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateBillingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBillingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBillingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBillingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateBillingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateBillingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateBillingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateBillingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateBillingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateBillingGroupError {
    fn code(&self) -> Option<&str> {
        UpdateBillingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBillingGroupError {
    /// Creates a new `UpdateBillingGroupError`.
    pub fn new(kind: UpdateBillingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateBillingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBillingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateBillingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBillingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateBillingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBillingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBillingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBillingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBillingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBillingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBillingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBillingGroupErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBillingGroupErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBillingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateBillingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBillingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateBillingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateBillingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateBillingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateBillingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateBillingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateCACertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCACertificateError {
    /// Kind of error that occurred.
    pub kind: UpdateCACertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateCACertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCACertificateErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCACertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCACertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateCACertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateCACertificateError {
    fn code(&self) -> Option<&str> {
        UpdateCACertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCACertificateError {
    /// Creates a new `UpdateCACertificateError`.
    pub fn new(kind: UpdateCACertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateCACertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCACertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateCACertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCACertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateCACertificateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCACertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCACertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCACertificateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCACertificateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCACertificateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCACertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateCACertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCACertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateCACertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCertificateError {
    /// Kind of error that occurred.
    pub kind: UpdateCertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCertificateErrorKind {
    /// <p>The certificate operation is not allowed.</p>
    CertificateStateException(crate::error::CertificateStateException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCertificateErrorKind::CertificateStateException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateCertificateError {
    fn code(&self) -> Option<&str> {
        UpdateCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCertificateError {
    /// Creates a new `UpdateCertificateError`.
    pub fn new(kind: UpdateCertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateCertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateCertificateErrorKind::CertificateStateException`.
    pub fn is_certificate_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::CertificateStateException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCertificateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCertificateErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCertificateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCertificateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCertificateErrorKind::CertificateStateException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateCustomMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCustomMetricError {
    /// Kind of error that occurred.
    pub kind: UpdateCustomMetricErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateCustomMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCustomMetricErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCustomMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCustomMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateCustomMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateCustomMetricErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateCustomMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateCustomMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateCustomMetricError {
    fn code(&self) -> Option<&str> {
        UpdateCustomMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCustomMetricError {
    /// Creates a new `UpdateCustomMetricError`.
    pub fn new(kind: UpdateCustomMetricErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateCustomMetricError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCustomMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateCustomMetricError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCustomMetricErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateCustomMetricErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomMetricErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCustomMetricErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomMetricErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCustomMetricErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomMetricErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCustomMetricErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomMetricErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateCustomMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCustomMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateCustomMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateCustomMetricErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateCustomMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateCustomMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateDimension` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDimensionError {
    /// Kind of error that occurred.
    pub kind: UpdateDimensionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateDimension` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDimensionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDimensionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDimensionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDimensionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateDimensionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDimensionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDimensionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDimensionError {
    fn code(&self) -> Option<&str> {
        UpdateDimensionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDimensionError {
    /// Creates a new `UpdateDimensionError`.
    pub fn new(kind: UpdateDimensionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateDimensionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDimensionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateDimensionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDimensionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateDimensionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDimensionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDimensionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDimensionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDimensionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDimensionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDimensionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateDimensionErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UpdateDimensionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDimensionErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDimensionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateDimensionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDimensionErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDimensionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateDomainConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDomainConfigurationError {
    /// Kind of error that occurred.
    pub kind: UpdateDomainConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateDomainConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDomainConfigurationErrorKind {
    /// <p>The certificate is invalid.</p>
    CertificateValidationException(crate::error::CertificateValidationException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDomainConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDomainConfigurationErrorKind::CertificateValidationException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDomainConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDomainConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDomainConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDomainConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateDomainConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDomainConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateDomainConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDomainConfigurationError {
    /// Creates a new `UpdateDomainConfigurationError`.
    pub fn new(kind: UpdateDomainConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateDomainConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDomainConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateDomainConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDomainConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateDomainConfigurationErrorKind::CertificateValidationException`.
    pub fn is_certificate_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::CertificateValidationException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDomainConfigurationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDomainConfigurationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDomainConfigurationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDomainConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDomainConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDomainConfigurationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateDomainConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDomainConfigurationErrorKind::CertificateValidationException(_inner) => {
                Some(_inner)
            }
            UpdateDomainConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateDomainConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateDynamicThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDynamicThingGroupError {
    /// Kind of error that occurred.
    pub kind: UpdateDynamicThingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateDynamicThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDynamicThingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The query is invalid.</p>
    InvalidQueryException(crate::error::InvalidQueryException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDynamicThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDynamicThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateDynamicThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDynamicThingGroupError {
    fn code(&self) -> Option<&str> {
        UpdateDynamicThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDynamicThingGroupError {
    /// Creates a new `UpdateDynamicThingGroupError`.
    pub fn new(kind: UpdateDynamicThingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateDynamicThingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDynamicThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateDynamicThingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDynamicThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateDynamicThingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDynamicThingGroupErrorKind::InvalidQueryException`.
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::InvalidQueryException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDynamicThingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDynamicThingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDynamicThingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDynamicThingGroupErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDynamicThingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateDynamicThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDynamicThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::InvalidQueryException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateDynamicThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateEventConfigurations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEventConfigurationsError {
    /// Kind of error that occurred.
    pub kind: UpdateEventConfigurationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateEventConfigurations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEventConfigurationsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEventConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEventConfigurationsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateEventConfigurationsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateEventConfigurationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateEventConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateEventConfigurationsError {
    fn code(&self) -> Option<&str> {
        UpdateEventConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateEventConfigurationsError {
    /// Creates a new `UpdateEventConfigurationsError`.
    pub fn new(kind: UpdateEventConfigurationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateEventConfigurationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEventConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateEventConfigurationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEventConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateEventConfigurationsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventConfigurationsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateEventConfigurationsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventConfigurationsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateEventConfigurationsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEventConfigurationsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateEventConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEventConfigurationsErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateEventConfigurationsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateEventConfigurationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateEventConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateFleetMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFleetMetricError {
    /// Kind of error that occurred.
    pub kind: UpdateFleetMetricErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateFleetMetric` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFleetMetricErrorKind {
    /// <p>The index is not ready.</p>
    IndexNotReadyException(crate::error::IndexNotReadyException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The aggregation is invalid.</p>
    InvalidAggregationException(crate::error::InvalidAggregationException),
    /// <p>The query is invalid.</p>
    InvalidQueryException(crate::error::InvalidQueryException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFleetMetricError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFleetMetricErrorKind::IndexNotReadyException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::InvalidAggregationException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::InvalidQueryException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateFleetMetricErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateFleetMetricError {
    fn code(&self) -> Option<&str> {
        UpdateFleetMetricError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFleetMetricError {
    /// Creates a new `UpdateFleetMetricError`.
    pub fn new(kind: UpdateFleetMetricErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateFleetMetricError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFleetMetricErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateFleetMetricError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFleetMetricErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateFleetMetricErrorKind::IndexNotReadyException`.
    pub fn is_index_not_ready_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::IndexNotReadyException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateFleetMetricErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateFleetMetricErrorKind::InvalidAggregationException`.
    pub fn is_invalid_aggregation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::InvalidAggregationException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateFleetMetricErrorKind::InvalidQueryException`.
    pub fn is_invalid_query_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::InvalidQueryException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateFleetMetricErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateFleetMetricErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateFleetMetricErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateFleetMetricErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateFleetMetricErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::UnauthorizedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateFleetMetricErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetricErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateFleetMetricError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFleetMetricErrorKind::IndexNotReadyException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::InvalidAggregationException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::InvalidQueryException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateFleetMetricErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateIndexingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIndexingConfigurationError {
    /// Kind of error that occurred.
    pub kind: UpdateIndexingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateIndexingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIndexingConfigurationErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIndexingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIndexingConfigurationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateIndexingConfigurationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateIndexingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateIndexingConfigurationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateIndexingConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateIndexingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateIndexingConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateIndexingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIndexingConfigurationError {
    /// Creates a new `UpdateIndexingConfigurationError`.
    pub fn new(kind: UpdateIndexingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateIndexingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIndexingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateIndexingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIndexingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateIndexingConfigurationErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexingConfigurationErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateIndexingConfigurationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexingConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateIndexingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateIndexingConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexingConfigurationErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateIndexingConfigurationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIndexingConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateIndexingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIndexingConfigurationErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateIndexingConfigurationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateIndexingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateIndexingConfigurationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateIndexingConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateIndexingConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateJobError {
    /// Kind of error that occurred.
    pub kind: UpdateJobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateJob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateJobErrorKind {
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateJobErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateJobError {
    fn code(&self) -> Option<&str> {
        UpdateJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateJobError {
    /// Creates a new `UpdateJobError`.
    pub fn new(kind: UpdateJobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateJobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateJobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateJobErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateJobErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdateJobErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateJobErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJobErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateJobErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateJobErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UpdateJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateJobErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateJobErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateJobErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateMitigationAction` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMitigationActionError {
    /// Kind of error that occurred.
    pub kind: UpdateMitigationActionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateMitigationAction` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMitigationActionErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMitigationActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMitigationActionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateMitigationActionErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateMitigationActionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateMitigationActionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateMitigationActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateMitigationActionError {
    fn code(&self) -> Option<&str> {
        UpdateMitigationActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMitigationActionError {
    /// Creates a new `UpdateMitigationActionError`.
    pub fn new(kind: UpdateMitigationActionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateMitigationActionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMitigationActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateMitigationActionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMitigationActionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateMitigationActionErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMitigationActionErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateMitigationActionErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMitigationActionErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateMitigationActionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMitigationActionErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateMitigationActionErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMitigationActionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateMitigationActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMitigationActionErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateMitigationActionErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateMitigationActionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateMitigationActionErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateMitigationActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateProvisioningTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateProvisioningTemplateError {
    /// Kind of error that occurred.
    pub kind: UpdateProvisioningTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateProvisioningTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateProvisioningTemplateErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateProvisioningTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            UpdateProvisioningTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateProvisioningTemplateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateProvisioningTemplateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateProvisioningTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateProvisioningTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateProvisioningTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateProvisioningTemplateError {
    /// Creates a new `UpdateProvisioningTemplateError`.
    pub fn new(kind: UpdateProvisioningTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateProvisioningTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateProvisioningTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateProvisioningTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateProvisioningTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateProvisioningTemplateErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateProvisioningTemplateErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProvisioningTemplateErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateProvisioningTemplateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProvisioningTemplateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateProvisioningTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProvisioningTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateProvisioningTemplateErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProvisioningTemplateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateProvisioningTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateProvisioningTemplateErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            UpdateProvisioningTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateProvisioningTemplateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateProvisioningTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateProvisioningTemplateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateProvisioningTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateRoleAlias` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoleAliasError {
    /// Kind of error that occurred.
    pub kind: UpdateRoleAliasErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateRoleAlias` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoleAliasErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoleAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoleAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateRoleAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRoleAliasError {
    fn code(&self) -> Option<&str> {
        UpdateRoleAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoleAliasError {
    /// Creates a new `UpdateRoleAliasError`.
    pub fn new(kind: UpdateRoleAliasErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateRoleAliasError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoleAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateRoleAliasError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoleAliasErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateRoleAliasErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleAliasErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRoleAliasErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleAliasErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRoleAliasErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRoleAliasErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleAliasErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRoleAliasErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateRoleAliasErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateRoleAliasErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoleAliasErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateRoleAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoleAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateRoleAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateScheduledAudit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateScheduledAuditError {
    /// Kind of error that occurred.
    pub kind: UpdateScheduledAuditErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateScheduledAudit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateScheduledAuditErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateScheduledAuditError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateScheduledAuditErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateScheduledAuditErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateScheduledAuditErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateScheduledAuditErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateScheduledAuditErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateScheduledAuditError {
    fn code(&self) -> Option<&str> {
        UpdateScheduledAuditError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateScheduledAuditError {
    /// Creates a new `UpdateScheduledAuditError`.
    pub fn new(kind: UpdateScheduledAuditErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateScheduledAuditError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateScheduledAuditErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateScheduledAuditError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateScheduledAuditErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateScheduledAuditErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateScheduledAuditErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateScheduledAuditErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateScheduledAuditErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateScheduledAuditErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateScheduledAuditErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateScheduledAuditErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateScheduledAuditErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateScheduledAuditError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateScheduledAuditErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateScheduledAuditErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateScheduledAuditErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateScheduledAuditErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateScheduledAuditErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSecurityProfileError {
    /// Kind of error that occurred.
    pub kind: UpdateSecurityProfileErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateSecurityProfile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSecurityProfileErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSecurityProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSecurityProfileErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateSecurityProfileErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateSecurityProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateSecurityProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateSecurityProfileErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateSecurityProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSecurityProfileError {
    fn code(&self) -> Option<&str> {
        UpdateSecurityProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSecurityProfileError {
    /// Creates a new `UpdateSecurityProfileError`.
    pub fn new(kind: UpdateSecurityProfileErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateSecurityProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSecurityProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateSecurityProfileError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSecurityProfileErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateSecurityProfileErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityProfileErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSecurityProfileErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityProfileErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSecurityProfileErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSecurityProfileErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityProfileErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSecurityProfileErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityProfileErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateSecurityProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSecurityProfileErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateSecurityProfileErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateSecurityProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateSecurityProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateSecurityProfileErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateSecurityProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateStream` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateStreamError {
    /// Kind of error that occurred.
    pub kind: UpdateStreamErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateStream` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateStreamErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateStreamErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateStreamError {
    fn code(&self) -> Option<&str> {
        UpdateStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateStreamError {
    /// Creates a new `UpdateStreamError`.
    pub fn new(kind: UpdateStreamErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateStreamError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateStreamError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateStreamErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateStreamErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStreamErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateStreamErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStreamErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateStreamErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStreamErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateStreamErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStreamErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateStreamErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateStreamErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateStreamErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateStreamErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateStreamErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateStreamErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateStreamErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateStreamErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateStreamErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateStreamErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateThingError {
    /// Kind of error that occurred.
    pub kind: UpdateThingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateThingErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateThingError {
    fn code(&self) -> Option<&str> {
        UpdateThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateThingError {
    /// Creates a new `UpdateThingError`.
    pub fn new(kind: UpdateThingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateThingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateThingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateThingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateThingErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateThingErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateThingErrorKind::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdateThingErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateThingErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateThingErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateThingErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateThingErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateThingErrorKind::UnauthorizedException(_))
    }
    /// Returns `true` if the error kind is `UpdateThingErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateThingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateThingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateThingErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateThingGroupError {
    /// Kind of error that occurred.
    pub kind: UpdateThingGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateThingGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateThingGroupErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>An exception thrown when the version of an entity specified with the
    /// <code>expectedVersion</code> parameter does not match the latest version in the
    /// system.</p>
    VersionConflictException(crate::error::VersionConflictException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateThingGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateThingGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateThingGroupErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateThingGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateThingGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateThingGroupErrorKind::VersionConflictException(_inner) => _inner.fmt(f),
            UpdateThingGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateThingGroupError {
    fn code(&self) -> Option<&str> {
        UpdateThingGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateThingGroupError {
    /// Creates a new `UpdateThingGroupError`.
    pub fn new(kind: UpdateThingGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateThingGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateThingGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateThingGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateThingGroupErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateThingGroupErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateThingGroupErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateThingGroupErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateThingGroupErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupErrorKind::ThrottlingException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateThingGroupErrorKind::VersionConflictException`.
    pub fn is_version_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupErrorKind::VersionConflictException(_)
        )
    }
}
impl std::error::Error for UpdateThingGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateThingGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateThingGroupErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateThingGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateThingGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateThingGroupErrorKind::VersionConflictException(_inner) => Some(_inner),
            UpdateThingGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateThingGroupsForThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateThingGroupsForThingError {
    /// Kind of error that occurred.
    pub kind: UpdateThingGroupsForThingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateThingGroupsForThing` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateThingGroupsForThingErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateThingGroupsForThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateThingGroupsForThingErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateThingGroupsForThingErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateThingGroupsForThingErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateThingGroupsForThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateThingGroupsForThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateThingGroupsForThingError {
    fn code(&self) -> Option<&str> {
        UpdateThingGroupsForThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateThingGroupsForThingError {
    /// Creates a new `UpdateThingGroupsForThingError`.
    pub fn new(kind: UpdateThingGroupsForThingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateThingGroupsForThingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateThingGroupsForThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateThingGroupsForThingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateThingGroupsForThingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateThingGroupsForThingErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupsForThingErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateThingGroupsForThingErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupsForThingErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateThingGroupsForThingErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupsForThingErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateThingGroupsForThingErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThingGroupsForThingErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateThingGroupsForThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateThingGroupsForThingErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateThingGroupsForThingErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateThingGroupsForThingErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateThingGroupsForThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateThingGroupsForThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateTopicRuleDestination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTopicRuleDestinationError {
    /// Kind of error that occurred.
    pub kind: UpdateTopicRuleDestinationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateTopicRuleDestination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTopicRuleDestinationErrorKind {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending
    /// updates cause a conflict.</p>
    ConflictingResourceUpdateException(crate::error::ConflictingResourceUpdateException),
    /// <p>An unexpected error has occurred.</p>
    InternalException(crate::error::InternalException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>You are not authorized to perform this operation.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTopicRuleDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            UpdateTopicRuleDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateTopicRuleDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateTopicRuleDestinationError {
    fn code(&self) -> Option<&str> {
        UpdateTopicRuleDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTopicRuleDestinationError {
    /// Creates a new `UpdateTopicRuleDestinationError`.
    pub fn new(kind: UpdateTopicRuleDestinationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateTopicRuleDestinationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTopicRuleDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateTopicRuleDestinationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTopicRuleDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException`.
    pub fn is_conflicting_resource_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateTopicRuleDestinationErrorKind::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTopicRuleDestinationErrorKind::InternalException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateTopicRuleDestinationErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTopicRuleDestinationErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateTopicRuleDestinationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTopicRuleDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateTopicRuleDestinationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTopicRuleDestinationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateTopicRuleDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTopicRuleDestinationErrorKind::ConflictingResourceUpdateException(_inner) => {
                Some(_inner)
            }
            UpdateTopicRuleDestinationErrorKind::InternalException(_inner) => Some(_inner),
            UpdateTopicRuleDestinationErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateTopicRuleDestinationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateTopicRuleDestinationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateTopicRuleDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ValidateSecurityProfileBehaviors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateSecurityProfileBehaviorsError {
    /// Kind of error that occurred.
    pub kind: ValidateSecurityProfileBehaviorsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateSecurityProfileBehaviors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateSecurityProfileBehaviorsErrorKind {
    /// <p>An unexpected error has occurred.</p>
    InternalFailureException(crate::error::InternalFailureException),
    /// <p>The request is not valid.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The rate exceeds the limit.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateSecurityProfileBehaviorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ValidateSecurityProfileBehaviorsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ValidateSecurityProfileBehaviorsErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ValidateSecurityProfileBehaviorsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ValidateSecurityProfileBehaviorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateSecurityProfileBehaviorsError {
    fn code(&self) -> Option<&str> {
        ValidateSecurityProfileBehaviorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ValidateSecurityProfileBehaviorsError {
    /// Creates a new `ValidateSecurityProfileBehaviorsError`.
    pub fn new(
        kind: ValidateSecurityProfileBehaviorsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ValidateSecurityProfileBehaviorsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ValidateSecurityProfileBehaviorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ValidateSecurityProfileBehaviorsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ValidateSecurityProfileBehaviorsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ValidateSecurityProfileBehaviorsErrorKind::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateSecurityProfileBehaviorsErrorKind::InternalFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ValidateSecurityProfileBehaviorsErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateSecurityProfileBehaviorsErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ValidateSecurityProfileBehaviorsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateSecurityProfileBehaviorsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ValidateSecurityProfileBehaviorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ValidateSecurityProfileBehaviorsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ValidateSecurityProfileBehaviorsErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ValidateSecurityProfileBehaviorsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ValidateSecurityProfileBehaviorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The rate exceeds the limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottlingException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>The request is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRequestException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequestException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequestException {}
/// See [`InvalidRequestException`](crate::error::InvalidRequestException)
pub mod invalid_request_exception {
    /// A builder for [`InvalidRequestException`](crate::error::InvalidRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestException`](crate::error::InvalidRequestException)
        pub fn build(self) -> crate::error::InvalidRequestException {
            crate::error::InvalidRequestException {
                message: self.message,
            }
        }
    }
}
impl InvalidRequestException {
    /// Creates a new builder-style object to manufacture [`InvalidRequestException`](crate::error::InvalidRequestException)
    pub fn builder() -> crate::error::invalid_request_exception::Builder {
        crate::error::invalid_request_exception::Builder::default()
    }
}

/// <p>An unexpected error has occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalFailureException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalFailureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalFailureException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalFailureException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalFailureException {}
/// See [`InternalFailureException`](crate::error::InternalFailureException)
pub mod internal_failure_exception {
    /// A builder for [`InternalFailureException`](crate::error::InternalFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalFailureException`](crate::error::InternalFailureException)
        pub fn build(self) -> crate::error::InternalFailureException {
            crate::error::InternalFailureException {
                message: self.message,
            }
        }
    }
}
impl InternalFailureException {
    /// Creates a new builder-style object to manufacture [`InternalFailureException`](crate::error::InternalFailureException)
    pub fn builder() -> crate::error::internal_failure_exception::Builder {
        crate::error::internal_failure_exception::Builder::default()
    }
}

/// <p>You are not authorized to perform this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedException {}
/// See [`UnauthorizedException`](crate::error::UnauthorizedException)
pub mod unauthorized_exception {
    /// A builder for [`UnauthorizedException`](crate::error::UnauthorizedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedException`](crate::error::UnauthorizedException)
        pub fn build(self) -> crate::error::UnauthorizedException {
            crate::error::UnauthorizedException {
                message: self.message,
            }
        }
    }
}
impl UnauthorizedException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedException`](crate::error::UnauthorizedException)
    pub fn builder() -> crate::error::unauthorized_exception::Builder {
        crate::error::unauthorized_exception::Builder::default()
    }
}

/// <p>The service is temporarily unavailable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// <p>An unexpected error has occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalException {}
/// See [`InternalException`](crate::error::InternalException)
pub mod internal_exception {
    /// A builder for [`InternalException`](crate::error::InternalException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalException`](crate::error::InternalException)
        pub fn build(self) -> crate::error::InternalException {
            crate::error::InternalException {
                message: self.message,
            }
        }
    }
}
impl InternalException {
    /// Creates a new builder-style object to manufacture [`InternalException`](crate::error::InternalException)
    pub fn builder() -> crate::error::internal_exception::Builder {
        crate::error::internal_exception::Builder::default()
    }
}

/// <p>A conflicting resource update exception. This exception is thrown when two pending
/// updates cause a conflict.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictingResourceUpdateException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictingResourceUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictingResourceUpdateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictingResourceUpdateException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictingResourceUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictingResourceUpdateException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictingResourceUpdateException {}
/// See [`ConflictingResourceUpdateException`](crate::error::ConflictingResourceUpdateException)
pub mod conflicting_resource_update_exception {
    /// A builder for [`ConflictingResourceUpdateException`](crate::error::ConflictingResourceUpdateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictingResourceUpdateException`](crate::error::ConflictingResourceUpdateException)
        pub fn build(self) -> crate::error::ConflictingResourceUpdateException {
            crate::error::ConflictingResourceUpdateException {
                message: self.message,
            }
        }
    }
}
impl ConflictingResourceUpdateException {
    /// Creates a new builder-style object to manufacture [`ConflictingResourceUpdateException`](crate::error::ConflictingResourceUpdateException)
    pub fn builder() -> crate::error::conflicting_resource_update_exception::Builder {
        crate::error::conflicting_resource_update_exception::Builder::default()
    }
}

/// <p>The specified resource does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>An exception thrown when the version of an entity specified with the
/// <code>expectedVersion</code> parameter does not match the latest version in the
/// system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VersionConflictException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VersionConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VersionConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl VersionConflictException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for VersionConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "VersionConflictException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for VersionConflictException {}
/// See [`VersionConflictException`](crate::error::VersionConflictException)
pub mod version_conflict_exception {
    /// A builder for [`VersionConflictException`](crate::error::VersionConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`VersionConflictException`](crate::error::VersionConflictException)
        pub fn build(self) -> crate::error::VersionConflictException {
            crate::error::VersionConflictException {
                message: self.message,
            }
        }
    }
}
impl VersionConflictException {
    /// Creates a new builder-style object to manufacture [`VersionConflictException`](crate::error::VersionConflictException)
    pub fn builder() -> crate::error::version_conflict_exception::Builder {
        crate::error::version_conflict_exception::Builder::default()
    }
}

/// <p>The query is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidQueryException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidQueryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidQueryException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidQueryException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidQueryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidQueryException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidQueryException {}
/// See [`InvalidQueryException`](crate::error::InvalidQueryException)
pub mod invalid_query_exception {
    /// A builder for [`InvalidQueryException`](crate::error::InvalidQueryException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidQueryException`](crate::error::InvalidQueryException)
        pub fn build(self) -> crate::error::InvalidQueryException {
            crate::error::InvalidQueryException {
                message: self.message,
            }
        }
    }
}
impl InvalidQueryException {
    /// Creates a new builder-style object to manufacture [`InvalidQueryException`](crate::error::InvalidQueryException)
    pub fn builder() -> crate::error::invalid_query_exception::Builder {
        crate::error::invalid_query_exception::Builder::default()
    }
}

/// <p>The aggregation is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAggregationException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAggregationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAggregationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAggregationException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAggregationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAggregationException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAggregationException {}
/// See [`InvalidAggregationException`](crate::error::InvalidAggregationException)
pub mod invalid_aggregation_exception {
    /// A builder for [`InvalidAggregationException`](crate::error::InvalidAggregationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAggregationException`](crate::error::InvalidAggregationException)
        pub fn build(self) -> crate::error::InvalidAggregationException {
            crate::error::InvalidAggregationException {
                message: self.message,
            }
        }
    }
}
impl InvalidAggregationException {
    /// Creates a new builder-style object to manufacture [`InvalidAggregationException`](crate::error::InvalidAggregationException)
    pub fn builder() -> crate::error::invalid_aggregation_exception::Builder {
        crate::error::invalid_aggregation_exception::Builder::default()
    }
}

/// <p>The index is not ready.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IndexNotReadyException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IndexNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IndexNotReadyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IndexNotReadyException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IndexNotReadyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IndexNotReadyException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for IndexNotReadyException {}
/// See [`IndexNotReadyException`](crate::error::IndexNotReadyException)
pub mod index_not_ready_exception {
    /// A builder for [`IndexNotReadyException`](crate::error::IndexNotReadyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IndexNotReadyException`](crate::error::IndexNotReadyException)
        pub fn build(self) -> crate::error::IndexNotReadyException {
            crate::error::IndexNotReadyException {
                message: self.message,
            }
        }
    }
}
impl IndexNotReadyException {
    /// Creates a new builder-style object to manufacture [`IndexNotReadyException`](crate::error::IndexNotReadyException)
    pub fn builder() -> crate::error::index_not_ready_exception::Builder {
        crate::error::index_not_ready_exception::Builder::default()
    }
}

/// <p>The certificate is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CertificateValidationException {
    /// <p>Additional information about the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CertificateValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CertificateValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CertificateValidationException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateValidationException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for CertificateValidationException {}
/// See [`CertificateValidationException`](crate::error::CertificateValidationException)
pub mod certificate_validation_exception {
    /// A builder for [`CertificateValidationException`](crate::error::CertificateValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Additional information about the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Additional information about the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateValidationException`](crate::error::CertificateValidationException)
        pub fn build(self) -> crate::error::CertificateValidationException {
            crate::error::CertificateValidationException {
                message: self.message,
            }
        }
    }
}
impl CertificateValidationException {
    /// Creates a new builder-style object to manufacture [`CertificateValidationException`](crate::error::CertificateValidationException)
    pub fn builder() -> crate::error::certificate_validation_exception::Builder {
        crate::error::certificate_validation_exception::Builder::default()
    }
}

/// <p>The certificate operation is not allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CertificateStateException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CertificateStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CertificateStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CertificateStateException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateStateException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for CertificateStateException {}
/// See [`CertificateStateException`](crate::error::CertificateStateException)
pub mod certificate_state_exception {
    /// A builder for [`CertificateStateException`](crate::error::CertificateStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateStateException`](crate::error::CertificateStateException)
        pub fn build(self) -> crate::error::CertificateStateException {
            crate::error::CertificateStateException {
                message: self.message,
            }
        }
    }
}
impl CertificateStateException {
    /// Creates a new builder-style object to manufacture [`CertificateStateException`](crate::error::CertificateStateException)
    pub fn builder() -> crate::error::certificate_state_exception::Builder {
        crate::error::certificate_state_exception::Builder::default()
    }
}

/// <p>A limit has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>You can't transfer the certificate because authorization policies are still
/// attached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransferConflictException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransferConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransferConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TransferConflictException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TransferConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransferConflictException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for TransferConflictException {}
/// See [`TransferConflictException`](crate::error::TransferConflictException)
pub mod transfer_conflict_exception {
    /// A builder for [`TransferConflictException`](crate::error::TransferConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TransferConflictException`](crate::error::TransferConflictException)
        pub fn build(self) -> crate::error::TransferConflictException {
            crate::error::TransferConflictException {
                message: self.message,
            }
        }
    }
}
impl TransferConflictException {
    /// Creates a new builder-style object to manufacture [`TransferConflictException`](crate::error::TransferConflictException)
    pub fn builder() -> crate::error::transfer_conflict_exception::Builder {
        crate::error::transfer_conflict_exception::Builder::default()
    }
}

/// <p>The response is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResponseException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidResponseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResponseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidResponseException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResponseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResponseException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResponseException {}
/// See [`InvalidResponseException`](crate::error::InvalidResponseException)
pub mod invalid_response_exception {
    /// A builder for [`InvalidResponseException`](crate::error::InvalidResponseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResponseException`](crate::error::InvalidResponseException)
        pub fn build(self) -> crate::error::InvalidResponseException {
            crate::error::InvalidResponseException {
                message: self.message,
            }
        }
    }
}
impl InvalidResponseException {
    /// Creates a new builder-style object to manufacture [`InvalidResponseException`](crate::error::InvalidResponseException)
    pub fn builder() -> crate::error::invalid_response_exception::Builder {
        crate::error::invalid_response_exception::Builder::default()
    }
}

/// <p>
/// This exception occurs if you attempt to start a task with the same task-id as an existing task but with a different clientRequestToken.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TaskAlreadyExistsException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TaskAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaskAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TaskAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TaskAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TaskAlreadyExistsException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for TaskAlreadyExistsException {}
/// See [`TaskAlreadyExistsException`](crate::error::TaskAlreadyExistsException)
pub mod task_already_exists_exception {
    /// A builder for [`TaskAlreadyExistsException`](crate::error::TaskAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TaskAlreadyExistsException`](crate::error::TaskAlreadyExistsException)
        pub fn build(self) -> crate::error::TaskAlreadyExistsException {
            crate::error::TaskAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl TaskAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`TaskAlreadyExistsException`](crate::error::TaskAlreadyExistsException)
    pub fn builder() -> crate::error::task_already_exists_exception::Builder {
        crate::error::task_already_exists_exception::Builder::default()
    }
}

/// <p>The resource is not configured.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotConfiguredException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotConfiguredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotConfiguredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotConfiguredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotConfiguredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotConfiguredException")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotConfiguredException {}
/// See [`NotConfiguredException`](crate::error::NotConfiguredException)
pub mod not_configured_exception {
    /// A builder for [`NotConfiguredException`](crate::error::NotConfiguredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotConfiguredException`](crate::error::NotConfiguredException)
        pub fn build(self) -> crate::error::NotConfiguredException {
            crate::error::NotConfiguredException {
                message: self.message,
            }
        }
    }
}
impl NotConfiguredException {
    /// Creates a new builder-style object to manufacture [`NotConfiguredException`](crate::error::NotConfiguredException)
    pub fn builder() -> crate::error::not_configured_exception::Builder {
        crate::error::not_configured_exception::Builder::default()
    }
}

/// <p>The resource already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAlreadyExistsException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The ID of the resource that caused the exception.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource that caused the exception.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
impl ResourceAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistsException")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsException {}
/// See [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
pub mod resource_already_exists_exception {
    /// A builder for [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The ID of the resource that caused the exception.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource that caused the exception.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The ARN of the resource that caused the exception.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource that caused the exception.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
        pub fn build(self) -> crate::error::ResourceAlreadyExistsException {
            crate::error::ResourceAlreadyExistsException {
                message: self.message,
                resource_id: self.resource_id,
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl ResourceAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    pub fn builder() -> crate::error::resource_already_exists_exception::Builder {
        crate::error::resource_already_exists_exception::Builder::default()
    }
}

/// <p>The Rule-SQL expression can't be parsed correctly.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SqlParseException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SqlParseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SqlParseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SqlParseException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SqlParseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SqlParseException")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for SqlParseException {}
/// See [`SqlParseException`](crate::error::SqlParseException)
pub mod sql_parse_exception {
    /// A builder for [`SqlParseException`](crate::error::SqlParseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SqlParseException`](crate::error::SqlParseException)
        pub fn build(self) -> crate::error::SqlParseException {
            crate::error::SqlParseException {
                message: self.message,
            }
        }
    }
}
impl SqlParseException {
    /// Creates a new builder-style object to manufacture [`SqlParseException`](crate::error::SqlParseException)
    pub fn builder() -> crate::error::sql_parse_exception::Builder {
        crate::error::sql_parse_exception::Builder::default()
    }
}

/// <p>You can't revert the certificate transfer because the transfer is already
/// complete.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransferAlreadyCompletedException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransferAlreadyCompletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransferAlreadyCompletedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TransferAlreadyCompletedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TransferAlreadyCompletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransferAlreadyCompletedException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for TransferAlreadyCompletedException {}
/// See [`TransferAlreadyCompletedException`](crate::error::TransferAlreadyCompletedException)
pub mod transfer_already_completed_exception {
    /// A builder for [`TransferAlreadyCompletedException`](crate::error::TransferAlreadyCompletedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TransferAlreadyCompletedException`](crate::error::TransferAlreadyCompletedException)
        pub fn build(self) -> crate::error::TransferAlreadyCompletedException {
            crate::error::TransferAlreadyCompletedException {
                message: self.message,
            }
        }
    }
}
impl TransferAlreadyCompletedException {
    /// Creates a new builder-style object to manufacture [`TransferAlreadyCompletedException`](crate::error::TransferAlreadyCompletedException)
    pub fn builder() -> crate::error::transfer_already_completed_exception::Builder {
        crate::error::transfer_already_completed_exception::Builder::default()
    }
}

/// <p>The resource registration failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceRegistrationFailureException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceRegistrationFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceRegistrationFailureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceRegistrationFailureException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceRegistrationFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceRegistrationFailureException")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceRegistrationFailureException {}
/// See [`ResourceRegistrationFailureException`](crate::error::ResourceRegistrationFailureException)
pub mod resource_registration_failure_exception {
    /// A builder for [`ResourceRegistrationFailureException`](crate::error::ResourceRegistrationFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceRegistrationFailureException`](crate::error::ResourceRegistrationFailureException)
        pub fn build(self) -> crate::error::ResourceRegistrationFailureException {
            crate::error::ResourceRegistrationFailureException {
                message: self.message,
            }
        }
    }
}
impl ResourceRegistrationFailureException {
    /// Creates a new builder-style object to manufacture [`ResourceRegistrationFailureException`](crate::error::ResourceRegistrationFailureException)
    pub fn builder() -> crate::error::resource_registration_failure_exception::Builder {
        crate::error::resource_registration_failure_exception::Builder::default()
    }
}

/// <p>Unable to verify the CA certificate used to sign the device certificate you are
/// attempting to register. This is happens when you have registered more than one CA
/// certificate that has the same subject field and public key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CertificateConflictException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CertificateConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CertificateConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CertificateConflictException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateConflictException")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for CertificateConflictException {}
/// See [`CertificateConflictException`](crate::error::CertificateConflictException)
pub mod certificate_conflict_exception {
    /// A builder for [`CertificateConflictException`](crate::error::CertificateConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateConflictException`](crate::error::CertificateConflictException)
        pub fn build(self) -> crate::error::CertificateConflictException {
            crate::error::CertificateConflictException {
                message: self.message,
            }
        }
    }
}
impl CertificateConflictException {
    /// Creates a new builder-style object to manufacture [`CertificateConflictException`](crate::error::CertificateConflictException)
    pub fn builder() -> crate::error::certificate_conflict_exception::Builder {
        crate::error::certificate_conflict_exception::Builder::default()
    }
}

/// <p>The registration code is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegistrationCodeValidationException {
    /// <p>Additional information about the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RegistrationCodeValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegistrationCodeValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RegistrationCodeValidationException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RegistrationCodeValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RegistrationCodeValidationException")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for RegistrationCodeValidationException {}
/// See [`RegistrationCodeValidationException`](crate::error::RegistrationCodeValidationException)
pub mod registration_code_validation_exception {
    /// A builder for [`RegistrationCodeValidationException`](crate::error::RegistrationCodeValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Additional information about the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Additional information about the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RegistrationCodeValidationException`](crate::error::RegistrationCodeValidationException)
        pub fn build(self) -> crate::error::RegistrationCodeValidationException {
            crate::error::RegistrationCodeValidationException {
                message: self.message,
            }
        }
    }
}
impl RegistrationCodeValidationException {
    /// Creates a new builder-style object to manufacture [`RegistrationCodeValidationException`](crate::error::RegistrationCodeValidationException)
    pub fn builder() -> crate::error::registration_code_validation_exception::Builder {
        crate::error::registration_code_validation_exception::Builder::default()
    }
}

/// <p>You can't delete the resource because it is attached to one or more
/// resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteConflictException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DeleteConflictException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeleteConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeleteConflictException")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for DeleteConflictException {}
/// See [`DeleteConflictException`](crate::error::DeleteConflictException)
pub mod delete_conflict_exception {
    /// A builder for [`DeleteConflictException`](crate::error::DeleteConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteConflictException`](crate::error::DeleteConflictException)
        pub fn build(self) -> crate::error::DeleteConflictException {
            crate::error::DeleteConflictException {
                message: self.message,
            }
        }
    }
}
impl DeleteConflictException {
    /// Creates a new builder-style object to manufacture [`DeleteConflictException`](crate::error::DeleteConflictException)
    pub fn builder() -> crate::error::delete_conflict_exception::Builder {
        crate::error::delete_conflict_exception::Builder::default()
    }
}

/// <p>An attempt was made to change to an invalid state, for example by deleting a job or a
/// job execution which is "IN_PROGRESS" without setting the <code>force</code>
/// parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidStateTransitionException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidStateTransitionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidStateTransitionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidStateTransitionException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidStateTransitionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidStateTransitionException")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidStateTransitionException {}
/// See [`InvalidStateTransitionException`](crate::error::InvalidStateTransitionException)
pub mod invalid_state_transition_exception {
    /// A builder for [`InvalidStateTransitionException`](crate::error::InvalidStateTransitionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidStateTransitionException`](crate::error::InvalidStateTransitionException)
        pub fn build(self) -> crate::error::InvalidStateTransitionException {
            crate::error::InvalidStateTransitionException {
                message: self.message,
            }
        }
    }
}
impl InvalidStateTransitionException {
    /// Creates a new builder-style object to manufacture [`InvalidStateTransitionException`](crate::error::InvalidStateTransitionException)
    pub fn builder() -> crate::error::invalid_state_transition_exception::Builder {
        crate::error::invalid_state_transition_exception::Builder::default()
    }
}

/// <p>The number of policy versions exceeds the limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VersionsLimitExceededException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VersionsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VersionsLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl VersionsLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for VersionsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "VersionsLimitExceededException")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for VersionsLimitExceededException {}
/// See [`VersionsLimitExceededException`](crate::error::VersionsLimitExceededException)
pub mod versions_limit_exceeded_exception {
    /// A builder for [`VersionsLimitExceededException`](crate::error::VersionsLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`VersionsLimitExceededException`](crate::error::VersionsLimitExceededException)
        pub fn build(self) -> crate::error::VersionsLimitExceededException {
            crate::error::VersionsLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl VersionsLimitExceededException {
    /// Creates a new builder-style object to manufacture [`VersionsLimitExceededException`](crate::error::VersionsLimitExceededException)
    pub fn builder() -> crate::error::versions_limit_exceeded_exception::Builder {
        crate::error::versions_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The policy documentation is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedPolicyException {
    /// <p>The message for the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedPolicyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedPolicyException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MalformedPolicyException")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedPolicyException {}
/// See [`MalformedPolicyException`](crate::error::MalformedPolicyException)
pub mod malformed_policy_exception {
    /// A builder for [`MalformedPolicyException`](crate::error::MalformedPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedPolicyException`](crate::error::MalformedPolicyException)
        pub fn build(self) -> crate::error::MalformedPolicyException {
            crate::error::MalformedPolicyException {
                message: self.message,
            }
        }
    }
}
impl MalformedPolicyException {
    /// Creates a new builder-style object to manufacture [`MalformedPolicyException`](crate::error::MalformedPolicyException)
    pub fn builder() -> crate::error::malformed_policy_exception::Builder {
        crate::error::malformed_policy_exception::Builder::default()
    }
}

/// <p>A resource with the same name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}
