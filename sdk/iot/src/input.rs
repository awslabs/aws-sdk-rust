// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`AcceptCertificateTransferInput`](crate::input::AcceptCertificateTransferInput)
pub mod accept_certificate_transfer_input {

    /// A builder for [`AcceptCertificateTransferInput`](crate::input::AcceptCertificateTransferInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_id: std::option::Option<std::string::String>,
        pub(crate) set_as_active: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(input.into());
            self
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_id = input;
            self
        }
        /// <p>Specifies whether the certificate is active.</p>
        pub fn set_as_active(mut self, input: bool) -> Self {
            self.set_as_active = Some(input);
            self
        }
        /// <p>Specifies whether the certificate is active.</p>
        pub fn set_set_as_active(mut self, input: std::option::Option<bool>) -> Self {
            self.set_as_active = input;
            self
        }
        /// Consumes the builder and constructs a [`AcceptCertificateTransferInput`](crate::input::AcceptCertificateTransferInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AcceptCertificateTransferInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AcceptCertificateTransferInput {
                certificate_id: self.certificate_id,
                set_as_active: self.set_as_active.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type AcceptCertificateTransferInputOperationOutputAlias =
    crate::operation::AcceptCertificateTransfer;
#[doc(hidden)]
pub type AcceptCertificateTransferInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AcceptCertificateTransferInput {
    /// Consumes the builder and constructs an Operation<[`AcceptCertificateTransfer`](crate::operation::AcceptCertificateTransfer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AcceptCertificateTransfer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AcceptCertificateTransferInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_1 = &_input.certificate_id;
                let input_1 = input_1.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let certificate_id = aws_smithy_http::label::fmt_string(input_1, false);
                if certificate_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accept-certificate-transfer/{certificateId}",
                    certificateId = certificate_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::AcceptCertificateTransferInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.set_as_active {
                    query.push_kv(
                        "setAsActive",
                        aws_smithy_types::primitive::Encoder::from(_input.set_as_active).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AcceptCertificateTransferInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AcceptCertificateTransfer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AcceptCertificateTransfer",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AcceptCertificateTransferInput`](crate::input::AcceptCertificateTransferInput)
    pub fn builder() -> crate::input::accept_certificate_transfer_input::Builder {
        crate::input::accept_certificate_transfer_input::Builder::default()
    }
}

/// See [`AddThingToBillingGroupInput`](crate::input::AddThingToBillingGroupInput)
pub mod add_thing_to_billing_group_input {

    /// A builder for [`AddThingToBillingGroupInput`](crate::input::AddThingToBillingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_group_name: std::option::Option<std::string::String>,
        pub(crate) billing_group_arn: std::option::Option<std::string::String>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) thing_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the billing group.</p> <note>
        /// <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p>
        /// </note>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the billing group.</p> <note>
        /// <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p>
        /// </note>
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_name = input;
            self
        }
        /// <p>The ARN of the billing group.</p>
        pub fn billing_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the billing group.</p>
        pub fn set_billing_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_arn = input;
            self
        }
        /// <p>The name of the thing to be added to the billing group.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing to be added to the billing group.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>The ARN of the thing to be added to the billing group.</p>
        pub fn thing_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the thing to be added to the billing group.</p>
        pub fn set_thing_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AddThingToBillingGroupInput`](crate::input::AddThingToBillingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AddThingToBillingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AddThingToBillingGroupInput {
                billing_group_name: self.billing_group_name,
                billing_group_arn: self.billing_group_arn,
                thing_name: self.thing_name,
                thing_arn: self.thing_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type AddThingToBillingGroupInputOperationOutputAlias = crate::operation::AddThingToBillingGroup;
#[doc(hidden)]
pub type AddThingToBillingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AddThingToBillingGroupInput {
    /// Consumes the builder and constructs an Operation<[`AddThingToBillingGroup`](crate::operation::AddThingToBillingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AddThingToBillingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AddThingToBillingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/billing-groups/addThingToBillingGroup")
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AddThingToBillingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_add_thing_to_billing_group(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AddThingToBillingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AddThingToBillingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AddThingToBillingGroupInput`](crate::input::AddThingToBillingGroupInput)
    pub fn builder() -> crate::input::add_thing_to_billing_group_input::Builder {
        crate::input::add_thing_to_billing_group_input::Builder::default()
    }
}

/// See [`AddThingToThingGroupInput`](crate::input::AddThingToThingGroupInput)
pub mod add_thing_to_thing_group_input {

    /// A builder for [`AddThingToThingGroupInput`](crate::input::AddThingToThingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_group_name: std::option::Option<std::string::String>,
        pub(crate) thing_group_arn: std::option::Option<std::string::String>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) thing_arn: std::option::Option<std::string::String>,
        pub(crate) override_dynamic_groups: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the group to which you are adding a thing.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the group to which you are adding a thing.</p>
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_name = input;
            self
        }
        /// <p>The ARN of the group to which you are adding a thing.</p>
        pub fn thing_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the group to which you are adding a thing.</p>
        pub fn set_thing_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_arn = input;
            self
        }
        /// <p>The name of the thing to add to a group.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing to add to a group.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>The ARN of the thing to add to a group.</p>
        pub fn thing_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the thing to add to a group.</p>
        pub fn set_thing_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_arn = input;
            self
        }
        /// <p>Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.</p>
        pub fn override_dynamic_groups(mut self, input: bool) -> Self {
            self.override_dynamic_groups = Some(input);
            self
        }
        /// <p>Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.</p>
        pub fn set_override_dynamic_groups(mut self, input: std::option::Option<bool>) -> Self {
            self.override_dynamic_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`AddThingToThingGroupInput`](crate::input::AddThingToThingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AddThingToThingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AddThingToThingGroupInput {
                thing_group_name: self.thing_group_name,
                thing_group_arn: self.thing_group_arn,
                thing_name: self.thing_name,
                thing_arn: self.thing_arn,
                override_dynamic_groups: self.override_dynamic_groups.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type AddThingToThingGroupInputOperationOutputAlias = crate::operation::AddThingToThingGroup;
#[doc(hidden)]
pub type AddThingToThingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AddThingToThingGroupInput {
    /// Consumes the builder and constructs an Operation<[`AddThingToThingGroup`](crate::operation::AddThingToThingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AddThingToThingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AddThingToThingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/thing-groups/addThingToThingGroup")
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AddThingToThingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_add_thing_to_thing_group(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AddThingToThingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AddThingToThingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AddThingToThingGroupInput`](crate::input::AddThingToThingGroupInput)
    pub fn builder() -> crate::input::add_thing_to_thing_group_input::Builder {
        crate::input::add_thing_to_thing_group_input::Builder::default()
    }
}

/// See [`AssociateTargetsWithJobInput`](crate::input::AssociateTargetsWithJobInput)
pub mod associate_targets_with_job_input {

    /// A builder for [`AssociateTargetsWithJobInput`](crate::input::AssociateTargetsWithJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) targets: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) comment: std::option::Option<std::string::String>,
        pub(crate) namespace_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `targets`.
        ///
        /// To override the contents of this collection use [`set_targets`](Self::set_targets).
        ///
        /// <p>A list of thing group ARNs that define the targets of the job.</p>
        pub fn targets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        /// <p>A list of thing group ARNs that define the targets of the job.</p>
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>An optional comment string describing why the job was associated with the targets.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p>An optional comment string describing why the job was associated with the targets.</p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_id = Some(input.into());
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateTargetsWithJobInput`](crate::input::AssociateTargetsWithJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateTargetsWithJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateTargetsWithJobInput {
                targets: self.targets,
                job_id: self.job_id,
                comment: self.comment,
                namespace_id: self.namespace_id,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateTargetsWithJobInputOperationOutputAlias =
    crate::operation::AssociateTargetsWithJob;
#[doc(hidden)]
pub type AssociateTargetsWithJobInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AssociateTargetsWithJobInput {
    /// Consumes the builder and constructs an Operation<[`AssociateTargetsWithJob`](crate::operation::AssociateTargetsWithJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateTargetsWithJob,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateTargetsWithJobInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_2 = &_input.job_id;
                let input_2 = input_2.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_id = aws_smithy_http::label::fmt_string(input_2, false);
                if job_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/jobs/{jobId}/targets", jobId = job_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::AssociateTargetsWithJobInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_3) = &_input.namespace_id {
                    query.push_kv("namespaceId", &aws_smithy_http::query::fmt_string(&inner_3));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateTargetsWithJobInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_targets_with_job(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateTargetsWithJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateTargetsWithJob",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociateTargetsWithJobInput`](crate::input::AssociateTargetsWithJobInput)
    pub fn builder() -> crate::input::associate_targets_with_job_input::Builder {
        crate::input::associate_targets_with_job_input::Builder::default()
    }
}

/// See [`AttachPolicyInput`](crate::input::AttachPolicyInput)
pub mod attach_policy_input {

    /// A builder for [`AttachPolicyInput`](crate::input::AttachPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) target: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the policy to attach.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy to attach.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/iot/latest/developerguide/security-iam.html">identity</a> to which the policy is attached. For example, a thing group or a certificate.</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.target = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/iot/latest/developerguide/security-iam.html">identity</a> to which the policy is attached. For example, a thing group or a certificate.</p>
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachPolicyInput`](crate::input::AttachPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AttachPolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AttachPolicyInput {
                policy_name: self.policy_name,
                target: self.target,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachPolicyInputOperationOutputAlias = crate::operation::AttachPolicy;
#[doc(hidden)]
pub type AttachPolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AttachPolicyInput {
    /// Consumes the builder and constructs an Operation<[`AttachPolicy`](crate::operation::AttachPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AttachPolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AttachPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_4 = &_input.policy_name;
                let input_4 = input_4.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_4, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/target-policies/{policyName}",
                    policyName = policy_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AttachPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_attach_policy(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AttachPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AttachPolicy",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AttachPolicyInput`](crate::input::AttachPolicyInput)
    pub fn builder() -> crate::input::attach_policy_input::Builder {
        crate::input::attach_policy_input::Builder::default()
    }
}

/// See [`AttachPrincipalPolicyInput`](crate::input::AttachPrincipalPolicyInput)
pub mod attach_principal_policy_input {

    /// A builder for [`AttachPrincipalPolicyInput`](crate::input::AttachPrincipalPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) principal: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The policy name.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal = Some(input.into());
            self
        }
        /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachPrincipalPolicyInput`](crate::input::AttachPrincipalPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AttachPrincipalPolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AttachPrincipalPolicyInput {
                policy_name: self.policy_name,
                principal: self.principal,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachPrincipalPolicyInputOperationOutputAlias = crate::operation::AttachPrincipalPolicy;
#[doc(hidden)]
pub type AttachPrincipalPolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AttachPrincipalPolicyInput {
    /// Consumes the builder and constructs an Operation<[`AttachPrincipalPolicy`](crate::operation::AttachPrincipalPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AttachPrincipalPolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AttachPrincipalPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_5 = &_input.policy_name;
                let input_5 = input_5.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_5, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/principal-policies/{policyName}",
                    policyName = policy_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AttachPrincipalPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_attach_principal_policy(input, builder)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AttachPrincipalPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AttachPrincipalPolicy",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AttachPrincipalPolicyInput`](crate::input::AttachPrincipalPolicyInput)
    pub fn builder() -> crate::input::attach_principal_policy_input::Builder {
        crate::input::attach_principal_policy_input::Builder::default()
    }
}

/// See [`AttachSecurityProfileInput`](crate::input::AttachSecurityProfileInput)
pub mod attach_security_profile_input {

    /// A builder for [`AttachSecurityProfileInput`](crate::input::AttachSecurityProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) security_profile_target_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The security profile that is attached.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The security profile that is attached.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p>The ARN of the target (thing group) to which the security profile is attached.</p>
        pub fn security_profile_target_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.security_profile_target_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the target (thing group) to which the security profile is attached.</p>
        pub fn set_security_profile_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_target_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachSecurityProfileInput`](crate::input::AttachSecurityProfileInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AttachSecurityProfileInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AttachSecurityProfileInput {
                security_profile_name: self.security_profile_name,
                security_profile_target_arn: self.security_profile_target_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachSecurityProfileInputOperationOutputAlias = crate::operation::AttachSecurityProfile;
#[doc(hidden)]
pub type AttachSecurityProfileInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AttachSecurityProfileInput {
    /// Consumes the builder and constructs an Operation<[`AttachSecurityProfile`](crate::operation::AttachSecurityProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AttachSecurityProfile,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AttachSecurityProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_6 = &_input.security_profile_name;
                let input_6 = input_6.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let security_profile_name = aws_smithy_http::label::fmt_string(input_6, false);
                if security_profile_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/security-profiles/{securityProfileName}/targets",
                    securityProfileName = security_profile_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::AttachSecurityProfileInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_7) = &_input.security_profile_target_arn {
                    query.push_kv(
                        "securityProfileTargetArn",
                        &aws_smithy_http::query::fmt_string(&inner_7),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AttachSecurityProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AttachSecurityProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AttachSecurityProfile",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AttachSecurityProfileInput`](crate::input::AttachSecurityProfileInput)
    pub fn builder() -> crate::input::attach_security_profile_input::Builder {
        crate::input::attach_security_profile_input::Builder::default()
    }
}

/// See [`AttachThingPrincipalInput`](crate::input::AttachThingPrincipalInput)
pub mod attach_thing_principal_input {

    /// A builder for [`AttachThingPrincipalInput`](crate::input::AttachThingPrincipalInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) principal: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal = Some(input.into());
            self
        }
        /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachThingPrincipalInput`](crate::input::AttachThingPrincipalInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AttachThingPrincipalInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AttachThingPrincipalInput {
                thing_name: self.thing_name,
                principal: self.principal,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachThingPrincipalInputOperationOutputAlias = crate::operation::AttachThingPrincipal;
#[doc(hidden)]
pub type AttachThingPrincipalInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AttachThingPrincipalInput {
    /// Consumes the builder and constructs an Operation<[`AttachThingPrincipal`](crate::operation::AttachThingPrincipal)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AttachThingPrincipal,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AttachThingPrincipalInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_8 = &_input.thing_name;
                let input_8 = input_8.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_8, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/things/{thingName}/principals",
                    thingName = thing_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AttachThingPrincipalInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_attach_thing_principal(input, builder)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AttachThingPrincipal::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AttachThingPrincipal",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AttachThingPrincipalInput`](crate::input::AttachThingPrincipalInput)
    pub fn builder() -> crate::input::attach_thing_principal_input::Builder {
        crate::input::attach_thing_principal_input::Builder::default()
    }
}

/// See [`CancelAuditMitigationActionsTaskInput`](crate::input::CancelAuditMitigationActionsTaskInput)
pub mod cancel_audit_mitigation_actions_task_input {

    /// A builder for [`CancelAuditMitigationActionsTaskInput`](crate::input::CancelAuditMitigationActionsTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the task that you want to cancel. </p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the task that you want to cancel. </p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelAuditMitigationActionsTaskInput`](crate::input::CancelAuditMitigationActionsTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CancelAuditMitigationActionsTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CancelAuditMitigationActionsTaskInput {
                task_id: self.task_id,
            })
        }
    }
}
#[doc(hidden)]
pub type CancelAuditMitigationActionsTaskInputOperationOutputAlias =
    crate::operation::CancelAuditMitigationActionsTask;
#[doc(hidden)]
pub type CancelAuditMitigationActionsTaskInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl CancelAuditMitigationActionsTaskInput {
    /// Consumes the builder and constructs an Operation<[`CancelAuditMitigationActionsTask`](crate::operation::CancelAuditMitigationActionsTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CancelAuditMitigationActionsTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CancelAuditMitigationActionsTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_9 = &_input.task_id;
                let input_9 = input_9.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let task_id = aws_smithy_http::label::fmt_string(input_9, false);
                if task_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/audit/mitigationactions/tasks/{taskId}/cancel",
                    taskId = task_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CancelAuditMitigationActionsTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CancelAuditMitigationActionsTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CancelAuditMitigationActionsTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CancelAuditMitigationActionsTaskInput`](crate::input::CancelAuditMitigationActionsTaskInput)
    pub fn builder() -> crate::input::cancel_audit_mitigation_actions_task_input::Builder {
        crate::input::cancel_audit_mitigation_actions_task_input::Builder::default()
    }
}

/// See [`CancelAuditTaskInput`](crate::input::CancelAuditTaskInput)
pub mod cancel_audit_task_input {

    /// A builder for [`CancelAuditTaskInput`](crate::input::CancelAuditTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelAuditTaskInput`](crate::input::CancelAuditTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CancelAuditTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CancelAuditTaskInput {
                task_id: self.task_id,
            })
        }
    }
}
#[doc(hidden)]
pub type CancelAuditTaskInputOperationOutputAlias = crate::operation::CancelAuditTask;
#[doc(hidden)]
pub type CancelAuditTaskInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CancelAuditTaskInput {
    /// Consumes the builder and constructs an Operation<[`CancelAuditTask`](crate::operation::CancelAuditTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CancelAuditTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CancelAuditTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_10 = &_input.task_id;
                let input_10 = input_10.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let task_id = aws_smithy_http::label::fmt_string(input_10, false);
                if task_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/audit/tasks/{taskId}/cancel", taskId = task_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CancelAuditTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CancelAuditTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CancelAuditTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CancelAuditTaskInput`](crate::input::CancelAuditTaskInput)
    pub fn builder() -> crate::input::cancel_audit_task_input::Builder {
        crate::input::cancel_audit_task_input::Builder::default()
    }
}

/// See [`CancelCertificateTransferInput`](crate::input::CancelCertificateTransferInput)
pub mod cancel_certificate_transfer_input {

    /// A builder for [`CancelCertificateTransferInput`](crate::input::CancelCertificateTransferInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(input.into());
            self
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelCertificateTransferInput`](crate::input::CancelCertificateTransferInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CancelCertificateTransferInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CancelCertificateTransferInput {
                certificate_id: self.certificate_id,
            })
        }
    }
}
#[doc(hidden)]
pub type CancelCertificateTransferInputOperationOutputAlias =
    crate::operation::CancelCertificateTransfer;
#[doc(hidden)]
pub type CancelCertificateTransferInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CancelCertificateTransferInput {
    /// Consumes the builder and constructs an Operation<[`CancelCertificateTransfer`](crate::operation::CancelCertificateTransfer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CancelCertificateTransfer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CancelCertificateTransferInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_11 = &_input.certificate_id;
                let input_11 = input_11.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let certificate_id = aws_smithy_http::label::fmt_string(input_11, false);
                if certificate_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/cancel-certificate-transfer/{certificateId}",
                    certificateId = certificate_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CancelCertificateTransferInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CancelCertificateTransfer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CancelCertificateTransfer",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CancelCertificateTransferInput`](crate::input::CancelCertificateTransferInput)
    pub fn builder() -> crate::input::cancel_certificate_transfer_input::Builder {
        crate::input::cancel_certificate_transfer_input::Builder::default()
    }
}

/// See [`CancelDetectMitigationActionsTaskInput`](crate::input::CancelDetectMitigationActionsTaskInput)
pub mod cancel_detect_mitigation_actions_task_input {

    /// A builder for [`CancelDetectMitigationActionsTaskInput`](crate::input::CancelDetectMitigationActionsTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier of the task. </p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p> The unique identifier of the task. </p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelDetectMitigationActionsTaskInput`](crate::input::CancelDetectMitigationActionsTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CancelDetectMitigationActionsTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CancelDetectMitigationActionsTaskInput {
                task_id: self.task_id,
            })
        }
    }
}
#[doc(hidden)]
pub type CancelDetectMitigationActionsTaskInputOperationOutputAlias =
    crate::operation::CancelDetectMitigationActionsTask;
#[doc(hidden)]
pub type CancelDetectMitigationActionsTaskInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl CancelDetectMitigationActionsTaskInput {
    /// Consumes the builder and constructs an Operation<[`CancelDetectMitigationActionsTask`](crate::operation::CancelDetectMitigationActionsTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CancelDetectMitigationActionsTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CancelDetectMitigationActionsTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_12 = &_input.task_id;
                let input_12 = input_12.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let task_id = aws_smithy_http::label::fmt_string(input_12, false);
                if task_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/detect/mitigationactions/tasks/{taskId}/cancel",
                    taskId = task_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CancelDetectMitigationActionsTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CancelDetectMitigationActionsTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CancelDetectMitigationActionsTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CancelDetectMitigationActionsTaskInput`](crate::input::CancelDetectMitigationActionsTaskInput)
    pub fn builder() -> crate::input::cancel_detect_mitigation_actions_task_input::Builder {
        crate::input::cancel_detect_mitigation_actions_task_input::Builder::default()
    }
}

/// See [`CancelJobInput`](crate::input::CancelJobInput)
pub mod cancel_job_input {

    /// A builder for [`CancelJobInput`](crate::input::CancelJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) reason_code: std::option::Option<std::string::String>,
        pub(crate) comment: std::option::Option<std::string::String>,
        pub(crate) force: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>(Optional)A reason code string that explains why the job was canceled.</p>
        pub fn reason_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.reason_code = Some(input.into());
            self
        }
        /// <p>(Optional)A reason code string that explains why the job was canceled.</p>
        pub fn set_reason_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reason_code = input;
            self
        }
        /// <p>An optional comment string describing why the job was canceled.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p>An optional comment string describing why the job was canceled.</p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p>
        /// <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.force = Some(input);
            self
        }
        /// <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p>
        /// <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.force = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelJobInput`](crate::input::CancelJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CancelJobInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::CancelJobInput {
                job_id: self.job_id,
                reason_code: self.reason_code,
                comment: self.comment,
                force: self.force.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type CancelJobInputOperationOutputAlias = crate::operation::CancelJob;
#[doc(hidden)]
pub type CancelJobInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CancelJobInput {
    /// Consumes the builder and constructs an Operation<[`CancelJob`](crate::operation::CancelJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CancelJob,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CancelJobInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_13 = &_input.job_id;
                let input_13 = input_13.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_id = aws_smithy_http::label::fmt_string(input_13, false);
                if job_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/jobs/{jobId}/cancel", jobId = job_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::CancelJobInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.force {
                    query.push_kv(
                        "force",
                        aws_smithy_types::primitive::Encoder::from(_input.force).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CancelJobInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_cancel_job(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::CancelJob::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "CancelJob",
                    "iot",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CancelJobInput`](crate::input::CancelJobInput)
    pub fn builder() -> crate::input::cancel_job_input::Builder {
        crate::input::cancel_job_input::Builder::default()
    }
}

/// See [`CancelJobExecutionInput`](crate::input::CancelJobExecutionInput)
pub mod cancel_job_execution_input {

    /// A builder for [`CancelJobExecutionInput`](crate::input::CancelJobExecutionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) force: std::option::Option<bool>,
        pub(crate) expected_version: std::option::Option<i64>,
        pub(crate) status_details: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ID of the job to be canceled.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The ID of the job to be canceled.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The name of the thing whose execution of the job will be canceled.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing whose execution of the job will be canceled.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p>
        /// <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.force = Some(input);
            self
        }
        /// <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p>
        /// <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.force = input;
            self
        }
        /// <p>(Optional) The expected current version of the job execution. Each time you update the job execution, its version is incremented. If the version of the job execution stored in Jobs does not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that contains the current job execution status data is returned. (This makes it unnecessary to perform a separate DescribeJobExecution request in order to obtain the job execution status data.)</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>(Optional) The expected current version of the job execution. Each time you update the job execution, its version is incremented. If the version of the job execution stored in Jobs does not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that contains the current job execution status data is returned. (This makes it unnecessary to perform a separate DescribeJobExecution request in order to obtain the job execution status data.)</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// Adds a key-value pair to `status_details`.
        ///
        /// To override the contents of this collection use [`set_status_details`](Self::set_status_details).
        ///
        /// <p>A collection of name/value pairs that describe the status of the job execution. If not specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.</p>
        pub fn status_details(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.status_details.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.status_details = Some(hash_map);
            self
        }
        /// <p>A collection of name/value pairs that describe the status of the job execution. If not specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.</p>
        pub fn set_status_details(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.status_details = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelJobExecutionInput`](crate::input::CancelJobExecutionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CancelJobExecutionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CancelJobExecutionInput {
                job_id: self.job_id,
                thing_name: self.thing_name,
                force: self.force.unwrap_or_default(),
                expected_version: self.expected_version,
                status_details: self.status_details,
            })
        }
    }
}
#[doc(hidden)]
pub type CancelJobExecutionInputOperationOutputAlias = crate::operation::CancelJobExecution;
#[doc(hidden)]
pub type CancelJobExecutionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CancelJobExecutionInput {
    /// Consumes the builder and constructs an Operation<[`CancelJobExecution`](crate::operation::CancelJobExecution)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CancelJobExecution,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CancelJobExecutionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_14 = &_input.thing_name;
                let input_14 = input_14.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_14, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                let input_15 = &_input.job_id;
                let input_15 = input_15.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_id = aws_smithy_http::label::fmt_string(input_15, false);
                if job_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/things/{thingName}/jobs/{jobId}/cancel",
                    thingName = thing_name,
                    jobId = job_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::CancelJobExecutionInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.force {
                    query.push_kv(
                        "force",
                        aws_smithy_types::primitive::Encoder::from(_input.force).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CancelJobExecutionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_cancel_job_execution(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CancelJobExecution::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CancelJobExecution",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CancelJobExecutionInput`](crate::input::CancelJobExecutionInput)
    pub fn builder() -> crate::input::cancel_job_execution_input::Builder {
        crate::input::cancel_job_execution_input::Builder::default()
    }
}

/// See [`ClearDefaultAuthorizerInput`](crate::input::ClearDefaultAuthorizerInput)
pub mod clear_default_authorizer_input {

    /// A builder for [`ClearDefaultAuthorizerInput`](crate::input::ClearDefaultAuthorizerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ClearDefaultAuthorizerInput`](crate::input::ClearDefaultAuthorizerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ClearDefaultAuthorizerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ClearDefaultAuthorizerInput {})
        }
    }
}
#[doc(hidden)]
pub type ClearDefaultAuthorizerInputOperationOutputAlias = crate::operation::ClearDefaultAuthorizer;
#[doc(hidden)]
pub type ClearDefaultAuthorizerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ClearDefaultAuthorizerInput {
    /// Consumes the builder and constructs an Operation<[`ClearDefaultAuthorizer`](crate::operation::ClearDefaultAuthorizer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ClearDefaultAuthorizer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ClearDefaultAuthorizerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/default-authorizer").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ClearDefaultAuthorizerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ClearDefaultAuthorizer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ClearDefaultAuthorizer",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ClearDefaultAuthorizerInput`](crate::input::ClearDefaultAuthorizerInput)
    pub fn builder() -> crate::input::clear_default_authorizer_input::Builder {
        crate::input::clear_default_authorizer_input::Builder::default()
    }
}

/// See [`ConfirmTopicRuleDestinationInput`](crate::input::ConfirmTopicRuleDestinationInput)
pub mod confirm_topic_rule_destination_input {

    /// A builder for [`ConfirmTopicRuleDestinationInput`](crate::input::ConfirmTopicRuleDestinationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) confirmation_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token used to confirm ownership or access to the topic rule confirmation URL.</p>
        pub fn confirmation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.confirmation_token = Some(input.into());
            self
        }
        /// <p>The token used to confirm ownership or access to the topic rule confirmation URL.</p>
        pub fn set_confirmation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.confirmation_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfirmTopicRuleDestinationInput`](crate::input::ConfirmTopicRuleDestinationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ConfirmTopicRuleDestinationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ConfirmTopicRuleDestinationInput {
                confirmation_token: self.confirmation_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ConfirmTopicRuleDestinationInputOperationOutputAlias =
    crate::operation::ConfirmTopicRuleDestination;
#[doc(hidden)]
pub type ConfirmTopicRuleDestinationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ConfirmTopicRuleDestinationInput {
    /// Consumes the builder and constructs an Operation<[`ConfirmTopicRuleDestination`](crate::operation::ConfirmTopicRuleDestination)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ConfirmTopicRuleDestination,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ConfirmTopicRuleDestinationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_16 = &_input.confirmation_token;
                let input_16 = input_16.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "confirmation_token",
                        details: "cannot be empty or unset",
                    },
                )?;
                let confirmation_token = aws_smithy_http::label::fmt_string(input_16, true);
                if confirmation_token.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "confirmation_token",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/confirmdestination/{confirmationToken}",
                    confirmationToken = confirmation_token
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ConfirmTopicRuleDestinationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ConfirmTopicRuleDestination::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ConfirmTopicRuleDestination",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ConfirmTopicRuleDestinationInput`](crate::input::ConfirmTopicRuleDestinationInput)
    pub fn builder() -> crate::input::confirm_topic_rule_destination_input::Builder {
        crate::input::confirm_topic_rule_destination_input::Builder::default()
    }
}

/// See [`CreateAuditSuppressionInput`](crate::input::CreateAuditSuppressionInput)
pub mod create_audit_suppression_input {

    /// A builder for [`CreateAuditSuppressionInput`](crate::input::CreateAuditSuppressionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) check_name: std::option::Option<std::string::String>,
        pub(crate) resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
        pub(crate) expiration_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) suppress_indefinitely: std::option::Option<bool>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.check_name = Some(input.into());
            self
        }
        /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.check_name = input;
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.resource_identifier = Some(input);
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.resource_identifier = input;
            self
        }
        /// <p> The epoch timestamp in seconds at which this suppression expires. </p>
        pub fn expiration_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expiration_date = Some(input);
            self
        }
        /// <p> The epoch timestamp in seconds at which this suppression expires. </p>
        pub fn set_expiration_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expiration_date = input;
            self
        }
        /// <p> Indicates whether a suppression should exist indefinitely or not. </p>
        pub fn suppress_indefinitely(mut self, input: bool) -> Self {
            self.suppress_indefinitely = Some(input);
            self
        }
        /// <p> Indicates whether a suppression should exist indefinitely or not. </p>
        pub fn set_suppress_indefinitely(mut self, input: std::option::Option<bool>) -> Self {
            self.suppress_indefinitely = input;
            self
        }
        /// <p> The description of the audit suppression. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The description of the audit suppression. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> Each audit supression must have a unique client request token. If you try to create a new audit suppression with the same token as one that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p> Each audit supression must have a unique client request token. If you try to create a new audit suppression with the same token as one that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAuditSuppressionInput`](crate::input::CreateAuditSuppressionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateAuditSuppressionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateAuditSuppressionInput {
                check_name: self.check_name,
                resource_identifier: self.resource_identifier,
                expiration_date: self.expiration_date,
                suppress_indefinitely: self.suppress_indefinitely,
                description: self.description,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateAuditSuppressionInputOperationOutputAlias = crate::operation::CreateAuditSuppression;
#[doc(hidden)]
pub type CreateAuditSuppressionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateAuditSuppressionInput {
    /// Consumes the builder and constructs an Operation<[`CreateAuditSuppression`](crate::operation::CreateAuditSuppression)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAuditSuppression,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAuditSuppressionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/suppressions/create").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAuditSuppressionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_audit_suppression(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAuditSuppression::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAuditSuppression",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAuditSuppressionInput`](crate::input::CreateAuditSuppressionInput)
    pub fn builder() -> crate::input::create_audit_suppression_input::Builder {
        crate::input::create_audit_suppression_input::Builder::default()
    }
}

/// See [`CreateAuthorizerInput`](crate::input::CreateAuthorizerInput)
pub mod create_authorizer_input {

    /// A builder for [`CreateAuthorizerInput`](crate::input::CreateAuthorizerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authorizer_name: std::option::Option<std::string::String>,
        pub(crate) authorizer_function_arn: std::option::Option<std::string::String>,
        pub(crate) token_key_name: std::option::Option<std::string::String>,
        pub(crate) token_signing_public_keys: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) status: std::option::Option<crate::model::AuthorizerStatus>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) signing_disabled: std::option::Option<bool>,
        pub(crate) enable_caching_for_http: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The authorizer name.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorizer_name = Some(input.into());
            self
        }
        /// <p>The authorizer name.</p>
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorizer_name = input;
            self
        }
        /// <p>The ARN of the authorizer's Lambda function.</p>
        pub fn authorizer_function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorizer_function_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the authorizer's Lambda function.</p>
        pub fn set_authorizer_function_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorizer_function_arn = input;
            self
        }
        /// <p>The name of the token key used to extract the token from the HTTP headers.</p>
        pub fn token_key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_key_name = Some(input.into());
            self
        }
        /// <p>The name of the token key used to extract the token from the HTTP headers.</p>
        pub fn set_token_key_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.token_key_name = input;
            self
        }
        /// Adds a key-value pair to `token_signing_public_keys`.
        ///
        /// To override the contents of this collection use [`set_token_signing_public_keys`](Self::set_token_signing_public_keys).
        ///
        /// <p>The public keys used to verify the digital signature returned by your custom authentication service.</p>
        pub fn token_signing_public_keys(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.token_signing_public_keys.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.token_signing_public_keys = Some(hash_map);
            self
        }
        /// <p>The public keys used to verify the digital signature returned by your custom authentication service.</p>
        pub fn set_token_signing_public_keys(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.token_signing_public_keys = input;
            self
        }
        /// <p>The status of the create authorizer request.</p>
        pub fn status(mut self, input: crate::model::AuthorizerStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the create authorizer request.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AuthorizerStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the custom authorizer.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the custom authorizer.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Specifies whether IoT validates the token signature in an authorization request.</p>
        pub fn signing_disabled(mut self, input: bool) -> Self {
            self.signing_disabled = Some(input);
            self
        }
        /// <p>Specifies whether IoT validates the token signature in an authorization request.</p>
        pub fn set_signing_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.signing_disabled = input;
            self
        }
        /// <p>When <code>true</code>, the result from the authorizers Lambda function is cached for clients that use persistent HTTP connections. The results are cached for the time specified by the Lambda function in <code>refreshAfterInSeconds</code>. This value does not affect authorization of clients that use MQTT connections.</p>
        /// <p>The default value is <code>false</code>.</p>
        pub fn enable_caching_for_http(mut self, input: bool) -> Self {
            self.enable_caching_for_http = Some(input);
            self
        }
        /// <p>When <code>true</code>, the result from the authorizers Lambda function is cached for clients that use persistent HTTP connections. The results are cached for the time specified by the Lambda function in <code>refreshAfterInSeconds</code>. This value does not affect authorization of clients that use MQTT connections.</p>
        /// <p>The default value is <code>false</code>.</p>
        pub fn set_enable_caching_for_http(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_caching_for_http = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAuthorizerInput`](crate::input::CreateAuthorizerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateAuthorizerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateAuthorizerInput {
                authorizer_name: self.authorizer_name,
                authorizer_function_arn: self.authorizer_function_arn,
                token_key_name: self.token_key_name,
                token_signing_public_keys: self.token_signing_public_keys,
                status: self.status,
                tags: self.tags,
                signing_disabled: self.signing_disabled,
                enable_caching_for_http: self.enable_caching_for_http,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateAuthorizerInputOperationOutputAlias = crate::operation::CreateAuthorizer;
#[doc(hidden)]
pub type CreateAuthorizerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateAuthorizerInput {
    /// Consumes the builder and constructs an Operation<[`CreateAuthorizer`](crate::operation::CreateAuthorizer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAuthorizer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAuthorizerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_17 = &_input.authorizer_name;
                let input_17 = input_17.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "authorizer_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let authorizer_name = aws_smithy_http::label::fmt_string(input_17, false);
                if authorizer_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "authorizer_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/authorizer/{authorizerName}",
                    authorizerName = authorizer_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAuthorizerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_authorizer(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAuthorizer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAuthorizer",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAuthorizerInput`](crate::input::CreateAuthorizerInput)
    pub fn builder() -> crate::input::create_authorizer_input::Builder {
        crate::input::create_authorizer_input::Builder::default()
    }
}

/// See [`CreateBillingGroupInput`](crate::input::CreateBillingGroupInput)
pub mod create_billing_group_input {

    /// A builder for [`CreateBillingGroupInput`](crate::input::CreateBillingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_group_name: std::option::Option<std::string::String>,
        pub(crate) billing_group_properties:
            std::option::Option<crate::model::BillingGroupProperties>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name you wish to give to the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_name = Some(input.into());
            self
        }
        /// <p>The name you wish to give to the billing group.</p>
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_name = input;
            self
        }
        /// <p>The properties of the billing group.</p>
        pub fn billing_group_properties(
            mut self,
            input: crate::model::BillingGroupProperties,
        ) -> Self {
            self.billing_group_properties = Some(input);
            self
        }
        /// <p>The properties of the billing group.</p>
        pub fn set_billing_group_properties(
            mut self,
            input: std::option::Option<crate::model::BillingGroupProperties>,
        ) -> Self {
            self.billing_group_properties = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the billing group.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the billing group.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateBillingGroupInput`](crate::input::CreateBillingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateBillingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateBillingGroupInput {
                billing_group_name: self.billing_group_name,
                billing_group_properties: self.billing_group_properties,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateBillingGroupInputOperationOutputAlias = crate::operation::CreateBillingGroup;
#[doc(hidden)]
pub type CreateBillingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateBillingGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateBillingGroup`](crate::operation::CreateBillingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateBillingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateBillingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_18 = &_input.billing_group_name;
                let input_18 = input_18.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "billing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let billing_group_name = aws_smithy_http::label::fmt_string(input_18, false);
                if billing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "billing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/billing-groups/{billingGroupName}",
                    billingGroupName = billing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateBillingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_billing_group(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateBillingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateBillingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateBillingGroupInput`](crate::input::CreateBillingGroupInput)
    pub fn builder() -> crate::input::create_billing_group_input::Builder {
        crate::input::create_billing_group_input::Builder::default()
    }
}

/// See [`CreateCertificateFromCsrInput`](crate::input::CreateCertificateFromCsrInput)
pub mod create_certificate_from_csr_input {

    /// A builder for [`CreateCertificateFromCsrInput`](crate::input::CreateCertificateFromCsrInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_signing_request: std::option::Option<std::string::String>,
        pub(crate) set_as_active: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The certificate signing request (CSR).</p>
        pub fn certificate_signing_request(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.certificate_signing_request = Some(input.into());
            self
        }
        /// <p>The certificate signing request (CSR).</p>
        pub fn set_certificate_signing_request(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_signing_request = input;
            self
        }
        /// <p>Specifies whether the certificate is active.</p>
        pub fn set_as_active(mut self, input: bool) -> Self {
            self.set_as_active = Some(input);
            self
        }
        /// <p>Specifies whether the certificate is active.</p>
        pub fn set_set_as_active(mut self, input: std::option::Option<bool>) -> Self {
            self.set_as_active = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCertificateFromCsrInput`](crate::input::CreateCertificateFromCsrInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateCertificateFromCsrInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateCertificateFromCsrInput {
                certificate_signing_request: self.certificate_signing_request,
                set_as_active: self.set_as_active.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type CreateCertificateFromCsrInputOperationOutputAlias =
    crate::operation::CreateCertificateFromCsr;
#[doc(hidden)]
pub type CreateCertificateFromCsrInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateCertificateFromCsrInput {
    /// Consumes the builder and constructs an Operation<[`CreateCertificateFromCsr`](crate::operation::CreateCertificateFromCsr)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateCertificateFromCsr,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateCertificateFromCsrInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/certificates").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::CreateCertificateFromCsrInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.set_as_active {
                    query.push_kv(
                        "setAsActive",
                        aws_smithy_types::primitive::Encoder::from(_input.set_as_active).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateCertificateFromCsrInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_certificate_from_csr(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateCertificateFromCsr::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateCertificateFromCsr",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateCertificateFromCsrInput`](crate::input::CreateCertificateFromCsrInput)
    pub fn builder() -> crate::input::create_certificate_from_csr_input::Builder {
        crate::input::create_certificate_from_csr_input::Builder::default()
    }
}

/// See [`CreateCustomMetricInput`](crate::input::CreateCustomMetricInput)
pub mod create_custom_metric_input {

    /// A builder for [`CreateCustomMetricInput`](crate::input::CreateCustomMetricInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) metric_type: std::option::Option<crate::model::CustomMetricType>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the custom metric. This will be used in the metric report submitted from the device/thing. The name can't begin with <code>aws:</code>. You can't change the name after you define it.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p> The name of the custom metric. This will be used in the metric report submitted from the device/thing. The name can't begin with <code>aws:</code>. You can't change the name after you define it.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p> The friendly name in the console for the custom metric. This name doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. You can update the friendly name after you define it.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p> The friendly name in the console for the custom metric. This name doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. You can update the friendly name after you define it.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p> The type of the custom metric. </p> <important>
        /// <p>The type <code>number</code> only takes a single metric value as an input, but when you submit the metrics value in the DeviceMetrics report, you must pass it as an array with a single value.</p>
        /// </important>
        pub fn metric_type(mut self, input: crate::model::CustomMetricType) -> Self {
            self.metric_type = Some(input);
            self
        }
        /// <p> The type of the custom metric. </p> <important>
        /// <p>The type <code>number</code> only takes a single metric value as an input, but when you submit the metrics value in the DeviceMetrics report, you must pass it as an array with a single value.</p>
        /// </important>
        pub fn set_metric_type(
            mut self,
            input: std::option::Option<crate::model::CustomMetricType>,
        ) -> Self {
            self.metric_type = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p> Metadata that can be used to manage the custom metric. </p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p> Metadata that can be used to manage the custom metric. </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Each custom metric must have a unique client request token. If you try to create a new custom metric that already exists with a different token, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request. </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>Each custom metric must have a unique client request token. If you try to create a new custom metric that already exists with a different token, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request. </p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCustomMetricInput`](crate::input::CreateCustomMetricInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateCustomMetricInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateCustomMetricInput {
                metric_name: self.metric_name,
                display_name: self.display_name,
                metric_type: self.metric_type,
                tags: self.tags,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateCustomMetricInputOperationOutputAlias = crate::operation::CreateCustomMetric;
#[doc(hidden)]
pub type CreateCustomMetricInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateCustomMetricInput {
    /// Consumes the builder and constructs an Operation<[`CreateCustomMetric`](crate::operation::CreateCustomMetric)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateCustomMetric,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateCustomMetricInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_19 = &_input.metric_name;
                let input_19 = input_19.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let metric_name = aws_smithy_http::label::fmt_string(input_19, false);
                if metric_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/custom-metric/{metricName}",
                    metricName = metric_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateCustomMetricInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_custom_metric(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateCustomMetric::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateCustomMetric",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateCustomMetricInput`](crate::input::CreateCustomMetricInput)
    pub fn builder() -> crate::input::create_custom_metric_input::Builder {
        crate::input::create_custom_metric_input::Builder::default()
    }
}

/// See [`CreateDimensionInput`](crate::input::CreateDimensionInput)
pub mod create_dimension_input {

    /// A builder for [`CreateDimensionInput`](crate::input::CreateDimensionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DimensionType>,
        pub(crate) string_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies the type of dimension. Supported types: <code>TOPIC_FILTER.</code> </p>
        pub fn r#type(mut self, input: crate::model::DimensionType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Specifies the type of dimension. Supported types: <code>TOPIC_FILTER.</code> </p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::DimensionType>) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `string_values`.
        ///
        /// To override the contents of this collection use [`set_string_values`](Self::set_string_values).
        ///
        /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
        pub fn string_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.string_values.unwrap_or_default();
            v.push(input.into());
            self.string_values = Some(v);
            self
        }
        /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
        pub fn set_string_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.string_values = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the dimension.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the dimension.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Each dimension must have a unique client request token. If you try to create a new dimension with the same token as a dimension that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>Each dimension must have a unique client request token. If you try to create a new dimension with the same token as a dimension that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDimensionInput`](crate::input::CreateDimensionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateDimensionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateDimensionInput {
                name: self.name,
                r#type: self.r#type,
                string_values: self.string_values,
                tags: self.tags,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateDimensionInputOperationOutputAlias = crate::operation::CreateDimension;
#[doc(hidden)]
pub type CreateDimensionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateDimensionInput {
    /// Consumes the builder and constructs an Operation<[`CreateDimension`](crate::operation::CreateDimension)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDimension,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateDimensionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_20 = &_input.name;
                let input_20 = input_20.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let name = aws_smithy_http::label::fmt_string(input_20, false);
                if name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/dimensions/{name}", name = name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateDimensionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_dimension(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDimension::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDimension",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDimensionInput`](crate::input::CreateDimensionInput)
    pub fn builder() -> crate::input::create_dimension_input::Builder {
        crate::input::create_dimension_input::Builder::default()
    }
}

/// See [`CreateDomainConfigurationInput`](crate::input::CreateDomainConfigurationInput)
pub mod create_domain_configuration_input {

    /// A builder for [`CreateDomainConfigurationInput`](crate::input::CreateDomainConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_configuration_name: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) server_certificate_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) validation_certificate_arn: std::option::Option<std::string::String>,
        pub(crate) authorizer_config: std::option::Option<crate::model::AuthorizerConfig>,
        pub(crate) service_type: std::option::Option<crate::model::ServiceType>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the domain configuration. This value must be unique to a region.</p>
        pub fn domain_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the domain configuration. This value must be unique to a region.</p>
        pub fn set_domain_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.domain_configuration_name = input;
            self
        }
        /// <p>The name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The name of the domain.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Appends an item to `server_certificate_arns`.
        ///
        /// To override the contents of this collection use [`set_server_certificate_arns`](Self::set_server_certificate_arns).
        ///
        /// <p>The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for Amazon Web Services-managed domains.</p>
        pub fn server_certificate_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.server_certificate_arns.unwrap_or_default();
            v.push(input.into());
            self.server_certificate_arns = Some(v);
            self
        }
        /// <p>The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for Amazon Web Services-managed domains.</p>
        pub fn set_server_certificate_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.server_certificate_arns = input;
            self
        }
        /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for Amazon Web Services-managed domains.</p>
        pub fn validation_certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.validation_certificate_arn = Some(input.into());
            self
        }
        /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for Amazon Web Services-managed domains.</p>
        pub fn set_validation_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.validation_certificate_arn = input;
            self
        }
        /// <p>An object that specifies the authorization service for a domain.</p>
        pub fn authorizer_config(mut self, input: crate::model::AuthorizerConfig) -> Self {
            self.authorizer_config = Some(input);
            self
        }
        /// <p>An object that specifies the authorization service for a domain.</p>
        pub fn set_authorizer_config(
            mut self,
            input: std::option::Option<crate::model::AuthorizerConfig>,
        ) -> Self {
            self.authorizer_config = input;
            self
        }
        /// <p>The type of service delivered by the endpoint.</p> <note>
        /// <p>Amazon Web Services IoT Core currently supports only the <code>DATA</code> service type.</p>
        /// </note>
        pub fn service_type(mut self, input: crate::model::ServiceType) -> Self {
            self.service_type = Some(input);
            self
        }
        /// <p>The type of service delivered by the endpoint.</p> <note>
        /// <p>Amazon Web Services IoT Core currently supports only the <code>DATA</code> service type.</p>
        /// </note>
        pub fn set_service_type(
            mut self,
            input: std::option::Option<crate::model::ServiceType>,
        ) -> Self {
            self.service_type = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the domain configuration.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the domain configuration.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDomainConfigurationInput`](crate::input::CreateDomainConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateDomainConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateDomainConfigurationInput {
                domain_configuration_name: self.domain_configuration_name,
                domain_name: self.domain_name,
                server_certificate_arns: self.server_certificate_arns,
                validation_certificate_arn: self.validation_certificate_arn,
                authorizer_config: self.authorizer_config,
                service_type: self.service_type,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateDomainConfigurationInputOperationOutputAlias =
    crate::operation::CreateDomainConfiguration;
#[doc(hidden)]
pub type CreateDomainConfigurationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateDomainConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`CreateDomainConfiguration`](crate::operation::CreateDomainConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDomainConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateDomainConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_21 = &_input.domain_configuration_name;
                let input_21 = input_21.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "domain_configuration_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let domain_configuration_name = aws_smithy_http::label::fmt_string(input_21, false);
                if domain_configuration_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "domain_configuration_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/domainConfigurations/{domainConfigurationName}",
                    domainConfigurationName = domain_configuration_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateDomainConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_domain_configuration(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDomainConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDomainConfiguration",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDomainConfigurationInput`](crate::input::CreateDomainConfigurationInput)
    pub fn builder() -> crate::input::create_domain_configuration_input::Builder {
        crate::input::create_domain_configuration_input::Builder::default()
    }
}

/// See [`CreateDynamicThingGroupInput`](crate::input::CreateDynamicThingGroupInput)
pub mod create_dynamic_thing_group_input {

    /// A builder for [`CreateDynamicThingGroupInput`](crate::input::CreateDynamicThingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_group_name: std::option::Option<std::string::String>,
        pub(crate) thing_group_properties: std::option::Option<crate::model::ThingGroupProperties>,
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) query_version: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The dynamic thing group name to create.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_name = Some(input.into());
            self
        }
        /// <p>The dynamic thing group name to create.</p>
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_name = input;
            self
        }
        /// <p>The dynamic thing group properties.</p>
        pub fn thing_group_properties(mut self, input: crate::model::ThingGroupProperties) -> Self {
            self.thing_group_properties = Some(input);
            self
        }
        /// <p>The dynamic thing group properties.</p>
        pub fn set_thing_group_properties(
            mut self,
            input: std::option::Option<crate::model::ThingGroupProperties>,
        ) -> Self {
            self.thing_group_properties = input;
            self
        }
        /// <p>The dynamic thing group index name.</p> <note>
        /// <p>Currently one index is supported: <code>AWS_Things</code>.</p>
        /// </note>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The dynamic thing group index name.</p> <note>
        /// <p>Currently one index is supported: <code>AWS_Things</code>.</p>
        /// </note>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>The dynamic thing group search query string.</p>
        /// <p>See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html">Query Syntax</a> for information about query string syntax.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The dynamic thing group search query string.</p>
        /// <p>See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html">Query Syntax</a> for information about query string syntax.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The dynamic thing group query version.</p> <note>
        /// <p>Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.</p>
        /// </note>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_version = Some(input.into());
            self
        }
        /// <p>The dynamic thing group query version.</p> <note>
        /// <p>Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.</p>
        /// </note>
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_version = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the dynamic thing group.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the dynamic thing group.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDynamicThingGroupInput`](crate::input::CreateDynamicThingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateDynamicThingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateDynamicThingGroupInput {
                thing_group_name: self.thing_group_name,
                thing_group_properties: self.thing_group_properties,
                index_name: self.index_name,
                query_string: self.query_string,
                query_version: self.query_version,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateDynamicThingGroupInputOperationOutputAlias =
    crate::operation::CreateDynamicThingGroup;
#[doc(hidden)]
pub type CreateDynamicThingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateDynamicThingGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateDynamicThingGroup`](crate::operation::CreateDynamicThingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDynamicThingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateDynamicThingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_22 = &_input.thing_group_name;
                let input_22 = input_22.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_group_name = aws_smithy_http::label::fmt_string(input_22, false);
                if thing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/dynamic-thing-groups/{thingGroupName}",
                    thingGroupName = thing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateDynamicThingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_dynamic_thing_group(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDynamicThingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDynamicThingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDynamicThingGroupInput`](crate::input::CreateDynamicThingGroupInput)
    pub fn builder() -> crate::input::create_dynamic_thing_group_input::Builder {
        crate::input::create_dynamic_thing_group_input::Builder::default()
    }
}

/// See [`CreateFleetMetricInput`](crate::input::CreateFleetMetricInput)
pub mod create_fleet_metric_input {

    /// A builder for [`CreateFleetMetricInput`](crate::input::CreateFleetMetricInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) aggregation_type: std::option::Option<crate::model::AggregationType>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) aggregation_field: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) query_version: std::option::Option<std::string::String>,
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<crate::model::FleetMetricUnit>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the fleet metric to create.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet metric to create.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The search query string.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The search query string.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The type of the aggregation query.</p>
        pub fn aggregation_type(mut self, input: crate::model::AggregationType) -> Self {
            self.aggregation_type = Some(input);
            self
        }
        /// <p>The type of the aggregation query.</p>
        pub fn set_aggregation_type(
            mut self,
            input: std::option::Option<crate::model::AggregationType>,
        ) -> Self {
            self.aggregation_type = input;
            self
        }
        /// <p>The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.</p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// <p>The field to aggregate.</p>
        pub fn aggregation_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.aggregation_field = Some(input.into());
            self
        }
        /// <p>The field to aggregate.</p>
        pub fn set_aggregation_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aggregation_field = input;
            self
        }
        /// <p>The fleet metric description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The fleet metric description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The query version.</p>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_version = Some(input.into());
            self
        }
        /// <p>The query version.</p>
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_version = input;
            self
        }
        /// <p>The name of the index to search.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The name of the index to search.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>Used to support unit transformation such as milliseconds to seconds. The unit must be supported by <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html">CW metric</a>. Default to null.</p>
        pub fn unit(mut self, input: crate::model::FleetMetricUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>Used to support unit transformation such as milliseconds to seconds. The unit must be supported by <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html">CW metric</a>. Default to null.</p>
        pub fn set_unit(
            mut self,
            input: std::option::Option<crate::model::FleetMetricUnit>,
        ) -> Self {
            self.unit = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata, which can be used to manage the fleet metric.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata, which can be used to manage the fleet metric.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateFleetMetricInput`](crate::input::CreateFleetMetricInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateFleetMetricInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateFleetMetricInput {
                metric_name: self.metric_name,
                query_string: self.query_string,
                aggregation_type: self.aggregation_type,
                period: self.period,
                aggregation_field: self.aggregation_field,
                description: self.description,
                query_version: self.query_version,
                index_name: self.index_name,
                unit: self.unit,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateFleetMetricInputOperationOutputAlias = crate::operation::CreateFleetMetric;
#[doc(hidden)]
pub type CreateFleetMetricInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateFleetMetricInput {
    /// Consumes the builder and constructs an Operation<[`CreateFleetMetric`](crate::operation::CreateFleetMetric)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateFleetMetric,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateFleetMetricInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_23 = &_input.metric_name;
                let input_23 = input_23.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let metric_name = aws_smithy_http::label::fmt_string(input_23, false);
                if metric_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/fleet-metric/{metricName}",
                    metricName = metric_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateFleetMetricInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_fleet_metric(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateFleetMetric::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateFleetMetric",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateFleetMetricInput`](crate::input::CreateFleetMetricInput)
    pub fn builder() -> crate::input::create_fleet_metric_input::Builder {
        crate::input::create_fleet_metric_input::Builder::default()
    }
}

/// See [`CreateJobInput`](crate::input::CreateJobInput)
pub mod create_job_input {

    /// A builder for [`CreateJobInput`](crate::input::CreateJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) targets: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) document_source: std::option::Option<std::string::String>,
        pub(crate) document: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) presigned_url_config: std::option::Option<crate::model::PresignedUrlConfig>,
        pub(crate) target_selection: std::option::Option<crate::model::TargetSelection>,
        pub(crate) job_executions_rollout_config:
            std::option::Option<crate::model::JobExecutionsRolloutConfig>,
        pub(crate) abort_config: std::option::Option<crate::model::AbortConfig>,
        pub(crate) timeout_config: std::option::Option<crate::model::TimeoutConfig>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) namespace_id: std::option::Option<std::string::String>,
        pub(crate) job_template_arn: std::option::Option<std::string::String>,
        pub(crate) job_executions_retry_config:
            std::option::Option<crate::model::JobExecutionsRetryConfig>,
        pub(crate) document_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>A job identifier which must be unique for your Amazon Web Services account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>A job identifier which must be unique for your Amazon Web Services account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Appends an item to `targets`.
        ///
        /// To override the contents of this collection use [`set_targets`](Self::set_targets).
        ///
        /// <p>A list of things and thing groups to which the job should be sent.</p>
        pub fn targets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        /// <p>A list of things and thing groups to which the job should be sent.</p>
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// <p>An S3 link to the job document. Required if you don't specify a value for <code>document</code>.</p> <note>
        /// <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
        /// <p>The placeholder link is of the following form:</p>
        /// <p> <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code> </p>
        /// <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
        /// </note>
        pub fn document_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_source = Some(input.into());
            self
        }
        /// <p>An S3 link to the job document. Required if you don't specify a value for <code>document</code>.</p> <note>
        /// <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
        /// <p>The placeholder link is of the following form:</p>
        /// <p> <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code> </p>
        /// <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
        /// </note>
        pub fn set_document_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_source = input;
            self
        }
        /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
        pub fn document(mut self, input: impl Into<std::string::String>) -> Self {
            self.document = Some(input.into());
            self
        }
        /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
        pub fn set_document(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.document = input;
            self
        }
        /// <p>A short text description of the job.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A short text description of the job.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Configuration information for pre-signed S3 URLs.</p>
        pub fn presigned_url_config(mut self, input: crate::model::PresignedUrlConfig) -> Self {
            self.presigned_url_config = Some(input);
            self
        }
        /// <p>Configuration information for pre-signed S3 URLs.</p>
        pub fn set_presigned_url_config(
            mut self,
            input: std::option::Option<crate::model::PresignedUrlConfig>,
        ) -> Self {
            self.presigned_url_config = input;
            self
        }
        /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p> <note>
        /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
        /// </note>
        pub fn target_selection(mut self, input: crate::model::TargetSelection) -> Self {
            self.target_selection = Some(input);
            self
        }
        /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p> <note>
        /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
        /// </note>
        pub fn set_target_selection(
            mut self,
            input: std::option::Option<crate::model::TargetSelection>,
        ) -> Self {
            self.target_selection = input;
            self
        }
        /// <p>Allows you to create a staged rollout of the job.</p>
        pub fn job_executions_rollout_config(
            mut self,
            input: crate::model::JobExecutionsRolloutConfig,
        ) -> Self {
            self.job_executions_rollout_config = Some(input);
            self
        }
        /// <p>Allows you to create a staged rollout of the job.</p>
        pub fn set_job_executions_rollout_config(
            mut self,
            input: std::option::Option<crate::model::JobExecutionsRolloutConfig>,
        ) -> Self {
            self.job_executions_rollout_config = input;
            self
        }
        /// <p>Allows you to create the criteria to abort a job.</p>
        pub fn abort_config(mut self, input: crate::model::AbortConfig) -> Self {
            self.abort_config = Some(input);
            self
        }
        /// <p>Allows you to create the criteria to abort a job.</p>
        pub fn set_abort_config(
            mut self,
            input: std::option::Option<crate::model::AbortConfig>,
        ) -> Self {
            self.abort_config = input;
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
        pub fn timeout_config(mut self, input: crate::model::TimeoutConfig) -> Self {
            self.timeout_config = Some(input);
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
        pub fn set_timeout_config(
            mut self,
            input: std::option::Option<crate::model::TimeoutConfig>,
        ) -> Self {
            self.timeout_config = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the job.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the job.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_id = Some(input.into());
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace_id = input;
            self
        }
        /// <p>The ARN of the job template used to create the job.</p>
        pub fn job_template_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_template_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the job template used to create the job.</p>
        pub fn set_job_template_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_template_arn = input;
            self
        }
        /// <p>Allows you to create the criteria to retry a job.</p>
        pub fn job_executions_retry_config(
            mut self,
            input: crate::model::JobExecutionsRetryConfig,
        ) -> Self {
            self.job_executions_retry_config = Some(input);
            self
        }
        /// <p>Allows you to create the criteria to retry a job.</p>
        pub fn set_job_executions_retry_config(
            mut self,
            input: std::option::Option<crate::model::JobExecutionsRetryConfig>,
        ) -> Self {
            self.job_executions_retry_config = input;
            self
        }
        /// Adds a key-value pair to `document_parameters`.
        ///
        /// To override the contents of this collection use [`set_document_parameters`](Self::set_document_parameters).
        ///
        /// <p>Parameters of an Amazon Web Services managed template that you can specify to create the job document.</p> <note>
        /// <p> <code>documentParameters</code> can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.</p>
        /// </note>
        pub fn document_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.document_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.document_parameters = Some(hash_map);
            self
        }
        /// <p>Parameters of an Amazon Web Services managed template that you can specify to create the job document.</p> <note>
        /// <p> <code>documentParameters</code> can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.</p>
        /// </note>
        pub fn set_document_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.document_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateJobInput`](crate::input::CreateJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateJobInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateJobInput {
                job_id: self.job_id,
                targets: self.targets,
                document_source: self.document_source,
                document: self.document,
                description: self.description,
                presigned_url_config: self.presigned_url_config,
                target_selection: self.target_selection,
                job_executions_rollout_config: self.job_executions_rollout_config,
                abort_config: self.abort_config,
                timeout_config: self.timeout_config,
                tags: self.tags,
                namespace_id: self.namespace_id,
                job_template_arn: self.job_template_arn,
                job_executions_retry_config: self.job_executions_retry_config,
                document_parameters: self.document_parameters,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateJobInputOperationOutputAlias = crate::operation::CreateJob;
#[doc(hidden)]
pub type CreateJobInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateJobInput {
    /// Consumes the builder and constructs an Operation<[`CreateJob`](crate::operation::CreateJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateJob,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateJobInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_24 = &_input.job_id;
                let input_24 = input_24.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_id = aws_smithy_http::label::fmt_string(input_24, false);
                if job_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/jobs/{jobId}", jobId = job_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateJobInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_job(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::CreateJob::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "CreateJob",
                    "iot",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateJobInput`](crate::input::CreateJobInput)
    pub fn builder() -> crate::input::create_job_input::Builder {
        crate::input::create_job_input::Builder::default()
    }
}

/// See [`CreateJobTemplateInput`](crate::input::CreateJobTemplateInput)
pub mod create_job_template_input {

    /// A builder for [`CreateJobTemplateInput`](crate::input::CreateJobTemplateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_template_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) document_source: std::option::Option<std::string::String>,
        pub(crate) document: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) presigned_url_config: std::option::Option<crate::model::PresignedUrlConfig>,
        pub(crate) job_executions_rollout_config:
            std::option::Option<crate::model::JobExecutionsRolloutConfig>,
        pub(crate) abort_config: std::option::Option<crate::model::AbortConfig>,
        pub(crate) timeout_config: std::option::Option<crate::model::TimeoutConfig>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) job_executions_retry_config:
            std::option::Option<crate::model::JobExecutionsRetryConfig>,
    }
    impl Builder {
        /// <p>A unique identifier for the job template. We recommend using a UUID. Alpha-numeric characters, "-", and "_" are valid for use here.</p>
        pub fn job_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the job template. We recommend using a UUID. Alpha-numeric characters, "-", and "_" are valid for use here.</p>
        pub fn set_job_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_template_id = input;
            self
        }
        /// <p>The ARN of the job to use as the basis for the job template.</p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the job to use as the basis for the job template.</p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>An S3 link to the job document to use in the template. Required if you don't specify a value for <code>document</code>.</p> <note>
        /// <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
        /// <p>The placeholder link is of the following form:</p>
        /// <p> <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code> </p>
        /// <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
        /// </note>
        pub fn document_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_source = Some(input.into());
            self
        }
        /// <p>An S3 link to the job document to use in the template. Required if you don't specify a value for <code>document</code>.</p> <note>
        /// <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
        /// <p>The placeholder link is of the following form:</p>
        /// <p> <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code> </p>
        /// <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
        /// </note>
        pub fn set_document_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_source = input;
            self
        }
        /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
        pub fn document(mut self, input: impl Into<std::string::String>) -> Self {
            self.document = Some(input.into());
            self
        }
        /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
        pub fn set_document(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.document = input;
            self
        }
        /// <p>A description of the job document.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the job document.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Configuration for pre-signed S3 URLs.</p>
        pub fn presigned_url_config(mut self, input: crate::model::PresignedUrlConfig) -> Self {
            self.presigned_url_config = Some(input);
            self
        }
        /// <p>Configuration for pre-signed S3 URLs.</p>
        pub fn set_presigned_url_config(
            mut self,
            input: std::option::Option<crate::model::PresignedUrlConfig>,
        ) -> Self {
            self.presigned_url_config = input;
            self
        }
        /// <p>Allows you to create a staged rollout of a job.</p>
        pub fn job_executions_rollout_config(
            mut self,
            input: crate::model::JobExecutionsRolloutConfig,
        ) -> Self {
            self.job_executions_rollout_config = Some(input);
            self
        }
        /// <p>Allows you to create a staged rollout of a job.</p>
        pub fn set_job_executions_rollout_config(
            mut self,
            input: std::option::Option<crate::model::JobExecutionsRolloutConfig>,
        ) -> Self {
            self.job_executions_rollout_config = input;
            self
        }
        /// <p>The criteria that determine when and how a job abort takes place.</p>
        pub fn abort_config(mut self, input: crate::model::AbortConfig) -> Self {
            self.abort_config = Some(input);
            self
        }
        /// <p>The criteria that determine when and how a job abort takes place.</p>
        pub fn set_abort_config(
            mut self,
            input: std::option::Option<crate::model::AbortConfig>,
        ) -> Self {
            self.abort_config = input;
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
        pub fn timeout_config(mut self, input: crate::model::TimeoutConfig) -> Self {
            self.timeout_config = Some(input);
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
        pub fn set_timeout_config(
            mut self,
            input: std::option::Option<crate::model::TimeoutConfig>,
        ) -> Self {
            self.timeout_config = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the job template.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the job template.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Allows you to create the criteria to retry a job.</p>
        pub fn job_executions_retry_config(
            mut self,
            input: crate::model::JobExecutionsRetryConfig,
        ) -> Self {
            self.job_executions_retry_config = Some(input);
            self
        }
        /// <p>Allows you to create the criteria to retry a job.</p>
        pub fn set_job_executions_retry_config(
            mut self,
            input: std::option::Option<crate::model::JobExecutionsRetryConfig>,
        ) -> Self {
            self.job_executions_retry_config = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateJobTemplateInput`](crate::input::CreateJobTemplateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateJobTemplateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateJobTemplateInput {
                job_template_id: self.job_template_id,
                job_arn: self.job_arn,
                document_source: self.document_source,
                document: self.document,
                description: self.description,
                presigned_url_config: self.presigned_url_config,
                job_executions_rollout_config: self.job_executions_rollout_config,
                abort_config: self.abort_config,
                timeout_config: self.timeout_config,
                tags: self.tags,
                job_executions_retry_config: self.job_executions_retry_config,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateJobTemplateInputOperationOutputAlias = crate::operation::CreateJobTemplate;
#[doc(hidden)]
pub type CreateJobTemplateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateJobTemplateInput {
    /// Consumes the builder and constructs an Operation<[`CreateJobTemplate`](crate::operation::CreateJobTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateJobTemplate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateJobTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_25 = &_input.job_template_id;
                let input_25 = input_25.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_template_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_template_id = aws_smithy_http::label::fmt_string(input_25, false);
                if job_template_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_template_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/job-templates/{jobTemplateId}",
                    jobTemplateId = job_template_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateJobTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_job_template(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateJobTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateJobTemplate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateJobTemplateInput`](crate::input::CreateJobTemplateInput)
    pub fn builder() -> crate::input::create_job_template_input::Builder {
        crate::input::create_job_template_input::Builder::default()
    }
}

/// See [`CreateKeysAndCertificateInput`](crate::input::CreateKeysAndCertificateInput)
pub mod create_keys_and_certificate_input {

    /// A builder for [`CreateKeysAndCertificateInput`](crate::input::CreateKeysAndCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) set_as_active: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Specifies whether the certificate is active.</p>
        pub fn set_as_active(mut self, input: bool) -> Self {
            self.set_as_active = Some(input);
            self
        }
        /// <p>Specifies whether the certificate is active.</p>
        pub fn set_set_as_active(mut self, input: std::option::Option<bool>) -> Self {
            self.set_as_active = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateKeysAndCertificateInput`](crate::input::CreateKeysAndCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateKeysAndCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateKeysAndCertificateInput {
                set_as_active: self.set_as_active.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type CreateKeysAndCertificateInputOperationOutputAlias =
    crate::operation::CreateKeysAndCertificate;
#[doc(hidden)]
pub type CreateKeysAndCertificateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateKeysAndCertificateInput {
    /// Consumes the builder and constructs an Operation<[`CreateKeysAndCertificate`](crate::operation::CreateKeysAndCertificate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateKeysAndCertificate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateKeysAndCertificateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/keys-and-certificate").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::CreateKeysAndCertificateInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.set_as_active {
                    query.push_kv(
                        "setAsActive",
                        aws_smithy_types::primitive::Encoder::from(_input.set_as_active).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateKeysAndCertificateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateKeysAndCertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateKeysAndCertificate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateKeysAndCertificateInput`](crate::input::CreateKeysAndCertificateInput)
    pub fn builder() -> crate::input::create_keys_and_certificate_input::Builder {
        crate::input::create_keys_and_certificate_input::Builder::default()
    }
}

/// See [`CreateMitigationActionInput`](crate::input::CreateMitigationActionInput)
pub mod create_mitigation_action_input {

    /// A builder for [`CreateMitigationActionInput`](crate::input::CreateMitigationActionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_name: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) action_params: std::option::Option<crate::model::MitigationActionParams>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).</p>
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input;
            self
        }
        /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>Defines the type of action and the parameters for that action.</p>
        pub fn action_params(mut self, input: crate::model::MitigationActionParams) -> Self {
            self.action_params = Some(input);
            self
        }
        /// <p>Defines the type of action and the parameters for that action.</p>
        pub fn set_action_params(
            mut self,
            input: std::option::Option<crate::model::MitigationActionParams>,
        ) -> Self {
            self.action_params = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the mitigation action.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the mitigation action.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateMitigationActionInput`](crate::input::CreateMitigationActionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateMitigationActionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateMitigationActionInput {
                action_name: self.action_name,
                role_arn: self.role_arn,
                action_params: self.action_params,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateMitigationActionInputOperationOutputAlias = crate::operation::CreateMitigationAction;
#[doc(hidden)]
pub type CreateMitigationActionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateMitigationActionInput {
    /// Consumes the builder and constructs an Operation<[`CreateMitigationAction`](crate::operation::CreateMitigationAction)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateMitigationAction,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateMitigationActionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_26 = &_input.action_name;
                let input_26 = input_26.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "action_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let action_name = aws_smithy_http::label::fmt_string(input_26, false);
                if action_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "action_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/mitigationactions/actions/{actionName}",
                    actionName = action_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateMitigationActionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_mitigation_action(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateMitigationAction::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateMitigationAction",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateMitigationActionInput`](crate::input::CreateMitigationActionInput)
    pub fn builder() -> crate::input::create_mitigation_action_input::Builder {
        crate::input::create_mitigation_action_input::Builder::default()
    }
}

/// See [`CreateOtaUpdateInput`](crate::input::CreateOtaUpdateInput)
pub mod create_ota_update_input {

    /// A builder for [`CreateOtaUpdateInput`](crate::input::CreateOtaUpdateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ota_update_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) targets: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) protocols: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
        pub(crate) target_selection: std::option::Option<crate::model::TargetSelection>,
        pub(crate) aws_job_executions_rollout_config:
            std::option::Option<crate::model::AwsJobExecutionsRolloutConfig>,
        pub(crate) aws_job_presigned_url_config:
            std::option::Option<crate::model::AwsJobPresignedUrlConfig>,
        pub(crate) aws_job_abort_config: std::option::Option<crate::model::AwsJobAbortConfig>,
        pub(crate) aws_job_timeout_config: std::option::Option<crate::model::AwsJobTimeoutConfig>,
        pub(crate) files: std::option::Option<std::vec::Vec<crate::model::OtaUpdateFile>>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) additional_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the OTA update to be created.</p>
        pub fn ota_update_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ota_update_id = Some(input.into());
            self
        }
        /// <p>The ID of the OTA update to be created.</p>
        pub fn set_ota_update_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ota_update_id = input;
            self
        }
        /// <p>The description of the OTA update.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the OTA update.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `targets`.
        ///
        /// To override the contents of this collection use [`set_targets`](Self::set_targets).
        ///
        /// <p>The devices targeted to receive OTA updates.</p>
        pub fn targets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.targets.unwrap_or_default();
            v.push(input.into());
            self.targets = Some(v);
            self
        }
        /// <p>The devices targeted to receive OTA updates.</p>
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.targets = input;
            self
        }
        /// Appends an item to `protocols`.
        ///
        /// To override the contents of this collection use [`set_protocols`](Self::set_protocols).
        ///
        /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.</p>
        pub fn protocols(mut self, input: crate::model::Protocol) -> Self {
            let mut v = self.protocols.unwrap_or_default();
            v.push(input);
            self.protocols = Some(v);
            self
        }
        /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.</p>
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
        ) -> Self {
            self.protocols = input;
            self
        }
        /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
        pub fn target_selection(mut self, input: crate::model::TargetSelection) -> Self {
            self.target_selection = Some(input);
            self
        }
        /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
        pub fn set_target_selection(
            mut self,
            input: std::option::Option<crate::model::TargetSelection>,
        ) -> Self {
            self.target_selection = input;
            self
        }
        /// <p>Configuration for the rollout of OTA updates.</p>
        pub fn aws_job_executions_rollout_config(
            mut self,
            input: crate::model::AwsJobExecutionsRolloutConfig,
        ) -> Self {
            self.aws_job_executions_rollout_config = Some(input);
            self
        }
        /// <p>Configuration for the rollout of OTA updates.</p>
        pub fn set_aws_job_executions_rollout_config(
            mut self,
            input: std::option::Option<crate::model::AwsJobExecutionsRolloutConfig>,
        ) -> Self {
            self.aws_job_executions_rollout_config = input;
            self
        }
        /// <p>Configuration information for pre-signed URLs.</p>
        pub fn aws_job_presigned_url_config(
            mut self,
            input: crate::model::AwsJobPresignedUrlConfig,
        ) -> Self {
            self.aws_job_presigned_url_config = Some(input);
            self
        }
        /// <p>Configuration information for pre-signed URLs.</p>
        pub fn set_aws_job_presigned_url_config(
            mut self,
            input: std::option::Option<crate::model::AwsJobPresignedUrlConfig>,
        ) -> Self {
            self.aws_job_presigned_url_config = input;
            self
        }
        /// <p>The criteria that determine when and how a job abort takes place.</p>
        pub fn aws_job_abort_config(mut self, input: crate::model::AwsJobAbortConfig) -> Self {
            self.aws_job_abort_config = Some(input);
            self
        }
        /// <p>The criteria that determine when and how a job abort takes place.</p>
        pub fn set_aws_job_abort_config(
            mut self,
            input: std::option::Option<crate::model::AwsJobAbortConfig>,
        ) -> Self {
            self.aws_job_abort_config = input;
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
        pub fn aws_job_timeout_config(mut self, input: crate::model::AwsJobTimeoutConfig) -> Self {
            self.aws_job_timeout_config = Some(input);
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
        pub fn set_aws_job_timeout_config(
            mut self,
            input: std::option::Option<crate::model::AwsJobTimeoutConfig>,
        ) -> Self {
            self.aws_job_timeout_config = input;
            self
        }
        /// Appends an item to `files`.
        ///
        /// To override the contents of this collection use [`set_files`](Self::set_files).
        ///
        /// <p>The files to be streamed by the OTA update.</p>
        pub fn files(mut self, input: crate::model::OtaUpdateFile) -> Self {
            let mut v = self.files.unwrap_or_default();
            v.push(input);
            self.files = Some(v);
            self
        }
        /// <p>The files to be streamed by the OTA update.</p>
        pub fn set_files(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OtaUpdateFile>>,
        ) -> Self {
            self.files = input;
            self
        }
        /// <p>The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Adds a key-value pair to `additional_parameters`.
        ///
        /// To override the contents of this collection use [`set_additional_parameters`](Self::set_additional_parameters).
        ///
        /// <p>A list of additional OTA update parameters which are name-value pairs.</p>
        pub fn additional_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.additional_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.additional_parameters = Some(hash_map);
            self
        }
        /// <p>A list of additional OTA update parameters which are name-value pairs.</p>
        pub fn set_additional_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.additional_parameters = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage updates.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage updates.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateOtaUpdateInput`](crate::input::CreateOtaUpdateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateOtaUpdateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateOtaUpdateInput {
                ota_update_id: self.ota_update_id,
                description: self.description,
                targets: self.targets,
                protocols: self.protocols,
                target_selection: self.target_selection,
                aws_job_executions_rollout_config: self.aws_job_executions_rollout_config,
                aws_job_presigned_url_config: self.aws_job_presigned_url_config,
                aws_job_abort_config: self.aws_job_abort_config,
                aws_job_timeout_config: self.aws_job_timeout_config,
                files: self.files,
                role_arn: self.role_arn,
                additional_parameters: self.additional_parameters,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateOtaUpdateInputOperationOutputAlias = crate::operation::CreateOTAUpdate;
#[doc(hidden)]
pub type CreateOtaUpdateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateOtaUpdateInput {
    /// Consumes the builder and constructs an Operation<[`CreateOTAUpdate`](crate::operation::CreateOTAUpdate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateOTAUpdate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateOtaUpdateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_27 = &_input.ota_update_id;
                let input_27 = input_27.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "ota_update_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let ota_update_id = aws_smithy_http::label::fmt_string(input_27, false);
                if ota_update_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "ota_update_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/otaUpdates/{otaUpdateId}",
                    otaUpdateId = ota_update_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateOtaUpdateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_ota_update(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateOTAUpdate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateOTAUpdate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateOtaUpdateInput`](crate::input::CreateOtaUpdateInput)
    pub fn builder() -> crate::input::create_ota_update_input::Builder {
        crate::input::create_ota_update_input::Builder::default()
    }
}

/// See [`CreatePolicyInput`](crate::input::CreatePolicyInput)
pub mod create_policy_input {

    /// A builder for [`CreatePolicyInput`](crate::input::CreatePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The policy name.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The JSON document that describes the policy. <b>policyDocument</b> must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p>The JSON document that describes the policy. <b>policyDocument</b> must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.</p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the policy.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the policy.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreatePolicyInput`](crate::input::CreatePolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreatePolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreatePolicyInput {
                policy_name: self.policy_name,
                policy_document: self.policy_document,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreatePolicyInputOperationOutputAlias = crate::operation::CreatePolicy;
#[doc(hidden)]
pub type CreatePolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreatePolicyInput {
    /// Consumes the builder and constructs an Operation<[`CreatePolicy`](crate::operation::CreatePolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreatePolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreatePolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_28 = &_input.policy_name;
                let input_28 = input_28.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_28, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/policies/{policyName}", policyName = policy_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreatePolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_policy(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreatePolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreatePolicy",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreatePolicyInput`](crate::input::CreatePolicyInput)
    pub fn builder() -> crate::input::create_policy_input::Builder {
        crate::input::create_policy_input::Builder::default()
    }
}

/// See [`CreatePolicyVersionInput`](crate::input::CreatePolicyVersionInput)
pub mod create_policy_version_input {

    /// A builder for [`CreatePolicyVersionInput`](crate::input::CreatePolicyVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) set_as_default: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The policy name.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespace.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p>The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespace.</p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// <p>Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
        pub fn set_as_default(mut self, input: bool) -> Self {
            self.set_as_default = Some(input);
            self
        }
        /// <p>Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
        pub fn set_set_as_default(mut self, input: std::option::Option<bool>) -> Self {
            self.set_as_default = input;
            self
        }
        /// Consumes the builder and constructs a [`CreatePolicyVersionInput`](crate::input::CreatePolicyVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreatePolicyVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreatePolicyVersionInput {
                policy_name: self.policy_name,
                policy_document: self.policy_document,
                set_as_default: self.set_as_default.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type CreatePolicyVersionInputOperationOutputAlias = crate::operation::CreatePolicyVersion;
#[doc(hidden)]
pub type CreatePolicyVersionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreatePolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreatePolicyVersion`](crate::operation::CreatePolicyVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreatePolicyVersion,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreatePolicyVersionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_29 = &_input.policy_name;
                let input_29 = input_29.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_29, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/policies/{policyName}/version",
                    policyName = policy_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::CreatePolicyVersionInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.set_as_default {
                    query.push_kv(
                        "setAsDefault",
                        aws_smithy_types::primitive::Encoder::from(_input.set_as_default).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreatePolicyVersionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_policy_version(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreatePolicyVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreatePolicyVersion",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreatePolicyVersionInput`](crate::input::CreatePolicyVersionInput)
    pub fn builder() -> crate::input::create_policy_version_input::Builder {
        crate::input::create_policy_version_input::Builder::default()
    }
}

/// See [`CreateProvisioningClaimInput`](crate::input::CreateProvisioningClaimInput)
pub mod create_provisioning_claim_input {

    /// A builder for [`CreateProvisioningClaimInput`](crate::input::CreateProvisioningClaimInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the provisioning template to use.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the provisioning template to use.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProvisioningClaimInput`](crate::input::CreateProvisioningClaimInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateProvisioningClaimInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateProvisioningClaimInput {
                template_name: self.template_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateProvisioningClaimInputOperationOutputAlias =
    crate::operation::CreateProvisioningClaim;
#[doc(hidden)]
pub type CreateProvisioningClaimInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateProvisioningClaimInput {
    /// Consumes the builder and constructs an Operation<[`CreateProvisioningClaim`](crate::operation::CreateProvisioningClaim)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateProvisioningClaim,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateProvisioningClaimInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_30 = &_input.template_name;
                let input_30 = input_30.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let template_name = aws_smithy_http::label::fmt_string(input_30, false);
                if template_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/provisioning-templates/{templateName}/provisioning-claim",
                    templateName = template_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateProvisioningClaimInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateProvisioningClaim::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateProvisioningClaim",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateProvisioningClaimInput`](crate::input::CreateProvisioningClaimInput)
    pub fn builder() -> crate::input::create_provisioning_claim_input::Builder {
        crate::input::create_provisioning_claim_input::Builder::default()
    }
}

/// See [`CreateProvisioningTemplateInput`](crate::input::CreateProvisioningTemplateInput)
pub mod create_provisioning_template_input {

    /// A builder for [`CreateProvisioningTemplateInput`](crate::input::CreateProvisioningTemplateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) template_body: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) provisioning_role_arn: std::option::Option<std::string::String>,
        pub(crate) pre_provisioning_hook: std::option::Option<crate::model::ProvisioningHook>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the fleet provisioning template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet provisioning template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The description of the fleet provisioning template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the fleet provisioning template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The JSON formatted contents of the fleet provisioning template.</p>
        pub fn template_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_body = Some(input.into());
            self
        }
        /// <p>The JSON formatted contents of the fleet provisioning template.</p>
        pub fn set_template_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_body = input;
            self
        }
        /// <p>True to enable the fleet provisioning template, otherwise false.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True to enable the fleet provisioning template, otherwise false.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The role ARN for the role associated with the fleet provisioning template. This IoT role grants permission to provision a device.</p>
        pub fn provisioning_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_role_arn = Some(input.into());
            self
        }
        /// <p>The role ARN for the role associated with the fleet provisioning template. This IoT role grants permission to provision a device.</p>
        pub fn set_provisioning_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_role_arn = input;
            self
        }
        /// <p>Creates a pre-provisioning hook template.</p>
        pub fn pre_provisioning_hook(mut self, input: crate::model::ProvisioningHook) -> Self {
            self.pre_provisioning_hook = Some(input);
            self
        }
        /// <p>Creates a pre-provisioning hook template.</p>
        pub fn set_pre_provisioning_hook(
            mut self,
            input: std::option::Option<crate::model::ProvisioningHook>,
        ) -> Self {
            self.pre_provisioning_hook = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the fleet provisioning template.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the fleet provisioning template.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProvisioningTemplateInput`](crate::input::CreateProvisioningTemplateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateProvisioningTemplateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateProvisioningTemplateInput {
                template_name: self.template_name,
                description: self.description,
                template_body: self.template_body,
                enabled: self.enabled.unwrap_or_default(),
                provisioning_role_arn: self.provisioning_role_arn,
                pre_provisioning_hook: self.pre_provisioning_hook,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateProvisioningTemplateInputOperationOutputAlias =
    crate::operation::CreateProvisioningTemplate;
#[doc(hidden)]
pub type CreateProvisioningTemplateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateProvisioningTemplateInput {
    /// Consumes the builder and constructs an Operation<[`CreateProvisioningTemplate`](crate::operation::CreateProvisioningTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateProvisioningTemplate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateProvisioningTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/provisioning-templates").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateProvisioningTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_provisioning_template(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateProvisioningTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateProvisioningTemplate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateProvisioningTemplateInput`](crate::input::CreateProvisioningTemplateInput)
    pub fn builder() -> crate::input::create_provisioning_template_input::Builder {
        crate::input::create_provisioning_template_input::Builder::default()
    }
}

/// See [`CreateProvisioningTemplateVersionInput`](crate::input::CreateProvisioningTemplateVersionInput)
pub mod create_provisioning_template_version_input {

    /// A builder for [`CreateProvisioningTemplateVersionInput`](crate::input::CreateProvisioningTemplateVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_body: std::option::Option<std::string::String>,
        pub(crate) set_as_default: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the fleet provisioning template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet provisioning template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The JSON formatted contents of the fleet provisioning template.</p>
        pub fn template_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_body = Some(input.into());
            self
        }
        /// <p>The JSON formatted contents of the fleet provisioning template.</p>
        pub fn set_template_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_body = input;
            self
        }
        /// <p>Sets a fleet provision template version as the default version.</p>
        pub fn set_as_default(mut self, input: bool) -> Self {
            self.set_as_default = Some(input);
            self
        }
        /// <p>Sets a fleet provision template version as the default version.</p>
        pub fn set_set_as_default(mut self, input: std::option::Option<bool>) -> Self {
            self.set_as_default = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProvisioningTemplateVersionInput`](crate::input::CreateProvisioningTemplateVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateProvisioningTemplateVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateProvisioningTemplateVersionInput {
                template_name: self.template_name,
                template_body: self.template_body,
                set_as_default: self.set_as_default.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type CreateProvisioningTemplateVersionInputOperationOutputAlias =
    crate::operation::CreateProvisioningTemplateVersion;
#[doc(hidden)]
pub type CreateProvisioningTemplateVersionInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl CreateProvisioningTemplateVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreateProvisioningTemplateVersion`](crate::operation::CreateProvisioningTemplateVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateProvisioningTemplateVersion,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateProvisioningTemplateVersionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_31 = &_input.template_name;
                let input_31 = input_31.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let template_name = aws_smithy_http::label::fmt_string(input_31, false);
                if template_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/provisioning-templates/{templateName}/versions",
                    templateName = template_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::CreateProvisioningTemplateVersionInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.set_as_default {
                    query.push_kv(
                        "setAsDefault",
                        aws_smithy_types::primitive::Encoder::from(_input.set_as_default).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateProvisioningTemplateVersionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_provisioning_template_version(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateProvisioningTemplateVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateProvisioningTemplateVersion",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateProvisioningTemplateVersionInput`](crate::input::CreateProvisioningTemplateVersionInput)
    pub fn builder() -> crate::input::create_provisioning_template_version_input::Builder {
        crate::input::create_provisioning_template_version_input::Builder::default()
    }
}

/// See [`CreateRoleAliasInput`](crate::input::CreateRoleAliasInput)
pub mod create_role_alias_input {

    /// A builder for [`CreateRoleAliasInput`](crate::input::CreateRoleAliasInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_alias: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) credential_duration_seconds: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The role alias that points to a role ARN. This allows you to change the role without having to update the device.</p>
        pub fn role_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_alias = Some(input.into());
            self
        }
        /// <p>The role alias that points to a role ARN. This allows you to change the role without having to update the device.</p>
        pub fn set_role_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_alias = input;
            self
        }
        /// <p>The role ARN.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The role ARN.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>How long (in seconds) the credentials will be valid. The default value is 3,600 seconds.</p>
        /// <p>This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.</p>
        pub fn credential_duration_seconds(mut self, input: i32) -> Self {
            self.credential_duration_seconds = Some(input);
            self
        }
        /// <p>How long (in seconds) the credentials will be valid. The default value is 3,600 seconds.</p>
        /// <p>This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.</p>
        pub fn set_credential_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.credential_duration_seconds = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the role alias.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the role alias.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRoleAliasInput`](crate::input::CreateRoleAliasInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateRoleAliasInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateRoleAliasInput {
                role_alias: self.role_alias,
                role_arn: self.role_arn,
                credential_duration_seconds: self.credential_duration_seconds,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateRoleAliasInputOperationOutputAlias = crate::operation::CreateRoleAlias;
#[doc(hidden)]
pub type CreateRoleAliasInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateRoleAliasInput {
    /// Consumes the builder and constructs an Operation<[`CreateRoleAlias`](crate::operation::CreateRoleAlias)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateRoleAlias,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateRoleAliasInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_32 = &_input.role_alias;
                let input_32 = input_32.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "role_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let role_alias = aws_smithy_http::label::fmt_string(input_32, false);
                if role_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "role_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/role-aliases/{roleAlias}", roleAlias = role_alias)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateRoleAliasInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_role_alias(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateRoleAlias::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateRoleAlias",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateRoleAliasInput`](crate::input::CreateRoleAliasInput)
    pub fn builder() -> crate::input::create_role_alias_input::Builder {
        crate::input::create_role_alias_input::Builder::default()
    }
}

/// See [`CreateScheduledAuditInput`](crate::input::CreateScheduledAuditInput)
pub mod create_scheduled_audit_input {

    /// A builder for [`CreateScheduledAuditInput`](crate::input::CreateScheduledAuditInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) frequency: std::option::Option<crate::model::AuditFrequency>,
        pub(crate) day_of_month: std::option::Option<std::string::String>,
        pub(crate) day_of_week: std::option::Option<crate::model::DayOfWeek>,
        pub(crate) target_check_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) scheduled_audit_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>How often the scheduled audit takes place, either <code>DAILY</code>, <code>WEEKLY</code>, <code>BIWEEKLY</code> or <code>MONTHLY</code>. The start time of each audit is determined by the system.</p>
        pub fn frequency(mut self, input: crate::model::AuditFrequency) -> Self {
            self.frequency = Some(input);
            self
        }
        /// <p>How often the scheduled audit takes place, either <code>DAILY</code>, <code>WEEKLY</code>, <code>BIWEEKLY</code> or <code>MONTHLY</code>. The start time of each audit is determined by the system.</p>
        pub fn set_frequency(
            mut self,
            input: std::option::Option<crate::model::AuditFrequency>,
        ) -> Self {
            self.frequency = input;
            self
        }
        /// <p>The day of the month on which the scheduled audit takes place. This can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to <code>MONTHLY</code>. If days 29 to 31 are specified, and the month doesn't have that many days, the audit takes place on the <code>LAST</code> day of the month.</p>
        pub fn day_of_month(mut self, input: impl Into<std::string::String>) -> Self {
            self.day_of_month = Some(input.into());
            self
        }
        /// <p>The day of the month on which the scheduled audit takes place. This can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to <code>MONTHLY</code>. If days 29 to 31 are specified, and the month doesn't have that many days, the audit takes place on the <code>LAST</code> day of the month.</p>
        pub fn set_day_of_month(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.day_of_month = input;
            self
        }
        /// <p>The day of the week on which the scheduled audit takes place, either <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the <code>frequency</code> parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
        pub fn day_of_week(mut self, input: crate::model::DayOfWeek) -> Self {
            self.day_of_week = Some(input);
            self
        }
        /// <p>The day of the week on which the scheduled audit takes place, either <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the <code>frequency</code> parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
        pub fn set_day_of_week(
            mut self,
            input: std::option::Option<crate::model::DayOfWeek>,
        ) -> Self {
            self.day_of_week = input;
            self
        }
        /// Appends an item to `target_check_names`.
        ///
        /// To override the contents of this collection use [`set_target_check_names`](Self::set_target_check_names).
        ///
        /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn target_check_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_check_names.unwrap_or_default();
            v.push(input.into());
            self.target_check_names = Some(v);
            self
        }
        /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn set_target_check_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_check_names = input;
            self
        }
        /// <p>The name you want to give to the scheduled audit. (Max. 128 chars)</p>
        pub fn scheduled_audit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduled_audit_name = Some(input.into());
            self
        }
        /// <p>The name you want to give to the scheduled audit. (Max. 128 chars)</p>
        pub fn set_scheduled_audit_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_audit_name = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the scheduled audit.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the scheduled audit.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateScheduledAuditInput`](crate::input::CreateScheduledAuditInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateScheduledAuditInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateScheduledAuditInput {
                frequency: self.frequency,
                day_of_month: self.day_of_month,
                day_of_week: self.day_of_week,
                target_check_names: self.target_check_names,
                scheduled_audit_name: self.scheduled_audit_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateScheduledAuditInputOperationOutputAlias = crate::operation::CreateScheduledAudit;
#[doc(hidden)]
pub type CreateScheduledAuditInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateScheduledAuditInput {
    /// Consumes the builder and constructs an Operation<[`CreateScheduledAudit`](crate::operation::CreateScheduledAudit)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateScheduledAudit,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateScheduledAuditInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_33 = &_input.scheduled_audit_name;
                let input_33 = input_33.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "scheduled_audit_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let scheduled_audit_name = aws_smithy_http::label::fmt_string(input_33, false);
                if scheduled_audit_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "scheduled_audit_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/audit/scheduledaudits/{scheduledAuditName}",
                    scheduledAuditName = scheduled_audit_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateScheduledAuditInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_scheduled_audit(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateScheduledAudit::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateScheduledAudit",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateScheduledAuditInput`](crate::input::CreateScheduledAuditInput)
    pub fn builder() -> crate::input::create_scheduled_audit_input::Builder {
        crate::input::create_scheduled_audit_input::Builder::default()
    }
}

/// See [`CreateSecurityProfileInput`](crate::input::CreateSecurityProfileInput)
pub mod create_security_profile_input {

    /// A builder for [`CreateSecurityProfileInput`](crate::input::CreateSecurityProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) security_profile_description: std::option::Option<std::string::String>,
        pub(crate) behaviors: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
        pub(crate) alert_targets: std::option::Option<
            std::collections::HashMap<crate::model::AlertTargetType, crate::model::AlertTarget>,
        >,
        pub(crate) additional_metrics_to_retain:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) additional_metrics_to_retain_v2:
            std::option::Option<std::vec::Vec<crate::model::MetricToRetain>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name you are giving to the security profile.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The name you are giving to the security profile.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p>A description of the security profile.</p>
        pub fn security_profile_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.security_profile_description = Some(input.into());
            self
        }
        /// <p>A description of the security profile.</p>
        pub fn set_security_profile_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_description = input;
            self
        }
        /// Appends an item to `behaviors`.
        ///
        /// To override the contents of this collection use [`set_behaviors`](Self::set_behaviors).
        ///
        /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
        pub fn behaviors(mut self, input: crate::model::Behavior) -> Self {
            let mut v = self.behaviors.unwrap_or_default();
            v.push(input);
            self.behaviors = Some(v);
            self
        }
        /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
        pub fn set_behaviors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
        ) -> Self {
            self.behaviors = input;
            self
        }
        /// Adds a key-value pair to `alert_targets`.
        ///
        /// To override the contents of this collection use [`set_alert_targets`](Self::set_alert_targets).
        ///
        /// <p>Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.</p>
        pub fn alert_targets(
            mut self,
            k: crate::model::AlertTargetType,
            v: crate::model::AlertTarget,
        ) -> Self {
            let mut hash_map = self.alert_targets.unwrap_or_default();
            hash_map.insert(k, v);
            self.alert_targets = Some(hash_map);
            self
        }
        /// <p>Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.</p>
        pub fn set_alert_targets(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::AlertTargetType, crate::model::AlertTarget>,
            >,
        ) -> Self {
            self.alert_targets = input;
            self
        }
        /// Appends an item to `additional_metrics_to_retain`.
        ///
        /// To override the contents of this collection use [`set_additional_metrics_to_retain`](Self::set_additional_metrics_to_retain).
        ///
        /// <p> <i>Please use <code>CreateSecurityProfileRequest$additionalMetricsToRetainV2</code> instead.</i> </p>
        /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn additional_metrics_to_retain(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.additional_metrics_to_retain.unwrap_or_default();
            v.push(input.into());
            self.additional_metrics_to_retain = Some(v);
            self
        }
        /// <p> <i>Please use <code>CreateSecurityProfileRequest$additionalMetricsToRetainV2</code> instead.</i> </p>
        /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn set_additional_metrics_to_retain(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.additional_metrics_to_retain = input;
            self
        }
        /// Appends an item to `additional_metrics_to_retain_v2`.
        ///
        /// To override the contents of this collection use [`set_additional_metrics_to_retain_v2`](Self::set_additional_metrics_to_retain_v2).
        ///
        /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn additional_metrics_to_retain_v2(
            mut self,
            input: crate::model::MetricToRetain,
        ) -> Self {
            let mut v = self.additional_metrics_to_retain_v2.unwrap_or_default();
            v.push(input);
            self.additional_metrics_to_retain_v2 = Some(v);
            self
        }
        /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn set_additional_metrics_to_retain_v2(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricToRetain>>,
        ) -> Self {
            self.additional_metrics_to_retain_v2 = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the security profile.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the security profile.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSecurityProfileInput`](crate::input::CreateSecurityProfileInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateSecurityProfileInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateSecurityProfileInput {
                security_profile_name: self.security_profile_name,
                security_profile_description: self.security_profile_description,
                behaviors: self.behaviors,
                alert_targets: self.alert_targets,
                additional_metrics_to_retain: self.additional_metrics_to_retain,
                additional_metrics_to_retain_v2: self.additional_metrics_to_retain_v2,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateSecurityProfileInputOperationOutputAlias = crate::operation::CreateSecurityProfile;
#[doc(hidden)]
pub type CreateSecurityProfileInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateSecurityProfileInput {
    /// Consumes the builder and constructs an Operation<[`CreateSecurityProfile`](crate::operation::CreateSecurityProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSecurityProfile,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateSecurityProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_34 = &_input.security_profile_name;
                let input_34 = input_34.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let security_profile_name = aws_smithy_http::label::fmt_string(input_34, false);
                if security_profile_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/security-profiles/{securityProfileName}",
                    securityProfileName = security_profile_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateSecurityProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_security_profile(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSecurityProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSecurityProfile",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSecurityProfileInput`](crate::input::CreateSecurityProfileInput)
    pub fn builder() -> crate::input::create_security_profile_input::Builder {
        crate::input::create_security_profile_input::Builder::default()
    }
}

/// See [`CreateStreamInput`](crate::input::CreateStreamInput)
pub mod create_stream_input {

    /// A builder for [`CreateStreamInput`](crate::input::CreateStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) files: std::option::Option<std::vec::Vec<crate::model::StreamFile>>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>The stream ID.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// <p>A description of the stream.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the stream.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `files`.
        ///
        /// To override the contents of this collection use [`set_files`](Self::set_files).
        ///
        /// <p>The files to stream.</p>
        pub fn files(mut self, input: crate::model::StreamFile) -> Self {
            let mut v = self.files.unwrap_or_default();
            v.push(input);
            self.files = Some(v);
            self
        }
        /// <p>The files to stream.</p>
        pub fn set_files(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamFile>>,
        ) -> Self {
            self.files = input;
            self
        }
        /// <p>An IAM role that allows the IoT service principal to access your S3 files.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>An IAM role that allows the IoT service principal to access your S3 files.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage streams.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage streams.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateStreamInput`](crate::input::CreateStreamInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateStreamInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateStreamInput {
                stream_id: self.stream_id,
                description: self.description,
                files: self.files,
                role_arn: self.role_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateStreamInputOperationOutputAlias = crate::operation::CreateStream;
#[doc(hidden)]
pub type CreateStreamInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateStreamInput {
    /// Consumes the builder and constructs an Operation<[`CreateStream`](crate::operation::CreateStream)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateStream,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateStreamInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_35 = &_input.stream_id;
                let input_35 = input_35.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "stream_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let stream_id = aws_smithy_http::label::fmt_string(input_35, false);
                if stream_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "stream_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/streams/{streamId}", streamId = stream_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateStreamInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_stream(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateStream::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateStream",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateStreamInput`](crate::input::CreateStreamInput)
    pub fn builder() -> crate::input::create_stream_input::Builder {
        crate::input::create_stream_input::Builder::default()
    }
}

/// See [`CreateThingInput`](crate::input::CreateThingInput)
pub mod create_thing_input {

    /// A builder for [`CreateThingInput`](crate::input::CreateThingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) thing_type_name: std::option::Option<std::string::String>,
        pub(crate) attribute_payload: std::option::Option<crate::model::AttributePayload>,
        pub(crate) billing_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the thing to create.</p>
        /// <p>You can't change a thing's name after you create it. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing to create.</p>
        /// <p>You can't change a thing's name after you create it. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>The name of the thing type associated with the new thing.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_type_name = Some(input.into());
            self
        }
        /// <p>The name of the thing type associated with the new thing.</p>
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_type_name = input;
            self
        }
        /// <p>The attribute payload, which consists of up to three name/value pairs in a JSON document. For example:</p>
        /// <p> <code>{\"attributes\":{\"string1\":\"string2\"}}</code> </p>
        pub fn attribute_payload(mut self, input: crate::model::AttributePayload) -> Self {
            self.attribute_payload = Some(input);
            self
        }
        /// <p>The attribute payload, which consists of up to three name/value pairs in a JSON document. For example:</p>
        /// <p> <code>{\"attributes\":{\"string1\":\"string2\"}}</code> </p>
        pub fn set_attribute_payload(
            mut self,
            input: std::option::Option<crate::model::AttributePayload>,
        ) -> Self {
            self.attribute_payload = input;
            self
        }
        /// <p>The name of the billing group the thing will be added to.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the billing group the thing will be added to.</p>
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateThingInput`](crate::input::CreateThingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateThingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateThingInput {
                thing_name: self.thing_name,
                thing_type_name: self.thing_type_name,
                attribute_payload: self.attribute_payload,
                billing_group_name: self.billing_group_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateThingInputOperationOutputAlias = crate::operation::CreateThing;
#[doc(hidden)]
pub type CreateThingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateThingInput {
    /// Consumes the builder and constructs an Operation<[`CreateThing`](crate::operation::CreateThing)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateThing,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateThingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_36 = &_input.thing_name;
                let input_36 = input_36.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_36, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/things/{thingName}", thingName = thing_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateThingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_thing(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateThing::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateThing",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateThingInput`](crate::input::CreateThingInput)
    pub fn builder() -> crate::input::create_thing_input::Builder {
        crate::input::create_thing_input::Builder::default()
    }
}

/// See [`CreateThingGroupInput`](crate::input::CreateThingGroupInput)
pub mod create_thing_group_input {

    /// A builder for [`CreateThingGroupInput`](crate::input::CreateThingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_group_name: std::option::Option<std::string::String>,
        pub(crate) parent_group_name: std::option::Option<std::string::String>,
        pub(crate) thing_group_properties: std::option::Option<crate::model::ThingGroupProperties>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The thing group name to create.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_name = Some(input.into());
            self
        }
        /// <p>The thing group name to create.</p>
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_name = input;
            self
        }
        /// <p>The name of the parent thing group.</p>
        pub fn parent_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parent_group_name = Some(input.into());
            self
        }
        /// <p>The name of the parent thing group.</p>
        pub fn set_parent_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parent_group_name = input;
            self
        }
        /// <p>The thing group properties.</p>
        pub fn thing_group_properties(mut self, input: crate::model::ThingGroupProperties) -> Self {
            self.thing_group_properties = Some(input);
            self
        }
        /// <p>The thing group properties.</p>
        pub fn set_thing_group_properties(
            mut self,
            input: std::option::Option<crate::model::ThingGroupProperties>,
        ) -> Self {
            self.thing_group_properties = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the thing group.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the thing group.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateThingGroupInput`](crate::input::CreateThingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateThingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateThingGroupInput {
                thing_group_name: self.thing_group_name,
                parent_group_name: self.parent_group_name,
                thing_group_properties: self.thing_group_properties,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateThingGroupInputOperationOutputAlias = crate::operation::CreateThingGroup;
#[doc(hidden)]
pub type CreateThingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateThingGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateThingGroup`](crate::operation::CreateThingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateThingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateThingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_37 = &_input.thing_group_name;
                let input_37 = input_37.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_group_name = aws_smithy_http::label::fmt_string(input_37, false);
                if thing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-groups/{thingGroupName}",
                    thingGroupName = thing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateThingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_thing_group(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateThingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateThingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateThingGroupInput`](crate::input::CreateThingGroupInput)
    pub fn builder() -> crate::input::create_thing_group_input::Builder {
        crate::input::create_thing_group_input::Builder::default()
    }
}

/// See [`CreateThingTypeInput`](crate::input::CreateThingTypeInput)
pub mod create_thing_type_input {

    /// A builder for [`CreateThingTypeInput`](crate::input::CreateThingTypeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_type_name: std::option::Option<std::string::String>,
        pub(crate) thing_type_properties: std::option::Option<crate::model::ThingTypeProperties>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the thing type.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_type_name = Some(input.into());
            self
        }
        /// <p>The name of the thing type.</p>
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_type_name = input;
            self
        }
        /// <p>The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.</p>
        pub fn thing_type_properties(mut self, input: crate::model::ThingTypeProperties) -> Self {
            self.thing_type_properties = Some(input);
            self
        }
        /// <p>The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.</p>
        pub fn set_thing_type_properties(
            mut self,
            input: std::option::Option<crate::model::ThingTypeProperties>,
        ) -> Self {
            self.thing_type_properties = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the thing type.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the thing type.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateThingTypeInput`](crate::input::CreateThingTypeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateThingTypeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateThingTypeInput {
                thing_type_name: self.thing_type_name,
                thing_type_properties: self.thing_type_properties,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateThingTypeInputOperationOutputAlias = crate::operation::CreateThingType;
#[doc(hidden)]
pub type CreateThingTypeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateThingTypeInput {
    /// Consumes the builder and constructs an Operation<[`CreateThingType`](crate::operation::CreateThingType)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateThingType,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateThingTypeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_38 = &_input.thing_type_name;
                let input_38 = input_38.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_type_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_type_name = aws_smithy_http::label::fmt_string(input_38, false);
                if thing_type_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_type_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-types/{thingTypeName}",
                    thingTypeName = thing_type_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateThingTypeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_thing_type(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateThingType::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateThingType",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateThingTypeInput`](crate::input::CreateThingTypeInput)
    pub fn builder() -> crate::input::create_thing_type_input::Builder {
        crate::input::create_thing_type_input::Builder::default()
    }
}

/// See [`CreateTopicRuleInput`](crate::input::CreateTopicRuleInput)
pub mod create_topic_rule_input {

    /// A builder for [`CreateTopicRuleInput`](crate::input::CreateTopicRuleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_name: std::option::Option<std::string::String>,
        pub(crate) topic_rule_payload: std::option::Option<crate::model::TopicRulePayload>,
        pub(crate) tags: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the rule.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_name = Some(input.into());
            self
        }
        /// <p>The name of the rule.</p>
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_name = input;
            self
        }
        /// <p>The rule payload.</p>
        pub fn topic_rule_payload(mut self, input: crate::model::TopicRulePayload) -> Self {
            self.topic_rule_payload = Some(input);
            self
        }
        /// <p>The rule payload.</p>
        pub fn set_topic_rule_payload(
            mut self,
            input: std::option::Option<crate::model::TopicRulePayload>,
        ) -> Self {
            self.topic_rule_payload = input;
            self
        }
        /// <p>Metadata which can be used to manage the topic rule.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, input: impl Into<std::string::String>) -> Self {
            self.tags = Some(input.into());
            self
        }
        /// <p>Metadata which can be used to manage the topic rule.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn set_tags(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTopicRuleInput`](crate::input::CreateTopicRuleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateTopicRuleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateTopicRuleInput {
                rule_name: self.rule_name,
                topic_rule_payload: self.topic_rule_payload,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateTopicRuleInputOperationOutputAlias = crate::operation::CreateTopicRule;
#[doc(hidden)]
pub type CreateTopicRuleInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateTopicRuleInput {
    /// Consumes the builder and constructs an Operation<[`CreateTopicRule`](crate::operation::CreateTopicRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateTopicRule,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateTopicRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_39 = &_input.rule_name;
                let input_39 = input_39.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let rule_name = aws_smithy_http::label::fmt_string(input_39, false);
                if rule_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/rules/{ruleName}", ruleName = rule_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateTopicRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_topic_rule(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_create_topic_rule_input(
                &self.topic_rule_payload,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateTopicRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateTopicRule",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateTopicRuleInput`](crate::input::CreateTopicRuleInput)
    pub fn builder() -> crate::input::create_topic_rule_input::Builder {
        crate::input::create_topic_rule_input::Builder::default()
    }
}

/// See [`CreateTopicRuleDestinationInput`](crate::input::CreateTopicRuleDestinationInput)
pub mod create_topic_rule_destination_input {

    /// A builder for [`CreateTopicRuleDestinationInput`](crate::input::CreateTopicRuleDestinationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_configuration:
            std::option::Option<crate::model::TopicRuleDestinationConfiguration>,
    }
    impl Builder {
        /// <p>The topic rule destination configuration.</p>
        pub fn destination_configuration(
            mut self,
            input: crate::model::TopicRuleDestinationConfiguration,
        ) -> Self {
            self.destination_configuration = Some(input);
            self
        }
        /// <p>The topic rule destination configuration.</p>
        pub fn set_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::TopicRuleDestinationConfiguration>,
        ) -> Self {
            self.destination_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTopicRuleDestinationInput`](crate::input::CreateTopicRuleDestinationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateTopicRuleDestinationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateTopicRuleDestinationInput {
                destination_configuration: self.destination_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateTopicRuleDestinationInputOperationOutputAlias =
    crate::operation::CreateTopicRuleDestination;
#[doc(hidden)]
pub type CreateTopicRuleDestinationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateTopicRuleDestinationInput {
    /// Consumes the builder and constructs an Operation<[`CreateTopicRuleDestination`](crate::operation::CreateTopicRuleDestination)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateTopicRuleDestination,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateTopicRuleDestinationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/destinations").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateTopicRuleDestinationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_topic_rule_destination(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateTopicRuleDestination::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateTopicRuleDestination",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateTopicRuleDestinationInput`](crate::input::CreateTopicRuleDestinationInput)
    pub fn builder() -> crate::input::create_topic_rule_destination_input::Builder {
        crate::input::create_topic_rule_destination_input::Builder::default()
    }
}

/// See [`DeleteAccountAuditConfigurationInput`](crate::input::DeleteAccountAuditConfigurationInput)
pub mod delete_account_audit_configuration_input {

    /// A builder for [`DeleteAccountAuditConfigurationInput`](crate::input::DeleteAccountAuditConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delete_scheduled_audits: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If true, all scheduled audits are deleted.</p>
        pub fn delete_scheduled_audits(mut self, input: bool) -> Self {
            self.delete_scheduled_audits = Some(input);
            self
        }
        /// <p>If true, all scheduled audits are deleted.</p>
        pub fn set_delete_scheduled_audits(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_scheduled_audits = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAccountAuditConfigurationInput`](crate::input::DeleteAccountAuditConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAccountAuditConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAccountAuditConfigurationInput {
                delete_scheduled_audits: self.delete_scheduled_audits.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAccountAuditConfigurationInputOperationOutputAlias =
    crate::operation::DeleteAccountAuditConfiguration;
#[doc(hidden)]
pub type DeleteAccountAuditConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DeleteAccountAuditConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAccountAuditConfiguration`](crate::operation::DeleteAccountAuditConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAccountAuditConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAccountAuditConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/configuration").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteAccountAuditConfigurationInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.delete_scheduled_audits {
                    query.push_kv(
                        "deleteScheduledAudits",
                        aws_smithy_types::primitive::Encoder::from(_input.delete_scheduled_audits)
                            .encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAccountAuditConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAccountAuditConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAccountAuditConfiguration",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAccountAuditConfigurationInput`](crate::input::DeleteAccountAuditConfigurationInput)
    pub fn builder() -> crate::input::delete_account_audit_configuration_input::Builder {
        crate::input::delete_account_audit_configuration_input::Builder::default()
    }
}

/// See [`DeleteAuditSuppressionInput`](crate::input::DeleteAuditSuppressionInput)
pub mod delete_audit_suppression_input {

    /// A builder for [`DeleteAuditSuppressionInput`](crate::input::DeleteAuditSuppressionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) check_name: std::option::Option<std::string::String>,
        pub(crate) resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
    }
    impl Builder {
        /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.check_name = Some(input.into());
            self
        }
        /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.check_name = input;
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.resource_identifier = Some(input);
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.resource_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAuditSuppressionInput`](crate::input::DeleteAuditSuppressionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAuditSuppressionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAuditSuppressionInput {
                check_name: self.check_name,
                resource_identifier: self.resource_identifier,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAuditSuppressionInputOperationOutputAlias = crate::operation::DeleteAuditSuppression;
#[doc(hidden)]
pub type DeleteAuditSuppressionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteAuditSuppressionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAuditSuppression`](crate::operation::DeleteAuditSuppression)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAuditSuppression,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAuditSuppressionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/suppressions/delete").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAuditSuppressionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_delete_audit_suppression(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAuditSuppression::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAuditSuppression",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAuditSuppressionInput`](crate::input::DeleteAuditSuppressionInput)
    pub fn builder() -> crate::input::delete_audit_suppression_input::Builder {
        crate::input::delete_audit_suppression_input::Builder::default()
    }
}

/// See [`DeleteAuthorizerInput`](crate::input::DeleteAuthorizerInput)
pub mod delete_authorizer_input {

    /// A builder for [`DeleteAuthorizerInput`](crate::input::DeleteAuthorizerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authorizer_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the authorizer to delete.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorizer_name = Some(input.into());
            self
        }
        /// <p>The name of the authorizer to delete.</p>
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorizer_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAuthorizerInput`](crate::input::DeleteAuthorizerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAuthorizerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAuthorizerInput {
                authorizer_name: self.authorizer_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAuthorizerInputOperationOutputAlias = crate::operation::DeleteAuthorizer;
#[doc(hidden)]
pub type DeleteAuthorizerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteAuthorizerInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAuthorizer`](crate::operation::DeleteAuthorizer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAuthorizer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAuthorizerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_40 = &_input.authorizer_name;
                let input_40 = input_40.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "authorizer_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let authorizer_name = aws_smithy_http::label::fmt_string(input_40, false);
                if authorizer_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "authorizer_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/authorizer/{authorizerName}",
                    authorizerName = authorizer_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAuthorizerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAuthorizer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAuthorizer",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAuthorizerInput`](crate::input::DeleteAuthorizerInput)
    pub fn builder() -> crate::input::delete_authorizer_input::Builder {
        crate::input::delete_authorizer_input::Builder::default()
    }
}

/// See [`DeleteBillingGroupInput`](crate::input::DeleteBillingGroupInput)
pub mod delete_billing_group_input {

    /// A builder for [`DeleteBillingGroupInput`](crate::input::DeleteBillingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_group_name: std::option::Option<std::string::String>,
        pub(crate) expected_version: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the billing group.</p>
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_name = input;
            self
        }
        /// <p>The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBillingGroupInput`](crate::input::DeleteBillingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBillingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBillingGroupInput {
                billing_group_name: self.billing_group_name,
                expected_version: self.expected_version,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBillingGroupInputOperationOutputAlias = crate::operation::DeleteBillingGroup;
#[doc(hidden)]
pub type DeleteBillingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteBillingGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBillingGroup`](crate::operation::DeleteBillingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteBillingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteBillingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_41 = &_input.billing_group_name;
                let input_41 = input_41.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "billing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let billing_group_name = aws_smithy_http::label::fmt_string(input_41, false);
                if billing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "billing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/billing-groups/{billingGroupName}",
                    billingGroupName = billing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteBillingGroupInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_42) = &_input.expected_version {
                    query.push_kv(
                        "expectedVersion",
                        aws_smithy_types::primitive::Encoder::from(*inner_42).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteBillingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBillingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteBillingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteBillingGroupInput`](crate::input::DeleteBillingGroupInput)
    pub fn builder() -> crate::input::delete_billing_group_input::Builder {
        crate::input::delete_billing_group_input::Builder::default()
    }
}

/// See [`DeleteCaCertificateInput`](crate::input::DeleteCaCertificateInput)
pub mod delete_ca_certificate_input {

    /// A builder for [`DeleteCaCertificateInput`](crate::input::DeleteCaCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(input.into());
            self
        }
        /// <p>The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCaCertificateInput`](crate::input::DeleteCaCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteCaCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteCaCertificateInput {
                certificate_id: self.certificate_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteCaCertificateInputOperationOutputAlias = crate::operation::DeleteCACertificate;
#[doc(hidden)]
pub type DeleteCaCertificateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteCaCertificateInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCACertificate`](crate::operation::DeleteCACertificate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCACertificate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteCaCertificateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_43 = &_input.certificate_id;
                let input_43 = input_43.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let certificate_id = aws_smithy_http::label::fmt_string(input_43, false);
                if certificate_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/cacertificate/{certificateId}",
                    certificateId = certificate_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteCaCertificateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCACertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCACertificate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteCaCertificateInput`](crate::input::DeleteCaCertificateInput)
    pub fn builder() -> crate::input::delete_ca_certificate_input::Builder {
        crate::input::delete_ca_certificate_input::Builder::default()
    }
}

/// See [`DeleteCertificateInput`](crate::input::DeleteCertificateInput)
pub mod delete_certificate_input {

    /// A builder for [`DeleteCertificateInput`](crate::input::DeleteCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_id: std::option::Option<std::string::String>,
        pub(crate) force_delete: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(input.into());
            self
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_id = input;
            self
        }
        /// <p>Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.</p>
        pub fn force_delete(mut self, input: bool) -> Self {
            self.force_delete = Some(input);
            self
        }
        /// <p>Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.</p>
        pub fn set_force_delete(mut self, input: std::option::Option<bool>) -> Self {
            self.force_delete = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCertificateInput`](crate::input::DeleteCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteCertificateInput {
                certificate_id: self.certificate_id,
                force_delete: self.force_delete.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteCertificateInputOperationOutputAlias = crate::operation::DeleteCertificate;
#[doc(hidden)]
pub type DeleteCertificateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteCertificateInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCertificate`](crate::operation::DeleteCertificate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCertificate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteCertificateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_44 = &_input.certificate_id;
                let input_44 = input_44.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let certificate_id = aws_smithy_http::label::fmt_string(input_44, false);
                if certificate_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/certificates/{certificateId}",
                    certificateId = certificate_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteCertificateInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.force_delete {
                    query.push_kv(
                        "forceDelete",
                        aws_smithy_types::primitive::Encoder::from(_input.force_delete).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteCertificateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCertificate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteCertificateInput`](crate::input::DeleteCertificateInput)
    pub fn builder() -> crate::input::delete_certificate_input::Builder {
        crate::input::delete_certificate_input::Builder::default()
    }
}

/// See [`DeleteCustomMetricInput`](crate::input::DeleteCustomMetricInput)
pub mod delete_custom_metric_input {

    /// A builder for [`DeleteCustomMetricInput`](crate::input::DeleteCustomMetricInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the custom metric. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p> The name of the custom metric. </p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCustomMetricInput`](crate::input::DeleteCustomMetricInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteCustomMetricInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteCustomMetricInput {
                metric_name: self.metric_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteCustomMetricInputOperationOutputAlias = crate::operation::DeleteCustomMetric;
#[doc(hidden)]
pub type DeleteCustomMetricInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteCustomMetricInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCustomMetric`](crate::operation::DeleteCustomMetric)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCustomMetric,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteCustomMetricInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_45 = &_input.metric_name;
                let input_45 = input_45.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let metric_name = aws_smithy_http::label::fmt_string(input_45, false);
                if metric_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/custom-metric/{metricName}",
                    metricName = metric_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteCustomMetricInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCustomMetric::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCustomMetric",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteCustomMetricInput`](crate::input::DeleteCustomMetricInput)
    pub fn builder() -> crate::input::delete_custom_metric_input::Builder {
        crate::input::delete_custom_metric_input::Builder::default()
    }
}

/// See [`DeleteDimensionInput`](crate::input::DeleteDimensionInput)
pub mod delete_dimension_input {

    /// A builder for [`DeleteDimensionInput`](crate::input::DeleteDimensionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the dimension that you want to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The unique identifier for the dimension that you want to delete.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDimensionInput`](crate::input::DeleteDimensionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteDimensionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteDimensionInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type DeleteDimensionInputOperationOutputAlias = crate::operation::DeleteDimension;
#[doc(hidden)]
pub type DeleteDimensionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteDimensionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDimension`](crate::operation::DeleteDimension)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDimension,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteDimensionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_46 = &_input.name;
                let input_46 = input_46.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let name = aws_smithy_http::label::fmt_string(input_46, false);
                if name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/dimensions/{name}", name = name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteDimensionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDimension::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDimension",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteDimensionInput`](crate::input::DeleteDimensionInput)
    pub fn builder() -> crate::input::delete_dimension_input::Builder {
        crate::input::delete_dimension_input::Builder::default()
    }
}

/// See [`DeleteDomainConfigurationInput`](crate::input::DeleteDomainConfigurationInput)
pub mod delete_domain_configuration_input {

    /// A builder for [`DeleteDomainConfigurationInput`](crate::input::DeleteDomainConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_configuration_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the domain configuration to be deleted.</p>
        pub fn domain_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the domain configuration to be deleted.</p>
        pub fn set_domain_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.domain_configuration_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDomainConfigurationInput`](crate::input::DeleteDomainConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteDomainConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteDomainConfigurationInput {
                domain_configuration_name: self.domain_configuration_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteDomainConfigurationInputOperationOutputAlias =
    crate::operation::DeleteDomainConfiguration;
#[doc(hidden)]
pub type DeleteDomainConfigurationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteDomainConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDomainConfiguration`](crate::operation::DeleteDomainConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDomainConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteDomainConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_47 = &_input.domain_configuration_name;
                let input_47 = input_47.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "domain_configuration_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let domain_configuration_name = aws_smithy_http::label::fmt_string(input_47, false);
                if domain_configuration_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "domain_configuration_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/domainConfigurations/{domainConfigurationName}",
                    domainConfigurationName = domain_configuration_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteDomainConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDomainConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDomainConfiguration",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteDomainConfigurationInput`](crate::input::DeleteDomainConfigurationInput)
    pub fn builder() -> crate::input::delete_domain_configuration_input::Builder {
        crate::input::delete_domain_configuration_input::Builder::default()
    }
}

/// See [`DeleteDynamicThingGroupInput`](crate::input::DeleteDynamicThingGroupInput)
pub mod delete_dynamic_thing_group_input {

    /// A builder for [`DeleteDynamicThingGroupInput`](crate::input::DeleteDynamicThingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_group_name: std::option::Option<std::string::String>,
        pub(crate) expected_version: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the dynamic thing group to delete.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the dynamic thing group to delete.</p>
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_name = input;
            self
        }
        /// <p>The expected version of the dynamic thing group to delete.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the dynamic thing group to delete.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDynamicThingGroupInput`](crate::input::DeleteDynamicThingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteDynamicThingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteDynamicThingGroupInput {
                thing_group_name: self.thing_group_name,
                expected_version: self.expected_version,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteDynamicThingGroupInputOperationOutputAlias =
    crate::operation::DeleteDynamicThingGroup;
#[doc(hidden)]
pub type DeleteDynamicThingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteDynamicThingGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDynamicThingGroup`](crate::operation::DeleteDynamicThingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDynamicThingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteDynamicThingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_48 = &_input.thing_group_name;
                let input_48 = input_48.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_group_name = aws_smithy_http::label::fmt_string(input_48, false);
                if thing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/dynamic-thing-groups/{thingGroupName}",
                    thingGroupName = thing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteDynamicThingGroupInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_49) = &_input.expected_version {
                    query.push_kv(
                        "expectedVersion",
                        aws_smithy_types::primitive::Encoder::from(*inner_49).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteDynamicThingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDynamicThingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDynamicThingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteDynamicThingGroupInput`](crate::input::DeleteDynamicThingGroupInput)
    pub fn builder() -> crate::input::delete_dynamic_thing_group_input::Builder {
        crate::input::delete_dynamic_thing_group_input::Builder::default()
    }
}

/// See [`DeleteFleetMetricInput`](crate::input::DeleteFleetMetricInput)
pub mod delete_fleet_metric_input {

    /// A builder for [`DeleteFleetMetricInput`](crate::input::DeleteFleetMetricInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) expected_version: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the fleet metric to delete.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet metric to delete.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The expected version of the fleet metric to delete.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the fleet metric to delete.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFleetMetricInput`](crate::input::DeleteFleetMetricInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteFleetMetricInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteFleetMetricInput {
                metric_name: self.metric_name,
                expected_version: self.expected_version,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteFleetMetricInputOperationOutputAlias = crate::operation::DeleteFleetMetric;
#[doc(hidden)]
pub type DeleteFleetMetricInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteFleetMetricInput {
    /// Consumes the builder and constructs an Operation<[`DeleteFleetMetric`](crate::operation::DeleteFleetMetric)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteFleetMetric,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteFleetMetricInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_50 = &_input.metric_name;
                let input_50 = input_50.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let metric_name = aws_smithy_http::label::fmt_string(input_50, false);
                if metric_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/fleet-metric/{metricName}",
                    metricName = metric_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteFleetMetricInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_51) = &_input.expected_version {
                    query.push_kv(
                        "expectedVersion",
                        aws_smithy_types::primitive::Encoder::from(*inner_51).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteFleetMetricInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteFleetMetric::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteFleetMetric",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteFleetMetricInput`](crate::input::DeleteFleetMetricInput)
    pub fn builder() -> crate::input::delete_fleet_metric_input::Builder {
        crate::input::delete_fleet_metric_input::Builder::default()
    }
}

/// See [`DeleteJobInput`](crate::input::DeleteJobInput)
pub mod delete_job_input {

    /// A builder for [`DeleteJobInput`](crate::input::DeleteJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) force: std::option::Option<bool>,
        pub(crate) namespace_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the job to be deleted.</p>
        /// <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The ID of the job to be deleted.</p>
        /// <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note>
        /// <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p>
        /// </note>
        pub fn force(mut self, input: bool) -> Self {
            self.force = Some(input);
            self
        }
        /// <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note>
        /// <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p>
        /// </note>
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.force = input;
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_id = Some(input.into());
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteJobInput`](crate::input::DeleteJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteJobInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteJobInput {
                job_id: self.job_id,
                force: self.force.unwrap_or_default(),
                namespace_id: self.namespace_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteJobInputOperationOutputAlias = crate::operation::DeleteJob;
#[doc(hidden)]
pub type DeleteJobInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteJobInput {
    /// Consumes the builder and constructs an Operation<[`DeleteJob`](crate::operation::DeleteJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteJob,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteJobInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_52 = &_input.job_id;
                let input_52 = input_52.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_id = aws_smithy_http::label::fmt_string(input_52, false);
                if job_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/jobs/{jobId}", jobId = job_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteJobInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.force {
                    query.push_kv(
                        "force",
                        aws_smithy_types::primitive::Encoder::from(_input.force).encode(),
                    );
                }
                if let Some(inner_53) = &_input.namespace_id {
                    query.push_kv(
                        "namespaceId",
                        &aws_smithy_http::query::fmt_string(&inner_53),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteJobInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteJob::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "DeleteJob",
                    "iot",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteJobInput`](crate::input::DeleteJobInput)
    pub fn builder() -> crate::input::delete_job_input::Builder {
        crate::input::delete_job_input::Builder::default()
    }
}

/// See [`DeleteJobExecutionInput`](crate::input::DeleteJobExecutionInput)
pub mod delete_job_execution_input {

    /// A builder for [`DeleteJobExecutionInput`](crate::input::DeleteJobExecutionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) execution_number: std::option::Option<i64>,
        pub(crate) force: std::option::Option<bool>,
        pub(crate) namespace_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the job whose execution on a particular device will be deleted.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The ID of the job whose execution on a particular device will be deleted.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The name of the thing whose job execution will be deleted.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing whose job execution will be deleted.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p>
        /// <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
        pub fn execution_number(mut self, input: i64) -> Self {
            self.execution_number = Some(input);
            self
        }
        /// <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p>
        /// <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
        pub fn set_execution_number(mut self, input: std::option::Option<i64>) -> Self {
            self.execution_number = input;
            self
        }
        /// <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note>
        /// <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
        /// </note>
        pub fn force(mut self, input: bool) -> Self {
            self.force = Some(input);
            self
        }
        /// <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note>
        /// <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
        /// </note>
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.force = input;
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_id = Some(input.into());
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteJobExecutionInput`](crate::input::DeleteJobExecutionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteJobExecutionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteJobExecutionInput {
                job_id: self.job_id,
                thing_name: self.thing_name,
                execution_number: self.execution_number,
                force: self.force.unwrap_or_default(),
                namespace_id: self.namespace_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteJobExecutionInputOperationOutputAlias = crate::operation::DeleteJobExecution;
#[doc(hidden)]
pub type DeleteJobExecutionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteJobExecutionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteJobExecution`](crate::operation::DeleteJobExecution)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteJobExecution,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteJobExecutionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_54 = &_input.thing_name;
                let input_54 = input_54.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_54, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                let input_55 = &_input.job_id;
                let input_55 = input_55.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_id = aws_smithy_http::label::fmt_string(input_55, false);
                if job_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_56 = &_input.execution_number;
                let input_56 = input_56.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "execution_number",
                        details: "cannot be empty or unset",
                    },
                )?;
                let mut execution_number_encoder =
                    aws_smithy_types::primitive::Encoder::from(*input_56);
                let execution_number = execution_number_encoder.encode();
                if execution_number.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "execution_number",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
                    thingName = thing_name,
                    jobId = job_id,
                    executionNumber = execution_number
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteJobExecutionInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.force {
                    query.push_kv(
                        "force",
                        aws_smithy_types::primitive::Encoder::from(_input.force).encode(),
                    );
                }
                if let Some(inner_57) = &_input.namespace_id {
                    query.push_kv(
                        "namespaceId",
                        &aws_smithy_http::query::fmt_string(&inner_57),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteJobExecutionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteJobExecution::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteJobExecution",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteJobExecutionInput`](crate::input::DeleteJobExecutionInput)
    pub fn builder() -> crate::input::delete_job_execution_input::Builder {
        crate::input::delete_job_execution_input::Builder::default()
    }
}

/// See [`DeleteJobTemplateInput`](crate::input::DeleteJobTemplateInput)
pub mod delete_job_template_input {

    /// A builder for [`DeleteJobTemplateInput`](crate::input::DeleteJobTemplateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_template_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the job template to delete.</p>
        pub fn job_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_template_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the job template to delete.</p>
        pub fn set_job_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_template_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteJobTemplateInput`](crate::input::DeleteJobTemplateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteJobTemplateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteJobTemplateInput {
                job_template_id: self.job_template_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteJobTemplateInputOperationOutputAlias = crate::operation::DeleteJobTemplate;
#[doc(hidden)]
pub type DeleteJobTemplateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteJobTemplateInput {
    /// Consumes the builder and constructs an Operation<[`DeleteJobTemplate`](crate::operation::DeleteJobTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteJobTemplate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteJobTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_58 = &_input.job_template_id;
                let input_58 = input_58.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_template_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_template_id = aws_smithy_http::label::fmt_string(input_58, false);
                if job_template_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_template_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/job-templates/{jobTemplateId}",
                    jobTemplateId = job_template_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteJobTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteJobTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteJobTemplate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteJobTemplateInput`](crate::input::DeleteJobTemplateInput)
    pub fn builder() -> crate::input::delete_job_template_input::Builder {
        crate::input::delete_job_template_input::Builder::default()
    }
}

/// See [`DeleteMitigationActionInput`](crate::input::DeleteMitigationActionInput)
pub mod delete_mitigation_action_input {

    /// A builder for [`DeleteMitigationActionInput`](crate::input::DeleteMitigationActionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the mitigation action that you want to delete.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        /// <p>The name of the mitigation action that you want to delete.</p>
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteMitigationActionInput`](crate::input::DeleteMitigationActionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteMitigationActionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteMitigationActionInput {
                action_name: self.action_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteMitigationActionInputOperationOutputAlias = crate::operation::DeleteMitigationAction;
#[doc(hidden)]
pub type DeleteMitigationActionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteMitigationActionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteMitigationAction`](crate::operation::DeleteMitigationAction)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteMitigationAction,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteMitigationActionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_59 = &_input.action_name;
                let input_59 = input_59.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "action_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let action_name = aws_smithy_http::label::fmt_string(input_59, false);
                if action_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "action_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/mitigationactions/actions/{actionName}",
                    actionName = action_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteMitigationActionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteMitigationAction::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteMitigationAction",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteMitigationActionInput`](crate::input::DeleteMitigationActionInput)
    pub fn builder() -> crate::input::delete_mitigation_action_input::Builder {
        crate::input::delete_mitigation_action_input::Builder::default()
    }
}

/// See [`DeleteOtaUpdateInput`](crate::input::DeleteOtaUpdateInput)
pub mod delete_ota_update_input {

    /// A builder for [`DeleteOtaUpdateInput`](crate::input::DeleteOtaUpdateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ota_update_id: std::option::Option<std::string::String>,
        pub(crate) delete_stream: std::option::Option<bool>,
        pub(crate) force_delete_aws_job: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the OTA update to delete.</p>
        pub fn ota_update_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ota_update_id = Some(input.into());
            self
        }
        /// <p>The ID of the OTA update to delete.</p>
        pub fn set_ota_update_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ota_update_id = input;
            self
        }
        /// <p>When true, the stream created by the OTAUpdate process is deleted when the OTA update is deleted. Ignored if the stream specified in the OTAUpdate is supplied by the user.</p>
        pub fn delete_stream(mut self, input: bool) -> Self {
            self.delete_stream = Some(input);
            self
        }
        /// <p>When true, the stream created by the OTAUpdate process is deleted when the OTA update is deleted. Ignored if the stream specified in the OTAUpdate is supplied by the user.</p>
        pub fn set_delete_stream(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_stream = input;
            self
        }
        /// <p>When true, deletes the IoT job created by the OTAUpdate process even if it is "IN_PROGRESS". Otherwise, if the job is not in a terminal state ("COMPLETED" or "CANCELED") an exception will occur. The default is false.</p>
        pub fn force_delete_aws_job(mut self, input: bool) -> Self {
            self.force_delete_aws_job = Some(input);
            self
        }
        /// <p>When true, deletes the IoT job created by the OTAUpdate process even if it is "IN_PROGRESS". Otherwise, if the job is not in a terminal state ("COMPLETED" or "CANCELED") an exception will occur. The default is false.</p>
        pub fn set_force_delete_aws_job(mut self, input: std::option::Option<bool>) -> Self {
            self.force_delete_aws_job = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteOtaUpdateInput`](crate::input::DeleteOtaUpdateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteOtaUpdateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteOtaUpdateInput {
                ota_update_id: self.ota_update_id,
                delete_stream: self.delete_stream.unwrap_or_default(),
                force_delete_aws_job: self.force_delete_aws_job.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteOtaUpdateInputOperationOutputAlias = crate::operation::DeleteOTAUpdate;
#[doc(hidden)]
pub type DeleteOtaUpdateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteOtaUpdateInput {
    /// Consumes the builder and constructs an Operation<[`DeleteOTAUpdate`](crate::operation::DeleteOTAUpdate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteOTAUpdate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteOtaUpdateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_60 = &_input.ota_update_id;
                let input_60 = input_60.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "ota_update_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let ota_update_id = aws_smithy_http::label::fmt_string(input_60, false);
                if ota_update_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "ota_update_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/otaUpdates/{otaUpdateId}",
                    otaUpdateId = ota_update_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteOtaUpdateInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.delete_stream {
                    query.push_kv(
                        "deleteStream",
                        aws_smithy_types::primitive::Encoder::from(_input.delete_stream).encode(),
                    );
                }
                if _input.force_delete_aws_job {
                    query.push_kv(
                        "forceDeleteAWSJob",
                        aws_smithy_types::primitive::Encoder::from(_input.force_delete_aws_job)
                            .encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteOtaUpdateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteOTAUpdate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteOTAUpdate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteOtaUpdateInput`](crate::input::DeleteOtaUpdateInput)
    pub fn builder() -> crate::input::delete_ota_update_input::Builder {
        crate::input::delete_ota_update_input::Builder::default()
    }
}

/// See [`DeletePolicyInput`](crate::input::DeletePolicyInput)
pub mod delete_policy_input {

    /// A builder for [`DeletePolicyInput`](crate::input::DeletePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the policy to delete.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy to delete.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePolicyInput`](crate::input::DeletePolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeletePolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeletePolicyInput {
                policy_name: self.policy_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeletePolicyInputOperationOutputAlias = crate::operation::DeletePolicy;
#[doc(hidden)]
pub type DeletePolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeletePolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeletePolicy`](crate::operation::DeletePolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeletePolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeletePolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_61 = &_input.policy_name;
                let input_61 = input_61.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_61, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/policies/{policyName}", policyName = policy_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeletePolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeletePolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeletePolicy",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeletePolicyInput`](crate::input::DeletePolicyInput)
    pub fn builder() -> crate::input::delete_policy_input::Builder {
        crate::input::delete_policy_input::Builder::default()
    }
}

/// See [`DeletePolicyVersionInput`](crate::input::DeletePolicyVersionInput)
pub mod delete_policy_version_input {

    /// A builder for [`DeletePolicyVersionInput`](crate::input::DeletePolicyVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The policy version ID.</p>
        pub fn policy_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_version_id = Some(input.into());
            self
        }
        /// <p>The policy version ID.</p>
        pub fn set_policy_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePolicyVersionInput`](crate::input::DeletePolicyVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeletePolicyVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeletePolicyVersionInput {
                policy_name: self.policy_name,
                policy_version_id: self.policy_version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeletePolicyVersionInputOperationOutputAlias = crate::operation::DeletePolicyVersion;
#[doc(hidden)]
pub type DeletePolicyVersionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeletePolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`DeletePolicyVersion`](crate::operation::DeletePolicyVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeletePolicyVersion,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeletePolicyVersionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_62 = &_input.policy_name;
                let input_62 = input_62.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_62, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                let input_63 = &_input.policy_version_id;
                let input_63 = input_63.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_version_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_version_id = aws_smithy_http::label::fmt_string(input_63, false);
                if policy_version_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_version_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/policies/{policyName}/version/{policyVersionId}",
                    policyName = policy_name,
                    policyVersionId = policy_version_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeletePolicyVersionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeletePolicyVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeletePolicyVersion",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeletePolicyVersionInput`](crate::input::DeletePolicyVersionInput)
    pub fn builder() -> crate::input::delete_policy_version_input::Builder {
        crate::input::delete_policy_version_input::Builder::default()
    }
}

/// See [`DeleteProvisioningTemplateInput`](crate::input::DeleteProvisioningTemplateInput)
pub mod delete_provisioning_template_input {

    /// A builder for [`DeleteProvisioningTemplateInput`](crate::input::DeleteProvisioningTemplateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the fleet provision template to delete.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet provision template to delete.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProvisioningTemplateInput`](crate::input::DeleteProvisioningTemplateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteProvisioningTemplateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteProvisioningTemplateInput {
                template_name: self.template_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProvisioningTemplateInputOperationOutputAlias =
    crate::operation::DeleteProvisioningTemplate;
#[doc(hidden)]
pub type DeleteProvisioningTemplateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteProvisioningTemplateInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProvisioningTemplate`](crate::operation::DeleteProvisioningTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteProvisioningTemplate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteProvisioningTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_64 = &_input.template_name;
                let input_64 = input_64.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let template_name = aws_smithy_http::label::fmt_string(input_64, false);
                if template_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/provisioning-templates/{templateName}",
                    templateName = template_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteProvisioningTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteProvisioningTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteProvisioningTemplate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteProvisioningTemplateInput`](crate::input::DeleteProvisioningTemplateInput)
    pub fn builder() -> crate::input::delete_provisioning_template_input::Builder {
        crate::input::delete_provisioning_template_input::Builder::default()
    }
}

/// See [`DeleteProvisioningTemplateVersionInput`](crate::input::DeleteProvisioningTemplateVersionInput)
pub mod delete_provisioning_template_version_input {

    /// A builder for [`DeleteProvisioningTemplateVersionInput`](crate::input::DeleteProvisioningTemplateVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the fleet provisioning template version to delete.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet provisioning template version to delete.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The fleet provisioning template version ID to delete.</p>
        pub fn version_id(mut self, input: i32) -> Self {
            self.version_id = Some(input);
            self
        }
        /// <p>The fleet provisioning template version ID to delete.</p>
        pub fn set_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProvisioningTemplateVersionInput`](crate::input::DeleteProvisioningTemplateVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteProvisioningTemplateVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteProvisioningTemplateVersionInput {
                template_name: self.template_name,
                version_id: self.version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProvisioningTemplateVersionInputOperationOutputAlias =
    crate::operation::DeleteProvisioningTemplateVersion;
#[doc(hidden)]
pub type DeleteProvisioningTemplateVersionInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DeleteProvisioningTemplateVersionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProvisioningTemplateVersion`](crate::operation::DeleteProvisioningTemplateVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteProvisioningTemplateVersion,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteProvisioningTemplateVersionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_65 = &_input.template_name;
                let input_65 = input_65.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let template_name = aws_smithy_http::label::fmt_string(input_65, false);
                if template_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    });
                }
                let input_66 = &_input.version_id;
                let input_66 = input_66.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "version_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let mut version_id_encoder = aws_smithy_types::primitive::Encoder::from(*input_66);
                let version_id = version_id_encoder.encode();
                if version_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "version_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/provisioning-templates/{templateName}/versions/{versionId}",
                    templateName = template_name,
                    versionId = version_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteProvisioningTemplateVersionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteProvisioningTemplateVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteProvisioningTemplateVersion",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteProvisioningTemplateVersionInput`](crate::input::DeleteProvisioningTemplateVersionInput)
    pub fn builder() -> crate::input::delete_provisioning_template_version_input::Builder {
        crate::input::delete_provisioning_template_version_input::Builder::default()
    }
}

/// See [`DeleteRegistrationCodeInput`](crate::input::DeleteRegistrationCodeInput)
pub mod delete_registration_code_input {

    /// A builder for [`DeleteRegistrationCodeInput`](crate::input::DeleteRegistrationCodeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteRegistrationCodeInput`](crate::input::DeleteRegistrationCodeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteRegistrationCodeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteRegistrationCodeInput {})
        }
    }
}
#[doc(hidden)]
pub type DeleteRegistrationCodeInputOperationOutputAlias = crate::operation::DeleteRegistrationCode;
#[doc(hidden)]
pub type DeleteRegistrationCodeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteRegistrationCodeInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRegistrationCode`](crate::operation::DeleteRegistrationCode)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteRegistrationCode,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteRegistrationCodeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/registrationcode").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteRegistrationCodeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteRegistrationCode::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteRegistrationCode",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteRegistrationCodeInput`](crate::input::DeleteRegistrationCodeInput)
    pub fn builder() -> crate::input::delete_registration_code_input::Builder {
        crate::input::delete_registration_code_input::Builder::default()
    }
}

/// See [`DeleteRoleAliasInput`](crate::input::DeleteRoleAliasInput)
pub mod delete_role_alias_input {

    /// A builder for [`DeleteRoleAliasInput`](crate::input::DeleteRoleAliasInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_alias: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The role alias to delete.</p>
        pub fn role_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_alias = Some(input.into());
            self
        }
        /// <p>The role alias to delete.</p>
        pub fn set_role_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_alias = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRoleAliasInput`](crate::input::DeleteRoleAliasInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteRoleAliasInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteRoleAliasInput {
                role_alias: self.role_alias,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRoleAliasInputOperationOutputAlias = crate::operation::DeleteRoleAlias;
#[doc(hidden)]
pub type DeleteRoleAliasInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteRoleAliasInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRoleAlias`](crate::operation::DeleteRoleAlias)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteRoleAlias,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteRoleAliasInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_67 = &_input.role_alias;
                let input_67 = input_67.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "role_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let role_alias = aws_smithy_http::label::fmt_string(input_67, false);
                if role_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "role_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/role-aliases/{roleAlias}", roleAlias = role_alias)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteRoleAliasInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteRoleAlias::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteRoleAlias",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteRoleAliasInput`](crate::input::DeleteRoleAliasInput)
    pub fn builder() -> crate::input::delete_role_alias_input::Builder {
        crate::input::delete_role_alias_input::Builder::default()
    }
}

/// See [`DeleteScheduledAuditInput`](crate::input::DeleteScheduledAuditInput)
pub mod delete_scheduled_audit_input {

    /// A builder for [`DeleteScheduledAuditInput`](crate::input::DeleteScheduledAuditInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scheduled_audit_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the scheduled audit you want to delete.</p>
        pub fn scheduled_audit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduled_audit_name = Some(input.into());
            self
        }
        /// <p>The name of the scheduled audit you want to delete.</p>
        pub fn set_scheduled_audit_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_audit_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteScheduledAuditInput`](crate::input::DeleteScheduledAuditInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteScheduledAuditInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteScheduledAuditInput {
                scheduled_audit_name: self.scheduled_audit_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteScheduledAuditInputOperationOutputAlias = crate::operation::DeleteScheduledAudit;
#[doc(hidden)]
pub type DeleteScheduledAuditInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteScheduledAuditInput {
    /// Consumes the builder and constructs an Operation<[`DeleteScheduledAudit`](crate::operation::DeleteScheduledAudit)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteScheduledAudit,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteScheduledAuditInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_68 = &_input.scheduled_audit_name;
                let input_68 = input_68.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "scheduled_audit_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let scheduled_audit_name = aws_smithy_http::label::fmt_string(input_68, false);
                if scheduled_audit_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "scheduled_audit_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/audit/scheduledaudits/{scheduledAuditName}",
                    scheduledAuditName = scheduled_audit_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteScheduledAuditInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteScheduledAudit::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteScheduledAudit",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteScheduledAuditInput`](crate::input::DeleteScheduledAuditInput)
    pub fn builder() -> crate::input::delete_scheduled_audit_input::Builder {
        crate::input::delete_scheduled_audit_input::Builder::default()
    }
}

/// See [`DeleteSecurityProfileInput`](crate::input::DeleteSecurityProfileInput)
pub mod delete_security_profile_input {

    /// A builder for [`DeleteSecurityProfileInput`](crate::input::DeleteSecurityProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) expected_version: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the security profile to be deleted.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The name of the security profile to be deleted.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSecurityProfileInput`](crate::input::DeleteSecurityProfileInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteSecurityProfileInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteSecurityProfileInput {
                security_profile_name: self.security_profile_name,
                expected_version: self.expected_version,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteSecurityProfileInputOperationOutputAlias = crate::operation::DeleteSecurityProfile;
#[doc(hidden)]
pub type DeleteSecurityProfileInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteSecurityProfileInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSecurityProfile`](crate::operation::DeleteSecurityProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteSecurityProfile,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteSecurityProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_69 = &_input.security_profile_name;
                let input_69 = input_69.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let security_profile_name = aws_smithy_http::label::fmt_string(input_69, false);
                if security_profile_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/security-profiles/{securityProfileName}",
                    securityProfileName = security_profile_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteSecurityProfileInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_70) = &_input.expected_version {
                    query.push_kv(
                        "expectedVersion",
                        aws_smithy_types::primitive::Encoder::from(*inner_70).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteSecurityProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteSecurityProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteSecurityProfile",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteSecurityProfileInput`](crate::input::DeleteSecurityProfileInput)
    pub fn builder() -> crate::input::delete_security_profile_input::Builder {
        crate::input::delete_security_profile_input::Builder::default()
    }
}

/// See [`DeleteStreamInput`](crate::input::DeleteStreamInput)
pub mod delete_stream_input {

    /// A builder for [`DeleteStreamInput`](crate::input::DeleteStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>The stream ID.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteStreamInput`](crate::input::DeleteStreamInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteStreamInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteStreamInput {
                stream_id: self.stream_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteStreamInputOperationOutputAlias = crate::operation::DeleteStream;
#[doc(hidden)]
pub type DeleteStreamInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteStreamInput {
    /// Consumes the builder and constructs an Operation<[`DeleteStream`](crate::operation::DeleteStream)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteStream,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteStreamInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_71 = &_input.stream_id;
                let input_71 = input_71.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "stream_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let stream_id = aws_smithy_http::label::fmt_string(input_71, false);
                if stream_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "stream_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/streams/{streamId}", streamId = stream_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteStreamInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteStream::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteStream",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteStreamInput`](crate::input::DeleteStreamInput)
    pub fn builder() -> crate::input::delete_stream_input::Builder {
        crate::input::delete_stream_input::Builder::default()
    }
}

/// See [`DeleteThingInput`](crate::input::DeleteThingInput)
pub mod delete_thing_input {

    /// A builder for [`DeleteThingInput`](crate::input::DeleteThingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) expected_version: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the thing to delete.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing to delete.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteThingInput`](crate::input::DeleteThingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteThingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteThingInput {
                thing_name: self.thing_name,
                expected_version: self.expected_version,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteThingInputOperationOutputAlias = crate::operation::DeleteThing;
#[doc(hidden)]
pub type DeleteThingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteThingInput {
    /// Consumes the builder and constructs an Operation<[`DeleteThing`](crate::operation::DeleteThing)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteThing,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteThingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_72 = &_input.thing_name;
                let input_72 = input_72.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_72, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/things/{thingName}", thingName = thing_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteThingInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_73) = &_input.expected_version {
                    query.push_kv(
                        "expectedVersion",
                        aws_smithy_types::primitive::Encoder::from(*inner_73).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteThingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteThing::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteThing",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteThingInput`](crate::input::DeleteThingInput)
    pub fn builder() -> crate::input::delete_thing_input::Builder {
        crate::input::delete_thing_input::Builder::default()
    }
}

/// See [`DeleteThingGroupInput`](crate::input::DeleteThingGroupInput)
pub mod delete_thing_group_input {

    /// A builder for [`DeleteThingGroupInput`](crate::input::DeleteThingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_group_name: std::option::Option<std::string::String>,
        pub(crate) expected_version: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the thing group to delete.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the thing group to delete.</p>
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_name = input;
            self
        }
        /// <p>The expected version of the thing group to delete.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the thing group to delete.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteThingGroupInput`](crate::input::DeleteThingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteThingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteThingGroupInput {
                thing_group_name: self.thing_group_name,
                expected_version: self.expected_version,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteThingGroupInputOperationOutputAlias = crate::operation::DeleteThingGroup;
#[doc(hidden)]
pub type DeleteThingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteThingGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteThingGroup`](crate::operation::DeleteThingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteThingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteThingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_74 = &_input.thing_group_name;
                let input_74 = input_74.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_group_name = aws_smithy_http::label::fmt_string(input_74, false);
                if thing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-groups/{thingGroupName}",
                    thingGroupName = thing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteThingGroupInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_75) = &_input.expected_version {
                    query.push_kv(
                        "expectedVersion",
                        aws_smithy_types::primitive::Encoder::from(*inner_75).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteThingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteThingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteThingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteThingGroupInput`](crate::input::DeleteThingGroupInput)
    pub fn builder() -> crate::input::delete_thing_group_input::Builder {
        crate::input::delete_thing_group_input::Builder::default()
    }
}

/// See [`DeleteThingTypeInput`](crate::input::DeleteThingTypeInput)
pub mod delete_thing_type_input {

    /// A builder for [`DeleteThingTypeInput`](crate::input::DeleteThingTypeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_type_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the thing type.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_type_name = Some(input.into());
            self
        }
        /// <p>The name of the thing type.</p>
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_type_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteThingTypeInput`](crate::input::DeleteThingTypeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteThingTypeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteThingTypeInput {
                thing_type_name: self.thing_type_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteThingTypeInputOperationOutputAlias = crate::operation::DeleteThingType;
#[doc(hidden)]
pub type DeleteThingTypeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteThingTypeInput {
    /// Consumes the builder and constructs an Operation<[`DeleteThingType`](crate::operation::DeleteThingType)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteThingType,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteThingTypeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_76 = &_input.thing_type_name;
                let input_76 = input_76.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_type_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_type_name = aws_smithy_http::label::fmt_string(input_76, false);
                if thing_type_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_type_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-types/{thingTypeName}",
                    thingTypeName = thing_type_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteThingTypeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteThingType::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteThingType",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteThingTypeInput`](crate::input::DeleteThingTypeInput)
    pub fn builder() -> crate::input::delete_thing_type_input::Builder {
        crate::input::delete_thing_type_input::Builder::default()
    }
}

/// See [`DeleteTopicRuleInput`](crate::input::DeleteTopicRuleInput)
pub mod delete_topic_rule_input {

    /// A builder for [`DeleteTopicRuleInput`](crate::input::DeleteTopicRuleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the rule.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_name = Some(input.into());
            self
        }
        /// <p>The name of the rule.</p>
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteTopicRuleInput`](crate::input::DeleteTopicRuleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteTopicRuleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteTopicRuleInput {
                rule_name: self.rule_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteTopicRuleInputOperationOutputAlias = crate::operation::DeleteTopicRule;
#[doc(hidden)]
pub type DeleteTopicRuleInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteTopicRuleInput {
    /// Consumes the builder and constructs an Operation<[`DeleteTopicRule`](crate::operation::DeleteTopicRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteTopicRule,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteTopicRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_77 = &_input.rule_name;
                let input_77 = input_77.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let rule_name = aws_smithy_http::label::fmt_string(input_77, false);
                if rule_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/rules/{ruleName}", ruleName = rule_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteTopicRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteTopicRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteTopicRule",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteTopicRuleInput`](crate::input::DeleteTopicRuleInput)
    pub fn builder() -> crate::input::delete_topic_rule_input::Builder {
        crate::input::delete_topic_rule_input::Builder::default()
    }
}

/// See [`DeleteTopicRuleDestinationInput`](crate::input::DeleteTopicRuleDestinationInput)
pub mod delete_topic_rule_destination_input {

    /// A builder for [`DeleteTopicRuleDestinationInput`](crate::input::DeleteTopicRuleDestinationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the topic rule destination to delete.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the topic rule destination to delete.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteTopicRuleDestinationInput`](crate::input::DeleteTopicRuleDestinationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteTopicRuleDestinationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteTopicRuleDestinationInput { arn: self.arn })
        }
    }
}
#[doc(hidden)]
pub type DeleteTopicRuleDestinationInputOperationOutputAlias =
    crate::operation::DeleteTopicRuleDestination;
#[doc(hidden)]
pub type DeleteTopicRuleDestinationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteTopicRuleDestinationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteTopicRuleDestination`](crate::operation::DeleteTopicRuleDestination)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteTopicRuleDestination,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteTopicRuleDestinationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_78 = &_input.arn;
                let input_78 = input_78.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let arn = aws_smithy_http::label::fmt_string(input_78, true);
                if arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/destinations/{arn}", arn = arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteTopicRuleDestinationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteTopicRuleDestination::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteTopicRuleDestination",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteTopicRuleDestinationInput`](crate::input::DeleteTopicRuleDestinationInput)
    pub fn builder() -> crate::input::delete_topic_rule_destination_input::Builder {
        crate::input::delete_topic_rule_destination_input::Builder::default()
    }
}

/// See [`DeleteV2LoggingLevelInput`](crate::input::DeleteV2LoggingLevelInput)
pub mod delete_v2_logging_level_input {

    /// A builder for [`DeleteV2LoggingLevelInput`](crate::input::DeleteV2LoggingLevelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_type: std::option::Option<crate::model::LogTargetType>,
        pub(crate) target_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
        pub fn target_type(mut self, input: crate::model::LogTargetType) -> Self {
            self.target_type = Some(input);
            self
        }
        /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
        pub fn set_target_type(
            mut self,
            input: std::option::Option<crate::model::LogTargetType>,
        ) -> Self {
            self.target_type = input;
            self
        }
        /// <p>The name of the resource for which you are configuring logging.</p>
        pub fn target_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_name = Some(input.into());
            self
        }
        /// <p>The name of the resource for which you are configuring logging.</p>
        pub fn set_target_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteV2LoggingLevelInput`](crate::input::DeleteV2LoggingLevelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteV2LoggingLevelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteV2LoggingLevelInput {
                target_type: self.target_type,
                target_name: self.target_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteV2LoggingLevelInputOperationOutputAlias = crate::operation::DeleteV2LoggingLevel;
#[doc(hidden)]
pub type DeleteV2LoggingLevelInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteV2LoggingLevelInput {
    /// Consumes the builder and constructs an Operation<[`DeleteV2LoggingLevel`](crate::operation::DeleteV2LoggingLevel)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteV2LoggingLevel,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteV2LoggingLevelInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/v2LoggingLevel").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteV2LoggingLevelInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_79) = &_input.target_type {
                    query.push_kv("targetType", &aws_smithy_http::query::fmt_string(&inner_79));
                }
                if let Some(inner_80) = &_input.target_name {
                    query.push_kv("targetName", &aws_smithy_http::query::fmt_string(&inner_80));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteV2LoggingLevelInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteV2LoggingLevel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteV2LoggingLevel",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteV2LoggingLevelInput`](crate::input::DeleteV2LoggingLevelInput)
    pub fn builder() -> crate::input::delete_v2_logging_level_input::Builder {
        crate::input::delete_v2_logging_level_input::Builder::default()
    }
}

/// See [`DeprecateThingTypeInput`](crate::input::DeprecateThingTypeInput)
pub mod deprecate_thing_type_input {

    /// A builder for [`DeprecateThingTypeInput`](crate::input::DeprecateThingTypeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_type_name: std::option::Option<std::string::String>,
        pub(crate) undo_deprecate: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the thing type to deprecate.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_type_name = Some(input.into());
            self
        }
        /// <p>The name of the thing type to deprecate.</p>
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_type_name = input;
            self
        }
        /// <p>Whether to undeprecate a deprecated thing type. If <b>true</b>, the thing type will not be deprecated anymore and you can associate it with things.</p>
        pub fn undo_deprecate(mut self, input: bool) -> Self {
            self.undo_deprecate = Some(input);
            self
        }
        /// <p>Whether to undeprecate a deprecated thing type. If <b>true</b>, the thing type will not be deprecated anymore and you can associate it with things.</p>
        pub fn set_undo_deprecate(mut self, input: std::option::Option<bool>) -> Self {
            self.undo_deprecate = input;
            self
        }
        /// Consumes the builder and constructs a [`DeprecateThingTypeInput`](crate::input::DeprecateThingTypeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeprecateThingTypeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeprecateThingTypeInput {
                thing_type_name: self.thing_type_name,
                undo_deprecate: self.undo_deprecate.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type DeprecateThingTypeInputOperationOutputAlias = crate::operation::DeprecateThingType;
#[doc(hidden)]
pub type DeprecateThingTypeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeprecateThingTypeInput {
    /// Consumes the builder and constructs an Operation<[`DeprecateThingType`](crate::operation::DeprecateThingType)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeprecateThingType,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeprecateThingTypeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_81 = &_input.thing_type_name;
                let input_81 = input_81.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_type_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_type_name = aws_smithy_http::label::fmt_string(input_81, false);
                if thing_type_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_type_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-types/{thingTypeName}/deprecate",
                    thingTypeName = thing_type_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeprecateThingTypeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_deprecate_thing_type(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeprecateThingType::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeprecateThingType",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeprecateThingTypeInput`](crate::input::DeprecateThingTypeInput)
    pub fn builder() -> crate::input::deprecate_thing_type_input::Builder {
        crate::input::deprecate_thing_type_input::Builder::default()
    }
}

/// See [`DescribeAccountAuditConfigurationInput`](crate::input::DescribeAccountAuditConfigurationInput)
pub mod describe_account_audit_configuration_input {

    /// A builder for [`DescribeAccountAuditConfigurationInput`](crate::input::DescribeAccountAuditConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeAccountAuditConfigurationInput`](crate::input::DescribeAccountAuditConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAccountAuditConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAccountAuditConfigurationInput {})
        }
    }
}
#[doc(hidden)]
pub type DescribeAccountAuditConfigurationInputOperationOutputAlias =
    crate::operation::DescribeAccountAuditConfiguration;
#[doc(hidden)]
pub type DescribeAccountAuditConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DescribeAccountAuditConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAccountAuditConfiguration`](crate::operation::DescribeAccountAuditConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAccountAuditConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeAccountAuditConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/configuration").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeAccountAuditConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAccountAuditConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAccountAuditConfiguration",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAccountAuditConfigurationInput`](crate::input::DescribeAccountAuditConfigurationInput)
    pub fn builder() -> crate::input::describe_account_audit_configuration_input::Builder {
        crate::input::describe_account_audit_configuration_input::Builder::default()
    }
}

/// See [`DescribeAuditFindingInput`](crate::input::DescribeAuditFindingInput)
pub mod describe_audit_finding_input {

    /// A builder for [`DescribeAuditFindingInput`](crate::input::DescribeAuditFindingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) finding_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.</p>
        pub fn finding_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.finding_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.</p>
        pub fn set_finding_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.finding_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAuditFindingInput`](crate::input::DescribeAuditFindingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAuditFindingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAuditFindingInput {
                finding_id: self.finding_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAuditFindingInputOperationOutputAlias = crate::operation::DescribeAuditFinding;
#[doc(hidden)]
pub type DescribeAuditFindingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeAuditFindingInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAuditFinding`](crate::operation::DescribeAuditFinding)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAuditFinding,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeAuditFindingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_82 = &_input.finding_id;
                let input_82 = input_82.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "finding_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let finding_id = aws_smithy_http::label::fmt_string(input_82, false);
                if finding_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "finding_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/audit/findings/{findingId}",
                    findingId = finding_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeAuditFindingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAuditFinding::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAuditFinding",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAuditFindingInput`](crate::input::DescribeAuditFindingInput)
    pub fn builder() -> crate::input::describe_audit_finding_input::Builder {
        crate::input::describe_audit_finding_input::Builder::default()
    }
}

/// See [`DescribeAuditMitigationActionsTaskInput`](crate::input::DescribeAuditMitigationActionsTaskInput)
pub mod describe_audit_mitigation_actions_task_input {

    /// A builder for [`DescribeAuditMitigationActionsTaskInput`](crate::input::DescribeAuditMitigationActionsTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the audit mitigation task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the audit mitigation task.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAuditMitigationActionsTaskInput`](crate::input::DescribeAuditMitigationActionsTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAuditMitigationActionsTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAuditMitigationActionsTaskInput {
                task_id: self.task_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAuditMitigationActionsTaskInputOperationOutputAlias =
    crate::operation::DescribeAuditMitigationActionsTask;
#[doc(hidden)]
pub type DescribeAuditMitigationActionsTaskInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DescribeAuditMitigationActionsTaskInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAuditMitigationActionsTask`](crate::operation::DescribeAuditMitigationActionsTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAuditMitigationActionsTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeAuditMitigationActionsTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_83 = &_input.task_id;
                let input_83 = input_83.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let task_id = aws_smithy_http::label::fmt_string(input_83, false);
                if task_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/audit/mitigationactions/tasks/{taskId}",
                    taskId = task_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeAuditMitigationActionsTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAuditMitigationActionsTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAuditMitigationActionsTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAuditMitigationActionsTaskInput`](crate::input::DescribeAuditMitigationActionsTaskInput)
    pub fn builder() -> crate::input::describe_audit_mitigation_actions_task_input::Builder {
        crate::input::describe_audit_mitigation_actions_task_input::Builder::default()
    }
}

/// See [`DescribeAuditSuppressionInput`](crate::input::DescribeAuditSuppressionInput)
pub mod describe_audit_suppression_input {

    /// A builder for [`DescribeAuditSuppressionInput`](crate::input::DescribeAuditSuppressionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) check_name: std::option::Option<std::string::String>,
        pub(crate) resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
    }
    impl Builder {
        /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.check_name = Some(input.into());
            self
        }
        /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.check_name = input;
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.resource_identifier = Some(input);
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.resource_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAuditSuppressionInput`](crate::input::DescribeAuditSuppressionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAuditSuppressionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAuditSuppressionInput {
                check_name: self.check_name,
                resource_identifier: self.resource_identifier,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAuditSuppressionInputOperationOutputAlias =
    crate::operation::DescribeAuditSuppression;
#[doc(hidden)]
pub type DescribeAuditSuppressionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeAuditSuppressionInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAuditSuppression`](crate::operation::DescribeAuditSuppression)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAuditSuppression,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeAuditSuppressionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/suppressions/describe").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeAuditSuppressionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_describe_audit_suppression(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAuditSuppression::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAuditSuppression",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAuditSuppressionInput`](crate::input::DescribeAuditSuppressionInput)
    pub fn builder() -> crate::input::describe_audit_suppression_input::Builder {
        crate::input::describe_audit_suppression_input::Builder::default()
    }
}

/// See [`DescribeAuditTaskInput`](crate::input::DescribeAuditTaskInput)
pub mod describe_audit_task_input {

    /// A builder for [`DescribeAuditTaskInput`](crate::input::DescribeAuditTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the audit whose information you want to get.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The ID of the audit whose information you want to get.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAuditTaskInput`](crate::input::DescribeAuditTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAuditTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAuditTaskInput {
                task_id: self.task_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAuditTaskInputOperationOutputAlias = crate::operation::DescribeAuditTask;
#[doc(hidden)]
pub type DescribeAuditTaskInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeAuditTaskInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAuditTask`](crate::operation::DescribeAuditTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAuditTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeAuditTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_84 = &_input.task_id;
                let input_84 = input_84.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let task_id = aws_smithy_http::label::fmt_string(input_84, false);
                if task_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/audit/tasks/{taskId}", taskId = task_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeAuditTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAuditTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAuditTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAuditTaskInput`](crate::input::DescribeAuditTaskInput)
    pub fn builder() -> crate::input::describe_audit_task_input::Builder {
        crate::input::describe_audit_task_input::Builder::default()
    }
}

/// See [`DescribeAuthorizerInput`](crate::input::DescribeAuthorizerInput)
pub mod describe_authorizer_input {

    /// A builder for [`DescribeAuthorizerInput`](crate::input::DescribeAuthorizerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authorizer_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the authorizer to describe.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorizer_name = Some(input.into());
            self
        }
        /// <p>The name of the authorizer to describe.</p>
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorizer_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAuthorizerInput`](crate::input::DescribeAuthorizerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAuthorizerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAuthorizerInput {
                authorizer_name: self.authorizer_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAuthorizerInputOperationOutputAlias = crate::operation::DescribeAuthorizer;
#[doc(hidden)]
pub type DescribeAuthorizerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeAuthorizerInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAuthorizer`](crate::operation::DescribeAuthorizer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAuthorizer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeAuthorizerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_85 = &_input.authorizer_name;
                let input_85 = input_85.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "authorizer_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let authorizer_name = aws_smithy_http::label::fmt_string(input_85, false);
                if authorizer_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "authorizer_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/authorizer/{authorizerName}",
                    authorizerName = authorizer_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeAuthorizerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAuthorizer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAuthorizer",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAuthorizerInput`](crate::input::DescribeAuthorizerInput)
    pub fn builder() -> crate::input::describe_authorizer_input::Builder {
        crate::input::describe_authorizer_input::Builder::default()
    }
}

/// See [`DescribeBillingGroupInput`](crate::input::DescribeBillingGroupInput)
pub mod describe_billing_group_input {

    /// A builder for [`DescribeBillingGroupInput`](crate::input::DescribeBillingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the billing group.</p>
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeBillingGroupInput`](crate::input::DescribeBillingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeBillingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeBillingGroupInput {
                billing_group_name: self.billing_group_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeBillingGroupInputOperationOutputAlias = crate::operation::DescribeBillingGroup;
#[doc(hidden)]
pub type DescribeBillingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeBillingGroupInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBillingGroup`](crate::operation::DescribeBillingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeBillingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeBillingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_86 = &_input.billing_group_name;
                let input_86 = input_86.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "billing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let billing_group_name = aws_smithy_http::label::fmt_string(input_86, false);
                if billing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "billing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/billing-groups/{billingGroupName}",
                    billingGroupName = billing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeBillingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeBillingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeBillingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeBillingGroupInput`](crate::input::DescribeBillingGroupInput)
    pub fn builder() -> crate::input::describe_billing_group_input::Builder {
        crate::input::describe_billing_group_input::Builder::default()
    }
}

/// See [`DescribeCaCertificateInput`](crate::input::DescribeCaCertificateInput)
pub mod describe_ca_certificate_input {

    /// A builder for [`DescribeCaCertificateInput`](crate::input::DescribeCaCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The CA certificate identifier.</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(input.into());
            self
        }
        /// <p>The CA certificate identifier.</p>
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeCaCertificateInput`](crate::input::DescribeCaCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeCaCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeCaCertificateInput {
                certificate_id: self.certificate_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeCaCertificateInputOperationOutputAlias = crate::operation::DescribeCACertificate;
#[doc(hidden)]
pub type DescribeCaCertificateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeCaCertificateInput {
    /// Consumes the builder and constructs an Operation<[`DescribeCACertificate`](crate::operation::DescribeCACertificate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeCACertificate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeCaCertificateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_87 = &_input.certificate_id;
                let input_87 = input_87.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let certificate_id = aws_smithy_http::label::fmt_string(input_87, false);
                if certificate_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/cacertificate/{certificateId}",
                    certificateId = certificate_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeCaCertificateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeCACertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeCACertificate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeCaCertificateInput`](crate::input::DescribeCaCertificateInput)
    pub fn builder() -> crate::input::describe_ca_certificate_input::Builder {
        crate::input::describe_ca_certificate_input::Builder::default()
    }
}

/// See [`DescribeCertificateInput`](crate::input::DescribeCertificateInput)
pub mod describe_certificate_input {

    /// A builder for [`DescribeCertificateInput`](crate::input::DescribeCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(input.into());
            self
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeCertificateInput`](crate::input::DescribeCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeCertificateInput {
                certificate_id: self.certificate_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeCertificateInputOperationOutputAlias = crate::operation::DescribeCertificate;
#[doc(hidden)]
pub type DescribeCertificateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeCertificateInput {
    /// Consumes the builder and constructs an Operation<[`DescribeCertificate`](crate::operation::DescribeCertificate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeCertificate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeCertificateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_88 = &_input.certificate_id;
                let input_88 = input_88.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let certificate_id = aws_smithy_http::label::fmt_string(input_88, false);
                if certificate_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/certificates/{certificateId}",
                    certificateId = certificate_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeCertificateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeCertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeCertificate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeCertificateInput`](crate::input::DescribeCertificateInput)
    pub fn builder() -> crate::input::describe_certificate_input::Builder {
        crate::input::describe_certificate_input::Builder::default()
    }
}

/// See [`DescribeCustomMetricInput`](crate::input::DescribeCustomMetricInput)
pub mod describe_custom_metric_input {

    /// A builder for [`DescribeCustomMetricInput`](crate::input::DescribeCustomMetricInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the custom metric. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p> The name of the custom metric. </p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeCustomMetricInput`](crate::input::DescribeCustomMetricInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeCustomMetricInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeCustomMetricInput {
                metric_name: self.metric_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeCustomMetricInputOperationOutputAlias = crate::operation::DescribeCustomMetric;
#[doc(hidden)]
pub type DescribeCustomMetricInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeCustomMetricInput {
    /// Consumes the builder and constructs an Operation<[`DescribeCustomMetric`](crate::operation::DescribeCustomMetric)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeCustomMetric,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeCustomMetricInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_89 = &_input.metric_name;
                let input_89 = input_89.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let metric_name = aws_smithy_http::label::fmt_string(input_89, false);
                if metric_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/custom-metric/{metricName}",
                    metricName = metric_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeCustomMetricInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeCustomMetric::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeCustomMetric",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeCustomMetricInput`](crate::input::DescribeCustomMetricInput)
    pub fn builder() -> crate::input::describe_custom_metric_input::Builder {
        crate::input::describe_custom_metric_input::Builder::default()
    }
}

/// See [`DescribeDefaultAuthorizerInput`](crate::input::DescribeDefaultAuthorizerInput)
pub mod describe_default_authorizer_input {

    /// A builder for [`DescribeDefaultAuthorizerInput`](crate::input::DescribeDefaultAuthorizerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeDefaultAuthorizerInput`](crate::input::DescribeDefaultAuthorizerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeDefaultAuthorizerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeDefaultAuthorizerInput {})
        }
    }
}
#[doc(hidden)]
pub type DescribeDefaultAuthorizerInputOperationOutputAlias =
    crate::operation::DescribeDefaultAuthorizer;
#[doc(hidden)]
pub type DescribeDefaultAuthorizerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeDefaultAuthorizerInput {
    /// Consumes the builder and constructs an Operation<[`DescribeDefaultAuthorizer`](crate::operation::DescribeDefaultAuthorizer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeDefaultAuthorizer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeDefaultAuthorizerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/default-authorizer").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeDefaultAuthorizerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeDefaultAuthorizer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeDefaultAuthorizer",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeDefaultAuthorizerInput`](crate::input::DescribeDefaultAuthorizerInput)
    pub fn builder() -> crate::input::describe_default_authorizer_input::Builder {
        crate::input::describe_default_authorizer_input::Builder::default()
    }
}

/// See [`DescribeDetectMitigationActionsTaskInput`](crate::input::DescribeDetectMitigationActionsTaskInput)
pub mod describe_detect_mitigation_actions_task_input {

    /// A builder for [`DescribeDetectMitigationActionsTaskInput`](crate::input::DescribeDetectMitigationActionsTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier of the task. </p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p> The unique identifier of the task. </p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDetectMitigationActionsTaskInput`](crate::input::DescribeDetectMitigationActionsTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeDetectMitigationActionsTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeDetectMitigationActionsTaskInput {
                task_id: self.task_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeDetectMitigationActionsTaskInputOperationOutputAlias =
    crate::operation::DescribeDetectMitigationActionsTask;
#[doc(hidden)]
pub type DescribeDetectMitigationActionsTaskInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DescribeDetectMitigationActionsTaskInput {
    /// Consumes the builder and constructs an Operation<[`DescribeDetectMitigationActionsTask`](crate::operation::DescribeDetectMitigationActionsTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeDetectMitigationActionsTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeDetectMitigationActionsTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_90 = &_input.task_id;
                let input_90 = input_90.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let task_id = aws_smithy_http::label::fmt_string(input_90, false);
                if task_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/detect/mitigationactions/tasks/{taskId}",
                    taskId = task_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeDetectMitigationActionsTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeDetectMitigationActionsTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeDetectMitigationActionsTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeDetectMitigationActionsTaskInput`](crate::input::DescribeDetectMitigationActionsTaskInput)
    pub fn builder() -> crate::input::describe_detect_mitigation_actions_task_input::Builder {
        crate::input::describe_detect_mitigation_actions_task_input::Builder::default()
    }
}

/// See [`DescribeDimensionInput`](crate::input::DescribeDimensionInput)
pub mod describe_dimension_input {

    /// A builder for [`DescribeDimensionInput`](crate::input::DescribeDimensionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the dimension.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The unique identifier for the dimension.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDimensionInput`](crate::input::DescribeDimensionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeDimensionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeDimensionInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type DescribeDimensionInputOperationOutputAlias = crate::operation::DescribeDimension;
#[doc(hidden)]
pub type DescribeDimensionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeDimensionInput {
    /// Consumes the builder and constructs an Operation<[`DescribeDimension`](crate::operation::DescribeDimension)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeDimension,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeDimensionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_91 = &_input.name;
                let input_91 = input_91.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let name = aws_smithy_http::label::fmt_string(input_91, false);
                if name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/dimensions/{name}", name = name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeDimensionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeDimension::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeDimension",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeDimensionInput`](crate::input::DescribeDimensionInput)
    pub fn builder() -> crate::input::describe_dimension_input::Builder {
        crate::input::describe_dimension_input::Builder::default()
    }
}

/// See [`DescribeDomainConfigurationInput`](crate::input::DescribeDomainConfigurationInput)
pub mod describe_domain_configuration_input {

    /// A builder for [`DescribeDomainConfigurationInput`](crate::input::DescribeDomainConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_configuration_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the domain configuration.</p>
        pub fn domain_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the domain configuration.</p>
        pub fn set_domain_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.domain_configuration_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDomainConfigurationInput`](crate::input::DescribeDomainConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeDomainConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeDomainConfigurationInput {
                domain_configuration_name: self.domain_configuration_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeDomainConfigurationInputOperationOutputAlias =
    crate::operation::DescribeDomainConfiguration;
#[doc(hidden)]
pub type DescribeDomainConfigurationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeDomainConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DescribeDomainConfiguration`](crate::operation::DescribeDomainConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeDomainConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeDomainConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_92 = &_input.domain_configuration_name;
                let input_92 = input_92.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "domain_configuration_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let domain_configuration_name = aws_smithy_http::label::fmt_string(input_92, false);
                if domain_configuration_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "domain_configuration_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/domainConfigurations/{domainConfigurationName}",
                    domainConfigurationName = domain_configuration_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeDomainConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeDomainConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeDomainConfiguration",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeDomainConfigurationInput`](crate::input::DescribeDomainConfigurationInput)
    pub fn builder() -> crate::input::describe_domain_configuration_input::Builder {
        crate::input::describe_domain_configuration_input::Builder::default()
    }
}

/// See [`DescribeEndpointInput`](crate::input::DescribeEndpointInput)
pub mod describe_endpoint_input {

    /// A builder for [`DescribeEndpointInput`](crate::input::DescribeEndpointInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The endpoint type. Valid endpoint types include:</p>
        /// <ul>
        /// <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li>
        /// </ul>
        /// <ul>
        /// <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li>
        /// </ul>
        /// <ul>
        /// <li> <p> <code>iot:CredentialProvider</code> - Returns an IoT credentials provider API endpoint.</p> </li>
        /// </ul>
        /// <ul>
        /// <li> <p> <code>iot:Jobs</code> - Returns an IoT device management Jobs API endpoint.</p> </li>
        /// </ul>
        /// <p>We strongly recommend that customers use the newer <code>iot:Data-ATS</code> endpoint type to avoid issues related to the widespread distrust of Symantec certificate authorities.</p>
        pub fn endpoint_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_type = Some(input.into());
            self
        }
        /// <p>The endpoint type. Valid endpoint types include:</p>
        /// <ul>
        /// <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li>
        /// </ul>
        /// <ul>
        /// <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li>
        /// </ul>
        /// <ul>
        /// <li> <p> <code>iot:CredentialProvider</code> - Returns an IoT credentials provider API endpoint.</p> </li>
        /// </ul>
        /// <ul>
        /// <li> <p> <code>iot:Jobs</code> - Returns an IoT device management Jobs API endpoint.</p> </li>
        /// </ul>
        /// <p>We strongly recommend that customers use the newer <code>iot:Data-ATS</code> endpoint type to avoid issues related to the widespread distrust of Symantec certificate authorities.</p>
        pub fn set_endpoint_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEndpointInput`](crate::input::DescribeEndpointInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeEndpointInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeEndpointInput {
                endpoint_type: self.endpoint_type,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeEndpointInputOperationOutputAlias = crate::operation::DescribeEndpoint;
#[doc(hidden)]
pub type DescribeEndpointInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeEndpointInput {
    /// Consumes the builder and constructs an Operation<[`DescribeEndpoint`](crate::operation::DescribeEndpoint)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeEndpoint,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeEndpointInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/endpoint").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DescribeEndpointInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_93) = &_input.endpoint_type {
                    query.push_kv(
                        "endpointType",
                        &aws_smithy_http::query::fmt_string(&inner_93),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeEndpointInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeEndpoint::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeEndpoint",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeEndpointInput`](crate::input::DescribeEndpointInput)
    pub fn builder() -> crate::input::describe_endpoint_input::Builder {
        crate::input::describe_endpoint_input::Builder::default()
    }
}

/// See [`DescribeEventConfigurationsInput`](crate::input::DescribeEventConfigurationsInput)
pub mod describe_event_configurations_input {

    /// A builder for [`DescribeEventConfigurationsInput`](crate::input::DescribeEventConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeEventConfigurationsInput`](crate::input::DescribeEventConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeEventConfigurationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeEventConfigurationsInput {})
        }
    }
}
#[doc(hidden)]
pub type DescribeEventConfigurationsInputOperationOutputAlias =
    crate::operation::DescribeEventConfigurations;
#[doc(hidden)]
pub type DescribeEventConfigurationsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeEventConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeEventConfigurations`](crate::operation::DescribeEventConfigurations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeEventConfigurations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeEventConfigurationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/event-configurations").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeEventConfigurationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeEventConfigurations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeEventConfigurations",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeEventConfigurationsInput`](crate::input::DescribeEventConfigurationsInput)
    pub fn builder() -> crate::input::describe_event_configurations_input::Builder {
        crate::input::describe_event_configurations_input::Builder::default()
    }
}

/// See [`DescribeFleetMetricInput`](crate::input::DescribeFleetMetricInput)
pub mod describe_fleet_metric_input {

    /// A builder for [`DescribeFleetMetricInput`](crate::input::DescribeFleetMetricInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the fleet metric to describe.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet metric to describe.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeFleetMetricInput`](crate::input::DescribeFleetMetricInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeFleetMetricInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeFleetMetricInput {
                metric_name: self.metric_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeFleetMetricInputOperationOutputAlias = crate::operation::DescribeFleetMetric;
#[doc(hidden)]
pub type DescribeFleetMetricInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeFleetMetricInput {
    /// Consumes the builder and constructs an Operation<[`DescribeFleetMetric`](crate::operation::DescribeFleetMetric)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeFleetMetric,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeFleetMetricInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_94 = &_input.metric_name;
                let input_94 = input_94.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let metric_name = aws_smithy_http::label::fmt_string(input_94, false);
                if metric_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/fleet-metric/{metricName}",
                    metricName = metric_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeFleetMetricInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeFleetMetric::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeFleetMetric",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeFleetMetricInput`](crate::input::DescribeFleetMetricInput)
    pub fn builder() -> crate::input::describe_fleet_metric_input::Builder {
        crate::input::describe_fleet_metric_input::Builder::default()
    }
}

/// See [`DescribeIndexInput`](crate::input::DescribeIndexInput)
pub mod describe_index_input {

    /// A builder for [`DescribeIndexInput`](crate::input::DescribeIndexInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The index name.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The index name.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeIndexInput`](crate::input::DescribeIndexInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeIndexInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeIndexInput {
                index_name: self.index_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeIndexInputOperationOutputAlias = crate::operation::DescribeIndex;
#[doc(hidden)]
pub type DescribeIndexInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeIndexInput {
    /// Consumes the builder and constructs an Operation<[`DescribeIndex`](crate::operation::DescribeIndex)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeIndex,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeIndexInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_95 = &_input.index_name;
                let input_95 = input_95.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "index_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let index_name = aws_smithy_http::label::fmt_string(input_95, false);
                if index_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "index_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/indices/{indexName}", indexName = index_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeIndexInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeIndex::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeIndex",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeIndexInput`](crate::input::DescribeIndexInput)
    pub fn builder() -> crate::input::describe_index_input::Builder {
        crate::input::describe_index_input::Builder::default()
    }
}

/// See [`DescribeJobInput`](crate::input::DescribeJobInput)
pub mod describe_job_input {

    /// A builder for [`DescribeJobInput`](crate::input::DescribeJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeJobInput`](crate::input::DescribeJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeJobInput {
                job_id: self.job_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeJobInputOperationOutputAlias = crate::operation::DescribeJob;
#[doc(hidden)]
pub type DescribeJobInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeJobInput {
    /// Consumes the builder and constructs an Operation<[`DescribeJob`](crate::operation::DescribeJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeJob,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeJobInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_96 = &_input.job_id;
                let input_96 = input_96.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_id = aws_smithy_http::label::fmt_string(input_96, false);
                if job_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/jobs/{jobId}", jobId = job_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeJobInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeJob",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeJobInput`](crate::input::DescribeJobInput)
    pub fn builder() -> crate::input::describe_job_input::Builder {
        crate::input::describe_job_input::Builder::default()
    }
}

/// See [`DescribeJobExecutionInput`](crate::input::DescribeJobExecutionInput)
pub mod describe_job_execution_input {

    /// A builder for [`DescribeJobExecutionInput`](crate::input::DescribeJobExecutionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) execution_number: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The name of the thing on which the job execution is running.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing on which the job execution is running.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.</p>
        pub fn execution_number(mut self, input: i64) -> Self {
            self.execution_number = Some(input);
            self
        }
        /// <p>A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.</p>
        pub fn set_execution_number(mut self, input: std::option::Option<i64>) -> Self {
            self.execution_number = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeJobExecutionInput`](crate::input::DescribeJobExecutionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeJobExecutionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeJobExecutionInput {
                job_id: self.job_id,
                thing_name: self.thing_name,
                execution_number: self.execution_number,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeJobExecutionInputOperationOutputAlias = crate::operation::DescribeJobExecution;
#[doc(hidden)]
pub type DescribeJobExecutionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeJobExecutionInput {
    /// Consumes the builder and constructs an Operation<[`DescribeJobExecution`](crate::operation::DescribeJobExecution)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeJobExecution,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeJobExecutionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_97 = &_input.thing_name;
                let input_97 = input_97.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_97, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                let input_98 = &_input.job_id;
                let input_98 = input_98.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_id = aws_smithy_http::label::fmt_string(input_98, false);
                if job_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/things/{thingName}/jobs/{jobId}",
                    thingName = thing_name,
                    jobId = job_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DescribeJobExecutionInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_99) = &_input.execution_number {
                    query.push_kv(
                        "executionNumber",
                        aws_smithy_types::primitive::Encoder::from(*inner_99).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeJobExecutionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeJobExecution::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeJobExecution",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeJobExecutionInput`](crate::input::DescribeJobExecutionInput)
    pub fn builder() -> crate::input::describe_job_execution_input::Builder {
        crate::input::describe_job_execution_input::Builder::default()
    }
}

/// See [`DescribeJobTemplateInput`](crate::input::DescribeJobTemplateInput)
pub mod describe_job_template_input {

    /// A builder for [`DescribeJobTemplateInput`](crate::input::DescribeJobTemplateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_template_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the job template.</p>
        pub fn job_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_template_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the job template.</p>
        pub fn set_job_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_template_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeJobTemplateInput`](crate::input::DescribeJobTemplateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeJobTemplateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeJobTemplateInput {
                job_template_id: self.job_template_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeJobTemplateInputOperationOutputAlias = crate::operation::DescribeJobTemplate;
#[doc(hidden)]
pub type DescribeJobTemplateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeJobTemplateInput {
    /// Consumes the builder and constructs an Operation<[`DescribeJobTemplate`](crate::operation::DescribeJobTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeJobTemplate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeJobTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_100 = &_input.job_template_id;
                let input_100 = input_100.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_template_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_template_id = aws_smithy_http::label::fmt_string(input_100, false);
                if job_template_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_template_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/job-templates/{jobTemplateId}",
                    jobTemplateId = job_template_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeJobTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeJobTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeJobTemplate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeJobTemplateInput`](crate::input::DescribeJobTemplateInput)
    pub fn builder() -> crate::input::describe_job_template_input::Builder {
        crate::input::describe_job_template_input::Builder::default()
    }
}

/// See [`DescribeManagedJobTemplateInput`](crate::input::DescribeManagedJobTemplateInput)
pub mod describe_managed_job_template_input {

    /// A builder for [`DescribeManagedJobTemplateInput`](crate::input::DescribeManagedJobTemplateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique name of a managed job template, which is required.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The unique name of a managed job template, which is required.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>An optional parameter to specify version of a managed template. If not specified, the pre-defined default version is returned.</p>
        pub fn template_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_version = Some(input.into());
            self
        }
        /// <p>An optional parameter to specify version of a managed template. If not specified, the pre-defined default version is returned.</p>
        pub fn set_template_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeManagedJobTemplateInput`](crate::input::DescribeManagedJobTemplateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeManagedJobTemplateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeManagedJobTemplateInput {
                template_name: self.template_name,
                template_version: self.template_version,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeManagedJobTemplateInputOperationOutputAlias =
    crate::operation::DescribeManagedJobTemplate;
#[doc(hidden)]
pub type DescribeManagedJobTemplateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeManagedJobTemplateInput {
    /// Consumes the builder and constructs an Operation<[`DescribeManagedJobTemplate`](crate::operation::DescribeManagedJobTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeManagedJobTemplate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeManagedJobTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_101 = &_input.template_name;
                let input_101 = input_101.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let template_name = aws_smithy_http::label::fmt_string(input_101, false);
                if template_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/managed-job-templates/{templateName}",
                    templateName = template_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DescribeManagedJobTemplateInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_102) = &_input.template_version {
                    query.push_kv(
                        "templateVersion",
                        &aws_smithy_http::query::fmt_string(&inner_102),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeManagedJobTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeManagedJobTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeManagedJobTemplate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeManagedJobTemplateInput`](crate::input::DescribeManagedJobTemplateInput)
    pub fn builder() -> crate::input::describe_managed_job_template_input::Builder {
        crate::input::describe_managed_job_template_input::Builder::default()
    }
}

/// See [`DescribeMitigationActionInput`](crate::input::DescribeMitigationActionInput)
pub mod describe_mitigation_action_input {

    /// A builder for [`DescribeMitigationActionInput`](crate::input::DescribeMitigationActionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The friendly name that uniquely identifies the mitigation action.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        /// <p>The friendly name that uniquely identifies the mitigation action.</p>
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeMitigationActionInput`](crate::input::DescribeMitigationActionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeMitigationActionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeMitigationActionInput {
                action_name: self.action_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeMitigationActionInputOperationOutputAlias =
    crate::operation::DescribeMitigationAction;
#[doc(hidden)]
pub type DescribeMitigationActionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeMitigationActionInput {
    /// Consumes the builder and constructs an Operation<[`DescribeMitigationAction`](crate::operation::DescribeMitigationAction)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeMitigationAction,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeMitigationActionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_103 = &_input.action_name;
                let input_103 = input_103.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "action_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let action_name = aws_smithy_http::label::fmt_string(input_103, false);
                if action_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "action_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/mitigationactions/actions/{actionName}",
                    actionName = action_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeMitigationActionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeMitigationAction::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeMitigationAction",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeMitigationActionInput`](crate::input::DescribeMitigationActionInput)
    pub fn builder() -> crate::input::describe_mitigation_action_input::Builder {
        crate::input::describe_mitigation_action_input::Builder::default()
    }
}

/// See [`DescribeProvisioningTemplateInput`](crate::input::DescribeProvisioningTemplateInput)
pub mod describe_provisioning_template_input {

    /// A builder for [`DescribeProvisioningTemplateInput`](crate::input::DescribeProvisioningTemplateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the fleet provisioning template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet provisioning template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeProvisioningTemplateInput`](crate::input::DescribeProvisioningTemplateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeProvisioningTemplateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeProvisioningTemplateInput {
                template_name: self.template_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeProvisioningTemplateInputOperationOutputAlias =
    crate::operation::DescribeProvisioningTemplate;
#[doc(hidden)]
pub type DescribeProvisioningTemplateInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DescribeProvisioningTemplateInput {
    /// Consumes the builder and constructs an Operation<[`DescribeProvisioningTemplate`](crate::operation::DescribeProvisioningTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeProvisioningTemplate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeProvisioningTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_104 = &_input.template_name;
                let input_104 = input_104.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let template_name = aws_smithy_http::label::fmt_string(input_104, false);
                if template_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/provisioning-templates/{templateName}",
                    templateName = template_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeProvisioningTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeProvisioningTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeProvisioningTemplate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeProvisioningTemplateInput`](crate::input::DescribeProvisioningTemplateInput)
    pub fn builder() -> crate::input::describe_provisioning_template_input::Builder {
        crate::input::describe_provisioning_template_input::Builder::default()
    }
}

/// See [`DescribeProvisioningTemplateVersionInput`](crate::input::DescribeProvisioningTemplateVersionInput)
pub mod describe_provisioning_template_version_input {

    /// A builder for [`DescribeProvisioningTemplateVersionInput`](crate::input::DescribeProvisioningTemplateVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The template name.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The template name.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The fleet provisioning template version ID.</p>
        pub fn version_id(mut self, input: i32) -> Self {
            self.version_id = Some(input);
            self
        }
        /// <p>The fleet provisioning template version ID.</p>
        pub fn set_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeProvisioningTemplateVersionInput`](crate::input::DescribeProvisioningTemplateVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeProvisioningTemplateVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeProvisioningTemplateVersionInput {
                template_name: self.template_name,
                version_id: self.version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeProvisioningTemplateVersionInputOperationOutputAlias =
    crate::operation::DescribeProvisioningTemplateVersion;
#[doc(hidden)]
pub type DescribeProvisioningTemplateVersionInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DescribeProvisioningTemplateVersionInput {
    /// Consumes the builder and constructs an Operation<[`DescribeProvisioningTemplateVersion`](crate::operation::DescribeProvisioningTemplateVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeProvisioningTemplateVersion,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeProvisioningTemplateVersionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_105 = &_input.template_name;
                let input_105 = input_105.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let template_name = aws_smithy_http::label::fmt_string(input_105, false);
                if template_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    });
                }
                let input_106 = &_input.version_id;
                let input_106 = input_106.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "version_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let mut version_id_encoder = aws_smithy_types::primitive::Encoder::from(*input_106);
                let version_id = version_id_encoder.encode();
                if version_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "version_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/provisioning-templates/{templateName}/versions/{versionId}",
                    templateName = template_name,
                    versionId = version_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeProvisioningTemplateVersionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeProvisioningTemplateVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeProvisioningTemplateVersion",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeProvisioningTemplateVersionInput`](crate::input::DescribeProvisioningTemplateVersionInput)
    pub fn builder() -> crate::input::describe_provisioning_template_version_input::Builder {
        crate::input::describe_provisioning_template_version_input::Builder::default()
    }
}

/// See [`DescribeRoleAliasInput`](crate::input::DescribeRoleAliasInput)
pub mod describe_role_alias_input {

    /// A builder for [`DescribeRoleAliasInput`](crate::input::DescribeRoleAliasInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_alias: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The role alias to describe.</p>
        pub fn role_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_alias = Some(input.into());
            self
        }
        /// <p>The role alias to describe.</p>
        pub fn set_role_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_alias = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRoleAliasInput`](crate::input::DescribeRoleAliasInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeRoleAliasInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeRoleAliasInput {
                role_alias: self.role_alias,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeRoleAliasInputOperationOutputAlias = crate::operation::DescribeRoleAlias;
#[doc(hidden)]
pub type DescribeRoleAliasInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeRoleAliasInput {
    /// Consumes the builder and constructs an Operation<[`DescribeRoleAlias`](crate::operation::DescribeRoleAlias)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeRoleAlias,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeRoleAliasInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_107 = &_input.role_alias;
                let input_107 = input_107.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "role_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let role_alias = aws_smithy_http::label::fmt_string(input_107, false);
                if role_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "role_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/role-aliases/{roleAlias}", roleAlias = role_alias)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeRoleAliasInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeRoleAlias::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeRoleAlias",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeRoleAliasInput`](crate::input::DescribeRoleAliasInput)
    pub fn builder() -> crate::input::describe_role_alias_input::Builder {
        crate::input::describe_role_alias_input::Builder::default()
    }
}

/// See [`DescribeScheduledAuditInput`](crate::input::DescribeScheduledAuditInput)
pub mod describe_scheduled_audit_input {

    /// A builder for [`DescribeScheduledAuditInput`](crate::input::DescribeScheduledAuditInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scheduled_audit_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the scheduled audit whose information you want to get.</p>
        pub fn scheduled_audit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduled_audit_name = Some(input.into());
            self
        }
        /// <p>The name of the scheduled audit whose information you want to get.</p>
        pub fn set_scheduled_audit_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_audit_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeScheduledAuditInput`](crate::input::DescribeScheduledAuditInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeScheduledAuditInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeScheduledAuditInput {
                scheduled_audit_name: self.scheduled_audit_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeScheduledAuditInputOperationOutputAlias = crate::operation::DescribeScheduledAudit;
#[doc(hidden)]
pub type DescribeScheduledAuditInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeScheduledAuditInput {
    /// Consumes the builder and constructs an Operation<[`DescribeScheduledAudit`](crate::operation::DescribeScheduledAudit)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeScheduledAudit,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeScheduledAuditInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_108 = &_input.scheduled_audit_name;
                let input_108 = input_108.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "scheduled_audit_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let scheduled_audit_name = aws_smithy_http::label::fmt_string(input_108, false);
                if scheduled_audit_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "scheduled_audit_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/audit/scheduledaudits/{scheduledAuditName}",
                    scheduledAuditName = scheduled_audit_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeScheduledAuditInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeScheduledAudit::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeScheduledAudit",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeScheduledAuditInput`](crate::input::DescribeScheduledAuditInput)
    pub fn builder() -> crate::input::describe_scheduled_audit_input::Builder {
        crate::input::describe_scheduled_audit_input::Builder::default()
    }
}

/// See [`DescribeSecurityProfileInput`](crate::input::DescribeSecurityProfileInput)
pub mod describe_security_profile_input {

    /// A builder for [`DescribeSecurityProfileInput`](crate::input::DescribeSecurityProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the security profile whose information you want to get.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The name of the security profile whose information you want to get.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeSecurityProfileInput`](crate::input::DescribeSecurityProfileInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeSecurityProfileInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeSecurityProfileInput {
                security_profile_name: self.security_profile_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeSecurityProfileInputOperationOutputAlias =
    crate::operation::DescribeSecurityProfile;
#[doc(hidden)]
pub type DescribeSecurityProfileInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeSecurityProfileInput {
    /// Consumes the builder and constructs an Operation<[`DescribeSecurityProfile`](crate::operation::DescribeSecurityProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeSecurityProfile,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeSecurityProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_109 = &_input.security_profile_name;
                let input_109 = input_109.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let security_profile_name = aws_smithy_http::label::fmt_string(input_109, false);
                if security_profile_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/security-profiles/{securityProfileName}",
                    securityProfileName = security_profile_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeSecurityProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeSecurityProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeSecurityProfile",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeSecurityProfileInput`](crate::input::DescribeSecurityProfileInput)
    pub fn builder() -> crate::input::describe_security_profile_input::Builder {
        crate::input::describe_security_profile_input::Builder::default()
    }
}

/// See [`DescribeStreamInput`](crate::input::DescribeStreamInput)
pub mod describe_stream_input {

    /// A builder for [`DescribeStreamInput`](crate::input::DescribeStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>The stream ID.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeStreamInput`](crate::input::DescribeStreamInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeStreamInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeStreamInput {
                stream_id: self.stream_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeStreamInputOperationOutputAlias = crate::operation::DescribeStream;
#[doc(hidden)]
pub type DescribeStreamInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeStreamInput {
    /// Consumes the builder and constructs an Operation<[`DescribeStream`](crate::operation::DescribeStream)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeStream,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeStreamInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_110 = &_input.stream_id;
                let input_110 = input_110.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "stream_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let stream_id = aws_smithy_http::label::fmt_string(input_110, false);
                if stream_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "stream_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/streams/{streamId}", streamId = stream_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeStreamInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeStream::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeStream",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeStreamInput`](crate::input::DescribeStreamInput)
    pub fn builder() -> crate::input::describe_stream_input::Builder {
        crate::input::describe_stream_input::Builder::default()
    }
}

/// See [`DescribeThingInput`](crate::input::DescribeThingInput)
pub mod describe_thing_input {

    /// A builder for [`DescribeThingInput`](crate::input::DescribeThingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeThingInput`](crate::input::DescribeThingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeThingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeThingInput {
                thing_name: self.thing_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeThingInputOperationOutputAlias = crate::operation::DescribeThing;
#[doc(hidden)]
pub type DescribeThingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeThingInput {
    /// Consumes the builder and constructs an Operation<[`DescribeThing`](crate::operation::DescribeThing)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeThing,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeThingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_111 = &_input.thing_name;
                let input_111 = input_111.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_111, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/things/{thingName}", thingName = thing_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeThingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeThing::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeThing",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeThingInput`](crate::input::DescribeThingInput)
    pub fn builder() -> crate::input::describe_thing_input::Builder {
        crate::input::describe_thing_input::Builder::default()
    }
}

/// See [`DescribeThingGroupInput`](crate::input::DescribeThingGroupInput)
pub mod describe_thing_group_input {

    /// A builder for [`DescribeThingGroupInput`](crate::input::DescribeThingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the thing group.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the thing group.</p>
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeThingGroupInput`](crate::input::DescribeThingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeThingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeThingGroupInput {
                thing_group_name: self.thing_group_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeThingGroupInputOperationOutputAlias = crate::operation::DescribeThingGroup;
#[doc(hidden)]
pub type DescribeThingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeThingGroupInput {
    /// Consumes the builder and constructs an Operation<[`DescribeThingGroup`](crate::operation::DescribeThingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeThingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeThingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_112 = &_input.thing_group_name;
                let input_112 = input_112.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_group_name = aws_smithy_http::label::fmt_string(input_112, false);
                if thing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-groups/{thingGroupName}",
                    thingGroupName = thing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeThingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeThingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeThingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeThingGroupInput`](crate::input::DescribeThingGroupInput)
    pub fn builder() -> crate::input::describe_thing_group_input::Builder {
        crate::input::describe_thing_group_input::Builder::default()
    }
}

/// See [`DescribeThingRegistrationTaskInput`](crate::input::DescribeThingRegistrationTaskInput)
pub mod describe_thing_registration_task_input {

    /// A builder for [`DescribeThingRegistrationTaskInput`](crate::input::DescribeThingRegistrationTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The task ID.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The task ID.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeThingRegistrationTaskInput`](crate::input::DescribeThingRegistrationTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeThingRegistrationTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeThingRegistrationTaskInput {
                task_id: self.task_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeThingRegistrationTaskInputOperationOutputAlias =
    crate::operation::DescribeThingRegistrationTask;
#[doc(hidden)]
pub type DescribeThingRegistrationTaskInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DescribeThingRegistrationTaskInput {
    /// Consumes the builder and constructs an Operation<[`DescribeThingRegistrationTask`](crate::operation::DescribeThingRegistrationTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeThingRegistrationTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeThingRegistrationTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_113 = &_input.task_id;
                let input_113 = input_113.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let task_id = aws_smithy_http::label::fmt_string(input_113, false);
                if task_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-registration-tasks/{taskId}",
                    taskId = task_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeThingRegistrationTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeThingRegistrationTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeThingRegistrationTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeThingRegistrationTaskInput`](crate::input::DescribeThingRegistrationTaskInput)
    pub fn builder() -> crate::input::describe_thing_registration_task_input::Builder {
        crate::input::describe_thing_registration_task_input::Builder::default()
    }
}

/// See [`DescribeThingTypeInput`](crate::input::DescribeThingTypeInput)
pub mod describe_thing_type_input {

    /// A builder for [`DescribeThingTypeInput`](crate::input::DescribeThingTypeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_type_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the thing type.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_type_name = Some(input.into());
            self
        }
        /// <p>The name of the thing type.</p>
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_type_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeThingTypeInput`](crate::input::DescribeThingTypeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeThingTypeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeThingTypeInput {
                thing_type_name: self.thing_type_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeThingTypeInputOperationOutputAlias = crate::operation::DescribeThingType;
#[doc(hidden)]
pub type DescribeThingTypeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeThingTypeInput {
    /// Consumes the builder and constructs an Operation<[`DescribeThingType`](crate::operation::DescribeThingType)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeThingType,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeThingTypeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_114 = &_input.thing_type_name;
                let input_114 = input_114.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_type_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_type_name = aws_smithy_http::label::fmt_string(input_114, false);
                if thing_type_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_type_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-types/{thingTypeName}",
                    thingTypeName = thing_type_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeThingTypeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeThingType::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeThingType",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeThingTypeInput`](crate::input::DescribeThingTypeInput)
    pub fn builder() -> crate::input::describe_thing_type_input::Builder {
        crate::input::describe_thing_type_input::Builder::default()
    }
}

/// See [`DetachPolicyInput`](crate::input::DetachPolicyInput)
pub mod detach_policy_input {

    /// A builder for [`DetachPolicyInput`](crate::input::DetachPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) target: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The policy to detach.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The policy to detach.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The target from which the policy will be detached.</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.target = Some(input.into());
            self
        }
        /// <p>The target from which the policy will be detached.</p>
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target = input;
            self
        }
        /// Consumes the builder and constructs a [`DetachPolicyInput`](crate::input::DetachPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetachPolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetachPolicyInput {
                policy_name: self.policy_name,
                target: self.target,
            })
        }
    }
}
#[doc(hidden)]
pub type DetachPolicyInputOperationOutputAlias = crate::operation::DetachPolicy;
#[doc(hidden)]
pub type DetachPolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DetachPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DetachPolicy`](crate::operation::DetachPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetachPolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DetachPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_115 = &_input.policy_name;
                let input_115 = input_115.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_115, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/target-policies/{policyName}",
                    policyName = policy_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DetachPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_detach_policy(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetachPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetachPolicy",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DetachPolicyInput`](crate::input::DetachPolicyInput)
    pub fn builder() -> crate::input::detach_policy_input::Builder {
        crate::input::detach_policy_input::Builder::default()
    }
}

/// See [`DetachPrincipalPolicyInput`](crate::input::DetachPrincipalPolicyInput)
pub mod detach_principal_policy_input {

    /// A builder for [`DetachPrincipalPolicyInput`](crate::input::DetachPrincipalPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) principal: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the policy to detach.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy to detach.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The principal.</p>
        /// <p>Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal = Some(input.into());
            self
        }
        /// <p>The principal.</p>
        /// <p>Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal = input;
            self
        }
        /// Consumes the builder and constructs a [`DetachPrincipalPolicyInput`](crate::input::DetachPrincipalPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetachPrincipalPolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetachPrincipalPolicyInput {
                policy_name: self.policy_name,
                principal: self.principal,
            })
        }
    }
}
#[doc(hidden)]
pub type DetachPrincipalPolicyInputOperationOutputAlias = crate::operation::DetachPrincipalPolicy;
#[doc(hidden)]
pub type DetachPrincipalPolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DetachPrincipalPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DetachPrincipalPolicy`](crate::operation::DetachPrincipalPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetachPrincipalPolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DetachPrincipalPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_116 = &_input.policy_name;
                let input_116 = input_116.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_116, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/principal-policies/{policyName}",
                    policyName = policy_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DetachPrincipalPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_detach_principal_policy(input, builder)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetachPrincipalPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetachPrincipalPolicy",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DetachPrincipalPolicyInput`](crate::input::DetachPrincipalPolicyInput)
    pub fn builder() -> crate::input::detach_principal_policy_input::Builder {
        crate::input::detach_principal_policy_input::Builder::default()
    }
}

/// See [`DetachSecurityProfileInput`](crate::input::DetachSecurityProfileInput)
pub mod detach_security_profile_input {

    /// A builder for [`DetachSecurityProfileInput`](crate::input::DetachSecurityProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) security_profile_target_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The security profile that is detached.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The security profile that is detached.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p>The ARN of the thing group from which the security profile is detached.</p>
        pub fn security_profile_target_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.security_profile_target_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the thing group from which the security profile is detached.</p>
        pub fn set_security_profile_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_target_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DetachSecurityProfileInput`](crate::input::DetachSecurityProfileInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetachSecurityProfileInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetachSecurityProfileInput {
                security_profile_name: self.security_profile_name,
                security_profile_target_arn: self.security_profile_target_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DetachSecurityProfileInputOperationOutputAlias = crate::operation::DetachSecurityProfile;
#[doc(hidden)]
pub type DetachSecurityProfileInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DetachSecurityProfileInput {
    /// Consumes the builder and constructs an Operation<[`DetachSecurityProfile`](crate::operation::DetachSecurityProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetachSecurityProfile,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DetachSecurityProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_117 = &_input.security_profile_name;
                let input_117 = input_117.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let security_profile_name = aws_smithy_http::label::fmt_string(input_117, false);
                if security_profile_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/security-profiles/{securityProfileName}/targets",
                    securityProfileName = security_profile_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DetachSecurityProfileInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_118) = &_input.security_profile_target_arn {
                    query.push_kv(
                        "securityProfileTargetArn",
                        &aws_smithy_http::query::fmt_string(&inner_118),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DetachSecurityProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetachSecurityProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetachSecurityProfile",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DetachSecurityProfileInput`](crate::input::DetachSecurityProfileInput)
    pub fn builder() -> crate::input::detach_security_profile_input::Builder {
        crate::input::detach_security_profile_input::Builder::default()
    }
}

/// See [`DetachThingPrincipalInput`](crate::input::DetachThingPrincipalInput)
pub mod detach_thing_principal_input {

    /// A builder for [`DetachThingPrincipalInput`](crate::input::DetachThingPrincipalInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) principal: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal = Some(input.into());
            self
        }
        /// <p>If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.</p>
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal = input;
            self
        }
        /// Consumes the builder and constructs a [`DetachThingPrincipalInput`](crate::input::DetachThingPrincipalInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetachThingPrincipalInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetachThingPrincipalInput {
                thing_name: self.thing_name,
                principal: self.principal,
            })
        }
    }
}
#[doc(hidden)]
pub type DetachThingPrincipalInputOperationOutputAlias = crate::operation::DetachThingPrincipal;
#[doc(hidden)]
pub type DetachThingPrincipalInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DetachThingPrincipalInput {
    /// Consumes the builder and constructs an Operation<[`DetachThingPrincipal`](crate::operation::DetachThingPrincipal)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetachThingPrincipal,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DetachThingPrincipalInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_119 = &_input.thing_name;
                let input_119 = input_119.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_119, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/things/{thingName}/principals",
                    thingName = thing_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DetachThingPrincipalInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_detach_thing_principal(input, builder)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetachThingPrincipal::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetachThingPrincipal",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DetachThingPrincipalInput`](crate::input::DetachThingPrincipalInput)
    pub fn builder() -> crate::input::detach_thing_principal_input::Builder {
        crate::input::detach_thing_principal_input::Builder::default()
    }
}

/// See [`DisableTopicRuleInput`](crate::input::DisableTopicRuleInput)
pub mod disable_topic_rule_input {

    /// A builder for [`DisableTopicRuleInput`](crate::input::DisableTopicRuleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the rule to disable.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_name = Some(input.into());
            self
        }
        /// <p>The name of the rule to disable.</p>
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DisableTopicRuleInput`](crate::input::DisableTopicRuleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisableTopicRuleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisableTopicRuleInput {
                rule_name: self.rule_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DisableTopicRuleInputOperationOutputAlias = crate::operation::DisableTopicRule;
#[doc(hidden)]
pub type DisableTopicRuleInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DisableTopicRuleInput {
    /// Consumes the builder and constructs an Operation<[`DisableTopicRule`](crate::operation::DisableTopicRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisableTopicRule,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisableTopicRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_120 = &_input.rule_name;
                let input_120 = input_120.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let rule_name = aws_smithy_http::label::fmt_string(input_120, false);
                if rule_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/rules/{ruleName}/disable", ruleName = rule_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisableTopicRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisableTopicRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisableTopicRule",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisableTopicRuleInput`](crate::input::DisableTopicRuleInput)
    pub fn builder() -> crate::input::disable_topic_rule_input::Builder {
        crate::input::disable_topic_rule_input::Builder::default()
    }
}

/// See [`EnableTopicRuleInput`](crate::input::EnableTopicRuleInput)
pub mod enable_topic_rule_input {

    /// A builder for [`EnableTopicRuleInput`](crate::input::EnableTopicRuleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the topic rule to enable.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_name = Some(input.into());
            self
        }
        /// <p>The name of the topic rule to enable.</p>
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_name = input;
            self
        }
        /// Consumes the builder and constructs a [`EnableTopicRuleInput`](crate::input::EnableTopicRuleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::EnableTopicRuleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::EnableTopicRuleInput {
                rule_name: self.rule_name,
            })
        }
    }
}
#[doc(hidden)]
pub type EnableTopicRuleInputOperationOutputAlias = crate::operation::EnableTopicRule;
#[doc(hidden)]
pub type EnableTopicRuleInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl EnableTopicRuleInput {
    /// Consumes the builder and constructs an Operation<[`EnableTopicRule`](crate::operation::EnableTopicRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::EnableTopicRule,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::EnableTopicRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_121 = &_input.rule_name;
                let input_121 = input_121.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let rule_name = aws_smithy_http::label::fmt_string(input_121, false);
                if rule_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/rules/{ruleName}/enable", ruleName = rule_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::EnableTopicRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::EnableTopicRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "EnableTopicRule",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`EnableTopicRuleInput`](crate::input::EnableTopicRuleInput)
    pub fn builder() -> crate::input::enable_topic_rule_input::Builder {
        crate::input::enable_topic_rule_input::Builder::default()
    }
}

/// See [`GetBehaviorModelTrainingSummariesInput`](crate::input::GetBehaviorModelTrainingSummariesInput)
pub mod get_behavior_model_training_summaries_input {

    /// A builder for [`GetBehaviorModelTrainingSummariesInput`](crate::input::GetBehaviorModelTrainingSummariesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the security profile. </p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p> The name of the security profile. </p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p> The maximum number of results to return at one time. The default is 25. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of results to return at one time. The default is 25. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p> The token for the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBehaviorModelTrainingSummariesInput`](crate::input::GetBehaviorModelTrainingSummariesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBehaviorModelTrainingSummariesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBehaviorModelTrainingSummariesInput {
                security_profile_name: self.security_profile_name,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBehaviorModelTrainingSummariesInputOperationOutputAlias =
    crate::operation::GetBehaviorModelTrainingSummaries;
#[doc(hidden)]
pub type GetBehaviorModelTrainingSummariesInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetBehaviorModelTrainingSummariesInput {
    /// Consumes the builder and constructs an Operation<[`GetBehaviorModelTrainingSummaries`](crate::operation::GetBehaviorModelTrainingSummaries)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetBehaviorModelTrainingSummaries,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetBehaviorModelTrainingSummariesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/behavior-model-training/summaries")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetBehaviorModelTrainingSummariesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_122) = &_input.security_profile_name {
                    query.push_kv(
                        "securityProfileName",
                        &aws_smithy_http::query::fmt_string(&inner_122),
                    );
                }
                if let Some(inner_123) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_123).encode(),
                    );
                }
                if let Some(inner_124) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_124));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetBehaviorModelTrainingSummariesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBehaviorModelTrainingSummaries::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetBehaviorModelTrainingSummaries",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetBehaviorModelTrainingSummariesInput`](crate::input::GetBehaviorModelTrainingSummariesInput)
    pub fn builder() -> crate::input::get_behavior_model_training_summaries_input::Builder {
        crate::input::get_behavior_model_training_summaries_input::Builder::default()
    }
}

/// See [`GetBucketsAggregationInput`](crate::input::GetBucketsAggregationInput)
pub mod get_buckets_aggregation_input {

    /// A builder for [`GetBucketsAggregationInput`](crate::input::GetBucketsAggregationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) aggregation_field: std::option::Option<std::string::String>,
        pub(crate) query_version: std::option::Option<std::string::String>,
        pub(crate) buckets_aggregation_type:
            std::option::Option<crate::model::BucketsAggregationType>,
    }
    impl Builder {
        /// <p>The name of the index to search.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The name of the index to search.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>The search query string.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The search query string.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The aggregation field.</p>
        pub fn aggregation_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.aggregation_field = Some(input.into());
            self
        }
        /// <p>The aggregation field.</p>
        pub fn set_aggregation_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aggregation_field = input;
            self
        }
        /// <p>The version of the query.</p>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_version = Some(input.into());
            self
        }
        /// <p>The version of the query.</p>
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_version = input;
            self
        }
        /// <p>The basic control of the response shape and the bucket aggregation type to perform. </p>
        pub fn buckets_aggregation_type(
            mut self,
            input: crate::model::BucketsAggregationType,
        ) -> Self {
            self.buckets_aggregation_type = Some(input);
            self
        }
        /// <p>The basic control of the response shape and the bucket aggregation type to perform. </p>
        pub fn set_buckets_aggregation_type(
            mut self,
            input: std::option::Option<crate::model::BucketsAggregationType>,
        ) -> Self {
            self.buckets_aggregation_type = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketsAggregationInput`](crate::input::GetBucketsAggregationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketsAggregationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketsAggregationInput {
                index_name: self.index_name,
                query_string: self.query_string,
                aggregation_field: self.aggregation_field,
                query_version: self.query_version,
                buckets_aggregation_type: self.buckets_aggregation_type,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketsAggregationInputOperationOutputAlias = crate::operation::GetBucketsAggregation;
#[doc(hidden)]
pub type GetBucketsAggregationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetBucketsAggregationInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketsAggregation`](crate::operation::GetBucketsAggregation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetBucketsAggregation,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetBucketsAggregationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/indices/buckets").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetBucketsAggregationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_get_buckets_aggregation(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketsAggregation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetBucketsAggregation",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetBucketsAggregationInput`](crate::input::GetBucketsAggregationInput)
    pub fn builder() -> crate::input::get_buckets_aggregation_input::Builder {
        crate::input::get_buckets_aggregation_input::Builder::default()
    }
}

/// See [`GetCardinalityInput`](crate::input::GetCardinalityInput)
pub mod get_cardinality_input {

    /// A builder for [`GetCardinalityInput`](crate::input::GetCardinalityInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) aggregation_field: std::option::Option<std::string::String>,
        pub(crate) query_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the index to search.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The name of the index to search.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>The search query string.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The search query string.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The field to aggregate.</p>
        pub fn aggregation_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.aggregation_field = Some(input.into());
            self
        }
        /// <p>The field to aggregate.</p>
        pub fn set_aggregation_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aggregation_field = input;
            self
        }
        /// <p>The query version.</p>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_version = Some(input.into());
            self
        }
        /// <p>The query version.</p>
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_version = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCardinalityInput`](crate::input::GetCardinalityInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCardinalityInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCardinalityInput {
                index_name: self.index_name,
                query_string: self.query_string,
                aggregation_field: self.aggregation_field,
                query_version: self.query_version,
            })
        }
    }
}
#[doc(hidden)]
pub type GetCardinalityInputOperationOutputAlias = crate::operation::GetCardinality;
#[doc(hidden)]
pub type GetCardinalityInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetCardinalityInput {
    /// Consumes the builder and constructs an Operation<[`GetCardinality`](crate::operation::GetCardinality)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCardinality,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCardinalityInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/indices/cardinality").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCardinalityInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_get_cardinality(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCardinality::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCardinality",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetCardinalityInput`](crate::input::GetCardinalityInput)
    pub fn builder() -> crate::input::get_cardinality_input::Builder {
        crate::input::get_cardinality_input::Builder::default()
    }
}

/// See [`GetEffectivePoliciesInput`](crate::input::GetEffectivePoliciesInput)
pub mod get_effective_policies_input {

    /// A builder for [`GetEffectivePoliciesInput`](crate::input::GetEffectivePoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal: std::option::Option<std::string::String>,
        pub(crate) cognito_identity_pool_id: std::option::Option<std::string::String>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal = Some(input.into());
            self
        }
        /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal = input;
            self
        }
        /// <p>The Cognito identity pool ID.</p>
        pub fn cognito_identity_pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.cognito_identity_pool_id = Some(input.into());
            self
        }
        /// <p>The Cognito identity pool ID.</p>
        pub fn set_cognito_identity_pool_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cognito_identity_pool_id = input;
            self
        }
        /// <p>The thing name.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The thing name.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetEffectivePoliciesInput`](crate::input::GetEffectivePoliciesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetEffectivePoliciesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetEffectivePoliciesInput {
                principal: self.principal,
                cognito_identity_pool_id: self.cognito_identity_pool_id,
                thing_name: self.thing_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetEffectivePoliciesInputOperationOutputAlias = crate::operation::GetEffectivePolicies;
#[doc(hidden)]
pub type GetEffectivePoliciesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetEffectivePoliciesInput {
    /// Consumes the builder and constructs an Operation<[`GetEffectivePolicies`](crate::operation::GetEffectivePolicies)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetEffectivePolicies,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetEffectivePoliciesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/effective-policies").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetEffectivePoliciesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_125) = &_input.thing_name {
                    query.push_kv("thingName", &aws_smithy_http::query::fmt_string(&inner_125));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetEffectivePoliciesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_get_effective_policies(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetEffectivePolicies::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetEffectivePolicies",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetEffectivePoliciesInput`](crate::input::GetEffectivePoliciesInput)
    pub fn builder() -> crate::input::get_effective_policies_input::Builder {
        crate::input::get_effective_policies_input::Builder::default()
    }
}

/// See [`GetIndexingConfigurationInput`](crate::input::GetIndexingConfigurationInput)
pub mod get_indexing_configuration_input {

    /// A builder for [`GetIndexingConfigurationInput`](crate::input::GetIndexingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetIndexingConfigurationInput`](crate::input::GetIndexingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetIndexingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetIndexingConfigurationInput {})
        }
    }
}
#[doc(hidden)]
pub type GetIndexingConfigurationInputOperationOutputAlias =
    crate::operation::GetIndexingConfiguration;
#[doc(hidden)]
pub type GetIndexingConfigurationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetIndexingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetIndexingConfiguration`](crate::operation::GetIndexingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetIndexingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetIndexingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/indexing/config").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetIndexingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetIndexingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetIndexingConfiguration",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetIndexingConfigurationInput`](crate::input::GetIndexingConfigurationInput)
    pub fn builder() -> crate::input::get_indexing_configuration_input::Builder {
        crate::input::get_indexing_configuration_input::Builder::default()
    }
}

/// See [`GetJobDocumentInput`](crate::input::GetJobDocumentInput)
pub mod get_job_document_input {

    /// A builder for [`GetJobDocumentInput`](crate::input::GetJobDocumentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetJobDocumentInput`](crate::input::GetJobDocumentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetJobDocumentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetJobDocumentInput {
                job_id: self.job_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetJobDocumentInputOperationOutputAlias = crate::operation::GetJobDocument;
#[doc(hidden)]
pub type GetJobDocumentInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetJobDocumentInput {
    /// Consumes the builder and constructs an Operation<[`GetJobDocument`](crate::operation::GetJobDocument)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetJobDocument,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetJobDocumentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_126 = &_input.job_id;
                let input_126 = input_126.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_id = aws_smithy_http::label::fmt_string(input_126, false);
                if job_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/jobs/{jobId}/job-document", jobId = job_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetJobDocumentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetJobDocument::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetJobDocument",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetJobDocumentInput`](crate::input::GetJobDocumentInput)
    pub fn builder() -> crate::input::get_job_document_input::Builder {
        crate::input::get_job_document_input::Builder::default()
    }
}

/// See [`GetLoggingOptionsInput`](crate::input::GetLoggingOptionsInput)
pub mod get_logging_options_input {

    /// A builder for [`GetLoggingOptionsInput`](crate::input::GetLoggingOptionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetLoggingOptionsInput`](crate::input::GetLoggingOptionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLoggingOptionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLoggingOptionsInput {})
        }
    }
}
#[doc(hidden)]
pub type GetLoggingOptionsInputOperationOutputAlias = crate::operation::GetLoggingOptions;
#[doc(hidden)]
pub type GetLoggingOptionsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetLoggingOptionsInput {
    /// Consumes the builder and constructs an Operation<[`GetLoggingOptions`](crate::operation::GetLoggingOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLoggingOptions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetLoggingOptionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/loggingOptions").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetLoggingOptionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLoggingOptions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLoggingOptions",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetLoggingOptionsInput`](crate::input::GetLoggingOptionsInput)
    pub fn builder() -> crate::input::get_logging_options_input::Builder {
        crate::input::get_logging_options_input::Builder::default()
    }
}

/// See [`GetOtaUpdateInput`](crate::input::GetOtaUpdateInput)
pub mod get_ota_update_input {

    /// A builder for [`GetOtaUpdateInput`](crate::input::GetOtaUpdateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ota_update_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The OTA update ID.</p>
        pub fn ota_update_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ota_update_id = Some(input.into());
            self
        }
        /// <p>The OTA update ID.</p>
        pub fn set_ota_update_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ota_update_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetOtaUpdateInput`](crate::input::GetOtaUpdateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetOtaUpdateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetOtaUpdateInput {
                ota_update_id: self.ota_update_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetOtaUpdateInputOperationOutputAlias = crate::operation::GetOTAUpdate;
#[doc(hidden)]
pub type GetOtaUpdateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetOtaUpdateInput {
    /// Consumes the builder and constructs an Operation<[`GetOTAUpdate`](crate::operation::GetOTAUpdate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetOTAUpdate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetOtaUpdateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_127 = &_input.ota_update_id;
                let input_127 = input_127.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "ota_update_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let ota_update_id = aws_smithy_http::label::fmt_string(input_127, false);
                if ota_update_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "ota_update_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/otaUpdates/{otaUpdateId}",
                    otaUpdateId = ota_update_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetOtaUpdateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetOTAUpdate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetOTAUpdate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetOtaUpdateInput`](crate::input::GetOtaUpdateInput)
    pub fn builder() -> crate::input::get_ota_update_input::Builder {
        crate::input::get_ota_update_input::Builder::default()
    }
}

/// See [`GetPercentilesInput`](crate::input::GetPercentilesInput)
pub mod get_percentiles_input {

    /// A builder for [`GetPercentilesInput`](crate::input::GetPercentilesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) aggregation_field: std::option::Option<std::string::String>,
        pub(crate) query_version: std::option::Option<std::string::String>,
        pub(crate) percents: std::option::Option<std::vec::Vec<f64>>,
    }
    impl Builder {
        /// <p>The name of the index to search.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The name of the index to search.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>The search query string.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The search query string.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The field to aggregate.</p>
        pub fn aggregation_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.aggregation_field = Some(input.into());
            self
        }
        /// <p>The field to aggregate.</p>
        pub fn set_aggregation_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aggregation_field = input;
            self
        }
        /// <p>The query version.</p>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_version = Some(input.into());
            self
        }
        /// <p>The query version.</p>
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_version = input;
            self
        }
        /// Appends an item to `percents`.
        ///
        /// To override the contents of this collection use [`set_percents`](Self::set_percents).
        ///
        /// <p>The percentile groups returned.</p>
        pub fn percents(mut self, input: f64) -> Self {
            let mut v = self.percents.unwrap_or_default();
            v.push(input);
            self.percents = Some(v);
            self
        }
        /// <p>The percentile groups returned.</p>
        pub fn set_percents(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.percents = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPercentilesInput`](crate::input::GetPercentilesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPercentilesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPercentilesInput {
                index_name: self.index_name,
                query_string: self.query_string,
                aggregation_field: self.aggregation_field,
                query_version: self.query_version,
                percents: self.percents,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPercentilesInputOperationOutputAlias = crate::operation::GetPercentiles;
#[doc(hidden)]
pub type GetPercentilesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetPercentilesInput {
    /// Consumes the builder and constructs an Operation<[`GetPercentiles`](crate::operation::GetPercentiles)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetPercentiles,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetPercentilesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/indices/percentiles").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetPercentilesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_get_percentiles(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetPercentiles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetPercentiles",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetPercentilesInput`](crate::input::GetPercentilesInput)
    pub fn builder() -> crate::input::get_percentiles_input::Builder {
        crate::input::get_percentiles_input::Builder::default()
    }
}

/// See [`GetPolicyInput`](crate::input::GetPolicyInput)
pub mod get_policy_input {

    /// A builder for [`GetPolicyInput`](crate::input::GetPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPolicyInput`](crate::input::GetPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetPolicyInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetPolicyInput {
                policy_name: self.policy_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPolicyInputOperationOutputAlias = crate::operation::GetPolicy;
#[doc(hidden)]
pub type GetPolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetPolicy`](crate::operation::GetPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetPolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_128 = &_input.policy_name;
                let input_128 = input_128.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_128, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/policies/{policyName}", policyName = policy_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetPolicy::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetPolicy",
                    "iot",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetPolicyInput`](crate::input::GetPolicyInput)
    pub fn builder() -> crate::input::get_policy_input::Builder {
        crate::input::get_policy_input::Builder::default()
    }
}

/// See [`GetPolicyVersionInput`](crate::input::GetPolicyVersionInput)
pub mod get_policy_version_input {

    /// A builder for [`GetPolicyVersionInput`](crate::input::GetPolicyVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The policy version ID.</p>
        pub fn policy_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_version_id = Some(input.into());
            self
        }
        /// <p>The policy version ID.</p>
        pub fn set_policy_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPolicyVersionInput`](crate::input::GetPolicyVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPolicyVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPolicyVersionInput {
                policy_name: self.policy_name,
                policy_version_id: self.policy_version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPolicyVersionInputOperationOutputAlias = crate::operation::GetPolicyVersion;
#[doc(hidden)]
pub type GetPolicyVersionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetPolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`GetPolicyVersion`](crate::operation::GetPolicyVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetPolicyVersion,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetPolicyVersionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_129 = &_input.policy_name;
                let input_129 = input_129.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_129, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                let input_130 = &_input.policy_version_id;
                let input_130 = input_130.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_version_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_version_id = aws_smithy_http::label::fmt_string(input_130, false);
                if policy_version_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_version_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/policies/{policyName}/version/{policyVersionId}",
                    policyName = policy_name,
                    policyVersionId = policy_version_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetPolicyVersionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetPolicyVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetPolicyVersion",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetPolicyVersionInput`](crate::input::GetPolicyVersionInput)
    pub fn builder() -> crate::input::get_policy_version_input::Builder {
        crate::input::get_policy_version_input::Builder::default()
    }
}

/// See [`GetRegistrationCodeInput`](crate::input::GetRegistrationCodeInput)
pub mod get_registration_code_input {

    /// A builder for [`GetRegistrationCodeInput`](crate::input::GetRegistrationCodeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetRegistrationCodeInput`](crate::input::GetRegistrationCodeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRegistrationCodeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRegistrationCodeInput {})
        }
    }
}
#[doc(hidden)]
pub type GetRegistrationCodeInputOperationOutputAlias = crate::operation::GetRegistrationCode;
#[doc(hidden)]
pub type GetRegistrationCodeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetRegistrationCodeInput {
    /// Consumes the builder and constructs an Operation<[`GetRegistrationCode`](crate::operation::GetRegistrationCode)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRegistrationCode,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetRegistrationCodeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/registrationcode").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetRegistrationCodeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRegistrationCode::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRegistrationCode",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetRegistrationCodeInput`](crate::input::GetRegistrationCodeInput)
    pub fn builder() -> crate::input::get_registration_code_input::Builder {
        crate::input::get_registration_code_input::Builder::default()
    }
}

/// See [`GetStatisticsInput`](crate::input::GetStatisticsInput)
pub mod get_statistics_input {

    /// A builder for [`GetStatisticsInput`](crate::input::GetStatisticsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) aggregation_field: std::option::Option<std::string::String>,
        pub(crate) query_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the index to search. The default value is <code>AWS_Things</code>.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The name of the index to search. The default value is <code>AWS_Things</code>.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>The query used to search. You can specify "*" for the query string to get the count of all indexed things in your Amazon Web Services account.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The query used to search. You can specify "*" for the query string to get the count of all indexed things in your Amazon Web Services account.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The aggregation field name.</p>
        pub fn aggregation_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.aggregation_field = Some(input.into());
            self
        }
        /// <p>The aggregation field name.</p>
        pub fn set_aggregation_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aggregation_field = input;
            self
        }
        /// <p>The version of the query used to search.</p>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_version = Some(input.into());
            self
        }
        /// <p>The version of the query used to search.</p>
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_version = input;
            self
        }
        /// Consumes the builder and constructs a [`GetStatisticsInput`](crate::input::GetStatisticsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetStatisticsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetStatisticsInput {
                index_name: self.index_name,
                query_string: self.query_string,
                aggregation_field: self.aggregation_field,
                query_version: self.query_version,
            })
        }
    }
}
#[doc(hidden)]
pub type GetStatisticsInputOperationOutputAlias = crate::operation::GetStatistics;
#[doc(hidden)]
pub type GetStatisticsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetStatisticsInput {
    /// Consumes the builder and constructs an Operation<[`GetStatistics`](crate::operation::GetStatistics)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetStatistics,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetStatisticsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/indices/statistics").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetStatisticsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_get_statistics(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetStatistics::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetStatistics",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetStatisticsInput`](crate::input::GetStatisticsInput)
    pub fn builder() -> crate::input::get_statistics_input::Builder {
        crate::input::get_statistics_input::Builder::default()
    }
}

/// See [`GetTopicRuleInput`](crate::input::GetTopicRuleInput)
pub mod get_topic_rule_input {

    /// A builder for [`GetTopicRuleInput`](crate::input::GetTopicRuleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the rule.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_name = Some(input.into());
            self
        }
        /// <p>The name of the rule.</p>
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTopicRuleInput`](crate::input::GetTopicRuleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetTopicRuleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetTopicRuleInput {
                rule_name: self.rule_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetTopicRuleInputOperationOutputAlias = crate::operation::GetTopicRule;
#[doc(hidden)]
pub type GetTopicRuleInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetTopicRuleInput {
    /// Consumes the builder and constructs an Operation<[`GetTopicRule`](crate::operation::GetTopicRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTopicRule,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetTopicRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_131 = &_input.rule_name;
                let input_131 = input_131.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let rule_name = aws_smithy_http::label::fmt_string(input_131, false);
                if rule_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/rules/{ruleName}", ruleName = rule_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetTopicRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTopicRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTopicRule",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetTopicRuleInput`](crate::input::GetTopicRuleInput)
    pub fn builder() -> crate::input::get_topic_rule_input::Builder {
        crate::input::get_topic_rule_input::Builder::default()
    }
}

/// See [`GetTopicRuleDestinationInput`](crate::input::GetTopicRuleDestinationInput)
pub mod get_topic_rule_destination_input {

    /// A builder for [`GetTopicRuleDestinationInput`](crate::input::GetTopicRuleDestinationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the topic rule destination.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the topic rule destination.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTopicRuleDestinationInput`](crate::input::GetTopicRuleDestinationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetTopicRuleDestinationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetTopicRuleDestinationInput { arn: self.arn })
        }
    }
}
#[doc(hidden)]
pub type GetTopicRuleDestinationInputOperationOutputAlias =
    crate::operation::GetTopicRuleDestination;
#[doc(hidden)]
pub type GetTopicRuleDestinationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetTopicRuleDestinationInput {
    /// Consumes the builder and constructs an Operation<[`GetTopicRuleDestination`](crate::operation::GetTopicRuleDestination)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTopicRuleDestination,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetTopicRuleDestinationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_132 = &_input.arn;
                let input_132 = input_132.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let arn = aws_smithy_http::label::fmt_string(input_132, true);
                if arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/destinations/{arn}", arn = arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetTopicRuleDestinationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTopicRuleDestination::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTopicRuleDestination",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetTopicRuleDestinationInput`](crate::input::GetTopicRuleDestinationInput)
    pub fn builder() -> crate::input::get_topic_rule_destination_input::Builder {
        crate::input::get_topic_rule_destination_input::Builder::default()
    }
}

/// See [`GetV2LoggingOptionsInput`](crate::input::GetV2LoggingOptionsInput)
pub mod get_v2_logging_options_input {

    /// A builder for [`GetV2LoggingOptionsInput`](crate::input::GetV2LoggingOptionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetV2LoggingOptionsInput`](crate::input::GetV2LoggingOptionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetV2LoggingOptionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetV2LoggingOptionsInput {})
        }
    }
}
#[doc(hidden)]
pub type GetV2LoggingOptionsInputOperationOutputAlias = crate::operation::GetV2LoggingOptions;
#[doc(hidden)]
pub type GetV2LoggingOptionsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetV2LoggingOptionsInput {
    /// Consumes the builder and constructs an Operation<[`GetV2LoggingOptions`](crate::operation::GetV2LoggingOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetV2LoggingOptions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetV2LoggingOptionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/v2LoggingOptions").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetV2LoggingOptionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetV2LoggingOptions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetV2LoggingOptions",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetV2LoggingOptionsInput`](crate::input::GetV2LoggingOptionsInput)
    pub fn builder() -> crate::input::get_v2_logging_options_input::Builder {
        crate::input::get_v2_logging_options_input::Builder::default()
    }
}

/// See [`ListActiveViolationsInput`](crate::input::ListActiveViolationsInput)
pub mod list_active_violations_input {

    /// A builder for [`ListActiveViolationsInput`](crate::input::ListActiveViolationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) behavior_criteria_type: std::option::Option<crate::model::BehaviorCriteriaType>,
        pub(crate) list_suppressed_alerts: std::option::Option<bool>,
        pub(crate) verification_state: std::option::Option<crate::model::VerificationState>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the thing whose active violations are listed.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing whose active violations are listed.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>The name of the Device Defender security profile for which violations are listed.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The name of the Device Defender security profile for which violations are listed.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p> The criteria for a behavior. </p>
        pub fn behavior_criteria_type(mut self, input: crate::model::BehaviorCriteriaType) -> Self {
            self.behavior_criteria_type = Some(input);
            self
        }
        /// <p> The criteria for a behavior. </p>
        pub fn set_behavior_criteria_type(
            mut self,
            input: std::option::Option<crate::model::BehaviorCriteriaType>,
        ) -> Self {
            self.behavior_criteria_type = input;
            self
        }
        /// <p> A list of all suppressed alerts. </p>
        pub fn list_suppressed_alerts(mut self, input: bool) -> Self {
            self.list_suppressed_alerts = Some(input);
            self
        }
        /// <p> A list of all suppressed alerts. </p>
        pub fn set_list_suppressed_alerts(mut self, input: std::option::Option<bool>) -> Self {
            self.list_suppressed_alerts = input;
            self
        }
        /// <p>The verification state of the violation (detect alarm).</p>
        pub fn verification_state(mut self, input: crate::model::VerificationState) -> Self {
            self.verification_state = Some(input);
            self
        }
        /// <p>The verification state of the violation (detect alarm).</p>
        pub fn set_verification_state(
            mut self,
            input: std::option::Option<crate::model::VerificationState>,
        ) -> Self {
            self.verification_state = input;
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListActiveViolationsInput`](crate::input::ListActiveViolationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListActiveViolationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListActiveViolationsInput {
                thing_name: self.thing_name,
                security_profile_name: self.security_profile_name,
                behavior_criteria_type: self.behavior_criteria_type,
                list_suppressed_alerts: self.list_suppressed_alerts,
                verification_state: self.verification_state,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListActiveViolationsInputOperationOutputAlias = crate::operation::ListActiveViolations;
#[doc(hidden)]
pub type ListActiveViolationsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListActiveViolationsInput {
    /// Consumes the builder and constructs an Operation<[`ListActiveViolations`](crate::operation::ListActiveViolations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListActiveViolations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListActiveViolationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/active-violations").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListActiveViolationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_133) = &_input.thing_name {
                    query.push_kv("thingName", &aws_smithy_http::query::fmt_string(&inner_133));
                }
                if let Some(inner_134) = &_input.security_profile_name {
                    query.push_kv(
                        "securityProfileName",
                        &aws_smithy_http::query::fmt_string(&inner_134),
                    );
                }
                if let Some(inner_135) = &_input.behavior_criteria_type {
                    query.push_kv(
                        "behaviorCriteriaType",
                        &aws_smithy_http::query::fmt_string(&inner_135),
                    );
                }
                if let Some(inner_136) = &_input.list_suppressed_alerts {
                    query.push_kv(
                        "listSuppressedAlerts",
                        aws_smithy_types::primitive::Encoder::from(*inner_136).encode(),
                    );
                }
                if let Some(inner_137) = &_input.verification_state {
                    query.push_kv(
                        "verificationState",
                        &aws_smithy_http::query::fmt_string(&inner_137),
                    );
                }
                if let Some(inner_138) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_138));
                }
                if let Some(inner_139) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_139).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListActiveViolationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListActiveViolations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListActiveViolations",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListActiveViolationsInput`](crate::input::ListActiveViolationsInput)
    pub fn builder() -> crate::input::list_active_violations_input::Builder {
        crate::input::list_active_violations_input::Builder::default()
    }
}

/// See [`ListAttachedPoliciesInput`](crate::input::ListAttachedPoliciesInput)
pub mod list_attached_policies_input {

    /// A builder for [`ListAttachedPoliciesInput`](crate::input::ListAttachedPoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target: std::option::Option<std::string::String>,
        pub(crate) recursive: std::option::Option<bool>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The group or principal for which the policies will be listed. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.target = Some(input.into());
            self
        }
        /// <p>The group or principal for which the policies will be listed. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target = input;
            self
        }
        /// <p>When true, recursively list attached policies.</p>
        pub fn recursive(mut self, input: bool) -> Self {
            self.recursive = Some(input);
            self
        }
        /// <p>When true, recursively list attached policies.</p>
        pub fn set_recursive(mut self, input: std::option::Option<bool>) -> Self {
            self.recursive = input;
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAttachedPoliciesInput`](crate::input::ListAttachedPoliciesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAttachedPoliciesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAttachedPoliciesInput {
                target: self.target,
                recursive: self.recursive.unwrap_or_default(),
                marker: self.marker,
                page_size: self.page_size,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAttachedPoliciesInputOperationOutputAlias = crate::operation::ListAttachedPolicies;
#[doc(hidden)]
pub type ListAttachedPoliciesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAttachedPoliciesInput {
    /// Consumes the builder and constructs an Operation<[`ListAttachedPolicies`](crate::operation::ListAttachedPolicies)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAttachedPolicies,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAttachedPoliciesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_140 = &_input.target;
                let input_140 = input_140.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "target",
                        details: "cannot be empty or unset",
                    },
                )?;
                let target = aws_smithy_http::label::fmt_string(input_140, false);
                if target.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "target",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/attached-policies/{target}", target = target)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAttachedPoliciesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.recursive {
                    query.push_kv(
                        "recursive",
                        aws_smithy_types::primitive::Encoder::from(_input.recursive).encode(),
                    );
                }
                if let Some(inner_141) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_141));
                }
                if let Some(inner_142) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_142).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAttachedPoliciesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAttachedPolicies::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAttachedPolicies",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAttachedPoliciesInput`](crate::input::ListAttachedPoliciesInput)
    pub fn builder() -> crate::input::list_attached_policies_input::Builder {
        crate::input::list_attached_policies_input::Builder::default()
    }
}

/// See [`ListAuditFindingsInput`](crate::input::ListAuditFindingsInput)
pub mod list_audit_findings_input {

    /// A builder for [`ListAuditFindingsInput`](crate::input::ListAuditFindingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) check_name: std::option::Option<std::string::String>,
        pub(crate) resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) list_suppressed_findings: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>A filter to limit results to the audit with the specified ID. You must specify either the taskId or the startTime and endTime, but not both.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>A filter to limit results to the audit with the specified ID. You must specify either the taskId or the startTime and endTime, but not both.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p>A filter to limit results to the findings for the specified audit check.</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.check_name = Some(input.into());
            self
        }
        /// <p>A filter to limit results to the findings for the specified audit check.</p>
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.check_name = input;
            self
        }
        /// <p>Information identifying the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.resource_identifier = Some(input);
            self
        }
        /// <p>Information identifying the noncompliant resource.</p>
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.resource_identifier = input;
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A filter to limit results to those found before the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>A filter to limit results to those found before the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p> Boolean flag indicating whether only the suppressed findings or the unsuppressed findings should be listed. If this parameter isn't provided, the response will list both suppressed and unsuppressed findings. </p>
        pub fn list_suppressed_findings(mut self, input: bool) -> Self {
            self.list_suppressed_findings = Some(input);
            self
        }
        /// <p> Boolean flag indicating whether only the suppressed findings or the unsuppressed findings should be listed. If this parameter isn't provided, the response will list both suppressed and unsuppressed findings. </p>
        pub fn set_list_suppressed_findings(mut self, input: std::option::Option<bool>) -> Self {
            self.list_suppressed_findings = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAuditFindingsInput`](crate::input::ListAuditFindingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAuditFindingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAuditFindingsInput {
                task_id: self.task_id,
                check_name: self.check_name,
                resource_identifier: self.resource_identifier,
                max_results: self.max_results,
                next_token: self.next_token,
                start_time: self.start_time,
                end_time: self.end_time,
                list_suppressed_findings: self.list_suppressed_findings.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListAuditFindingsInputOperationOutputAlias = crate::operation::ListAuditFindings;
#[doc(hidden)]
pub type ListAuditFindingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAuditFindingsInput {
    /// Consumes the builder and constructs an Operation<[`ListAuditFindings`](crate::operation::ListAuditFindings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAuditFindings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAuditFindingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/findings").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAuditFindingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_audit_findings(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAuditFindings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAuditFindings",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAuditFindingsInput`](crate::input::ListAuditFindingsInput)
    pub fn builder() -> crate::input::list_audit_findings_input::Builder {
        crate::input::list_audit_findings_input::Builder::default()
    }
}

/// See [`ListAuditMitigationActionsExecutionsInput`](crate::input::ListAuditMitigationActionsExecutionsInput)
pub mod list_audit_mitigation_actions_executions_input {

    /// A builder for [`ListAuditMitigationActionsExecutionsInput`](crate::input::ListAuditMitigationActionsExecutionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) action_status:
            std::option::Option<crate::model::AuditMitigationActionsExecutionStatus>,
        pub(crate) finding_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specify this filter to limit results to actions for a specific audit mitigation actions task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>Specify this filter to limit results to actions for a specific audit mitigation actions task.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p>Specify this filter to limit results to those with a specific status.</p>
        pub fn action_status(
            mut self,
            input: crate::model::AuditMitigationActionsExecutionStatus,
        ) -> Self {
            self.action_status = Some(input);
            self
        }
        /// <p>Specify this filter to limit results to those with a specific status.</p>
        pub fn set_action_status(
            mut self,
            input: std::option::Option<crate::model::AuditMitigationActionsExecutionStatus>,
        ) -> Self {
            self.action_status = input;
            self
        }
        /// <p>Specify this filter to limit results to those that were applied to a specific audit finding.</p>
        pub fn finding_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.finding_id = Some(input.into());
            self
        }
        /// <p>Specify this filter to limit results to those that were applied to a specific audit finding.</p>
        pub fn set_finding_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.finding_id = input;
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAuditMitigationActionsExecutionsInput`](crate::input::ListAuditMitigationActionsExecutionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAuditMitigationActionsExecutionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAuditMitigationActionsExecutionsInput {
                task_id: self.task_id,
                action_status: self.action_status,
                finding_id: self.finding_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAuditMitigationActionsExecutionsInputOperationOutputAlias =
    crate::operation::ListAuditMitigationActionsExecutions;
#[doc(hidden)]
pub type ListAuditMitigationActionsExecutionsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListAuditMitigationActionsExecutionsInput {
    /// Consumes the builder and constructs an Operation<[`ListAuditMitigationActionsExecutions`](crate::operation::ListAuditMitigationActionsExecutions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAuditMitigationActionsExecutions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAuditMitigationActionsExecutionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/mitigationactions/executions")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAuditMitigationActionsExecutionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_143) = &_input.task_id {
                    query.push_kv("taskId", &aws_smithy_http::query::fmt_string(&inner_143));
                }
                if let Some(inner_144) = &_input.action_status {
                    query.push_kv(
                        "actionStatus",
                        &aws_smithy_http::query::fmt_string(&inner_144),
                    );
                }
                if let Some(inner_145) = &_input.finding_id {
                    query.push_kv("findingId", &aws_smithy_http::query::fmt_string(&inner_145));
                }
                if let Some(inner_146) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_146).encode(),
                    );
                }
                if let Some(inner_147) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_147));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAuditMitigationActionsExecutionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAuditMitigationActionsExecutions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAuditMitigationActionsExecutions",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAuditMitigationActionsExecutionsInput`](crate::input::ListAuditMitigationActionsExecutionsInput)
    pub fn builder() -> crate::input::list_audit_mitigation_actions_executions_input::Builder {
        crate::input::list_audit_mitigation_actions_executions_input::Builder::default()
    }
}

/// See [`ListAuditMitigationActionsTasksInput`](crate::input::ListAuditMitigationActionsTasksInput)
pub mod list_audit_mitigation_actions_tasks_input {

    /// A builder for [`ListAuditMitigationActionsTasksInput`](crate::input::ListAuditMitigationActionsTasksInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) audit_task_id: std::option::Option<std::string::String>,
        pub(crate) finding_id: std::option::Option<std::string::String>,
        pub(crate) task_status: std::option::Option<crate::model::AuditMitigationActionsTaskStatus>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Specify this filter to limit results to tasks that were applied to results for a specific audit.</p>
        pub fn audit_task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.audit_task_id = Some(input.into());
            self
        }
        /// <p>Specify this filter to limit results to tasks that were applied to results for a specific audit.</p>
        pub fn set_audit_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.audit_task_id = input;
            self
        }
        /// <p>Specify this filter to limit results to tasks that were applied to a specific audit finding.</p>
        pub fn finding_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.finding_id = Some(input.into());
            self
        }
        /// <p>Specify this filter to limit results to tasks that were applied to a specific audit finding.</p>
        pub fn set_finding_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.finding_id = input;
            self
        }
        /// <p>Specify this filter to limit results to tasks that are in a specific state.</p>
        pub fn task_status(
            mut self,
            input: crate::model::AuditMitigationActionsTaskStatus,
        ) -> Self {
            self.task_status = Some(input);
            self
        }
        /// <p>Specify this filter to limit results to tasks that are in a specific state.</p>
        pub fn set_task_status(
            mut self,
            input: std::option::Option<crate::model::AuditMitigationActionsTaskStatus>,
        ) -> Self {
            self.task_status = input;
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Specify this filter to limit results to tasks that began on or after a specific date and time.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>Specify this filter to limit results to tasks that began on or after a specific date and time.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAuditMitigationActionsTasksInput`](crate::input::ListAuditMitigationActionsTasksInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAuditMitigationActionsTasksInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAuditMitigationActionsTasksInput {
                audit_task_id: self.audit_task_id,
                finding_id: self.finding_id,
                task_status: self.task_status,
                max_results: self.max_results,
                next_token: self.next_token,
                start_time: self.start_time,
                end_time: self.end_time,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAuditMitigationActionsTasksInputOperationOutputAlias =
    crate::operation::ListAuditMitigationActionsTasks;
#[doc(hidden)]
pub type ListAuditMitigationActionsTasksInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListAuditMitigationActionsTasksInput {
    /// Consumes the builder and constructs an Operation<[`ListAuditMitigationActionsTasks`](crate::operation::ListAuditMitigationActionsTasks)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAuditMitigationActionsTasks,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAuditMitigationActionsTasksInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/mitigationactions/tasks")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAuditMitigationActionsTasksInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_148) = &_input.audit_task_id {
                    query.push_kv(
                        "auditTaskId",
                        &aws_smithy_http::query::fmt_string(&inner_148),
                    );
                }
                if let Some(inner_149) = &_input.finding_id {
                    query.push_kv("findingId", &aws_smithy_http::query::fmt_string(&inner_149));
                }
                if let Some(inner_150) = &_input.task_status {
                    query.push_kv(
                        "taskStatus",
                        &aws_smithy_http::query::fmt_string(&inner_150),
                    );
                }
                if let Some(inner_151) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_151).encode(),
                    );
                }
                if let Some(inner_152) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_152));
                }
                if let Some(inner_153) = &_input.start_time {
                    query.push_kv(
                        "startTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_153,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_154) = &_input.end_time {
                    query.push_kv(
                        "endTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_154,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAuditMitigationActionsTasksInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAuditMitigationActionsTasks::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAuditMitigationActionsTasks",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAuditMitigationActionsTasksInput`](crate::input::ListAuditMitigationActionsTasksInput)
    pub fn builder() -> crate::input::list_audit_mitigation_actions_tasks_input::Builder {
        crate::input::list_audit_mitigation_actions_tasks_input::Builder::default()
    }
}

/// See [`ListAuditSuppressionsInput`](crate::input::ListAuditSuppressionsInput)
pub mod list_audit_suppressions_input {

    /// A builder for [`ListAuditSuppressionsInput`](crate::input::ListAuditSuppressionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) check_name: std::option::Option<std::string::String>,
        pub(crate) resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
        pub(crate) ascending_order: std::option::Option<bool>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.check_name = Some(input.into());
            self
        }
        /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.check_name = input;
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.resource_identifier = Some(input);
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.resource_identifier = input;
            self
        }
        /// <p> Determines whether suppressions are listed in ascending order by expiration date or not. If parameter isn't provided, <code>ascendingOrder=true</code>. </p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.ascending_order = Some(input);
            self
        }
        /// <p> Determines whether suppressions are listed in ascending order by expiration date or not. If parameter isn't provided, <code>ascendingOrder=true</code>. </p>
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.ascending_order = input;
            self
        }
        /// <p> The token for the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of results to return at one time. The default is 25. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of results to return at one time. The default is 25. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAuditSuppressionsInput`](crate::input::ListAuditSuppressionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAuditSuppressionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAuditSuppressionsInput {
                check_name: self.check_name,
                resource_identifier: self.resource_identifier,
                ascending_order: self.ascending_order.unwrap_or_default(),
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAuditSuppressionsInputOperationOutputAlias = crate::operation::ListAuditSuppressions;
#[doc(hidden)]
pub type ListAuditSuppressionsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAuditSuppressionsInput {
    /// Consumes the builder and constructs an Operation<[`ListAuditSuppressions`](crate::operation::ListAuditSuppressions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAuditSuppressions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAuditSuppressionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/suppressions/list").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAuditSuppressionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_audit_suppressions(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAuditSuppressions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAuditSuppressions",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAuditSuppressionsInput`](crate::input::ListAuditSuppressionsInput)
    pub fn builder() -> crate::input::list_audit_suppressions_input::Builder {
        crate::input::list_audit_suppressions_input::Builder::default()
    }
}

/// See [`ListAuditTasksInput`](crate::input::ListAuditTasksInput)
pub mod list_audit_tasks_input {

    /// A builder for [`ListAuditTasksInput`](crate::input::ListAuditTasksInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) task_type: std::option::Option<crate::model::AuditTaskType>,
        pub(crate) task_status: std::option::Option<crate::model::AuditTaskStatus>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The beginning of the time period. Audit information is retained for a limited time (90 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The beginning of the time period. Audit information is retained for a limited time (90 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end of the time period.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end of the time period.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".</p>
        pub fn task_type(mut self, input: crate::model::AuditTaskType) -> Self {
            self.task_type = Some(input);
            self
        }
        /// <p>A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".</p>
        pub fn set_task_type(
            mut self,
            input: std::option::Option<crate::model::AuditTaskType>,
        ) -> Self {
            self.task_type = input;
            self
        }
        /// <p>A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".</p>
        pub fn task_status(mut self, input: crate::model::AuditTaskStatus) -> Self {
            self.task_status = Some(input);
            self
        }
        /// <p>A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".</p>
        pub fn set_task_status(
            mut self,
            input: std::option::Option<crate::model::AuditTaskStatus>,
        ) -> Self {
            self.task_status = input;
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAuditTasksInput`](crate::input::ListAuditTasksInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAuditTasksInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAuditTasksInput {
                start_time: self.start_time,
                end_time: self.end_time,
                task_type: self.task_type,
                task_status: self.task_status,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAuditTasksInputOperationOutputAlias = crate::operation::ListAuditTasks;
#[doc(hidden)]
pub type ListAuditTasksInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAuditTasksInput {
    /// Consumes the builder and constructs an Operation<[`ListAuditTasks`](crate::operation::ListAuditTasks)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAuditTasks,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAuditTasksInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/tasks").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAuditTasksInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_155) = &_input.start_time {
                    query.push_kv(
                        "startTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_155,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_156) = &_input.end_time {
                    query.push_kv(
                        "endTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_156,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_157) = &_input.task_type {
                    query.push_kv("taskType", &aws_smithy_http::query::fmt_string(&inner_157));
                }
                if let Some(inner_158) = &_input.task_status {
                    query.push_kv(
                        "taskStatus",
                        &aws_smithy_http::query::fmt_string(&inner_158),
                    );
                }
                if let Some(inner_159) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_159));
                }
                if let Some(inner_160) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_160).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAuditTasksInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAuditTasks::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAuditTasks",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAuditTasksInput`](crate::input::ListAuditTasksInput)
    pub fn builder() -> crate::input::list_audit_tasks_input::Builder {
        crate::input::list_audit_tasks_input::Builder::default()
    }
}

/// See [`ListAuthorizersInput`](crate::input::ListAuthorizersInput)
pub mod list_authorizers_input {

    /// A builder for [`ListAuthorizersInput`](crate::input::ListAuthorizersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) ascending_order: std::option::Option<bool>,
        pub(crate) status: std::option::Option<crate::model::AuthorizerStatus>,
    }
    impl Builder {
        /// <p>The maximum number of results to return at one time.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>A marker used to get the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>A marker used to get the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>Return the list of authorizers in ascending alphabetical order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.ascending_order = Some(input);
            self
        }
        /// <p>Return the list of authorizers in ascending alphabetical order.</p>
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.ascending_order = input;
            self
        }
        /// <p>The status of the list authorizers request.</p>
        pub fn status(mut self, input: crate::model::AuthorizerStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the list authorizers request.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AuthorizerStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAuthorizersInput`](crate::input::ListAuthorizersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAuthorizersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAuthorizersInput {
                page_size: self.page_size,
                marker: self.marker,
                ascending_order: self.ascending_order.unwrap_or_default(),
                status: self.status,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAuthorizersInputOperationOutputAlias = crate::operation::ListAuthorizers;
#[doc(hidden)]
pub type ListAuthorizersInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAuthorizersInput {
    /// Consumes the builder and constructs an Operation<[`ListAuthorizers`](crate::operation::ListAuthorizers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAuthorizers,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAuthorizersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/authorizers").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAuthorizersInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_161) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_161).encode(),
                    );
                }
                if let Some(inner_162) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_162));
                }
                if _input.ascending_order {
                    query.push_kv(
                        "isAscendingOrder",
                        aws_smithy_types::primitive::Encoder::from(_input.ascending_order).encode(),
                    );
                }
                if let Some(inner_163) = &_input.status {
                    query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_163));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAuthorizersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAuthorizers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAuthorizers",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAuthorizersInput`](crate::input::ListAuthorizersInput)
    pub fn builder() -> crate::input::list_authorizers_input::Builder {
        crate::input::list_authorizers_input::Builder::default()
    }
}

/// See [`ListBillingGroupsInput`](crate::input::ListBillingGroupsInput)
pub mod list_billing_groups_input {

    /// A builder for [`ListBillingGroupsInput`](crate::input::ListBillingGroupsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) name_prefix_filter: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Limit the results to billing groups whose names have the given prefix.</p>
        pub fn name_prefix_filter(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_prefix_filter = Some(input.into());
            self
        }
        /// <p>Limit the results to billing groups whose names have the given prefix.</p>
        pub fn set_name_prefix_filter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.name_prefix_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBillingGroupsInput`](crate::input::ListBillingGroupsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListBillingGroupsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListBillingGroupsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                name_prefix_filter: self.name_prefix_filter,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBillingGroupsInputOperationOutputAlias = crate::operation::ListBillingGroups;
#[doc(hidden)]
pub type ListBillingGroupsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListBillingGroupsInput {
    /// Consumes the builder and constructs an Operation<[`ListBillingGroups`](crate::operation::ListBillingGroups)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListBillingGroups,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListBillingGroupsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/billing-groups").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListBillingGroupsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_164) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_164));
                }
                if let Some(inner_165) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_165).encode(),
                    );
                }
                if let Some(inner_166) = &_input.name_prefix_filter {
                    query.push_kv(
                        "namePrefixFilter",
                        &aws_smithy_http::query::fmt_string(&inner_166),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListBillingGroupsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListBillingGroups::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListBillingGroups",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListBillingGroupsInput`](crate::input::ListBillingGroupsInput)
    pub fn builder() -> crate::input::list_billing_groups_input::Builder {
        crate::input::list_billing_groups_input::Builder::default()
    }
}

/// See [`ListCaCertificatesInput`](crate::input::ListCaCertificatesInput)
pub mod list_ca_certificates_input {

    /// A builder for [`ListCaCertificatesInput`](crate::input::ListCaCertificatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) ascending_order: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>Determines the order of the results.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.ascending_order = Some(input);
            self
        }
        /// <p>Determines the order of the results.</p>
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.ascending_order = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCaCertificatesInput`](crate::input::ListCaCertificatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListCaCertificatesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListCaCertificatesInput {
                page_size: self.page_size,
                marker: self.marker,
                ascending_order: self.ascending_order.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListCaCertificatesInputOperationOutputAlias = crate::operation::ListCACertificates;
#[doc(hidden)]
pub type ListCaCertificatesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListCaCertificatesInput {
    /// Consumes the builder and constructs an Operation<[`ListCACertificates`](crate::operation::ListCACertificates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCACertificates,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListCaCertificatesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/cacertificates").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListCaCertificatesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_167) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_167).encode(),
                    );
                }
                if let Some(inner_168) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_168));
                }
                if _input.ascending_order {
                    query.push_kv(
                        "isAscendingOrder",
                        aws_smithy_types::primitive::Encoder::from(_input.ascending_order).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListCaCertificatesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCACertificates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCACertificates",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListCaCertificatesInput`](crate::input::ListCaCertificatesInput)
    pub fn builder() -> crate::input::list_ca_certificates_input::Builder {
        crate::input::list_ca_certificates_input::Builder::default()
    }
}

/// See [`ListCertificatesInput`](crate::input::ListCertificatesInput)
pub mod list_certificates_input {

    /// A builder for [`ListCertificatesInput`](crate::input::ListCertificatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) ascending_order: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.ascending_order = Some(input);
            self
        }
        /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.ascending_order = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCertificatesInput`](crate::input::ListCertificatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListCertificatesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListCertificatesInput {
                page_size: self.page_size,
                marker: self.marker,
                ascending_order: self.ascending_order.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListCertificatesInputOperationOutputAlias = crate::operation::ListCertificates;
#[doc(hidden)]
pub type ListCertificatesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListCertificatesInput {
    /// Consumes the builder and constructs an Operation<[`ListCertificates`](crate::operation::ListCertificates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCertificates,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListCertificatesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/certificates").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListCertificatesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_169) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_169).encode(),
                    );
                }
                if let Some(inner_170) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_170));
                }
                if _input.ascending_order {
                    query.push_kv(
                        "isAscendingOrder",
                        aws_smithy_types::primitive::Encoder::from(_input.ascending_order).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListCertificatesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCertificates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCertificates",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListCertificatesInput`](crate::input::ListCertificatesInput)
    pub fn builder() -> crate::input::list_certificates_input::Builder {
        crate::input::list_certificates_input::Builder::default()
    }
}

/// See [`ListCertificatesByCaInput`](crate::input::ListCertificatesByCaInput)
pub mod list_certificates_by_ca_input {

    /// A builder for [`ListCertificatesByCaInput`](crate::input::ListCertificatesByCaInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ca_certificate_id: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) ascending_order: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.</p>
        pub fn ca_certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ca_certificate_id = Some(input.into());
            self
        }
        /// <p>The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.</p>
        pub fn set_ca_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ca_certificate_id = input;
            self
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.ascending_order = Some(input);
            self
        }
        /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.ascending_order = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCertificatesByCaInput`](crate::input::ListCertificatesByCaInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListCertificatesByCaInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListCertificatesByCaInput {
                ca_certificate_id: self.ca_certificate_id,
                page_size: self.page_size,
                marker: self.marker,
                ascending_order: self.ascending_order.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListCertificatesByCaInputOperationOutputAlias = crate::operation::ListCertificatesByCA;
#[doc(hidden)]
pub type ListCertificatesByCaInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListCertificatesByCaInput {
    /// Consumes the builder and constructs an Operation<[`ListCertificatesByCA`](crate::operation::ListCertificatesByCA)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCertificatesByCA,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListCertificatesByCaInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_171 = &_input.ca_certificate_id;
                let input_171 = input_171.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "ca_certificate_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let ca_certificate_id = aws_smithy_http::label::fmt_string(input_171, false);
                if ca_certificate_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "ca_certificate_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/certificates-by-ca/{caCertificateId}",
                    caCertificateId = ca_certificate_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListCertificatesByCaInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_172) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_172).encode(),
                    );
                }
                if let Some(inner_173) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_173));
                }
                if _input.ascending_order {
                    query.push_kv(
                        "isAscendingOrder",
                        aws_smithy_types::primitive::Encoder::from(_input.ascending_order).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListCertificatesByCaInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCertificatesByCA::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCertificatesByCA",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListCertificatesByCaInput`](crate::input::ListCertificatesByCaInput)
    pub fn builder() -> crate::input::list_certificates_by_ca_input::Builder {
        crate::input::list_certificates_by_ca_input::Builder::default()
    }
}

/// See [`ListCustomMetricsInput`](crate::input::ListCustomMetricsInput)
pub mod list_custom_metrics_input {

    /// A builder for [`ListCustomMetricsInput`](crate::input::ListCustomMetricsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The token for the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of results to return at one time. The default is 25. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of results to return at one time. The default is 25. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCustomMetricsInput`](crate::input::ListCustomMetricsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListCustomMetricsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListCustomMetricsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListCustomMetricsInputOperationOutputAlias = crate::operation::ListCustomMetrics;
#[doc(hidden)]
pub type ListCustomMetricsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListCustomMetricsInput {
    /// Consumes the builder and constructs an Operation<[`ListCustomMetrics`](crate::operation::ListCustomMetrics)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCustomMetrics,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListCustomMetricsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/custom-metrics").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListCustomMetricsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_174) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_174));
                }
                if let Some(inner_175) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_175).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListCustomMetricsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCustomMetrics::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCustomMetrics",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListCustomMetricsInput`](crate::input::ListCustomMetricsInput)
    pub fn builder() -> crate::input::list_custom_metrics_input::Builder {
        crate::input::list_custom_metrics_input::Builder::default()
    }
}

/// See [`ListDetectMitigationActionsExecutionsInput`](crate::input::ListDetectMitigationActionsExecutionsInput)
pub mod list_detect_mitigation_actions_executions_input {

    /// A builder for [`ListDetectMitigationActionsExecutionsInput`](crate::input::ListDetectMitigationActionsExecutionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) violation_id: std::option::Option<std::string::String>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier of the task. </p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p> The unique identifier of the task. </p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p> The unique identifier of the violation. </p>
        pub fn violation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_id = Some(input.into());
            self
        }
        /// <p> The unique identifier of the violation. </p>
        pub fn set_violation_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.violation_id = input;
            self
        }
        /// <p> The name of the thing whose mitigation actions are listed. </p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p> The name of the thing whose mitigation actions are listed. </p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p> A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both. </p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p> A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both. </p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p> The end of the time period for which ML Detect mitigation actions executions are returned. </p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p> The end of the time period for which ML Detect mitigation actions executions are returned. </p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p> The maximum number of results to return at one time. The default is 25. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of results to return at one time. The default is 25. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p> The token for the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDetectMitigationActionsExecutionsInput`](crate::input::ListDetectMitigationActionsExecutionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListDetectMitigationActionsExecutionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListDetectMitigationActionsExecutionsInput {
                task_id: self.task_id,
                violation_id: self.violation_id,
                thing_name: self.thing_name,
                start_time: self.start_time,
                end_time: self.end_time,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListDetectMitigationActionsExecutionsInputOperationOutputAlias =
    crate::operation::ListDetectMitigationActionsExecutions;
#[doc(hidden)]
pub type ListDetectMitigationActionsExecutionsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListDetectMitigationActionsExecutionsInput {
    /// Consumes the builder and constructs an Operation<[`ListDetectMitigationActionsExecutions`](crate::operation::ListDetectMitigationActionsExecutions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDetectMitigationActionsExecutions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListDetectMitigationActionsExecutionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/detect/mitigationactions/executions")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListDetectMitigationActionsExecutionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_176) = &_input.task_id {
                    query.push_kv("taskId", &aws_smithy_http::query::fmt_string(&inner_176));
                }
                if let Some(inner_177) = &_input.violation_id {
                    query.push_kv(
                        "violationId",
                        &aws_smithy_http::query::fmt_string(&inner_177),
                    );
                }
                if let Some(inner_178) = &_input.thing_name {
                    query.push_kv("thingName", &aws_smithy_http::query::fmt_string(&inner_178));
                }
                if let Some(inner_179) = &_input.start_time {
                    query.push_kv(
                        "startTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_179,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_180) = &_input.end_time {
                    query.push_kv(
                        "endTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_180,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_181) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_181).encode(),
                    );
                }
                if let Some(inner_182) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_182));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListDetectMitigationActionsExecutionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDetectMitigationActionsExecutions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDetectMitigationActionsExecutions",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListDetectMitigationActionsExecutionsInput`](crate::input::ListDetectMitigationActionsExecutionsInput)
    pub fn builder() -> crate::input::list_detect_mitigation_actions_executions_input::Builder {
        crate::input::list_detect_mitigation_actions_executions_input::Builder::default()
    }
}

/// See [`ListDetectMitigationActionsTasksInput`](crate::input::ListDetectMitigationActionsTasksInput)
pub mod list_detect_mitigation_actions_tasks_input {

    /// A builder for [`ListDetectMitigationActionsTasksInput`](crate::input::ListDetectMitigationActionsTasksInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p> The token for the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The token for the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both. </p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p> A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both. </p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p> The end of the time period for which ML Detect mitigation actions tasks are returned. </p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p> The end of the time period for which ML Detect mitigation actions tasks are returned. </p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDetectMitigationActionsTasksInput`](crate::input::ListDetectMitigationActionsTasksInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListDetectMitigationActionsTasksInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListDetectMitigationActionsTasksInput {
                max_results: self.max_results,
                next_token: self.next_token,
                start_time: self.start_time,
                end_time: self.end_time,
            })
        }
    }
}
#[doc(hidden)]
pub type ListDetectMitigationActionsTasksInputOperationOutputAlias =
    crate::operation::ListDetectMitigationActionsTasks;
#[doc(hidden)]
pub type ListDetectMitigationActionsTasksInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListDetectMitigationActionsTasksInput {
    /// Consumes the builder and constructs an Operation<[`ListDetectMitigationActionsTasks`](crate::operation::ListDetectMitigationActionsTasks)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDetectMitigationActionsTasks,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListDetectMitigationActionsTasksInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/detect/mitigationactions/tasks")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListDetectMitigationActionsTasksInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_183) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_183).encode(),
                    );
                }
                if let Some(inner_184) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_184));
                }
                if let Some(inner_185) = &_input.start_time {
                    query.push_kv(
                        "startTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_185,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_186) = &_input.end_time {
                    query.push_kv(
                        "endTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_186,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListDetectMitigationActionsTasksInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDetectMitigationActionsTasks::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDetectMitigationActionsTasks",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListDetectMitigationActionsTasksInput`](crate::input::ListDetectMitigationActionsTasksInput)
    pub fn builder() -> crate::input::list_detect_mitigation_actions_tasks_input::Builder {
        crate::input::list_detect_mitigation_actions_tasks_input::Builder::default()
    }
}

/// See [`ListDimensionsInput`](crate::input::ListDimensionsInput)
pub mod list_dimensions_input {

    /// A builder for [`ListDimensionsInput`](crate::input::ListDimensionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to retrieve at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to retrieve at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDimensionsInput`](crate::input::ListDimensionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListDimensionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListDimensionsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListDimensionsInputOperationOutputAlias = crate::operation::ListDimensions;
#[doc(hidden)]
pub type ListDimensionsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListDimensionsInput {
    /// Consumes the builder and constructs an Operation<[`ListDimensions`](crate::operation::ListDimensions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDimensions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListDimensionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/dimensions").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListDimensionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_187) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_187));
                }
                if let Some(inner_188) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_188).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListDimensionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDimensions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDimensions",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListDimensionsInput`](crate::input::ListDimensionsInput)
    pub fn builder() -> crate::input::list_dimensions_input::Builder {
        crate::input::list_dimensions_input::Builder::default()
    }
}

/// See [`ListDomainConfigurationsInput`](crate::input::ListDomainConfigurationsInput)
pub mod list_domain_configurations_input {

    /// A builder for [`ListDomainConfigurationsInput`](crate::input::ListDomainConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) service_type: std::option::Option<crate::model::ServiceType>,
    }
    impl Builder {
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>The type of service delivered by the endpoint.</p>
        pub fn service_type(mut self, input: crate::model::ServiceType) -> Self {
            self.service_type = Some(input);
            self
        }
        /// <p>The type of service delivered by the endpoint.</p>
        pub fn set_service_type(
            mut self,
            input: std::option::Option<crate::model::ServiceType>,
        ) -> Self {
            self.service_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDomainConfigurationsInput`](crate::input::ListDomainConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListDomainConfigurationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListDomainConfigurationsInput {
                marker: self.marker,
                page_size: self.page_size,
                service_type: self.service_type,
            })
        }
    }
}
#[doc(hidden)]
pub type ListDomainConfigurationsInputOperationOutputAlias =
    crate::operation::ListDomainConfigurations;
#[doc(hidden)]
pub type ListDomainConfigurationsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListDomainConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`ListDomainConfigurations`](crate::operation::ListDomainConfigurations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDomainConfigurations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListDomainConfigurationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/domainConfigurations").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListDomainConfigurationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_189) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_189));
                }
                if let Some(inner_190) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_190).encode(),
                    );
                }
                if let Some(inner_191) = &_input.service_type {
                    query.push_kv(
                        "serviceType",
                        &aws_smithy_http::query::fmt_string(&inner_191),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListDomainConfigurationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDomainConfigurations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDomainConfigurations",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListDomainConfigurationsInput`](crate::input::ListDomainConfigurationsInput)
    pub fn builder() -> crate::input::list_domain_configurations_input::Builder {
        crate::input::list_domain_configurations_input::Builder::default()
    }
}

/// See [`ListFleetMetricsInput`](crate::input::ListFleetMetricsInput)
pub mod list_fleet_metrics_input {

    /// A builder for [`ListFleetMetricsInput`](crate::input::ListFleetMetricsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <code>null</code> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <code>null</code> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListFleetMetricsInput`](crate::input::ListFleetMetricsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListFleetMetricsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListFleetMetricsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListFleetMetricsInputOperationOutputAlias = crate::operation::ListFleetMetrics;
#[doc(hidden)]
pub type ListFleetMetricsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListFleetMetricsInput {
    /// Consumes the builder and constructs an Operation<[`ListFleetMetrics`](crate::operation::ListFleetMetrics)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListFleetMetrics,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListFleetMetricsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/fleet-metrics").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListFleetMetricsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_192) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_192));
                }
                if let Some(inner_193) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_193).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListFleetMetricsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListFleetMetrics::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListFleetMetrics",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListFleetMetricsInput`](crate::input::ListFleetMetricsInput)
    pub fn builder() -> crate::input::list_fleet_metrics_input::Builder {
        crate::input::list_fleet_metrics_input::Builder::default()
    }
}

/// See [`ListIndicesInput`](crate::input::ListIndicesInput)
pub mod list_indices_input {

    /// A builder for [`ListIndicesInput`](crate::input::ListIndicesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListIndicesInput`](crate::input::ListIndicesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListIndicesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListIndicesInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListIndicesInputOperationOutputAlias = crate::operation::ListIndices;
#[doc(hidden)]
pub type ListIndicesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListIndicesInput {
    /// Consumes the builder and constructs an Operation<[`ListIndices`](crate::operation::ListIndices)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListIndices,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListIndicesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/indices").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListIndicesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_194) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_194));
                }
                if let Some(inner_195) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_195).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListIndicesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListIndices::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListIndices",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListIndicesInput`](crate::input::ListIndicesInput)
    pub fn builder() -> crate::input::list_indices_input::Builder {
        crate::input::list_indices_input::Builder::default()
    }
}

/// See [`ListJobExecutionsForJobInput`](crate::input::ListJobExecutionsForJobInput)
pub mod list_job_executions_for_job_input {

    /// A builder for [`ListJobExecutionsForJobInput`](crate::input::ListJobExecutionsForJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::JobExecutionStatus>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The status of the job.</p>
        pub fn status(mut self, input: crate::model::JobExecutionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the job.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::JobExecutionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListJobExecutionsForJobInput`](crate::input::ListJobExecutionsForJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListJobExecutionsForJobInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListJobExecutionsForJobInput {
                job_id: self.job_id,
                status: self.status,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListJobExecutionsForJobInputOperationOutputAlias =
    crate::operation::ListJobExecutionsForJob;
#[doc(hidden)]
pub type ListJobExecutionsForJobInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListJobExecutionsForJobInput {
    /// Consumes the builder and constructs an Operation<[`ListJobExecutionsForJob`](crate::operation::ListJobExecutionsForJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListJobExecutionsForJob,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListJobExecutionsForJobInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_196 = &_input.job_id;
                let input_196 = input_196.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_id = aws_smithy_http::label::fmt_string(input_196, false);
                if job_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/jobs/{jobId}/things", jobId = job_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListJobExecutionsForJobInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_197) = &_input.status {
                    query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_197));
                }
                if let Some(inner_198) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_198).encode(),
                    );
                }
                if let Some(inner_199) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_199));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListJobExecutionsForJobInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListJobExecutionsForJob::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListJobExecutionsForJob",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListJobExecutionsForJobInput`](crate::input::ListJobExecutionsForJobInput)
    pub fn builder() -> crate::input::list_job_executions_for_job_input::Builder {
        crate::input::list_job_executions_for_job_input::Builder::default()
    }
}

/// See [`ListJobExecutionsForThingInput`](crate::input::ListJobExecutionsForThingInput)
pub mod list_job_executions_for_thing_input {

    /// A builder for [`ListJobExecutionsForThingInput`](crate::input::ListJobExecutionsForThingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::JobExecutionStatus>,
        pub(crate) namespace_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The thing name.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The thing name.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
        pub fn status(mut self, input: crate::model::JobExecutionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::JobExecutionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_id = Some(input.into());
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace_id = input;
            self
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListJobExecutionsForThingInput`](crate::input::ListJobExecutionsForThingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListJobExecutionsForThingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListJobExecutionsForThingInput {
                thing_name: self.thing_name,
                status: self.status,
                namespace_id: self.namespace_id,
                max_results: self.max_results,
                next_token: self.next_token,
                job_id: self.job_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ListJobExecutionsForThingInputOperationOutputAlias =
    crate::operation::ListJobExecutionsForThing;
#[doc(hidden)]
pub type ListJobExecutionsForThingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListJobExecutionsForThingInput {
    /// Consumes the builder and constructs an Operation<[`ListJobExecutionsForThing`](crate::operation::ListJobExecutionsForThing)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListJobExecutionsForThing,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListJobExecutionsForThingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_200 = &_input.thing_name;
                let input_200 = input_200.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_200, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/things/{thingName}/jobs", thingName = thing_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListJobExecutionsForThingInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_201) = &_input.status {
                    query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_201));
                }
                if let Some(inner_202) = &_input.namespace_id {
                    query.push_kv(
                        "namespaceId",
                        &aws_smithy_http::query::fmt_string(&inner_202),
                    );
                }
                if let Some(inner_203) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_203).encode(),
                    );
                }
                if let Some(inner_204) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_204));
                }
                if let Some(inner_205) = &_input.job_id {
                    query.push_kv("jobId", &aws_smithy_http::query::fmt_string(&inner_205));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListJobExecutionsForThingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListJobExecutionsForThing::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListJobExecutionsForThing",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListJobExecutionsForThingInput`](crate::input::ListJobExecutionsForThingInput)
    pub fn builder() -> crate::input::list_job_executions_for_thing_input::Builder {
        crate::input::list_job_executions_for_thing_input::Builder::default()
    }
}

/// See [`ListJobsInput`](crate::input::ListJobsInput)
pub mod list_jobs_input {

    /// A builder for [`ListJobsInput`](crate::input::ListJobsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::JobStatus>,
        pub(crate) target_selection: std::option::Option<crate::model::TargetSelection>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) thing_group_name: std::option::Option<std::string::String>,
        pub(crate) thing_group_id: std::option::Option<std::string::String>,
        pub(crate) namespace_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
        pub fn status(mut self, input: crate::model::JobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::JobStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. </p> <note>
        /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
        /// </note>
        pub fn target_selection(mut self, input: crate::model::TargetSelection) -> Self {
            self.target_selection = Some(input);
            self
        }
        /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. </p> <note>
        /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
        /// </note>
        pub fn set_target_selection(
            mut self,
            input: std::option::Option<crate::model::TargetSelection>,
        ) -> Self {
            self.target_selection = input;
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>A filter that limits the returned jobs to those for the specified group.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_name = Some(input.into());
            self
        }
        /// <p>A filter that limits the returned jobs to those for the specified group.</p>
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_name = input;
            self
        }
        /// <p>A filter that limits the returned jobs to those for the specified group.</p>
        pub fn thing_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_id = Some(input.into());
            self
        }
        /// <p>A filter that limits the returned jobs to those for the specified group.</p>
        pub fn set_thing_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_id = input;
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_id = Some(input.into());
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListJobsInput`](crate::input::ListJobsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListJobsInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListJobsInput {
                status: self.status,
                target_selection: self.target_selection,
                max_results: self.max_results,
                next_token: self.next_token,
                thing_group_name: self.thing_group_name,
                thing_group_id: self.thing_group_id,
                namespace_id: self.namespace_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ListJobsInputOperationOutputAlias = crate::operation::ListJobs;
#[doc(hidden)]
pub type ListJobsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListJobsInput {
    /// Consumes the builder and constructs an Operation<[`ListJobs`](crate::operation::ListJobs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListJobs,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListJobsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/jobs").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListJobsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_206) = &_input.status {
                    query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_206));
                }
                if let Some(inner_207) = &_input.target_selection {
                    query.push_kv(
                        "targetSelection",
                        &aws_smithy_http::query::fmt_string(&inner_207),
                    );
                }
                if let Some(inner_208) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_208).encode(),
                    );
                }
                if let Some(inner_209) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_209));
                }
                if let Some(inner_210) = &_input.thing_group_name {
                    query.push_kv(
                        "thingGroupName",
                        &aws_smithy_http::query::fmt_string(&inner_210),
                    );
                }
                if let Some(inner_211) = &_input.thing_group_id {
                    query.push_kv(
                        "thingGroupId",
                        &aws_smithy_http::query::fmt_string(&inner_211),
                    );
                }
                if let Some(inner_212) = &_input.namespace_id {
                    query.push_kv(
                        "namespaceId",
                        &aws_smithy_http::query::fmt_string(&inner_212),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListJobsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::ListJobs::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new("ListJobs", "iot"));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListJobsInput`](crate::input::ListJobsInput)
    pub fn builder() -> crate::input::list_jobs_input::Builder {
        crate::input::list_jobs_input::Builder::default()
    }
}

/// See [`ListJobTemplatesInput`](crate::input::ListJobTemplatesInput)
pub mod list_job_templates_input {

    /// A builder for [`ListJobTemplatesInput`](crate::input::ListJobTemplatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of results to return in the list.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in the list.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to use to return the next set of results in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to return the next set of results in the list.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListJobTemplatesInput`](crate::input::ListJobTemplatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListJobTemplatesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListJobTemplatesInput {
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListJobTemplatesInputOperationOutputAlias = crate::operation::ListJobTemplates;
#[doc(hidden)]
pub type ListJobTemplatesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListJobTemplatesInput {
    /// Consumes the builder and constructs an Operation<[`ListJobTemplates`](crate::operation::ListJobTemplates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListJobTemplates,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListJobTemplatesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/job-templates").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListJobTemplatesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_213) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_213).encode(),
                    );
                }
                if let Some(inner_214) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_214));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListJobTemplatesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListJobTemplates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListJobTemplates",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListJobTemplatesInput`](crate::input::ListJobTemplatesInput)
    pub fn builder() -> crate::input::list_job_templates_input::Builder {
        crate::input::list_job_templates_input::Builder::default()
    }
}

/// See [`ListManagedJobTemplatesInput`](crate::input::ListManagedJobTemplatesInput)
pub mod list_managed_job_templates_input {

    /// A builder for [`ListManagedJobTemplatesInput`](crate::input::ListManagedJobTemplatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An optional parameter for template name. If specified, only the versions of the managed job templates that have the specified template name will be returned.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>An optional parameter for template name. If specified, only the versions of the managed job templates that have the specified template name will be returned.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>Maximum number of entries that can be returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Maximum number of entries that can be returned.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListManagedJobTemplatesInput`](crate::input::ListManagedJobTemplatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListManagedJobTemplatesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListManagedJobTemplatesInput {
                template_name: self.template_name,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListManagedJobTemplatesInputOperationOutputAlias =
    crate::operation::ListManagedJobTemplates;
#[doc(hidden)]
pub type ListManagedJobTemplatesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListManagedJobTemplatesInput {
    /// Consumes the builder and constructs an Operation<[`ListManagedJobTemplates`](crate::operation::ListManagedJobTemplates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListManagedJobTemplates,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListManagedJobTemplatesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/managed-job-templates").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListManagedJobTemplatesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_215) = &_input.template_name {
                    query.push_kv(
                        "templateName",
                        &aws_smithy_http::query::fmt_string(&inner_215),
                    );
                }
                if let Some(inner_216) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_216).encode(),
                    );
                }
                if let Some(inner_217) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_217));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListManagedJobTemplatesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListManagedJobTemplates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListManagedJobTemplates",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListManagedJobTemplatesInput`](crate::input::ListManagedJobTemplatesInput)
    pub fn builder() -> crate::input::list_managed_job_templates_input::Builder {
        crate::input::list_managed_job_templates_input::Builder::default()
    }
}

/// See [`ListMetricValuesInput`](crate::input::ListMetricValuesInput)
pub mod list_metric_values_input {

    /// A builder for [`ListMetricValuesInput`](crate::input::ListMetricValuesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) dimension_name: std::option::Option<std::string::String>,
        pub(crate) dimension_value_operator:
            std::option::Option<crate::model::DimensionValueOperator>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the thing for which security profile metric values are returned.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing for which security profile metric values are returned.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>The name of the security profile metric for which values are returned.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the security profile metric for which values are returned.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The dimension name.</p>
        pub fn dimension_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dimension_name = Some(input.into());
            self
        }
        /// <p>The dimension name.</p>
        pub fn set_dimension_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dimension_name = input;
            self
        }
        /// <p>The dimension value operator.</p>
        pub fn dimension_value_operator(
            mut self,
            input: crate::model::DimensionValueOperator,
        ) -> Self {
            self.dimension_value_operator = Some(input);
            self
        }
        /// <p>The dimension value operator.</p>
        pub fn set_dimension_value_operator(
            mut self,
            input: std::option::Option<crate::model::DimensionValueOperator>,
        ) -> Self {
            self.dimension_value_operator = input;
            self
        }
        /// <p>The start of the time period for which metric values are returned.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start of the time period for which metric values are returned.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end of the time period for which metric values are returned.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end of the time period for which metric values are returned.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMetricValuesInput`](crate::input::ListMetricValuesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMetricValuesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMetricValuesInput {
                thing_name: self.thing_name,
                metric_name: self.metric_name,
                dimension_name: self.dimension_name,
                dimension_value_operator: self.dimension_value_operator,
                start_time: self.start_time,
                end_time: self.end_time,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMetricValuesInputOperationOutputAlias = crate::operation::ListMetricValues;
#[doc(hidden)]
pub type ListMetricValuesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListMetricValuesInput {
    /// Consumes the builder and constructs an Operation<[`ListMetricValues`](crate::operation::ListMetricValues)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListMetricValues,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListMetricValuesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/metric-values").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListMetricValuesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_218) = &_input.thing_name {
                    query.push_kv("thingName", &aws_smithy_http::query::fmt_string(&inner_218));
                }
                if let Some(inner_219) = &_input.metric_name {
                    query.push_kv(
                        "metricName",
                        &aws_smithy_http::query::fmt_string(&inner_219),
                    );
                }
                if let Some(inner_220) = &_input.dimension_name {
                    query.push_kv(
                        "dimensionName",
                        &aws_smithy_http::query::fmt_string(&inner_220),
                    );
                }
                if let Some(inner_221) = &_input.dimension_value_operator {
                    query.push_kv(
                        "dimensionValueOperator",
                        &aws_smithy_http::query::fmt_string(&inner_221),
                    );
                }
                if let Some(inner_222) = &_input.start_time {
                    query.push_kv(
                        "startTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_222,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_223) = &_input.end_time {
                    query.push_kv(
                        "endTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_223,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_224) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_224).encode(),
                    );
                }
                if let Some(inner_225) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_225));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListMetricValuesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListMetricValues::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListMetricValues",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListMetricValuesInput`](crate::input::ListMetricValuesInput)
    pub fn builder() -> crate::input::list_metric_values_input::Builder {
        crate::input::list_metric_values_input::Builder::default()
    }
}

/// See [`ListMitigationActionsInput`](crate::input::ListMitigationActionsInput)
pub mod list_mitigation_actions_input {

    /// A builder for [`ListMitigationActionsInput`](crate::input::ListMitigationActionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_type: std::option::Option<crate::model::MitigationActionType>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specify a value to limit the result to mitigation actions with a specific action type.</p>
        pub fn action_type(mut self, input: crate::model::MitigationActionType) -> Self {
            self.action_type = Some(input);
            self
        }
        /// <p>Specify a value to limit the result to mitigation actions with a specific action type.</p>
        pub fn set_action_type(
            mut self,
            input: std::option::Option<crate::model::MitigationActionType>,
        ) -> Self {
            self.action_type = input;
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMitigationActionsInput`](crate::input::ListMitigationActionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMitigationActionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMitigationActionsInput {
                action_type: self.action_type,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMitigationActionsInputOperationOutputAlias = crate::operation::ListMitigationActions;
#[doc(hidden)]
pub type ListMitigationActionsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListMitigationActionsInput {
    /// Consumes the builder and constructs an Operation<[`ListMitigationActions`](crate::operation::ListMitigationActions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListMitigationActions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListMitigationActionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/mitigationactions/actions").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListMitigationActionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_226) = &_input.action_type {
                    query.push_kv(
                        "actionType",
                        &aws_smithy_http::query::fmt_string(&inner_226),
                    );
                }
                if let Some(inner_227) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_227).encode(),
                    );
                }
                if let Some(inner_228) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_228));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListMitigationActionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListMitigationActions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListMitigationActions",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListMitigationActionsInput`](crate::input::ListMitigationActionsInput)
    pub fn builder() -> crate::input::list_mitigation_actions_input::Builder {
        crate::input::list_mitigation_actions_input::Builder::default()
    }
}

/// See [`ListOtaUpdatesInput`](crate::input::ListOtaUpdatesInput)
pub mod list_ota_updates_input {

    /// A builder for [`ListOtaUpdatesInput`](crate::input::ListOtaUpdatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) ota_update_status: std::option::Option<crate::model::OtaUpdateStatus>,
    }
    impl Builder {
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>A token used to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token used to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The OTA update job status.</p>
        pub fn ota_update_status(mut self, input: crate::model::OtaUpdateStatus) -> Self {
            self.ota_update_status = Some(input);
            self
        }
        /// <p>The OTA update job status.</p>
        pub fn set_ota_update_status(
            mut self,
            input: std::option::Option<crate::model::OtaUpdateStatus>,
        ) -> Self {
            self.ota_update_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ListOtaUpdatesInput`](crate::input::ListOtaUpdatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListOtaUpdatesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListOtaUpdatesInput {
                max_results: self.max_results,
                next_token: self.next_token,
                ota_update_status: self.ota_update_status,
            })
        }
    }
}
#[doc(hidden)]
pub type ListOtaUpdatesInputOperationOutputAlias = crate::operation::ListOTAUpdates;
#[doc(hidden)]
pub type ListOtaUpdatesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListOtaUpdatesInput {
    /// Consumes the builder and constructs an Operation<[`ListOTAUpdates`](crate::operation::ListOTAUpdates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListOTAUpdates,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListOtaUpdatesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/otaUpdates").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListOtaUpdatesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_229) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_229).encode(),
                    );
                }
                if let Some(inner_230) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_230));
                }
                if let Some(inner_231) = &_input.ota_update_status {
                    query.push_kv(
                        "otaUpdateStatus",
                        &aws_smithy_http::query::fmt_string(&inner_231),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListOtaUpdatesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListOTAUpdates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListOTAUpdates",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListOtaUpdatesInput`](crate::input::ListOtaUpdatesInput)
    pub fn builder() -> crate::input::list_ota_updates_input::Builder {
        crate::input::list_ota_updates_input::Builder::default()
    }
}

/// See [`ListOutgoingCertificatesInput`](crate::input::ListOutgoingCertificatesInput)
pub mod list_outgoing_certificates_input {

    /// A builder for [`ListOutgoingCertificatesInput`](crate::input::ListOutgoingCertificatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) ascending_order: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.ascending_order = Some(input);
            self
        }
        /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.ascending_order = input;
            self
        }
        /// Consumes the builder and constructs a [`ListOutgoingCertificatesInput`](crate::input::ListOutgoingCertificatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListOutgoingCertificatesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListOutgoingCertificatesInput {
                page_size: self.page_size,
                marker: self.marker,
                ascending_order: self.ascending_order.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListOutgoingCertificatesInputOperationOutputAlias =
    crate::operation::ListOutgoingCertificates;
#[doc(hidden)]
pub type ListOutgoingCertificatesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListOutgoingCertificatesInput {
    /// Consumes the builder and constructs an Operation<[`ListOutgoingCertificates`](crate::operation::ListOutgoingCertificates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListOutgoingCertificates,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListOutgoingCertificatesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/certificates-out-going").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListOutgoingCertificatesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_232) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_232).encode(),
                    );
                }
                if let Some(inner_233) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_233));
                }
                if _input.ascending_order {
                    query.push_kv(
                        "isAscendingOrder",
                        aws_smithy_types::primitive::Encoder::from(_input.ascending_order).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListOutgoingCertificatesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListOutgoingCertificates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListOutgoingCertificates",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListOutgoingCertificatesInput`](crate::input::ListOutgoingCertificatesInput)
    pub fn builder() -> crate::input::list_outgoing_certificates_input::Builder {
        crate::input::list_outgoing_certificates_input::Builder::default()
    }
}

/// See [`ListPoliciesInput`](crate::input::ListPoliciesInput)
pub mod list_policies_input {

    /// A builder for [`ListPoliciesInput`](crate::input::ListPoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) ascending_order: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.ascending_order = Some(input);
            self
        }
        /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.ascending_order = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPoliciesInput`](crate::input::ListPoliciesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListPoliciesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListPoliciesInput {
                marker: self.marker,
                page_size: self.page_size,
                ascending_order: self.ascending_order.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListPoliciesInputOperationOutputAlias = crate::operation::ListPolicies;
#[doc(hidden)]
pub type ListPoliciesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListPoliciesInput {
    /// Consumes the builder and constructs an Operation<[`ListPolicies`](crate::operation::ListPolicies)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPolicies,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPoliciesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/policies").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPoliciesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_234) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_234));
                }
                if let Some(inner_235) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_235).encode(),
                    );
                }
                if _input.ascending_order {
                    query.push_kv(
                        "isAscendingOrder",
                        aws_smithy_types::primitive::Encoder::from(_input.ascending_order).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPoliciesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPolicies::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPolicies",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListPoliciesInput`](crate::input::ListPoliciesInput)
    pub fn builder() -> crate::input::list_policies_input::Builder {
        crate::input::list_policies_input::Builder::default()
    }
}

/// See [`ListPolicyPrincipalsInput`](crate::input::ListPolicyPrincipalsInput)
pub mod list_policy_principals_input {

    /// A builder for [`ListPolicyPrincipalsInput`](crate::input::ListPolicyPrincipalsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) ascending_order: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The policy name.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.ascending_order = Some(input);
            self
        }
        /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.ascending_order = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPolicyPrincipalsInput`](crate::input::ListPolicyPrincipalsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListPolicyPrincipalsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListPolicyPrincipalsInput {
                policy_name: self.policy_name,
                marker: self.marker,
                page_size: self.page_size,
                ascending_order: self.ascending_order.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListPolicyPrincipalsInputOperationOutputAlias = crate::operation::ListPolicyPrincipals;
#[doc(hidden)]
pub type ListPolicyPrincipalsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListPolicyPrincipalsInput {
    /// Consumes the builder and constructs an Operation<[`ListPolicyPrincipals`](crate::operation::ListPolicyPrincipals)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPolicyPrincipals,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPolicyPrincipalsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/policy-principals").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPolicyPrincipalsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_236) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_236));
                }
                if let Some(inner_237) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_237).encode(),
                    );
                }
                if _input.ascending_order {
                    query.push_kv(
                        "isAscendingOrder",
                        aws_smithy_types::primitive::Encoder::from(_input.ascending_order).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPolicyPrincipalsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_list_policy_principals(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPolicyPrincipals::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPolicyPrincipals",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListPolicyPrincipalsInput`](crate::input::ListPolicyPrincipalsInput)
    pub fn builder() -> crate::input::list_policy_principals_input::Builder {
        crate::input::list_policy_principals_input::Builder::default()
    }
}

/// See [`ListPolicyVersionsInput`](crate::input::ListPolicyVersionsInput)
pub mod list_policy_versions_input {

    /// A builder for [`ListPolicyVersionsInput`](crate::input::ListPolicyVersionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The policy name.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPolicyVersionsInput`](crate::input::ListPolicyVersionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListPolicyVersionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListPolicyVersionsInput {
                policy_name: self.policy_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPolicyVersionsInputOperationOutputAlias = crate::operation::ListPolicyVersions;
#[doc(hidden)]
pub type ListPolicyVersionsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListPolicyVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListPolicyVersions`](crate::operation::ListPolicyVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPolicyVersions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPolicyVersionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_238 = &_input.policy_name;
                let input_238 = input_238.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_238, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/policies/{policyName}/version",
                    policyName = policy_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPolicyVersionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPolicyVersions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPolicyVersions",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListPolicyVersionsInput`](crate::input::ListPolicyVersionsInput)
    pub fn builder() -> crate::input::list_policy_versions_input::Builder {
        crate::input::list_policy_versions_input::Builder::default()
    }
}

/// See [`ListPrincipalPoliciesInput`](crate::input::ListPrincipalPoliciesInput)
pub mod list_principal_policies_input {

    /// A builder for [`ListPrincipalPoliciesInput`](crate::input::ListPrincipalPoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) ascending_order: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal = Some(input.into());
            self
        }
        /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal = input;
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>Specifies the order for results. If true, results are returned in ascending creation order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.ascending_order = Some(input);
            self
        }
        /// <p>Specifies the order for results. If true, results are returned in ascending creation order.</p>
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.ascending_order = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPrincipalPoliciesInput`](crate::input::ListPrincipalPoliciesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListPrincipalPoliciesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListPrincipalPoliciesInput {
                principal: self.principal,
                marker: self.marker,
                page_size: self.page_size,
                ascending_order: self.ascending_order.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListPrincipalPoliciesInputOperationOutputAlias = crate::operation::ListPrincipalPolicies;
#[doc(hidden)]
pub type ListPrincipalPoliciesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListPrincipalPoliciesInput {
    /// Consumes the builder and constructs an Operation<[`ListPrincipalPolicies`](crate::operation::ListPrincipalPolicies)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPrincipalPolicies,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPrincipalPoliciesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/principal-policies").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPrincipalPoliciesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_239) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_239));
                }
                if let Some(inner_240) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_240).encode(),
                    );
                }
                if _input.ascending_order {
                    query.push_kv(
                        "isAscendingOrder",
                        aws_smithy_types::primitive::Encoder::from(_input.ascending_order).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPrincipalPoliciesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_list_principal_policies(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPrincipalPolicies::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPrincipalPolicies",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListPrincipalPoliciesInput`](crate::input::ListPrincipalPoliciesInput)
    pub fn builder() -> crate::input::list_principal_policies_input::Builder {
        crate::input::list_principal_policies_input::Builder::default()
    }
}

/// See [`ListPrincipalThingsInput`](crate::input::ListPrincipalThingsInput)
pub mod list_principal_things_input {

    /// A builder for [`ListPrincipalThingsInput`](crate::input::ListPrincipalThingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) principal: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The principal.</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal = Some(input.into());
            self
        }
        /// <p>The principal.</p>
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPrincipalThingsInput`](crate::input::ListPrincipalThingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListPrincipalThingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListPrincipalThingsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                principal: self.principal,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPrincipalThingsInputOperationOutputAlias = crate::operation::ListPrincipalThings;
#[doc(hidden)]
pub type ListPrincipalThingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListPrincipalThingsInput {
    /// Consumes the builder and constructs an Operation<[`ListPrincipalThings`](crate::operation::ListPrincipalThings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPrincipalThings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPrincipalThingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/principals/things").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPrincipalThingsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_241) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_241));
                }
                if let Some(inner_242) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_242).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPrincipalThingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_list_principal_things(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPrincipalThings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPrincipalThings",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListPrincipalThingsInput`](crate::input::ListPrincipalThingsInput)
    pub fn builder() -> crate::input::list_principal_things_input::Builder {
        crate::input::list_principal_things_input::Builder::default()
    }
}

/// See [`ListProvisioningTemplatesInput`](crate::input::ListProvisioningTemplatesInput)
pub mod list_provisioning_templates_input {

    /// A builder for [`ListProvisioningTemplatesInput`](crate::input::ListProvisioningTemplatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>A token to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListProvisioningTemplatesInput`](crate::input::ListProvisioningTemplatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListProvisioningTemplatesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListProvisioningTemplatesInput {
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListProvisioningTemplatesInputOperationOutputAlias =
    crate::operation::ListProvisioningTemplates;
#[doc(hidden)]
pub type ListProvisioningTemplatesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListProvisioningTemplatesInput {
    /// Consumes the builder and constructs an Operation<[`ListProvisioningTemplates`](crate::operation::ListProvisioningTemplates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListProvisioningTemplates,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListProvisioningTemplatesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/provisioning-templates").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListProvisioningTemplatesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_243) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_243).encode(),
                    );
                }
                if let Some(inner_244) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_244));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListProvisioningTemplatesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListProvisioningTemplates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListProvisioningTemplates",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListProvisioningTemplatesInput`](crate::input::ListProvisioningTemplatesInput)
    pub fn builder() -> crate::input::list_provisioning_templates_input::Builder {
        crate::input::list_provisioning_templates_input::Builder::default()
    }
}

/// See [`ListProvisioningTemplateVersionsInput`](crate::input::ListProvisioningTemplateVersionsInput)
pub mod list_provisioning_template_versions_input {

    /// A builder for [`ListProvisioningTemplateVersionsInput`](crate::input::ListProvisioningTemplateVersionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the fleet provisioning template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet provisioning template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>A token to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListProvisioningTemplateVersionsInput`](crate::input::ListProvisioningTemplateVersionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListProvisioningTemplateVersionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListProvisioningTemplateVersionsInput {
                template_name: self.template_name,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListProvisioningTemplateVersionsInputOperationOutputAlias =
    crate::operation::ListProvisioningTemplateVersions;
#[doc(hidden)]
pub type ListProvisioningTemplateVersionsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListProvisioningTemplateVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListProvisioningTemplateVersions`](crate::operation::ListProvisioningTemplateVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListProvisioningTemplateVersions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListProvisioningTemplateVersionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_245 = &_input.template_name;
                let input_245 = input_245.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let template_name = aws_smithy_http::label::fmt_string(input_245, false);
                if template_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/provisioning-templates/{templateName}/versions",
                    templateName = template_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListProvisioningTemplateVersionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_246) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_246).encode(),
                    );
                }
                if let Some(inner_247) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_247));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListProvisioningTemplateVersionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListProvisioningTemplateVersions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListProvisioningTemplateVersions",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListProvisioningTemplateVersionsInput`](crate::input::ListProvisioningTemplateVersionsInput)
    pub fn builder() -> crate::input::list_provisioning_template_versions_input::Builder {
        crate::input::list_provisioning_template_versions_input::Builder::default()
    }
}

/// See [`ListRoleAliasesInput`](crate::input::ListRoleAliasesInput)
pub mod list_role_aliases_input {

    /// A builder for [`ListRoleAliasesInput`](crate::input::ListRoleAliasesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) ascending_order: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The maximum number of results to return at one time.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>A marker used to get the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>A marker used to get the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>Return the list of role aliases in ascending alphabetical order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.ascending_order = Some(input);
            self
        }
        /// <p>Return the list of role aliases in ascending alphabetical order.</p>
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.ascending_order = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRoleAliasesInput`](crate::input::ListRoleAliasesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListRoleAliasesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListRoleAliasesInput {
                page_size: self.page_size,
                marker: self.marker,
                ascending_order: self.ascending_order.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListRoleAliasesInputOperationOutputAlias = crate::operation::ListRoleAliases;
#[doc(hidden)]
pub type ListRoleAliasesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListRoleAliasesInput {
    /// Consumes the builder and constructs an Operation<[`ListRoleAliases`](crate::operation::ListRoleAliases)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListRoleAliases,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListRoleAliasesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/role-aliases").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListRoleAliasesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_248) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_248).encode(),
                    );
                }
                if let Some(inner_249) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_249));
                }
                if _input.ascending_order {
                    query.push_kv(
                        "isAscendingOrder",
                        aws_smithy_types::primitive::Encoder::from(_input.ascending_order).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListRoleAliasesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListRoleAliases::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListRoleAliases",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListRoleAliasesInput`](crate::input::ListRoleAliasesInput)
    pub fn builder() -> crate::input::list_role_aliases_input::Builder {
        crate::input::list_role_aliases_input::Builder::default()
    }
}

/// See [`ListScheduledAuditsInput`](crate::input::ListScheduledAuditsInput)
pub mod list_scheduled_audits_input {

    /// A builder for [`ListScheduledAuditsInput`](crate::input::ListScheduledAuditsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListScheduledAuditsInput`](crate::input::ListScheduledAuditsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListScheduledAuditsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListScheduledAuditsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListScheduledAuditsInputOperationOutputAlias = crate::operation::ListScheduledAudits;
#[doc(hidden)]
pub type ListScheduledAuditsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListScheduledAuditsInput {
    /// Consumes the builder and constructs an Operation<[`ListScheduledAudits`](crate::operation::ListScheduledAudits)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListScheduledAudits,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListScheduledAuditsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/scheduledaudits").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListScheduledAuditsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_250) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_250));
                }
                if let Some(inner_251) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_251).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListScheduledAuditsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListScheduledAudits::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListScheduledAudits",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListScheduledAuditsInput`](crate::input::ListScheduledAuditsInput)
    pub fn builder() -> crate::input::list_scheduled_audits_input::Builder {
        crate::input::list_scheduled_audits_input::Builder::default()
    }
}

/// See [`ListSecurityProfilesInput`](crate::input::ListSecurityProfilesInput)
pub mod list_security_profiles_input {

    /// A builder for [`ListSecurityProfilesInput`](crate::input::ListSecurityProfilesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) dimension_name: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>A filter to limit results to the security profiles that use the defined dimension. Cannot be used with <code>metricName</code> </p>
        pub fn dimension_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dimension_name = Some(input.into());
            self
        }
        /// <p>A filter to limit results to the security profiles that use the defined dimension. Cannot be used with <code>metricName</code> </p>
        pub fn set_dimension_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dimension_name = input;
            self
        }
        /// <p> The name of the custom metric. Cannot be used with <code>dimensionName</code>. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p> The name of the custom metric. Cannot be used with <code>dimensionName</code>. </p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSecurityProfilesInput`](crate::input::ListSecurityProfilesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListSecurityProfilesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListSecurityProfilesInput {
                next_token: self.next_token,
                max_results: self.max_results,
                dimension_name: self.dimension_name,
                metric_name: self.metric_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ListSecurityProfilesInputOperationOutputAlias = crate::operation::ListSecurityProfiles;
#[doc(hidden)]
pub type ListSecurityProfilesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListSecurityProfilesInput {
    /// Consumes the builder and constructs an Operation<[`ListSecurityProfiles`](crate::operation::ListSecurityProfiles)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSecurityProfiles,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSecurityProfilesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/security-profiles").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListSecurityProfilesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_252) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_252));
                }
                if let Some(inner_253) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_253).encode(),
                    );
                }
                if let Some(inner_254) = &_input.dimension_name {
                    query.push_kv(
                        "dimensionName",
                        &aws_smithy_http::query::fmt_string(&inner_254),
                    );
                }
                if let Some(inner_255) = &_input.metric_name {
                    query.push_kv(
                        "metricName",
                        &aws_smithy_http::query::fmt_string(&inner_255),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSecurityProfilesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSecurityProfiles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSecurityProfiles",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSecurityProfilesInput`](crate::input::ListSecurityProfilesInput)
    pub fn builder() -> crate::input::list_security_profiles_input::Builder {
        crate::input::list_security_profiles_input::Builder::default()
    }
}

/// See [`ListSecurityProfilesForTargetInput`](crate::input::ListSecurityProfilesForTargetInput)
pub mod list_security_profiles_for_target_input {

    /// A builder for [`ListSecurityProfilesForTargetInput`](crate::input::ListSecurityProfilesForTargetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) recursive: std::option::Option<bool>,
        pub(crate) security_profile_target_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>If true, return child groups too.</p>
        pub fn recursive(mut self, input: bool) -> Self {
            self.recursive = Some(input);
            self
        }
        /// <p>If true, return child groups too.</p>
        pub fn set_recursive(mut self, input: std::option::Option<bool>) -> Self {
            self.recursive = input;
            self
        }
        /// <p>The ARN of the target (thing group) whose attached security profiles you want to get.</p>
        pub fn security_profile_target_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.security_profile_target_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the target (thing group) whose attached security profiles you want to get.</p>
        pub fn set_security_profile_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_target_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSecurityProfilesForTargetInput`](crate::input::ListSecurityProfilesForTargetInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListSecurityProfilesForTargetInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListSecurityProfilesForTargetInput {
                next_token: self.next_token,
                max_results: self.max_results,
                recursive: self.recursive.unwrap_or_default(),
                security_profile_target_arn: self.security_profile_target_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListSecurityProfilesForTargetInputOperationOutputAlias =
    crate::operation::ListSecurityProfilesForTarget;
#[doc(hidden)]
pub type ListSecurityProfilesForTargetInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListSecurityProfilesForTargetInput {
    /// Consumes the builder and constructs an Operation<[`ListSecurityProfilesForTarget`](crate::operation::ListSecurityProfilesForTarget)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSecurityProfilesForTarget,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSecurityProfilesForTargetInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/security-profiles-for-target").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListSecurityProfilesForTargetInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_256) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_256));
                }
                if let Some(inner_257) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_257).encode(),
                    );
                }
                if _input.recursive {
                    query.push_kv(
                        "recursive",
                        aws_smithy_types::primitive::Encoder::from(_input.recursive).encode(),
                    );
                }
                if let Some(inner_258) = &_input.security_profile_target_arn {
                    query.push_kv(
                        "securityProfileTargetArn",
                        &aws_smithy_http::query::fmt_string(&inner_258),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSecurityProfilesForTargetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSecurityProfilesForTarget::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSecurityProfilesForTarget",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSecurityProfilesForTargetInput`](crate::input::ListSecurityProfilesForTargetInput)
    pub fn builder() -> crate::input::list_security_profiles_for_target_input::Builder {
        crate::input::list_security_profiles_for_target_input::Builder::default()
    }
}

/// See [`ListStreamsInput`](crate::input::ListStreamsInput)
pub mod list_streams_input {

    /// A builder for [`ListStreamsInput`](crate::input::ListStreamsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) ascending_order: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The maximum number of results to return at a time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at a time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>A token used to get the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token used to get the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Set to true to return the list of streams in ascending order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.ascending_order = Some(input);
            self
        }
        /// <p>Set to true to return the list of streams in ascending order.</p>
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.ascending_order = input;
            self
        }
        /// Consumes the builder and constructs a [`ListStreamsInput`](crate::input::ListStreamsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListStreamsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListStreamsInput {
                max_results: self.max_results,
                next_token: self.next_token,
                ascending_order: self.ascending_order.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListStreamsInputOperationOutputAlias = crate::operation::ListStreams;
#[doc(hidden)]
pub type ListStreamsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListStreamsInput {
    /// Consumes the builder and constructs an Operation<[`ListStreams`](crate::operation::ListStreams)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListStreams,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListStreamsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/streams").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListStreamsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_259) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_259).encode(),
                    );
                }
                if let Some(inner_260) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_260));
                }
                if _input.ascending_order {
                    query.push_kv(
                        "isAscendingOrder",
                        aws_smithy_types::primitive::Encoder::from(_input.ascending_order).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListStreamsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListStreams::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListStreams",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListStreamsInput`](crate::input::ListStreamsInput)
    pub fn builder() -> crate::input::list_streams_input::Builder {
        crate::input::list_streams_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {

    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTagsForResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/tags").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListTagsForResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_261) = &_input.resource_arn {
                    query.push_kv(
                        "resourceArn",
                        &aws_smithy_http::query::fmt_string(&inner_261),
                    );
                }
                if let Some(inner_262) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_262));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTagsForResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTargetsForPolicyInput`](crate::input::ListTargetsForPolicyInput)
pub mod list_targets_for_policy_input {

    /// A builder for [`ListTargetsForPolicyInput`](crate::input::ListTargetsForPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The policy name.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>A marker used to get the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>A marker used to get the next set of results.</p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTargetsForPolicyInput`](crate::input::ListTargetsForPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTargetsForPolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTargetsForPolicyInput {
                policy_name: self.policy_name,
                marker: self.marker,
                page_size: self.page_size,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTargetsForPolicyInputOperationOutputAlias = crate::operation::ListTargetsForPolicy;
#[doc(hidden)]
pub type ListTargetsForPolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListTargetsForPolicyInput {
    /// Consumes the builder and constructs an Operation<[`ListTargetsForPolicy`](crate::operation::ListTargetsForPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTargetsForPolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTargetsForPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_263 = &_input.policy_name;
                let input_263 = input_263.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_263, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/policy-targets/{policyName}",
                    policyName = policy_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListTargetsForPolicyInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_264) = &_input.marker {
                    query.push_kv("marker", &aws_smithy_http::query::fmt_string(&inner_264));
                }
                if let Some(inner_265) = &_input.page_size {
                    query.push_kv(
                        "pageSize",
                        aws_smithy_types::primitive::Encoder::from(*inner_265).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTargetsForPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTargetsForPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTargetsForPolicy",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTargetsForPolicyInput`](crate::input::ListTargetsForPolicyInput)
    pub fn builder() -> crate::input::list_targets_for_policy_input::Builder {
        crate::input::list_targets_for_policy_input::Builder::default()
    }
}

/// See [`ListTargetsForSecurityProfileInput`](crate::input::ListTargetsForSecurityProfileInput)
pub mod list_targets_for_security_profile_input {

    /// A builder for [`ListTargetsForSecurityProfileInput`](crate::input::ListTargetsForSecurityProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The security profile.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The security profile.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTargetsForSecurityProfileInput`](crate::input::ListTargetsForSecurityProfileInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTargetsForSecurityProfileInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTargetsForSecurityProfileInput {
                security_profile_name: self.security_profile_name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTargetsForSecurityProfileInputOperationOutputAlias =
    crate::operation::ListTargetsForSecurityProfile;
#[doc(hidden)]
pub type ListTargetsForSecurityProfileInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListTargetsForSecurityProfileInput {
    /// Consumes the builder and constructs an Operation<[`ListTargetsForSecurityProfile`](crate::operation::ListTargetsForSecurityProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTargetsForSecurityProfile,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTargetsForSecurityProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_266 = &_input.security_profile_name;
                let input_266 = input_266.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let security_profile_name = aws_smithy_http::label::fmt_string(input_266, false);
                if security_profile_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/security-profiles/{securityProfileName}/targets",
                    securityProfileName = security_profile_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListTargetsForSecurityProfileInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_267) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_267));
                }
                if let Some(inner_268) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_268).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTargetsForSecurityProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTargetsForSecurityProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTargetsForSecurityProfile",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTargetsForSecurityProfileInput`](crate::input::ListTargetsForSecurityProfileInput)
    pub fn builder() -> crate::input::list_targets_for_security_profile_input::Builder {
        crate::input::list_targets_for_security_profile_input::Builder::default()
    }
}

/// See [`ListThingGroupsInput`](crate::input::ListThingGroupsInput)
pub mod list_thing_groups_input {

    /// A builder for [`ListThingGroupsInput`](crate::input::ListThingGroupsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) parent_group: std::option::Option<std::string::String>,
        pub(crate) name_prefix_filter: std::option::Option<std::string::String>,
        pub(crate) recursive: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>A filter that limits the results to those with the specified parent group.</p>
        pub fn parent_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.parent_group = Some(input.into());
            self
        }
        /// <p>A filter that limits the results to those with the specified parent group.</p>
        pub fn set_parent_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parent_group = input;
            self
        }
        /// <p>A filter that limits the results to those with the specified name prefix.</p>
        pub fn name_prefix_filter(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_prefix_filter = Some(input.into());
            self
        }
        /// <p>A filter that limits the results to those with the specified name prefix.</p>
        pub fn set_name_prefix_filter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.name_prefix_filter = input;
            self
        }
        /// <p>If true, return child groups as well.</p>
        pub fn recursive(mut self, input: bool) -> Self {
            self.recursive = Some(input);
            self
        }
        /// <p>If true, return child groups as well.</p>
        pub fn set_recursive(mut self, input: std::option::Option<bool>) -> Self {
            self.recursive = input;
            self
        }
        /// Consumes the builder and constructs a [`ListThingGroupsInput`](crate::input::ListThingGroupsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListThingGroupsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListThingGroupsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                parent_group: self.parent_group,
                name_prefix_filter: self.name_prefix_filter,
                recursive: self.recursive,
            })
        }
    }
}
#[doc(hidden)]
pub type ListThingGroupsInputOperationOutputAlias = crate::operation::ListThingGroups;
#[doc(hidden)]
pub type ListThingGroupsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListThingGroupsInput {
    /// Consumes the builder and constructs an Operation<[`ListThingGroups`](crate::operation::ListThingGroups)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListThingGroups,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListThingGroupsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/thing-groups").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListThingGroupsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_269) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_269));
                }
                if let Some(inner_270) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_270).encode(),
                    );
                }
                if let Some(inner_271) = &_input.parent_group {
                    query.push_kv(
                        "parentGroup",
                        &aws_smithy_http::query::fmt_string(&inner_271),
                    );
                }
                if let Some(inner_272) = &_input.name_prefix_filter {
                    query.push_kv(
                        "namePrefixFilter",
                        &aws_smithy_http::query::fmt_string(&inner_272),
                    );
                }
                if let Some(inner_273) = &_input.recursive {
                    query.push_kv(
                        "recursive",
                        aws_smithy_types::primitive::Encoder::from(*inner_273).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListThingGroupsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListThingGroups::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListThingGroups",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListThingGroupsInput`](crate::input::ListThingGroupsInput)
    pub fn builder() -> crate::input::list_thing_groups_input::Builder {
        crate::input::list_thing_groups_input::Builder::default()
    }
}

/// See [`ListThingGroupsForThingInput`](crate::input::ListThingGroupsForThingInput)
pub mod list_thing_groups_for_thing_input {

    /// A builder for [`ListThingGroupsForThingInput`](crate::input::ListThingGroupsForThingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The thing name.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The thing name.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListThingGroupsForThingInput`](crate::input::ListThingGroupsForThingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListThingGroupsForThingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListThingGroupsForThingInput {
                thing_name: self.thing_name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListThingGroupsForThingInputOperationOutputAlias =
    crate::operation::ListThingGroupsForThing;
#[doc(hidden)]
pub type ListThingGroupsForThingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListThingGroupsForThingInput {
    /// Consumes the builder and constructs an Operation<[`ListThingGroupsForThing`](crate::operation::ListThingGroupsForThing)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListThingGroupsForThing,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListThingGroupsForThingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_274 = &_input.thing_name;
                let input_274 = input_274.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_274, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/things/{thingName}/thing-groups",
                    thingName = thing_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListThingGroupsForThingInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_275) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_275));
                }
                if let Some(inner_276) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_276).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListThingGroupsForThingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListThingGroupsForThing::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListThingGroupsForThing",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListThingGroupsForThingInput`](crate::input::ListThingGroupsForThingInput)
    pub fn builder() -> crate::input::list_thing_groups_for_thing_input::Builder {
        crate::input::list_thing_groups_for_thing_input::Builder::default()
    }
}

/// See [`ListThingPrincipalsInput`](crate::input::ListThingPrincipalsInput)
pub mod list_thing_principals_input {

    /// A builder for [`ListThingPrincipalsInput`](crate::input::ListThingPrincipalsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The name of the thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListThingPrincipalsInput`](crate::input::ListThingPrincipalsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListThingPrincipalsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListThingPrincipalsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                thing_name: self.thing_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ListThingPrincipalsInputOperationOutputAlias = crate::operation::ListThingPrincipals;
#[doc(hidden)]
pub type ListThingPrincipalsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListThingPrincipalsInput {
    /// Consumes the builder and constructs an Operation<[`ListThingPrincipals`](crate::operation::ListThingPrincipals)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListThingPrincipals,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListThingPrincipalsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_277 = &_input.thing_name;
                let input_277 = input_277.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_277, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/things/{thingName}/principals",
                    thingName = thing_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListThingPrincipalsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_278) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_278));
                }
                if let Some(inner_279) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_279).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListThingPrincipalsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListThingPrincipals::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListThingPrincipals",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListThingPrincipalsInput`](crate::input::ListThingPrincipalsInput)
    pub fn builder() -> crate::input::list_thing_principals_input::Builder {
        crate::input::list_thing_principals_input::Builder::default()
    }
}

/// See [`ListThingRegistrationTaskReportsInput`](crate::input::ListThingRegistrationTaskReportsInput)
pub mod list_thing_registration_task_reports_input {

    /// A builder for [`ListThingRegistrationTaskReportsInput`](crate::input::ListThingRegistrationTaskReportsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) report_type: std::option::Option<crate::model::ReportType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The id of the task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The id of the task.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p>The type of task report.</p>
        pub fn report_type(mut self, input: crate::model::ReportType) -> Self {
            self.report_type = Some(input);
            self
        }
        /// <p>The type of task report.</p>
        pub fn set_report_type(
            mut self,
            input: std::option::Option<crate::model::ReportType>,
        ) -> Self {
            self.report_type = input;
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListThingRegistrationTaskReportsInput`](crate::input::ListThingRegistrationTaskReportsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListThingRegistrationTaskReportsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListThingRegistrationTaskReportsInput {
                task_id: self.task_id,
                report_type: self.report_type,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListThingRegistrationTaskReportsInputOperationOutputAlias =
    crate::operation::ListThingRegistrationTaskReports;
#[doc(hidden)]
pub type ListThingRegistrationTaskReportsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListThingRegistrationTaskReportsInput {
    /// Consumes the builder and constructs an Operation<[`ListThingRegistrationTaskReports`](crate::operation::ListThingRegistrationTaskReports)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListThingRegistrationTaskReports,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListThingRegistrationTaskReportsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_280 = &_input.task_id;
                let input_280 = input_280.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let task_id = aws_smithy_http::label::fmt_string(input_280, false);
                if task_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-registration-tasks/{taskId}/reports",
                    taskId = task_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListThingRegistrationTaskReportsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_281) = &_input.report_type {
                    query.push_kv(
                        "reportType",
                        &aws_smithy_http::query::fmt_string(&inner_281),
                    );
                }
                if let Some(inner_282) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_282));
                }
                if let Some(inner_283) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_283).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListThingRegistrationTaskReportsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListThingRegistrationTaskReports::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListThingRegistrationTaskReports",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListThingRegistrationTaskReportsInput`](crate::input::ListThingRegistrationTaskReportsInput)
    pub fn builder() -> crate::input::list_thing_registration_task_reports_input::Builder {
        crate::input::list_thing_registration_task_reports_input::Builder::default()
    }
}

/// See [`ListThingRegistrationTasksInput`](crate::input::ListThingRegistrationTasksInput)
pub mod list_thing_registration_tasks_input {

    /// A builder for [`ListThingRegistrationTasksInput`](crate::input::ListThingRegistrationTasksInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::Status>,
    }
    impl Builder {
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The status of the bulk thing provisioning task.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the bulk thing provisioning task.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ListThingRegistrationTasksInput`](crate::input::ListThingRegistrationTasksInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListThingRegistrationTasksInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListThingRegistrationTasksInput {
                next_token: self.next_token,
                max_results: self.max_results,
                status: self.status,
            })
        }
    }
}
#[doc(hidden)]
pub type ListThingRegistrationTasksInputOperationOutputAlias =
    crate::operation::ListThingRegistrationTasks;
#[doc(hidden)]
pub type ListThingRegistrationTasksInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListThingRegistrationTasksInput {
    /// Consumes the builder and constructs an Operation<[`ListThingRegistrationTasks`](crate::operation::ListThingRegistrationTasks)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListThingRegistrationTasks,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListThingRegistrationTasksInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/thing-registration-tasks").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListThingRegistrationTasksInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_284) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_284));
                }
                if let Some(inner_285) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_285).encode(),
                    );
                }
                if let Some(inner_286) = &_input.status {
                    query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_286));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListThingRegistrationTasksInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListThingRegistrationTasks::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListThingRegistrationTasks",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListThingRegistrationTasksInput`](crate::input::ListThingRegistrationTasksInput)
    pub fn builder() -> crate::input::list_thing_registration_tasks_input::Builder {
        crate::input::list_thing_registration_tasks_input::Builder::default()
    }
}

/// See [`ListThingsInput`](crate::input::ListThingsInput)
pub mod list_things_input {

    /// A builder for [`ListThingsInput`](crate::input::ListThingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) attribute_value: std::option::Option<std::string::String>,
        pub(crate) thing_type_name: std::option::Option<std::string::String>,
        pub(crate) use_prefix_attribute_value: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The attribute name used to search for things.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
            self
        }
        /// <p>The attribute name used to search for things.</p>
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        /// <p>The attribute value used to search for things.</p>
        pub fn attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_value = Some(input.into());
            self
        }
        /// <p>The attribute value used to search for things.</p>
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_value = input;
            self
        }
        /// <p>The name of the thing type used to search for things.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_type_name = Some(input.into());
            self
        }
        /// <p>The name of the thing type used to search for things.</p>
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_type_name = input;
            self
        }
        /// <p>When <code>true</code>, the action returns the thing resources with attribute values that start with the <code>attributeValue</code> provided.</p>
        /// <p>When <code>false</code>, or not present, the action returns only the thing resources with attribute values that match the entire <code>attributeValue</code> provided. </p>
        pub fn use_prefix_attribute_value(mut self, input: bool) -> Self {
            self.use_prefix_attribute_value = Some(input);
            self
        }
        /// <p>When <code>true</code>, the action returns the thing resources with attribute values that start with the <code>attributeValue</code> provided.</p>
        /// <p>When <code>false</code>, or not present, the action returns only the thing resources with attribute values that match the entire <code>attributeValue</code> provided. </p>
        pub fn set_use_prefix_attribute_value(mut self, input: std::option::Option<bool>) -> Self {
            self.use_prefix_attribute_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ListThingsInput`](crate::input::ListThingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListThingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListThingsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                attribute_name: self.attribute_name,
                attribute_value: self.attribute_value,
                thing_type_name: self.thing_type_name,
                use_prefix_attribute_value: self.use_prefix_attribute_value.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListThingsInputOperationOutputAlias = crate::operation::ListThings;
#[doc(hidden)]
pub type ListThingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListThingsInput {
    /// Consumes the builder and constructs an Operation<[`ListThings`](crate::operation::ListThings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListThings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListThingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/things").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListThingsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_287) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_287));
                }
                if let Some(inner_288) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_288).encode(),
                    );
                }
                if let Some(inner_289) = &_input.attribute_name {
                    query.push_kv(
                        "attributeName",
                        &aws_smithy_http::query::fmt_string(&inner_289),
                    );
                }
                if let Some(inner_290) = &_input.attribute_value {
                    query.push_kv(
                        "attributeValue",
                        &aws_smithy_http::query::fmt_string(&inner_290),
                    );
                }
                if let Some(inner_291) = &_input.thing_type_name {
                    query.push_kv(
                        "thingTypeName",
                        &aws_smithy_http::query::fmt_string(&inner_291),
                    );
                }
                if _input.use_prefix_attribute_value {
                    query.push_kv(
                        "usePrefixAttributeValue",
                        aws_smithy_types::primitive::Encoder::from(
                            _input.use_prefix_attribute_value,
                        )
                        .encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListThingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListThings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListThings",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListThingsInput`](crate::input::ListThingsInput)
    pub fn builder() -> crate::input::list_things_input::Builder {
        crate::input::list_things_input::Builder::default()
    }
}

/// See [`ListThingsInBillingGroupInput`](crate::input::ListThingsInBillingGroupInput)
pub mod list_things_in_billing_group_input {

    /// A builder for [`ListThingsInBillingGroupInput`](crate::input::ListThingsInBillingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_group_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the billing group.</p>
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_name = input;
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListThingsInBillingGroupInput`](crate::input::ListThingsInBillingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListThingsInBillingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListThingsInBillingGroupInput {
                billing_group_name: self.billing_group_name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListThingsInBillingGroupInputOperationOutputAlias =
    crate::operation::ListThingsInBillingGroup;
#[doc(hidden)]
pub type ListThingsInBillingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListThingsInBillingGroupInput {
    /// Consumes the builder and constructs an Operation<[`ListThingsInBillingGroup`](crate::operation::ListThingsInBillingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListThingsInBillingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListThingsInBillingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_292 = &_input.billing_group_name;
                let input_292 = input_292.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "billing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let billing_group_name = aws_smithy_http::label::fmt_string(input_292, false);
                if billing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "billing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/billing-groups/{billingGroupName}/things",
                    billingGroupName = billing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListThingsInBillingGroupInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_293) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_293));
                }
                if let Some(inner_294) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_294).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListThingsInBillingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListThingsInBillingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListThingsInBillingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListThingsInBillingGroupInput`](crate::input::ListThingsInBillingGroupInput)
    pub fn builder() -> crate::input::list_things_in_billing_group_input::Builder {
        crate::input::list_things_in_billing_group_input::Builder::default()
    }
}

/// See [`ListThingsInThingGroupInput`](crate::input::ListThingsInThingGroupInput)
pub mod list_things_in_thing_group_input {

    /// A builder for [`ListThingsInThingGroupInput`](crate::input::ListThingsInThingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_group_name: std::option::Option<std::string::String>,
        pub(crate) recursive: std::option::Option<bool>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The thing group name.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_name = Some(input.into());
            self
        }
        /// <p>The thing group name.</p>
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_name = input;
            self
        }
        /// <p>When true, list things in this thing group and in all child groups as well.</p>
        pub fn recursive(mut self, input: bool) -> Self {
            self.recursive = Some(input);
            self
        }
        /// <p>When true, list things in this thing group and in all child groups as well.</p>
        pub fn set_recursive(mut self, input: std::option::Option<bool>) -> Self {
            self.recursive = input;
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListThingsInThingGroupInput`](crate::input::ListThingsInThingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListThingsInThingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListThingsInThingGroupInput {
                thing_group_name: self.thing_group_name,
                recursive: self.recursive.unwrap_or_default(),
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListThingsInThingGroupInputOperationOutputAlias = crate::operation::ListThingsInThingGroup;
#[doc(hidden)]
pub type ListThingsInThingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListThingsInThingGroupInput {
    /// Consumes the builder and constructs an Operation<[`ListThingsInThingGroup`](crate::operation::ListThingsInThingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListThingsInThingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListThingsInThingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_295 = &_input.thing_group_name;
                let input_295 = input_295.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_group_name = aws_smithy_http::label::fmt_string(input_295, false);
                if thing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-groups/{thingGroupName}/things",
                    thingGroupName = thing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListThingsInThingGroupInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.recursive {
                    query.push_kv(
                        "recursive",
                        aws_smithy_types::primitive::Encoder::from(_input.recursive).encode(),
                    );
                }
                if let Some(inner_296) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_296));
                }
                if let Some(inner_297) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_297).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListThingsInThingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListThingsInThingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListThingsInThingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListThingsInThingGroupInput`](crate::input::ListThingsInThingGroupInput)
    pub fn builder() -> crate::input::list_things_in_thing_group_input::Builder {
        crate::input::list_things_in_thing_group_input::Builder::default()
    }
}

/// See [`ListThingTypesInput`](crate::input::ListThingTypesInput)
pub mod list_thing_types_input {

    /// A builder for [`ListThingTypesInput`](crate::input::ListThingTypesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) thing_type_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The name of the thing type.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_type_name = Some(input.into());
            self
        }
        /// <p>The name of the thing type.</p>
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_type_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListThingTypesInput`](crate::input::ListThingTypesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListThingTypesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListThingTypesInput {
                next_token: self.next_token,
                max_results: self.max_results,
                thing_type_name: self.thing_type_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ListThingTypesInputOperationOutputAlias = crate::operation::ListThingTypes;
#[doc(hidden)]
pub type ListThingTypesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListThingTypesInput {
    /// Consumes the builder and constructs an Operation<[`ListThingTypes`](crate::operation::ListThingTypes)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListThingTypes,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListThingTypesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/thing-types").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListThingTypesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_298) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_298));
                }
                if let Some(inner_299) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_299).encode(),
                    );
                }
                if let Some(inner_300) = &_input.thing_type_name {
                    query.push_kv(
                        "thingTypeName",
                        &aws_smithy_http::query::fmt_string(&inner_300),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListThingTypesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListThingTypes::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListThingTypes",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListThingTypesInput`](crate::input::ListThingTypesInput)
    pub fn builder() -> crate::input::list_thing_types_input::Builder {
        crate::input::list_thing_types_input::Builder::default()
    }
}

/// See [`ListTopicRuleDestinationsInput`](crate::input::ListTopicRuleDestinationsInput)
pub mod list_topic_rule_destinations_input {

    /// A builder for [`ListTopicRuleDestinationsInput`](crate::input::ListTopicRuleDestinationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTopicRuleDestinationsInput`](crate::input::ListTopicRuleDestinationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTopicRuleDestinationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTopicRuleDestinationsInput {
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTopicRuleDestinationsInputOperationOutputAlias =
    crate::operation::ListTopicRuleDestinations;
#[doc(hidden)]
pub type ListTopicRuleDestinationsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListTopicRuleDestinationsInput {
    /// Consumes the builder and constructs an Operation<[`ListTopicRuleDestinations`](crate::operation::ListTopicRuleDestinations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTopicRuleDestinations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTopicRuleDestinationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/destinations").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListTopicRuleDestinationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_301) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_301).encode(),
                    );
                }
                if let Some(inner_302) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_302));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTopicRuleDestinationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTopicRuleDestinations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTopicRuleDestinations",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTopicRuleDestinationsInput`](crate::input::ListTopicRuleDestinationsInput)
    pub fn builder() -> crate::input::list_topic_rule_destinations_input::Builder {
        crate::input::list_topic_rule_destinations_input::Builder::default()
    }
}

/// See [`ListTopicRulesInput`](crate::input::ListTopicRulesInput)
pub mod list_topic_rules_input {

    /// A builder for [`ListTopicRulesInput`](crate::input::ListTopicRulesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) topic: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) rule_disabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The topic.</p>
        pub fn topic(mut self, input: impl Into<std::string::String>) -> Self {
            self.topic = Some(input.into());
            self
        }
        /// <p>The topic.</p>
        pub fn set_topic(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.topic = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Specifies whether the rule is disabled.</p>
        pub fn rule_disabled(mut self, input: bool) -> Self {
            self.rule_disabled = Some(input);
            self
        }
        /// <p>Specifies whether the rule is disabled.</p>
        pub fn set_rule_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.rule_disabled = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTopicRulesInput`](crate::input::ListTopicRulesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTopicRulesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTopicRulesInput {
                topic: self.topic,
                max_results: self.max_results,
                next_token: self.next_token,
                rule_disabled: self.rule_disabled,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTopicRulesInputOperationOutputAlias = crate::operation::ListTopicRules;
#[doc(hidden)]
pub type ListTopicRulesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListTopicRulesInput {
    /// Consumes the builder and constructs an Operation<[`ListTopicRules`](crate::operation::ListTopicRules)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTopicRules,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTopicRulesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/rules").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListTopicRulesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_303) = &_input.topic {
                    query.push_kv("topic", &aws_smithy_http::query::fmt_string(&inner_303));
                }
                if let Some(inner_304) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_304).encode(),
                    );
                }
                if let Some(inner_305) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_305));
                }
                if let Some(inner_306) = &_input.rule_disabled {
                    query.push_kv(
                        "ruleDisabled",
                        aws_smithy_types::primitive::Encoder::from(*inner_306).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTopicRulesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTopicRules::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTopicRules",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTopicRulesInput`](crate::input::ListTopicRulesInput)
    pub fn builder() -> crate::input::list_topic_rules_input::Builder {
        crate::input::list_topic_rules_input::Builder::default()
    }
}

/// See [`ListV2LoggingLevelsInput`](crate::input::ListV2LoggingLevelsInput)
pub mod list_v2_logging_levels_input {

    /// A builder for [`ListV2LoggingLevelsInput`](crate::input::ListV2LoggingLevelsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_type: std::option::Option<crate::model::LogTargetType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
        pub fn target_type(mut self, input: crate::model::LogTargetType) -> Self {
            self.target_type = Some(input);
            self
        }
        /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
        pub fn set_target_type(
            mut self,
            input: std::option::Option<crate::model::LogTargetType>,
        ) -> Self {
            self.target_type = input;
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListV2LoggingLevelsInput`](crate::input::ListV2LoggingLevelsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListV2LoggingLevelsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListV2LoggingLevelsInput {
                target_type: self.target_type,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListV2LoggingLevelsInputOperationOutputAlias = crate::operation::ListV2LoggingLevels;
#[doc(hidden)]
pub type ListV2LoggingLevelsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListV2LoggingLevelsInput {
    /// Consumes the builder and constructs an Operation<[`ListV2LoggingLevels`](crate::operation::ListV2LoggingLevels)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListV2LoggingLevels,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListV2LoggingLevelsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/v2LoggingLevel").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListV2LoggingLevelsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_307) = &_input.target_type {
                    query.push_kv(
                        "targetType",
                        &aws_smithy_http::query::fmt_string(&inner_307),
                    );
                }
                if let Some(inner_308) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_308));
                }
                if let Some(inner_309) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_309).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListV2LoggingLevelsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListV2LoggingLevels::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListV2LoggingLevels",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListV2LoggingLevelsInput`](crate::input::ListV2LoggingLevelsInput)
    pub fn builder() -> crate::input::list_v2_logging_levels_input::Builder {
        crate::input::list_v2_logging_levels_input::Builder::default()
    }
}

/// See [`ListViolationEventsInput`](crate::input::ListViolationEventsInput)
pub mod list_violation_events_input {

    /// A builder for [`ListViolationEventsInput`](crate::input::ListViolationEventsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) behavior_criteria_type: std::option::Option<crate::model::BehaviorCriteriaType>,
        pub(crate) list_suppressed_alerts: std::option::Option<bool>,
        pub(crate) verification_state: std::option::Option<crate::model::VerificationState>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The start time for the alerts to be listed.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time for the alerts to be listed.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time for the alerts to be listed.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time for the alerts to be listed.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>A filter to limit results to those alerts caused by the specified thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>A filter to limit results to those alerts caused by the specified thing.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>A filter to limit results to those alerts generated by the specified security profile.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>A filter to limit results to those alerts generated by the specified security profile.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p> The criteria for a behavior. </p>
        pub fn behavior_criteria_type(mut self, input: crate::model::BehaviorCriteriaType) -> Self {
            self.behavior_criteria_type = Some(input);
            self
        }
        /// <p> The criteria for a behavior. </p>
        pub fn set_behavior_criteria_type(
            mut self,
            input: std::option::Option<crate::model::BehaviorCriteriaType>,
        ) -> Self {
            self.behavior_criteria_type = input;
            self
        }
        /// <p> A list of all suppressed alerts. </p>
        pub fn list_suppressed_alerts(mut self, input: bool) -> Self {
            self.list_suppressed_alerts = Some(input);
            self
        }
        /// <p> A list of all suppressed alerts. </p>
        pub fn set_list_suppressed_alerts(mut self, input: std::option::Option<bool>) -> Self {
            self.list_suppressed_alerts = input;
            self
        }
        /// <p>The verification state of the violation (detect alarm).</p>
        pub fn verification_state(mut self, input: crate::model::VerificationState) -> Self {
            self.verification_state = Some(input);
            self
        }
        /// <p>The verification state of the violation (detect alarm).</p>
        pub fn set_verification_state(
            mut self,
            input: std::option::Option<crate::model::VerificationState>,
        ) -> Self {
            self.verification_state = input;
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListViolationEventsInput`](crate::input::ListViolationEventsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListViolationEventsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListViolationEventsInput {
                start_time: self.start_time,
                end_time: self.end_time,
                thing_name: self.thing_name,
                security_profile_name: self.security_profile_name,
                behavior_criteria_type: self.behavior_criteria_type,
                list_suppressed_alerts: self.list_suppressed_alerts,
                verification_state: self.verification_state,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListViolationEventsInputOperationOutputAlias = crate::operation::ListViolationEvents;
#[doc(hidden)]
pub type ListViolationEventsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListViolationEventsInput {
    /// Consumes the builder and constructs an Operation<[`ListViolationEvents`](crate::operation::ListViolationEvents)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListViolationEvents,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListViolationEventsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/violation-events").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListViolationEventsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_310) = &_input.start_time {
                    query.push_kv(
                        "startTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_310,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_311) = &_input.end_time {
                    query.push_kv(
                        "endTime",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_311,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_312) = &_input.thing_name {
                    query.push_kv("thingName", &aws_smithy_http::query::fmt_string(&inner_312));
                }
                if let Some(inner_313) = &_input.security_profile_name {
                    query.push_kv(
                        "securityProfileName",
                        &aws_smithy_http::query::fmt_string(&inner_313),
                    );
                }
                if let Some(inner_314) = &_input.behavior_criteria_type {
                    query.push_kv(
                        "behaviorCriteriaType",
                        &aws_smithy_http::query::fmt_string(&inner_314),
                    );
                }
                if let Some(inner_315) = &_input.list_suppressed_alerts {
                    query.push_kv(
                        "listSuppressedAlerts",
                        aws_smithy_types::primitive::Encoder::from(*inner_315).encode(),
                    );
                }
                if let Some(inner_316) = &_input.verification_state {
                    query.push_kv(
                        "verificationState",
                        &aws_smithy_http::query::fmt_string(&inner_316),
                    );
                }
                if let Some(inner_317) = &_input.next_token {
                    query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_317));
                }
                if let Some(inner_318) = &_input.max_results {
                    query.push_kv(
                        "maxResults",
                        aws_smithy_types::primitive::Encoder::from(*inner_318).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListViolationEventsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListViolationEvents::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListViolationEvents",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListViolationEventsInput`](crate::input::ListViolationEventsInput)
    pub fn builder() -> crate::input::list_violation_events_input::Builder {
        crate::input::list_violation_events_input::Builder::default()
    }
}

/// See [`PutVerificationStateOnViolationInput`](crate::input::PutVerificationStateOnViolationInput)
pub mod put_verification_state_on_violation_input {

    /// A builder for [`PutVerificationStateOnViolationInput`](crate::input::PutVerificationStateOnViolationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) violation_id: std::option::Option<std::string::String>,
        pub(crate) verification_state: std::option::Option<crate::model::VerificationState>,
        pub(crate) verification_state_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The violation ID.</p>
        pub fn violation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.violation_id = Some(input.into());
            self
        }
        /// <p>The violation ID.</p>
        pub fn set_violation_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.violation_id = input;
            self
        }
        /// <p>The verification state of the violation.</p>
        pub fn verification_state(mut self, input: crate::model::VerificationState) -> Self {
            self.verification_state = Some(input);
            self
        }
        /// <p>The verification state of the violation.</p>
        pub fn set_verification_state(
            mut self,
            input: std::option::Option<crate::model::VerificationState>,
        ) -> Self {
            self.verification_state = input;
            self
        }
        /// <p>The description of the verification state of the violation (detect alarm).</p>
        pub fn verification_state_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.verification_state_description = Some(input.into());
            self
        }
        /// <p>The description of the verification state of the violation (detect alarm).</p>
        pub fn set_verification_state_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.verification_state_description = input;
            self
        }
        /// Consumes the builder and constructs a [`PutVerificationStateOnViolationInput`](crate::input::PutVerificationStateOnViolationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutVerificationStateOnViolationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutVerificationStateOnViolationInput {
                violation_id: self.violation_id,
                verification_state: self.verification_state,
                verification_state_description: self.verification_state_description,
            })
        }
    }
}
#[doc(hidden)]
pub type PutVerificationStateOnViolationInputOperationOutputAlias =
    crate::operation::PutVerificationStateOnViolation;
#[doc(hidden)]
pub type PutVerificationStateOnViolationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl PutVerificationStateOnViolationInput {
    /// Consumes the builder and constructs an Operation<[`PutVerificationStateOnViolation`](crate::operation::PutVerificationStateOnViolation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutVerificationStateOnViolation,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutVerificationStateOnViolationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_319 = &_input.violation_id;
                let input_319 = input_319.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "violation_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let violation_id = aws_smithy_http::label::fmt_string(input_319, false);
                if violation_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "violation_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/violations/verification-state/{violationId}",
                    violationId = violation_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutVerificationStateOnViolationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_verification_state_on_violation(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutVerificationStateOnViolation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutVerificationStateOnViolation",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutVerificationStateOnViolationInput`](crate::input::PutVerificationStateOnViolationInput)
    pub fn builder() -> crate::input::put_verification_state_on_violation_input::Builder {
        crate::input::put_verification_state_on_violation_input::Builder::default()
    }
}

/// See [`RegisterCaCertificateInput`](crate::input::RegisterCaCertificateInput)
pub mod register_ca_certificate_input {

    /// A builder for [`RegisterCaCertificateInput`](crate::input::RegisterCaCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ca_certificate: std::option::Option<std::string::String>,
        pub(crate) verification_certificate: std::option::Option<std::string::String>,
        pub(crate) set_as_active: std::option::Option<bool>,
        pub(crate) allow_auto_registration: std::option::Option<bool>,
        pub(crate) registration_config: std::option::Option<crate::model::RegistrationConfig>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The CA certificate.</p>
        pub fn ca_certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.ca_certificate = Some(input.into());
            self
        }
        /// <p>The CA certificate.</p>
        pub fn set_ca_certificate(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ca_certificate = input;
            self
        }
        /// <p>The private key verification certificate.</p>
        pub fn verification_certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.verification_certificate = Some(input.into());
            self
        }
        /// <p>The private key verification certificate.</p>
        pub fn set_verification_certificate(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.verification_certificate = input;
            self
        }
        /// <p>A boolean value that specifies if the CA certificate is set to active.</p>
        /// <p>Valid values: <code>ACTIVE | INACTIVE</code> </p>
        pub fn set_as_active(mut self, input: bool) -> Self {
            self.set_as_active = Some(input);
            self
        }
        /// <p>A boolean value that specifies if the CA certificate is set to active.</p>
        /// <p>Valid values: <code>ACTIVE | INACTIVE</code> </p>
        pub fn set_set_as_active(mut self, input: std::option::Option<bool>) -> Self {
            self.set_as_active = input;
            self
        }
        /// <p>Allows this CA certificate to be used for auto registration of device certificates.</p>
        pub fn allow_auto_registration(mut self, input: bool) -> Self {
            self.allow_auto_registration = Some(input);
            self
        }
        /// <p>Allows this CA certificate to be used for auto registration of device certificates.</p>
        pub fn set_allow_auto_registration(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_auto_registration = input;
            self
        }
        /// <p>Information about the registration configuration.</p>
        pub fn registration_config(mut self, input: crate::model::RegistrationConfig) -> Self {
            self.registration_config = Some(input);
            self
        }
        /// <p>Information about the registration configuration.</p>
        pub fn set_registration_config(
            mut self,
            input: std::option::Option<crate::model::RegistrationConfig>,
        ) -> Self {
            self.registration_config = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the CA certificate.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the CA certificate.</p> <note>
        /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
        /// </note>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterCaCertificateInput`](crate::input::RegisterCaCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RegisterCaCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RegisterCaCertificateInput {
                ca_certificate: self.ca_certificate,
                verification_certificate: self.verification_certificate,
                set_as_active: self.set_as_active.unwrap_or_default(),
                allow_auto_registration: self.allow_auto_registration.unwrap_or_default(),
                registration_config: self.registration_config,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type RegisterCaCertificateInputOperationOutputAlias = crate::operation::RegisterCACertificate;
#[doc(hidden)]
pub type RegisterCaCertificateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RegisterCaCertificateInput {
    /// Consumes the builder and constructs an Operation<[`RegisterCACertificate`](crate::operation::RegisterCACertificate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RegisterCACertificate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RegisterCaCertificateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/cacertificate").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::RegisterCaCertificateInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.set_as_active {
                    query.push_kv(
                        "setAsActive",
                        aws_smithy_types::primitive::Encoder::from(_input.set_as_active).encode(),
                    );
                }
                if _input.allow_auto_registration {
                    query.push_kv(
                        "allowAutoRegistration",
                        aws_smithy_types::primitive::Encoder::from(_input.allow_auto_registration)
                            .encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RegisterCaCertificateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_register_ca_certificate(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RegisterCACertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RegisterCACertificate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RegisterCaCertificateInput`](crate::input::RegisterCaCertificateInput)
    pub fn builder() -> crate::input::register_ca_certificate_input::Builder {
        crate::input::register_ca_certificate_input::Builder::default()
    }
}

/// See [`RegisterCertificateInput`](crate::input::RegisterCertificateInput)
pub mod register_certificate_input {

    /// A builder for [`RegisterCertificateInput`](crate::input::RegisterCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_pem: std::option::Option<std::string::String>,
        pub(crate) ca_certificate_pem: std::option::Option<std::string::String>,
        pub(crate) set_as_active: std::option::Option<bool>,
        pub(crate) status: std::option::Option<crate::model::CertificateStatus>,
    }
    impl Builder {
        /// <p>The certificate data, in PEM format.</p>
        pub fn certificate_pem(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_pem = Some(input.into());
            self
        }
        /// <p>The certificate data, in PEM format.</p>
        pub fn set_certificate_pem(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_pem = input;
            self
        }
        /// <p>The CA certificate used to sign the device certificate being registered.</p>
        pub fn ca_certificate_pem(mut self, input: impl Into<std::string::String>) -> Self {
            self.ca_certificate_pem = Some(input.into());
            self
        }
        /// <p>The CA certificate used to sign the device certificate being registered.</p>
        pub fn set_ca_certificate_pem(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ca_certificate_pem = input;
            self
        }
        /// <p>A boolean value that specifies if the certificate is set to active.</p>
        /// <p>Valid values: <code>ACTIVE | INACTIVE</code> </p>
        pub fn set_as_active(mut self, input: bool) -> Self {
            self.set_as_active = Some(input);
            self
        }
        /// <p>A boolean value that specifies if the certificate is set to active.</p>
        /// <p>Valid values: <code>ACTIVE | INACTIVE</code> </p>
        pub fn set_set_as_active(mut self, input: std::option::Option<bool>) -> Self {
            self.set_as_active = input;
            self
        }
        /// <p>The status of the register certificate request. Valid values that you can use include <code>ACTIVE</code>, <code>INACTIVE</code>, and <code>REVOKED</code>.</p>
        pub fn status(mut self, input: crate::model::CertificateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the register certificate request. Valid values that you can use include <code>ACTIVE</code>, <code>INACTIVE</code>, and <code>REVOKED</code>.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CertificateStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterCertificateInput`](crate::input::RegisterCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RegisterCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RegisterCertificateInput {
                certificate_pem: self.certificate_pem,
                ca_certificate_pem: self.ca_certificate_pem,
                set_as_active: self.set_as_active,
                status: self.status,
            })
        }
    }
}
#[doc(hidden)]
pub type RegisterCertificateInputOperationOutputAlias = crate::operation::RegisterCertificate;
#[doc(hidden)]
pub type RegisterCertificateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RegisterCertificateInput {
    /// Consumes the builder and constructs an Operation<[`RegisterCertificate`](crate::operation::RegisterCertificate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RegisterCertificate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RegisterCertificateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/certificate/register").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::RegisterCertificateInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_320) = &_input.set_as_active {
                    query.push_kv(
                        "setAsActive",
                        aws_smithy_types::primitive::Encoder::from(*inner_320).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RegisterCertificateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_register_certificate(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RegisterCertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RegisterCertificate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RegisterCertificateInput`](crate::input::RegisterCertificateInput)
    pub fn builder() -> crate::input::register_certificate_input::Builder {
        crate::input::register_certificate_input::Builder::default()
    }
}

/// See [`RegisterCertificateWithoutCaInput`](crate::input::RegisterCertificateWithoutCaInput)
pub mod register_certificate_without_ca_input {

    /// A builder for [`RegisterCertificateWithoutCaInput`](crate::input::RegisterCertificateWithoutCaInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_pem: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::CertificateStatus>,
    }
    impl Builder {
        /// <p>The certificate data, in PEM format.</p>
        pub fn certificate_pem(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_pem = Some(input.into());
            self
        }
        /// <p>The certificate data, in PEM format.</p>
        pub fn set_certificate_pem(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_pem = input;
            self
        }
        /// <p>The status of the register certificate request.</p>
        pub fn status(mut self, input: crate::model::CertificateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the register certificate request.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CertificateStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterCertificateWithoutCaInput`](crate::input::RegisterCertificateWithoutCaInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RegisterCertificateWithoutCaInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RegisterCertificateWithoutCaInput {
                certificate_pem: self.certificate_pem,
                status: self.status,
            })
        }
    }
}
#[doc(hidden)]
pub type RegisterCertificateWithoutCaInputOperationOutputAlias =
    crate::operation::RegisterCertificateWithoutCA;
#[doc(hidden)]
pub type RegisterCertificateWithoutCaInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl RegisterCertificateWithoutCaInput {
    /// Consumes the builder and constructs an Operation<[`RegisterCertificateWithoutCA`](crate::operation::RegisterCertificateWithoutCA)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RegisterCertificateWithoutCA,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RegisterCertificateWithoutCaInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/certificate/register-no-ca").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RegisterCertificateWithoutCaInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_register_certificate_without_ca(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RegisterCertificateWithoutCA::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RegisterCertificateWithoutCA",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RegisterCertificateWithoutCaInput`](crate::input::RegisterCertificateWithoutCaInput)
    pub fn builder() -> crate::input::register_certificate_without_ca_input::Builder {
        crate::input::register_certificate_without_ca_input::Builder::default()
    }
}

/// See [`RegisterThingInput`](crate::input::RegisterThingInput)
pub mod register_thing_input {

    /// A builder for [`RegisterThingInput`](crate::input::RegisterThingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_body: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The provisioning template. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-w-cert.html">Provisioning Devices That Have Device Certificates</a> for more information.</p>
        pub fn template_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_body = Some(input.into());
            self
        }
        /// <p>The provisioning template. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-w-cert.html">Provisioning Devices That Have Device Certificates</a> for more information.</p>
        pub fn set_template_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_body = input;
            self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>The parameters for provisioning a thing. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html">Provisioning Templates</a> for more information.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        /// <p>The parameters for provisioning a thing. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html">Provisioning Templates</a> for more information.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterThingInput`](crate::input::RegisterThingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RegisterThingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RegisterThingInput {
                template_body: self.template_body,
                parameters: self.parameters,
            })
        }
    }
}
#[doc(hidden)]
pub type RegisterThingInputOperationOutputAlias = crate::operation::RegisterThing;
#[doc(hidden)]
pub type RegisterThingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RegisterThingInput {
    /// Consumes the builder and constructs an Operation<[`RegisterThing`](crate::operation::RegisterThing)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RegisterThing,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RegisterThingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/things").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RegisterThingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_register_thing(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RegisterThing::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RegisterThing",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RegisterThingInput`](crate::input::RegisterThingInput)
    pub fn builder() -> crate::input::register_thing_input::Builder {
        crate::input::register_thing_input::Builder::default()
    }
}

/// See [`RejectCertificateTransferInput`](crate::input::RejectCertificateTransferInput)
pub mod reject_certificate_transfer_input {

    /// A builder for [`RejectCertificateTransferInput`](crate::input::RejectCertificateTransferInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_id: std::option::Option<std::string::String>,
        pub(crate) reject_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(input.into());
            self
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_id = input;
            self
        }
        /// <p>The reason the certificate transfer was rejected.</p>
        pub fn reject_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.reject_reason = Some(input.into());
            self
        }
        /// <p>The reason the certificate transfer was rejected.</p>
        pub fn set_reject_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reject_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`RejectCertificateTransferInput`](crate::input::RejectCertificateTransferInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RejectCertificateTransferInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RejectCertificateTransferInput {
                certificate_id: self.certificate_id,
                reject_reason: self.reject_reason,
            })
        }
    }
}
#[doc(hidden)]
pub type RejectCertificateTransferInputOperationOutputAlias =
    crate::operation::RejectCertificateTransfer;
#[doc(hidden)]
pub type RejectCertificateTransferInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RejectCertificateTransferInput {
    /// Consumes the builder and constructs an Operation<[`RejectCertificateTransfer`](crate::operation::RejectCertificateTransfer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RejectCertificateTransfer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RejectCertificateTransferInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_321 = &_input.certificate_id;
                let input_321 = input_321.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let certificate_id = aws_smithy_http::label::fmt_string(input_321, false);
                if certificate_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/reject-certificate-transfer/{certificateId}",
                    certificateId = certificate_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RejectCertificateTransferInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_reject_certificate_transfer(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RejectCertificateTransfer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RejectCertificateTransfer",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RejectCertificateTransferInput`](crate::input::RejectCertificateTransferInput)
    pub fn builder() -> crate::input::reject_certificate_transfer_input::Builder {
        crate::input::reject_certificate_transfer_input::Builder::default()
    }
}

/// See [`RemoveThingFromBillingGroupInput`](crate::input::RemoveThingFromBillingGroupInput)
pub mod remove_thing_from_billing_group_input {

    /// A builder for [`RemoveThingFromBillingGroupInput`](crate::input::RemoveThingFromBillingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_group_name: std::option::Option<std::string::String>,
        pub(crate) billing_group_arn: std::option::Option<std::string::String>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) thing_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the billing group.</p>
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_name = input;
            self
        }
        /// <p>The ARN of the billing group.</p>
        pub fn billing_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the billing group.</p>
        pub fn set_billing_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_arn = input;
            self
        }
        /// <p>The name of the thing to be removed from the billing group.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing to be removed from the billing group.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>The ARN of the thing to be removed from the billing group.</p>
        pub fn thing_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the thing to be removed from the billing group.</p>
        pub fn set_thing_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RemoveThingFromBillingGroupInput`](crate::input::RemoveThingFromBillingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RemoveThingFromBillingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RemoveThingFromBillingGroupInput {
                billing_group_name: self.billing_group_name,
                billing_group_arn: self.billing_group_arn,
                thing_name: self.thing_name,
                thing_arn: self.thing_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type RemoveThingFromBillingGroupInputOperationOutputAlias =
    crate::operation::RemoveThingFromBillingGroup;
#[doc(hidden)]
pub type RemoveThingFromBillingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RemoveThingFromBillingGroupInput {
    /// Consumes the builder and constructs an Operation<[`RemoveThingFromBillingGroup`](crate::operation::RemoveThingFromBillingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RemoveThingFromBillingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RemoveThingFromBillingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/billing-groups/removeThingFromBillingGroup")
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RemoveThingFromBillingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_remove_thing_from_billing_group(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RemoveThingFromBillingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RemoveThingFromBillingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RemoveThingFromBillingGroupInput`](crate::input::RemoveThingFromBillingGroupInput)
    pub fn builder() -> crate::input::remove_thing_from_billing_group_input::Builder {
        crate::input::remove_thing_from_billing_group_input::Builder::default()
    }
}

/// See [`RemoveThingFromThingGroupInput`](crate::input::RemoveThingFromThingGroupInput)
pub mod remove_thing_from_thing_group_input {

    /// A builder for [`RemoveThingFromThingGroupInput`](crate::input::RemoveThingFromThingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_group_name: std::option::Option<std::string::String>,
        pub(crate) thing_group_arn: std::option::Option<std::string::String>,
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) thing_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The group name.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_name = Some(input.into());
            self
        }
        /// <p>The group name.</p>
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_name = input;
            self
        }
        /// <p>The group ARN.</p>
        pub fn thing_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_arn = Some(input.into());
            self
        }
        /// <p>The group ARN.</p>
        pub fn set_thing_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_arn = input;
            self
        }
        /// <p>The name of the thing to remove from the group.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing to remove from the group.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>The ARN of the thing to remove from the group.</p>
        pub fn thing_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the thing to remove from the group.</p>
        pub fn set_thing_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RemoveThingFromThingGroupInput`](crate::input::RemoveThingFromThingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RemoveThingFromThingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RemoveThingFromThingGroupInput {
                thing_group_name: self.thing_group_name,
                thing_group_arn: self.thing_group_arn,
                thing_name: self.thing_name,
                thing_arn: self.thing_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type RemoveThingFromThingGroupInputOperationOutputAlias =
    crate::operation::RemoveThingFromThingGroup;
#[doc(hidden)]
pub type RemoveThingFromThingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RemoveThingFromThingGroupInput {
    /// Consumes the builder and constructs an Operation<[`RemoveThingFromThingGroup`](crate::operation::RemoveThingFromThingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RemoveThingFromThingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RemoveThingFromThingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/thing-groups/removeThingFromThingGroup")
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RemoveThingFromThingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_remove_thing_from_thing_group(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RemoveThingFromThingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RemoveThingFromThingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RemoveThingFromThingGroupInput`](crate::input::RemoveThingFromThingGroupInput)
    pub fn builder() -> crate::input::remove_thing_from_thing_group_input::Builder {
        crate::input::remove_thing_from_thing_group_input::Builder::default()
    }
}

/// See [`ReplaceTopicRuleInput`](crate::input::ReplaceTopicRuleInput)
pub mod replace_topic_rule_input {

    /// A builder for [`ReplaceTopicRuleInput`](crate::input::ReplaceTopicRuleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_name: std::option::Option<std::string::String>,
        pub(crate) topic_rule_payload: std::option::Option<crate::model::TopicRulePayload>,
    }
    impl Builder {
        /// <p>The name of the rule.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_name = Some(input.into());
            self
        }
        /// <p>The name of the rule.</p>
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_name = input;
            self
        }
        /// <p>The rule payload.</p>
        pub fn topic_rule_payload(mut self, input: crate::model::TopicRulePayload) -> Self {
            self.topic_rule_payload = Some(input);
            self
        }
        /// <p>The rule payload.</p>
        pub fn set_topic_rule_payload(
            mut self,
            input: std::option::Option<crate::model::TopicRulePayload>,
        ) -> Self {
            self.topic_rule_payload = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplaceTopicRuleInput`](crate::input::ReplaceTopicRuleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ReplaceTopicRuleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ReplaceTopicRuleInput {
                rule_name: self.rule_name,
                topic_rule_payload: self.topic_rule_payload,
            })
        }
    }
}
#[doc(hidden)]
pub type ReplaceTopicRuleInputOperationOutputAlias = crate::operation::ReplaceTopicRule;
#[doc(hidden)]
pub type ReplaceTopicRuleInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ReplaceTopicRuleInput {
    /// Consumes the builder and constructs an Operation<[`ReplaceTopicRule`](crate::operation::ReplaceTopicRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ReplaceTopicRule,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ReplaceTopicRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_322 = &_input.rule_name;
                let input_322 = input_322.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let rule_name = aws_smithy_http::label::fmt_string(input_322, false);
                if rule_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "rule_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/rules/{ruleName}", ruleName = rule_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ReplaceTopicRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_replace_topic_rule_input(
                &self.topic_rule_payload,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ReplaceTopicRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ReplaceTopicRule",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ReplaceTopicRuleInput`](crate::input::ReplaceTopicRuleInput)
    pub fn builder() -> crate::input::replace_topic_rule_input::Builder {
        crate::input::replace_topic_rule_input::Builder::default()
    }
}

/// See [`SearchIndexInput`](crate::input::SearchIndexInput)
pub mod search_index_input {

    /// A builder for [`SearchIndexInput`](crate::input::SearchIndexInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) query_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The search index name.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The search index name.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>The search query string.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The search query string.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The query version.</p>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_version = Some(input.into());
            self
        }
        /// <p>The query version.</p>
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_version = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchIndexInput`](crate::input::SearchIndexInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SearchIndexInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SearchIndexInput {
                index_name: self.index_name,
                query_string: self.query_string,
                next_token: self.next_token,
                max_results: self.max_results,
                query_version: self.query_version,
            })
        }
    }
}
#[doc(hidden)]
pub type SearchIndexInputOperationOutputAlias = crate::operation::SearchIndex;
#[doc(hidden)]
pub type SearchIndexInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl SearchIndexInput {
    /// Consumes the builder and constructs an Operation<[`SearchIndex`](crate::operation::SearchIndex)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchIndex,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::SearchIndexInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/indices/search").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SearchIndexInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_search_index(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchIndex::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchIndex",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`SearchIndexInput`](crate::input::SearchIndexInput)
    pub fn builder() -> crate::input::search_index_input::Builder {
        crate::input::search_index_input::Builder::default()
    }
}

/// See [`SetDefaultAuthorizerInput`](crate::input::SetDefaultAuthorizerInput)
pub mod set_default_authorizer_input {

    /// A builder for [`SetDefaultAuthorizerInput`](crate::input::SetDefaultAuthorizerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authorizer_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The authorizer name.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorizer_name = Some(input.into());
            self
        }
        /// <p>The authorizer name.</p>
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorizer_name = input;
            self
        }
        /// Consumes the builder and constructs a [`SetDefaultAuthorizerInput`](crate::input::SetDefaultAuthorizerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SetDefaultAuthorizerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SetDefaultAuthorizerInput {
                authorizer_name: self.authorizer_name,
            })
        }
    }
}
#[doc(hidden)]
pub type SetDefaultAuthorizerInputOperationOutputAlias = crate::operation::SetDefaultAuthorizer;
#[doc(hidden)]
pub type SetDefaultAuthorizerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl SetDefaultAuthorizerInput {
    /// Consumes the builder and constructs an Operation<[`SetDefaultAuthorizer`](crate::operation::SetDefaultAuthorizer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SetDefaultAuthorizer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::SetDefaultAuthorizerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/default-authorizer").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SetDefaultAuthorizerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_set_default_authorizer(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SetDefaultAuthorizer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SetDefaultAuthorizer",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`SetDefaultAuthorizerInput`](crate::input::SetDefaultAuthorizerInput)
    pub fn builder() -> crate::input::set_default_authorizer_input::Builder {
        crate::input::set_default_authorizer_input::Builder::default()
    }
}

/// See [`SetDefaultPolicyVersionInput`](crate::input::SetDefaultPolicyVersionInput)
pub mod set_default_policy_version_input {

    /// A builder for [`SetDefaultPolicyVersionInput`](crate::input::SetDefaultPolicyVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The policy name.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The policy version ID.</p>
        pub fn policy_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_version_id = Some(input.into());
            self
        }
        /// <p>The policy version ID.</p>
        pub fn set_policy_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SetDefaultPolicyVersionInput`](crate::input::SetDefaultPolicyVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SetDefaultPolicyVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SetDefaultPolicyVersionInput {
                policy_name: self.policy_name,
                policy_version_id: self.policy_version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type SetDefaultPolicyVersionInputOperationOutputAlias =
    crate::operation::SetDefaultPolicyVersion;
#[doc(hidden)]
pub type SetDefaultPolicyVersionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl SetDefaultPolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`SetDefaultPolicyVersion`](crate::operation::SetDefaultPolicyVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SetDefaultPolicyVersion,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::SetDefaultPolicyVersionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_323 = &_input.policy_name;
                let input_323 = input_323.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_name = aws_smithy_http::label::fmt_string(input_323, false);
                if policy_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_name",
                        details: "cannot be empty or unset",
                    });
                }
                let input_324 = &_input.policy_version_id;
                let input_324 = input_324.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_version_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let policy_version_id = aws_smithy_http::label::fmt_string(input_324, false);
                if policy_version_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_version_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/policies/{policyName}/version/{policyVersionId}",
                    policyName = policy_name,
                    policyVersionId = policy_version_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SetDefaultPolicyVersionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SetDefaultPolicyVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SetDefaultPolicyVersion",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`SetDefaultPolicyVersionInput`](crate::input::SetDefaultPolicyVersionInput)
    pub fn builder() -> crate::input::set_default_policy_version_input::Builder {
        crate::input::set_default_policy_version_input::Builder::default()
    }
}

/// See [`SetLoggingOptionsInput`](crate::input::SetLoggingOptionsInput)
pub mod set_logging_options_input {

    /// A builder for [`SetLoggingOptionsInput`](crate::input::SetLoggingOptionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logging_options_payload:
            std::option::Option<crate::model::LoggingOptionsPayload>,
    }
    impl Builder {
        /// <p>The logging options payload.</p>
        pub fn logging_options_payload(
            mut self,
            input: crate::model::LoggingOptionsPayload,
        ) -> Self {
            self.logging_options_payload = Some(input);
            self
        }
        /// <p>The logging options payload.</p>
        pub fn set_logging_options_payload(
            mut self,
            input: std::option::Option<crate::model::LoggingOptionsPayload>,
        ) -> Self {
            self.logging_options_payload = input;
            self
        }
        /// Consumes the builder and constructs a [`SetLoggingOptionsInput`](crate::input::SetLoggingOptionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SetLoggingOptionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SetLoggingOptionsInput {
                logging_options_payload: self.logging_options_payload,
            })
        }
    }
}
#[doc(hidden)]
pub type SetLoggingOptionsInputOperationOutputAlias = crate::operation::SetLoggingOptions;
#[doc(hidden)]
pub type SetLoggingOptionsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl SetLoggingOptionsInput {
    /// Consumes the builder and constructs an Operation<[`SetLoggingOptions`](crate::operation::SetLoggingOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SetLoggingOptions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::SetLoggingOptionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/loggingOptions").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SetLoggingOptionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_set_logging_options_input(
                &self.logging_options_payload,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SetLoggingOptions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SetLoggingOptions",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`SetLoggingOptionsInput`](crate::input::SetLoggingOptionsInput)
    pub fn builder() -> crate::input::set_logging_options_input::Builder {
        crate::input::set_logging_options_input::Builder::default()
    }
}

/// See [`SetV2LoggingLevelInput`](crate::input::SetV2LoggingLevelInput)
pub mod set_v2_logging_level_input {

    /// A builder for [`SetV2LoggingLevelInput`](crate::input::SetV2LoggingLevelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_target: std::option::Option<crate::model::LogTarget>,
        pub(crate) log_level: std::option::Option<crate::model::LogLevel>,
    }
    impl Builder {
        /// <p>The log target.</p>
        pub fn log_target(mut self, input: crate::model::LogTarget) -> Self {
            self.log_target = Some(input);
            self
        }
        /// <p>The log target.</p>
        pub fn set_log_target(
            mut self,
            input: std::option::Option<crate::model::LogTarget>,
        ) -> Self {
            self.log_target = input;
            self
        }
        /// <p>The log level.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>The log level.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.log_level = input;
            self
        }
        /// Consumes the builder and constructs a [`SetV2LoggingLevelInput`](crate::input::SetV2LoggingLevelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SetV2LoggingLevelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SetV2LoggingLevelInput {
                log_target: self.log_target,
                log_level: self.log_level,
            })
        }
    }
}
#[doc(hidden)]
pub type SetV2LoggingLevelInputOperationOutputAlias = crate::operation::SetV2LoggingLevel;
#[doc(hidden)]
pub type SetV2LoggingLevelInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl SetV2LoggingLevelInput {
    /// Consumes the builder and constructs an Operation<[`SetV2LoggingLevel`](crate::operation::SetV2LoggingLevel)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SetV2LoggingLevel,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::SetV2LoggingLevelInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/v2LoggingLevel").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SetV2LoggingLevelInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_set_v2_logging_level(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SetV2LoggingLevel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SetV2LoggingLevel",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`SetV2LoggingLevelInput`](crate::input::SetV2LoggingLevelInput)
    pub fn builder() -> crate::input::set_v2_logging_level_input::Builder {
        crate::input::set_v2_logging_level_input::Builder::default()
    }
}

/// See [`SetV2LoggingOptionsInput`](crate::input::SetV2LoggingOptionsInput)
pub mod set_v2_logging_options_input {

    /// A builder for [`SetV2LoggingOptionsInput`](crate::input::SetV2LoggingOptionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) default_log_level: std::option::Option<crate::model::LogLevel>,
        pub(crate) disable_all_logs: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ARN of the role that allows IoT to write to Cloudwatch logs.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the role that allows IoT to write to Cloudwatch logs.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The default logging level.</p>
        pub fn default_log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.default_log_level = Some(input);
            self
        }
        /// <p>The default logging level.</p>
        pub fn set_default_log_level(
            mut self,
            input: std::option::Option<crate::model::LogLevel>,
        ) -> Self {
            self.default_log_level = input;
            self
        }
        /// <p>If true all logs are disabled. The default is false.</p>
        pub fn disable_all_logs(mut self, input: bool) -> Self {
            self.disable_all_logs = Some(input);
            self
        }
        /// <p>If true all logs are disabled. The default is false.</p>
        pub fn set_disable_all_logs(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_all_logs = input;
            self
        }
        /// Consumes the builder and constructs a [`SetV2LoggingOptionsInput`](crate::input::SetV2LoggingOptionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SetV2LoggingOptionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SetV2LoggingOptionsInput {
                role_arn: self.role_arn,
                default_log_level: self.default_log_level,
                disable_all_logs: self.disable_all_logs.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type SetV2LoggingOptionsInputOperationOutputAlias = crate::operation::SetV2LoggingOptions;
#[doc(hidden)]
pub type SetV2LoggingOptionsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl SetV2LoggingOptionsInput {
    /// Consumes the builder and constructs an Operation<[`SetV2LoggingOptions`](crate::operation::SetV2LoggingOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SetV2LoggingOptions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::SetV2LoggingOptionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/v2LoggingOptions").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SetV2LoggingOptionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_set_v2_logging_options(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SetV2LoggingOptions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SetV2LoggingOptions",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`SetV2LoggingOptionsInput`](crate::input::SetV2LoggingOptionsInput)
    pub fn builder() -> crate::input::set_v2_logging_options_input::Builder {
        crate::input::set_v2_logging_options_input::Builder::default()
    }
}

/// See [`StartAuditMitigationActionsTaskInput`](crate::input::StartAuditMitigationActionsTaskInput)
pub mod start_audit_mitigation_actions_task_input {

    /// A builder for [`StartAuditMitigationActionsTaskInput`](crate::input::StartAuditMitigationActionsTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) target: std::option::Option<crate::model::AuditMitigationActionsTaskTarget>,
        pub(crate) audit_check_to_actions_mapping: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p>Specifies the audit findings to which the mitigation actions are applied. You can apply them to a type of audit check, to all findings from an audit, or to a specific set of findings.</p>
        pub fn target(mut self, input: crate::model::AuditMitigationActionsTaskTarget) -> Self {
            self.target = Some(input);
            self
        }
        /// <p>Specifies the audit findings to which the mitigation actions are applied. You can apply them to a type of audit check, to all findings from an audit, or to a specific set of findings.</p>
        pub fn set_target(
            mut self,
            input: std::option::Option<crate::model::AuditMitigationActionsTaskTarget>,
        ) -> Self {
            self.target = input;
            self
        }
        /// Adds a key-value pair to `audit_check_to_actions_mapping`.
        ///
        /// To override the contents of this collection use [`set_audit_check_to_actions_mapping`](Self::set_audit_check_to_actions_mapping).
        ///
        /// <p>For an audit check, specifies which mitigation actions to apply. Those actions must be defined in your Amazon Web Services accounts.</p>
        pub fn audit_check_to_actions_mapping(
            mut self,
            k: impl Into<std::string::String>,
            v: std::vec::Vec<std::string::String>,
        ) -> Self {
            let mut hash_map = self.audit_check_to_actions_mapping.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.audit_check_to_actions_mapping = Some(hash_map);
            self
        }
        /// <p>For an audit check, specifies which mitigation actions to apply. Those actions must be defined in your Amazon Web Services accounts.</p>
        pub fn set_audit_check_to_actions_mapping(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.audit_check_to_actions_mapping = input;
            self
        }
        /// <p>Each audit mitigation task must have a unique client request token. If you try to start a new task with the same token as a task that already exists, an exception occurs. If you omit this value, a unique client request token is generated automatically.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>Each audit mitigation task must have a unique client request token. If you try to start a new task with the same token as a task that already exists, an exception occurs. If you omit this value, a unique client request token is generated automatically.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`StartAuditMitigationActionsTaskInput`](crate::input::StartAuditMitigationActionsTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartAuditMitigationActionsTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartAuditMitigationActionsTaskInput {
                task_id: self.task_id,
                target: self.target,
                audit_check_to_actions_mapping: self.audit_check_to_actions_mapping,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type StartAuditMitigationActionsTaskInputOperationOutputAlias =
    crate::operation::StartAuditMitigationActionsTask;
#[doc(hidden)]
pub type StartAuditMitigationActionsTaskInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl StartAuditMitigationActionsTaskInput {
    /// Consumes the builder and constructs an Operation<[`StartAuditMitigationActionsTask`](crate::operation::StartAuditMitigationActionsTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartAuditMitigationActionsTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartAuditMitigationActionsTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_325 = &_input.task_id;
                let input_325 = input_325.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let task_id = aws_smithy_http::label::fmt_string(input_325, false);
                if task_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/audit/mitigationactions/tasks/{taskId}",
                    taskId = task_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartAuditMitigationActionsTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_audit_mitigation_actions_task(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartAuditMitigationActionsTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartAuditMitigationActionsTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartAuditMitigationActionsTaskInput`](crate::input::StartAuditMitigationActionsTaskInput)
    pub fn builder() -> crate::input::start_audit_mitigation_actions_task_input::Builder {
        crate::input::start_audit_mitigation_actions_task_input::Builder::default()
    }
}

/// See [`StartDetectMitigationActionsTaskInput`](crate::input::StartDetectMitigationActionsTaskInput)
pub mod start_detect_mitigation_actions_task_input {

    /// A builder for [`StartDetectMitigationActionsTaskInput`](crate::input::StartDetectMitigationActionsTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) target: std::option::Option<crate::model::DetectMitigationActionsTaskTarget>,
        pub(crate) actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) violation_event_occurrence_range:
            std::option::Option<crate::model::ViolationEventOccurrenceRange>,
        pub(crate) include_only_active_violations: std::option::Option<bool>,
        pub(crate) include_suppressed_alerts: std::option::Option<bool>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier of the task. </p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p> The unique identifier of the task. </p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p> Specifies the ML Detect findings to which the mitigation actions are applied. </p>
        pub fn target(mut self, input: crate::model::DetectMitigationActionsTaskTarget) -> Self {
            self.target = Some(input);
            self
        }
        /// <p> Specifies the ML Detect findings to which the mitigation actions are applied. </p>
        pub fn set_target(
            mut self,
            input: std::option::Option<crate::model::DetectMitigationActionsTaskTarget>,
        ) -> Self {
            self.target = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p> The actions to be performed when a device has unexpected behavior. </p>
        pub fn actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input.into());
            self.actions = Some(v);
            self
        }
        /// <p> The actions to be performed when a device has unexpected behavior. </p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// <p> Specifies the time period of which violation events occurred between. </p>
        pub fn violation_event_occurrence_range(
            mut self,
            input: crate::model::ViolationEventOccurrenceRange,
        ) -> Self {
            self.violation_event_occurrence_range = Some(input);
            self
        }
        /// <p> Specifies the time period of which violation events occurred between. </p>
        pub fn set_violation_event_occurrence_range(
            mut self,
            input: std::option::Option<crate::model::ViolationEventOccurrenceRange>,
        ) -> Self {
            self.violation_event_occurrence_range = input;
            self
        }
        /// <p> Specifies to list only active violations. </p>
        pub fn include_only_active_violations(mut self, input: bool) -> Self {
            self.include_only_active_violations = Some(input);
            self
        }
        /// <p> Specifies to list only active violations. </p>
        pub fn set_include_only_active_violations(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.include_only_active_violations = input;
            self
        }
        /// <p> Specifies to include suppressed alerts. </p>
        pub fn include_suppressed_alerts(mut self, input: bool) -> Self {
            self.include_suppressed_alerts = Some(input);
            self
        }
        /// <p> Specifies to include suppressed alerts. </p>
        pub fn set_include_suppressed_alerts(mut self, input: std::option::Option<bool>) -> Self {
            self.include_suppressed_alerts = input;
            self
        }
        /// <p> Each mitigation action task must have a unique client request token. If you try to create a new task with the same token as a task that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request. </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p> Each mitigation action task must have a unique client request token. If you try to create a new task with the same token as a task that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request. </p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`StartDetectMitigationActionsTaskInput`](crate::input::StartDetectMitigationActionsTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartDetectMitigationActionsTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartDetectMitigationActionsTaskInput {
                task_id: self.task_id,
                target: self.target,
                actions: self.actions,
                violation_event_occurrence_range: self.violation_event_occurrence_range,
                include_only_active_violations: self.include_only_active_violations,
                include_suppressed_alerts: self.include_suppressed_alerts,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type StartDetectMitigationActionsTaskInputOperationOutputAlias =
    crate::operation::StartDetectMitigationActionsTask;
#[doc(hidden)]
pub type StartDetectMitigationActionsTaskInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl StartDetectMitigationActionsTaskInput {
    /// Consumes the builder and constructs an Operation<[`StartDetectMitigationActionsTask`](crate::operation::StartDetectMitigationActionsTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartDetectMitigationActionsTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartDetectMitigationActionsTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_326 = &_input.task_id;
                let input_326 = input_326.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let task_id = aws_smithy_http::label::fmt_string(input_326, false);
                if task_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/detect/mitigationactions/tasks/{taskId}",
                    taskId = task_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartDetectMitigationActionsTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_detect_mitigation_actions_task(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartDetectMitigationActionsTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartDetectMitigationActionsTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartDetectMitigationActionsTaskInput`](crate::input::StartDetectMitigationActionsTaskInput)
    pub fn builder() -> crate::input::start_detect_mitigation_actions_task_input::Builder {
        crate::input::start_detect_mitigation_actions_task_input::Builder::default()
    }
}

/// See [`StartOnDemandAuditTaskInput`](crate::input::StartOnDemandAuditTaskInput)
pub mod start_on_demand_audit_task_input {

    /// A builder for [`StartOnDemandAuditTaskInput`](crate::input::StartOnDemandAuditTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_check_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `target_check_names`.
        ///
        /// To override the contents of this collection use [`set_target_check_names`](Self::set_target_check_names).
        ///
        /// <p>Which checks are performed during the audit. The checks you specify must be enabled for your account or an exception occurs. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.</p>
        pub fn target_check_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_check_names.unwrap_or_default();
            v.push(input.into());
            self.target_check_names = Some(v);
            self
        }
        /// <p>Which checks are performed during the audit. The checks you specify must be enabled for your account or an exception occurs. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.</p>
        pub fn set_target_check_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_check_names = input;
            self
        }
        /// Consumes the builder and constructs a [`StartOnDemandAuditTaskInput`](crate::input::StartOnDemandAuditTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartOnDemandAuditTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartOnDemandAuditTaskInput {
                target_check_names: self.target_check_names,
            })
        }
    }
}
#[doc(hidden)]
pub type StartOnDemandAuditTaskInputOperationOutputAlias = crate::operation::StartOnDemandAuditTask;
#[doc(hidden)]
pub type StartOnDemandAuditTaskInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl StartOnDemandAuditTaskInput {
    /// Consumes the builder and constructs an Operation<[`StartOnDemandAuditTask`](crate::operation::StartOnDemandAuditTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartOnDemandAuditTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartOnDemandAuditTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/tasks").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartOnDemandAuditTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_on_demand_audit_task(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartOnDemandAuditTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartOnDemandAuditTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartOnDemandAuditTaskInput`](crate::input::StartOnDemandAuditTaskInput)
    pub fn builder() -> crate::input::start_on_demand_audit_task_input::Builder {
        crate::input::start_on_demand_audit_task_input::Builder::default()
    }
}

/// See [`StartThingRegistrationTaskInput`](crate::input::StartThingRegistrationTaskInput)
pub mod start_thing_registration_task_input {

    /// A builder for [`StartThingRegistrationTaskInput`](crate::input::StartThingRegistrationTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_body: std::option::Option<std::string::String>,
        pub(crate) input_file_bucket: std::option::Option<std::string::String>,
        pub(crate) input_file_key: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The provisioning template.</p>
        pub fn template_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_body = Some(input.into());
            self
        }
        /// <p>The provisioning template.</p>
        pub fn set_template_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_body = input;
            self
        }
        /// <p>The S3 bucket that contains the input file.</p>
        pub fn input_file_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_file_bucket = Some(input.into());
            self
        }
        /// <p>The S3 bucket that contains the input file.</p>
        pub fn set_input_file_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.input_file_bucket = input;
            self
        }
        /// <p>The name of input file within the S3 bucket. This file contains a newline delimited JSON file. Each line contains the parameter values to provision one device (thing).</p>
        pub fn input_file_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_file_key = Some(input.into());
            self
        }
        /// <p>The name of input file within the S3 bucket. This file contains a newline delimited JSON file. Each line contains the parameter values to provision one device (thing).</p>
        pub fn set_input_file_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.input_file_key = input;
            self
        }
        /// <p>The IAM role ARN that grants permission the input file.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The IAM role ARN that grants permission the input file.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`StartThingRegistrationTaskInput`](crate::input::StartThingRegistrationTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartThingRegistrationTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartThingRegistrationTaskInput {
                template_body: self.template_body,
                input_file_bucket: self.input_file_bucket,
                input_file_key: self.input_file_key,
                role_arn: self.role_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type StartThingRegistrationTaskInputOperationOutputAlias =
    crate::operation::StartThingRegistrationTask;
#[doc(hidden)]
pub type StartThingRegistrationTaskInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl StartThingRegistrationTaskInput {
    /// Consumes the builder and constructs an Operation<[`StartThingRegistrationTask`](crate::operation::StartThingRegistrationTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartThingRegistrationTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartThingRegistrationTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/thing-registration-tasks").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartThingRegistrationTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_thing_registration_task(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartThingRegistrationTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartThingRegistrationTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartThingRegistrationTaskInput`](crate::input::StartThingRegistrationTaskInput)
    pub fn builder() -> crate::input::start_thing_registration_task_input::Builder {
        crate::input::start_thing_registration_task_input::Builder::default()
    }
}

/// See [`StopThingRegistrationTaskInput`](crate::input::StopThingRegistrationTaskInput)
pub mod stop_thing_registration_task_input {

    /// A builder for [`StopThingRegistrationTaskInput`](crate::input::StopThingRegistrationTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bulk thing provisioning task ID.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The bulk thing provisioning task ID.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopThingRegistrationTaskInput`](crate::input::StopThingRegistrationTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StopThingRegistrationTaskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StopThingRegistrationTaskInput {
                task_id: self.task_id,
            })
        }
    }
}
#[doc(hidden)]
pub type StopThingRegistrationTaskInputOperationOutputAlias =
    crate::operation::StopThingRegistrationTask;
#[doc(hidden)]
pub type StopThingRegistrationTaskInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl StopThingRegistrationTaskInput {
    /// Consumes the builder and constructs an Operation<[`StopThingRegistrationTask`](crate::operation::StopThingRegistrationTask)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopThingRegistrationTask,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::StopThingRegistrationTaskInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_327 = &_input.task_id;
                let input_327 = input_327.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let task_id = aws_smithy_http::label::fmt_string(input_327, false);
                if task_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "task_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-registration-tasks/{taskId}/cancel",
                    taskId = task_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StopThingRegistrationTaskInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopThingRegistrationTask::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopThingRegistrationTask",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StopThingRegistrationTaskInput`](crate::input::StopThingRegistrationTaskInput)
    pub fn builder() -> crate::input::stop_thing_registration_task_input::Builder {
        crate::input::stop_thing_registration_task_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {

    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The new or modified tags for the resource.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The new or modified tags for the resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/tags").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`TestAuthorizationInput`](crate::input::TestAuthorizationInput)
pub mod test_authorization_input {

    /// A builder for [`TestAuthorizationInput`](crate::input::TestAuthorizationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal: std::option::Option<std::string::String>,
        pub(crate) cognito_identity_pool_id: std::option::Option<std::string::String>,
        pub(crate) auth_infos: std::option::Option<std::vec::Vec<crate::model::AuthInfo>>,
        pub(crate) client_id: std::option::Option<std::string::String>,
        pub(crate) policy_names_to_add: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) policy_names_to_skip: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal = Some(input.into());
            self
        }
        /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal = input;
            self
        }
        /// <p>The Cognito identity pool ID.</p>
        pub fn cognito_identity_pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.cognito_identity_pool_id = Some(input.into());
            self
        }
        /// <p>The Cognito identity pool ID.</p>
        pub fn set_cognito_identity_pool_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cognito_identity_pool_id = input;
            self
        }
        /// Appends an item to `auth_infos`.
        ///
        /// To override the contents of this collection use [`set_auth_infos`](Self::set_auth_infos).
        ///
        /// <p>A list of authorization info objects. Simulating authorization will create a response for each <code>authInfo</code> object in the list.</p>
        pub fn auth_infos(mut self, input: crate::model::AuthInfo) -> Self {
            let mut v = self.auth_infos.unwrap_or_default();
            v.push(input);
            self.auth_infos = Some(v);
            self
        }
        /// <p>A list of authorization info objects. Simulating authorization will create a response for each <code>authInfo</code> object in the list.</p>
        pub fn set_auth_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AuthInfo>>,
        ) -> Self {
            self.auth_infos = input;
            self
        }
        /// <p>The MQTT client ID.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_id = Some(input.into());
            self
        }
        /// <p>The MQTT client ID.</p>
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_id = input;
            self
        }
        /// Appends an item to `policy_names_to_add`.
        ///
        /// To override the contents of this collection use [`set_policy_names_to_add`](Self::set_policy_names_to_add).
        ///
        /// <p>When testing custom authorization, the policies specified here are treated as if they are attached to the principal being authorized.</p>
        pub fn policy_names_to_add(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.policy_names_to_add.unwrap_or_default();
            v.push(input.into());
            self.policy_names_to_add = Some(v);
            self
        }
        /// <p>When testing custom authorization, the policies specified here are treated as if they are attached to the principal being authorized.</p>
        pub fn set_policy_names_to_add(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.policy_names_to_add = input;
            self
        }
        /// Appends an item to `policy_names_to_skip`.
        ///
        /// To override the contents of this collection use [`set_policy_names_to_skip`](Self::set_policy_names_to_skip).
        ///
        /// <p>When testing custom authorization, the policies specified here are treated as if they are not attached to the principal being authorized.</p>
        pub fn policy_names_to_skip(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.policy_names_to_skip.unwrap_or_default();
            v.push(input.into());
            self.policy_names_to_skip = Some(v);
            self
        }
        /// <p>When testing custom authorization, the policies specified here are treated as if they are not attached to the principal being authorized.</p>
        pub fn set_policy_names_to_skip(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.policy_names_to_skip = input;
            self
        }
        /// Consumes the builder and constructs a [`TestAuthorizationInput`](crate::input::TestAuthorizationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TestAuthorizationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TestAuthorizationInput {
                principal: self.principal,
                cognito_identity_pool_id: self.cognito_identity_pool_id,
                auth_infos: self.auth_infos,
                client_id: self.client_id,
                policy_names_to_add: self.policy_names_to_add,
                policy_names_to_skip: self.policy_names_to_skip,
            })
        }
    }
}
#[doc(hidden)]
pub type TestAuthorizationInputOperationOutputAlias = crate::operation::TestAuthorization;
#[doc(hidden)]
pub type TestAuthorizationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl TestAuthorizationInput {
    /// Consumes the builder and constructs an Operation<[`TestAuthorization`](crate::operation::TestAuthorization)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TestAuthorization,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::TestAuthorizationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/test-authorization").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::TestAuthorizationInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_328) = &_input.client_id {
                    query.push_kv("clientId", &aws_smithy_http::query::fmt_string(&inner_328));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TestAuthorizationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_test_authorization(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TestAuthorization::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TestAuthorization",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TestAuthorizationInput`](crate::input::TestAuthorizationInput)
    pub fn builder() -> crate::input::test_authorization_input::Builder {
        crate::input::test_authorization_input::Builder::default()
    }
}

/// See [`TestInvokeAuthorizerInput`](crate::input::TestInvokeAuthorizerInput)
pub mod test_invoke_authorizer_input {

    /// A builder for [`TestInvokeAuthorizerInput`](crate::input::TestInvokeAuthorizerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authorizer_name: std::option::Option<std::string::String>,
        pub(crate) token: std::option::Option<std::string::String>,
        pub(crate) token_signature: std::option::Option<std::string::String>,
        pub(crate) http_context: std::option::Option<crate::model::HttpContext>,
        pub(crate) mqtt_context: std::option::Option<crate::model::MqttContext>,
        pub(crate) tls_context: std::option::Option<crate::model::TlsContext>,
    }
    impl Builder {
        /// <p>The custom authorizer name.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorizer_name = Some(input.into());
            self
        }
        /// <p>The custom authorizer name.</p>
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorizer_name = input;
            self
        }
        /// <p>The token returned by your custom authentication service.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.token = Some(input.into());
            self
        }
        /// <p>The token returned by your custom authentication service.</p>
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token = input;
            self
        }
        /// <p>The signature made with the token and your custom authentication service's private key. This value must be Base-64-encoded.</p>
        pub fn token_signature(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_signature = Some(input.into());
            self
        }
        /// <p>The signature made with the token and your custom authentication service's private key. This value must be Base-64-encoded.</p>
        pub fn set_token_signature(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.token_signature = input;
            self
        }
        /// <p>Specifies a test HTTP authorization request.</p>
        pub fn http_context(mut self, input: crate::model::HttpContext) -> Self {
            self.http_context = Some(input);
            self
        }
        /// <p>Specifies a test HTTP authorization request.</p>
        pub fn set_http_context(
            mut self,
            input: std::option::Option<crate::model::HttpContext>,
        ) -> Self {
            self.http_context = input;
            self
        }
        /// <p>Specifies a test MQTT authorization request.</p>
        pub fn mqtt_context(mut self, input: crate::model::MqttContext) -> Self {
            self.mqtt_context = Some(input);
            self
        }
        /// <p>Specifies a test MQTT authorization request.</p>
        pub fn set_mqtt_context(
            mut self,
            input: std::option::Option<crate::model::MqttContext>,
        ) -> Self {
            self.mqtt_context = input;
            self
        }
        /// <p>Specifies a test TLS authorization request.</p>
        pub fn tls_context(mut self, input: crate::model::TlsContext) -> Self {
            self.tls_context = Some(input);
            self
        }
        /// <p>Specifies a test TLS authorization request.</p>
        pub fn set_tls_context(
            mut self,
            input: std::option::Option<crate::model::TlsContext>,
        ) -> Self {
            self.tls_context = input;
            self
        }
        /// Consumes the builder and constructs a [`TestInvokeAuthorizerInput`](crate::input::TestInvokeAuthorizerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TestInvokeAuthorizerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TestInvokeAuthorizerInput {
                authorizer_name: self.authorizer_name,
                token: self.token,
                token_signature: self.token_signature,
                http_context: self.http_context,
                mqtt_context: self.mqtt_context,
                tls_context: self.tls_context,
            })
        }
    }
}
#[doc(hidden)]
pub type TestInvokeAuthorizerInputOperationOutputAlias = crate::operation::TestInvokeAuthorizer;
#[doc(hidden)]
pub type TestInvokeAuthorizerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl TestInvokeAuthorizerInput {
    /// Consumes the builder and constructs an Operation<[`TestInvokeAuthorizer`](crate::operation::TestInvokeAuthorizer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TestInvokeAuthorizer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::TestInvokeAuthorizerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_329 = &_input.authorizer_name;
                let input_329 = input_329.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "authorizer_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let authorizer_name = aws_smithy_http::label::fmt_string(input_329, false);
                if authorizer_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "authorizer_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/authorizer/{authorizerName}/test",
                    authorizerName = authorizer_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TestInvokeAuthorizerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_test_invoke_authorizer(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TestInvokeAuthorizer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TestInvokeAuthorizer",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TestInvokeAuthorizerInput`](crate::input::TestInvokeAuthorizerInput)
    pub fn builder() -> crate::input::test_invoke_authorizer_input::Builder {
        crate::input::test_invoke_authorizer_input::Builder::default()
    }
}

/// See [`TransferCertificateInput`](crate::input::TransferCertificateInput)
pub mod transfer_certificate_input {

    /// A builder for [`TransferCertificateInput`](crate::input::TransferCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_id: std::option::Option<std::string::String>,
        pub(crate) target_aws_account: std::option::Option<std::string::String>,
        pub(crate) transfer_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(input.into());
            self
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_id = input;
            self
        }
        /// <p>The Amazon Web Services account.</p>
        pub fn target_aws_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_aws_account = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account.</p>
        pub fn set_target_aws_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_aws_account = input;
            self
        }
        /// <p>The transfer message.</p>
        pub fn transfer_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.transfer_message = Some(input.into());
            self
        }
        /// <p>The transfer message.</p>
        pub fn set_transfer_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transfer_message = input;
            self
        }
        /// Consumes the builder and constructs a [`TransferCertificateInput`](crate::input::TransferCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TransferCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TransferCertificateInput {
                certificate_id: self.certificate_id,
                target_aws_account: self.target_aws_account,
                transfer_message: self.transfer_message,
            })
        }
    }
}
#[doc(hidden)]
pub type TransferCertificateInputOperationOutputAlias = crate::operation::TransferCertificate;
#[doc(hidden)]
pub type TransferCertificateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl TransferCertificateInput {
    /// Consumes the builder and constructs an Operation<[`TransferCertificate`](crate::operation::TransferCertificate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TransferCertificate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::TransferCertificateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_330 = &_input.certificate_id;
                let input_330 = input_330.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let certificate_id = aws_smithy_http::label::fmt_string(input_330, false);
                if certificate_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/transfer-certificate/{certificateId}",
                    certificateId = certificate_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::TransferCertificateInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_331) = &_input.target_aws_account {
                    query.push_kv(
                        "targetAwsAccount",
                        &aws_smithy_http::query::fmt_string(&inner_331),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TransferCertificateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_transfer_certificate(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TransferCertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TransferCertificate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TransferCertificateInput`](crate::input::TransferCertificateInput)
    pub fn builder() -> crate::input::transfer_certificate_input::Builder {
        crate::input::transfer_certificate_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {

    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>A list of the keys of the tags to be removed from the resource.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>A list of the keys of the tags to be removed from the resource.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/untag").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_untag_resource(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateAccountAuditConfigurationInput`](crate::input::UpdateAccountAuditConfigurationInput)
pub mod update_account_audit_configuration_input {

    /// A builder for [`UpdateAccountAuditConfigurationInput`](crate::input::UpdateAccountAuditConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) audit_notification_target_configurations: std::option::Option<
            std::collections::HashMap<
                crate::model::AuditNotificationType,
                crate::model::AuditNotificationTarget,
            >,
        >,
        pub(crate) audit_check_configurations: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AuditCheckConfiguration>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the role that grants permission to IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the role that grants permission to IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Adds a key-value pair to `audit_notification_target_configurations`.
        ///
        /// To override the contents of this collection use [`set_audit_notification_target_configurations`](Self::set_audit_notification_target_configurations).
        ///
        /// <p>Information about the targets to which audit notifications are sent.</p>
        pub fn audit_notification_target_configurations(
            mut self,
            k: crate::model::AuditNotificationType,
            v: crate::model::AuditNotificationTarget,
        ) -> Self {
            let mut hash_map = self
                .audit_notification_target_configurations
                .unwrap_or_default();
            hash_map.insert(k, v);
            self.audit_notification_target_configurations = Some(hash_map);
            self
        }
        /// <p>Information about the targets to which audit notifications are sent.</p>
        pub fn set_audit_notification_target_configurations(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::AuditNotificationType,
                    crate::model::AuditNotificationTarget,
                >,
            >,
        ) -> Self {
            self.audit_notification_target_configurations = input;
            self
        }
        /// Adds a key-value pair to `audit_check_configurations`.
        ///
        /// To override the contents of this collection use [`set_audit_check_configurations`](Self::set_audit_check_configurations).
        ///
        /// <p>Specifies which audit checks are enabled and disabled for this account. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are currently enabled.</p>
        /// <p>Some data collection might start immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted.</p>
        /// <p>You cannot disable a check if it's used by any scheduled audit. You must first delete the check from the scheduled audit or delete the scheduled audit itself.</p>
        /// <p>On the first call to <code>UpdateAccountAuditConfiguration</code>, this parameter is required and must specify at least one enabled check.</p>
        pub fn audit_check_configurations(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::AuditCheckConfiguration,
        ) -> Self {
            let mut hash_map = self.audit_check_configurations.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.audit_check_configurations = Some(hash_map);
            self
        }
        /// <p>Specifies which audit checks are enabled and disabled for this account. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are currently enabled.</p>
        /// <p>Some data collection might start immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted.</p>
        /// <p>You cannot disable a check if it's used by any scheduled audit. You must first delete the check from the scheduled audit or delete the scheduled audit itself.</p>
        /// <p>On the first call to <code>UpdateAccountAuditConfiguration</code>, this parameter is required and must specify at least one enabled check.</p>
        pub fn set_audit_check_configurations(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::AuditCheckConfiguration,
                >,
            >,
        ) -> Self {
            self.audit_check_configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAccountAuditConfigurationInput`](crate::input::UpdateAccountAuditConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateAccountAuditConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateAccountAuditConfigurationInput {
                role_arn: self.role_arn,
                audit_notification_target_configurations: self
                    .audit_notification_target_configurations,
                audit_check_configurations: self.audit_check_configurations,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateAccountAuditConfigurationInputOperationOutputAlias =
    crate::operation::UpdateAccountAuditConfiguration;
#[doc(hidden)]
pub type UpdateAccountAuditConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl UpdateAccountAuditConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAccountAuditConfiguration`](crate::operation::UpdateAccountAuditConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAccountAuditConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAccountAuditConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/configuration").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAccountAuditConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_account_audit_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAccountAuditConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAccountAuditConfiguration",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAccountAuditConfigurationInput`](crate::input::UpdateAccountAuditConfigurationInput)
    pub fn builder() -> crate::input::update_account_audit_configuration_input::Builder {
        crate::input::update_account_audit_configuration_input::Builder::default()
    }
}

/// See [`UpdateAuditSuppressionInput`](crate::input::UpdateAuditSuppressionInput)
pub mod update_audit_suppression_input {

    /// A builder for [`UpdateAuditSuppressionInput`](crate::input::UpdateAuditSuppressionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) check_name: std::option::Option<std::string::String>,
        pub(crate) resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
        pub(crate) expiration_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) suppress_indefinitely: std::option::Option<bool>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.check_name = Some(input.into());
            self
        }
        /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.check_name = input;
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.resource_identifier = Some(input);
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.resource_identifier = input;
            self
        }
        /// <p> The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to. </p>
        pub fn expiration_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expiration_date = Some(input);
            self
        }
        /// <p> The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to. </p>
        pub fn set_expiration_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expiration_date = input;
            self
        }
        /// <p> Indicates whether a suppression should exist indefinitely or not. </p>
        pub fn suppress_indefinitely(mut self, input: bool) -> Self {
            self.suppress_indefinitely = Some(input);
            self
        }
        /// <p> Indicates whether a suppression should exist indefinitely or not. </p>
        pub fn set_suppress_indefinitely(mut self, input: std::option::Option<bool>) -> Self {
            self.suppress_indefinitely = input;
            self
        }
        /// <p> The description of the audit suppression. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The description of the audit suppression. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAuditSuppressionInput`](crate::input::UpdateAuditSuppressionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateAuditSuppressionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateAuditSuppressionInput {
                check_name: self.check_name,
                resource_identifier: self.resource_identifier,
                expiration_date: self.expiration_date,
                suppress_indefinitely: self.suppress_indefinitely,
                description: self.description,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateAuditSuppressionInputOperationOutputAlias = crate::operation::UpdateAuditSuppression;
#[doc(hidden)]
pub type UpdateAuditSuppressionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateAuditSuppressionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAuditSuppression`](crate::operation::UpdateAuditSuppression)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAuditSuppression,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAuditSuppressionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/audit/suppressions/update").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAuditSuppressionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_audit_suppression(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAuditSuppression::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAuditSuppression",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAuditSuppressionInput`](crate::input::UpdateAuditSuppressionInput)
    pub fn builder() -> crate::input::update_audit_suppression_input::Builder {
        crate::input::update_audit_suppression_input::Builder::default()
    }
}

/// See [`UpdateAuthorizerInput`](crate::input::UpdateAuthorizerInput)
pub mod update_authorizer_input {

    /// A builder for [`UpdateAuthorizerInput`](crate::input::UpdateAuthorizerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authorizer_name: std::option::Option<std::string::String>,
        pub(crate) authorizer_function_arn: std::option::Option<std::string::String>,
        pub(crate) token_key_name: std::option::Option<std::string::String>,
        pub(crate) token_signing_public_keys: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) status: std::option::Option<crate::model::AuthorizerStatus>,
        pub(crate) enable_caching_for_http: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The authorizer name.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorizer_name = Some(input.into());
            self
        }
        /// <p>The authorizer name.</p>
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorizer_name = input;
            self
        }
        /// <p>The ARN of the authorizer's Lambda function.</p>
        pub fn authorizer_function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorizer_function_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the authorizer's Lambda function.</p>
        pub fn set_authorizer_function_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorizer_function_arn = input;
            self
        }
        /// <p>The key used to extract the token from the HTTP headers. </p>
        pub fn token_key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_key_name = Some(input.into());
            self
        }
        /// <p>The key used to extract the token from the HTTP headers. </p>
        pub fn set_token_key_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.token_key_name = input;
            self
        }
        /// Adds a key-value pair to `token_signing_public_keys`.
        ///
        /// To override the contents of this collection use [`set_token_signing_public_keys`](Self::set_token_signing_public_keys).
        ///
        /// <p>The public keys used to verify the token signature.</p>
        pub fn token_signing_public_keys(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.token_signing_public_keys.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.token_signing_public_keys = Some(hash_map);
            self
        }
        /// <p>The public keys used to verify the token signature.</p>
        pub fn set_token_signing_public_keys(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.token_signing_public_keys = input;
            self
        }
        /// <p>The status of the update authorizer request.</p>
        pub fn status(mut self, input: crate::model::AuthorizerStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the update authorizer request.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AuthorizerStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When <code>true</code>, the result from the authorizers Lambda function is cached for the time specified in <code>refreshAfterInSeconds</code>. The cached result is used while the device reuses the same HTTP connection.</p>
        pub fn enable_caching_for_http(mut self, input: bool) -> Self {
            self.enable_caching_for_http = Some(input);
            self
        }
        /// <p>When <code>true</code>, the result from the authorizers Lambda function is cached for the time specified in <code>refreshAfterInSeconds</code>. The cached result is used while the device reuses the same HTTP connection.</p>
        pub fn set_enable_caching_for_http(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_caching_for_http = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAuthorizerInput`](crate::input::UpdateAuthorizerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateAuthorizerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateAuthorizerInput {
                authorizer_name: self.authorizer_name,
                authorizer_function_arn: self.authorizer_function_arn,
                token_key_name: self.token_key_name,
                token_signing_public_keys: self.token_signing_public_keys,
                status: self.status,
                enable_caching_for_http: self.enable_caching_for_http,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateAuthorizerInputOperationOutputAlias = crate::operation::UpdateAuthorizer;
#[doc(hidden)]
pub type UpdateAuthorizerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateAuthorizerInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAuthorizer`](crate::operation::UpdateAuthorizer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAuthorizer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAuthorizerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_332 = &_input.authorizer_name;
                let input_332 = input_332.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "authorizer_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let authorizer_name = aws_smithy_http::label::fmt_string(input_332, false);
                if authorizer_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "authorizer_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/authorizer/{authorizerName}",
                    authorizerName = authorizer_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAuthorizerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_authorizer(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAuthorizer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAuthorizer",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAuthorizerInput`](crate::input::UpdateAuthorizerInput)
    pub fn builder() -> crate::input::update_authorizer_input::Builder {
        crate::input::update_authorizer_input::Builder::default()
    }
}

/// See [`UpdateBillingGroupInput`](crate::input::UpdateBillingGroupInput)
pub mod update_billing_group_input {

    /// A builder for [`UpdateBillingGroupInput`](crate::input::UpdateBillingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_group_name: std::option::Option<std::string::String>,
        pub(crate) billing_group_properties:
            std::option::Option<crate::model::BillingGroupProperties>,
        pub(crate) expected_version: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the billing group.</p>
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_name = input;
            self
        }
        /// <p>The properties of the billing group.</p>
        pub fn billing_group_properties(
            mut self,
            input: crate::model::BillingGroupProperties,
        ) -> Self {
            self.billing_group_properties = Some(input);
            self
        }
        /// <p>The properties of the billing group.</p>
        pub fn set_billing_group_properties(
            mut self,
            input: std::option::Option<crate::model::BillingGroupProperties>,
        ) -> Self {
            self.billing_group_properties = input;
            self
        }
        /// <p>The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>UpdateBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>UpdateBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateBillingGroupInput`](crate::input::UpdateBillingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateBillingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateBillingGroupInput {
                billing_group_name: self.billing_group_name,
                billing_group_properties: self.billing_group_properties,
                expected_version: self.expected_version,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateBillingGroupInputOperationOutputAlias = crate::operation::UpdateBillingGroup;
#[doc(hidden)]
pub type UpdateBillingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateBillingGroupInput {
    /// Consumes the builder and constructs an Operation<[`UpdateBillingGroup`](crate::operation::UpdateBillingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateBillingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateBillingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_333 = &_input.billing_group_name;
                let input_333 = input_333.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "billing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let billing_group_name = aws_smithy_http::label::fmt_string(input_333, false);
                if billing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "billing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/billing-groups/{billingGroupName}",
                    billingGroupName = billing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateBillingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_billing_group(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateBillingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateBillingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateBillingGroupInput`](crate::input::UpdateBillingGroupInput)
    pub fn builder() -> crate::input::update_billing_group_input::Builder {
        crate::input::update_billing_group_input::Builder::default()
    }
}

/// See [`UpdateCaCertificateInput`](crate::input::UpdateCaCertificateInput)
pub mod update_ca_certificate_input {

    /// A builder for [`UpdateCaCertificateInput`](crate::input::UpdateCaCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_id: std::option::Option<std::string::String>,
        pub(crate) new_status: std::option::Option<crate::model::CaCertificateStatus>,
        pub(crate) new_auto_registration_status:
            std::option::Option<crate::model::AutoRegistrationStatus>,
        pub(crate) registration_config: std::option::Option<crate::model::RegistrationConfig>,
        pub(crate) remove_auto_registration: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The CA certificate identifier.</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(input.into());
            self
        }
        /// <p>The CA certificate identifier.</p>
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_id = input;
            self
        }
        /// <p>The updated status of the CA certificate.</p>
        /// <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
        pub fn new_status(mut self, input: crate::model::CaCertificateStatus) -> Self {
            self.new_status = Some(input);
            self
        }
        /// <p>The updated status of the CA certificate.</p>
        /// <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
        pub fn set_new_status(
            mut self,
            input: std::option::Option<crate::model::CaCertificateStatus>,
        ) -> Self {
            self.new_status = input;
            self
        }
        /// <p>The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".</p>
        pub fn new_auto_registration_status(
            mut self,
            input: crate::model::AutoRegistrationStatus,
        ) -> Self {
            self.new_auto_registration_status = Some(input);
            self
        }
        /// <p>The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".</p>
        pub fn set_new_auto_registration_status(
            mut self,
            input: std::option::Option<crate::model::AutoRegistrationStatus>,
        ) -> Self {
            self.new_auto_registration_status = input;
            self
        }
        /// <p>Information about the registration configuration.</p>
        pub fn registration_config(mut self, input: crate::model::RegistrationConfig) -> Self {
            self.registration_config = Some(input);
            self
        }
        /// <p>Information about the registration configuration.</p>
        pub fn set_registration_config(
            mut self,
            input: std::option::Option<crate::model::RegistrationConfig>,
        ) -> Self {
            self.registration_config = input;
            self
        }
        /// <p>If true, removes auto registration.</p>
        pub fn remove_auto_registration(mut self, input: bool) -> Self {
            self.remove_auto_registration = Some(input);
            self
        }
        /// <p>If true, removes auto registration.</p>
        pub fn set_remove_auto_registration(mut self, input: std::option::Option<bool>) -> Self {
            self.remove_auto_registration = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCaCertificateInput`](crate::input::UpdateCaCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateCaCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateCaCertificateInput {
                certificate_id: self.certificate_id,
                new_status: self.new_status,
                new_auto_registration_status: self.new_auto_registration_status,
                registration_config: self.registration_config,
                remove_auto_registration: self.remove_auto_registration.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateCaCertificateInputOperationOutputAlias = crate::operation::UpdateCACertificate;
#[doc(hidden)]
pub type UpdateCaCertificateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateCaCertificateInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCACertificate`](crate::operation::UpdateCACertificate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateCACertificate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateCaCertificateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_334 = &_input.certificate_id;
                let input_334 = input_334.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let certificate_id = aws_smithy_http::label::fmt_string(input_334, false);
                if certificate_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/cacertificate/{certificateId}",
                    certificateId = certificate_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UpdateCaCertificateInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_335) = &_input.new_status {
                    query.push_kv("newStatus", &aws_smithy_http::query::fmt_string(&inner_335));
                }
                if let Some(inner_336) = &_input.new_auto_registration_status {
                    query.push_kv(
                        "newAutoRegistrationStatus",
                        &aws_smithy_http::query::fmt_string(&inner_336),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateCaCertificateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_ca_certificate(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateCACertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateCACertificate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateCaCertificateInput`](crate::input::UpdateCaCertificateInput)
    pub fn builder() -> crate::input::update_ca_certificate_input::Builder {
        crate::input::update_ca_certificate_input::Builder::default()
    }
}

/// See [`UpdateCertificateInput`](crate::input::UpdateCertificateInput)
pub mod update_certificate_input {

    /// A builder for [`UpdateCertificateInput`](crate::input::UpdateCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_id: std::option::Option<std::string::String>,
        pub(crate) new_status: std::option::Option<crate::model::CertificateStatus>,
    }
    impl Builder {
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_id = Some(input.into());
            self
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_id = input;
            self
        }
        /// <p>The new status.</p>
        /// <p> <b>Note:</b> Setting the status to PENDING_TRANSFER or PENDING_ACTIVATION will result in an exception being thrown. PENDING_TRANSFER and PENDING_ACTIVATION are statuses used internally by IoT. They are not intended for developer use.</p>
        /// <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
        pub fn new_status(mut self, input: crate::model::CertificateStatus) -> Self {
            self.new_status = Some(input);
            self
        }
        /// <p>The new status.</p>
        /// <p> <b>Note:</b> Setting the status to PENDING_TRANSFER or PENDING_ACTIVATION will result in an exception being thrown. PENDING_TRANSFER and PENDING_ACTIVATION are statuses used internally by IoT. They are not intended for developer use.</p>
        /// <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
        pub fn set_new_status(
            mut self,
            input: std::option::Option<crate::model::CertificateStatus>,
        ) -> Self {
            self.new_status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCertificateInput`](crate::input::UpdateCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateCertificateInput {
                certificate_id: self.certificate_id,
                new_status: self.new_status,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateCertificateInputOperationOutputAlias = crate::operation::UpdateCertificate;
#[doc(hidden)]
pub type UpdateCertificateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateCertificateInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCertificate`](crate::operation::UpdateCertificate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateCertificate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateCertificateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_337 = &_input.certificate_id;
                let input_337 = input_337.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let certificate_id = aws_smithy_http::label::fmt_string(input_337, false);
                if certificate_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "certificate_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/certificates/{certificateId}",
                    certificateId = certificate_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UpdateCertificateInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_338) = &_input.new_status {
                    query.push_kv("newStatus", &aws_smithy_http::query::fmt_string(&inner_338));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateCertificateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateCertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateCertificate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateCertificateInput`](crate::input::UpdateCertificateInput)
    pub fn builder() -> crate::input::update_certificate_input::Builder {
        crate::input::update_certificate_input::Builder::default()
    }
}

/// See [`UpdateCustomMetricInput`](crate::input::UpdateCustomMetricInput)
pub mod update_custom_metric_input {

    /// A builder for [`UpdateCustomMetricInput`](crate::input::UpdateCustomMetricInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the custom metric. Cannot be updated. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p> The name of the custom metric. Cannot be updated. </p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p> Field represents a friendly name in the console for the custom metric, it doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. Can be updated. </p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p> Field represents a friendly name in the console for the custom metric, it doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. Can be updated. </p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCustomMetricInput`](crate::input::UpdateCustomMetricInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateCustomMetricInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateCustomMetricInput {
                metric_name: self.metric_name,
                display_name: self.display_name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateCustomMetricInputOperationOutputAlias = crate::operation::UpdateCustomMetric;
#[doc(hidden)]
pub type UpdateCustomMetricInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateCustomMetricInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCustomMetric`](crate::operation::UpdateCustomMetric)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateCustomMetric,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateCustomMetricInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_339 = &_input.metric_name;
                let input_339 = input_339.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let metric_name = aws_smithy_http::label::fmt_string(input_339, false);
                if metric_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/custom-metric/{metricName}",
                    metricName = metric_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateCustomMetricInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_custom_metric(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateCustomMetric::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateCustomMetric",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateCustomMetricInput`](crate::input::UpdateCustomMetricInput)
    pub fn builder() -> crate::input::update_custom_metric_input::Builder {
        crate::input::update_custom_metric_input::Builder::default()
    }
}

/// See [`UpdateDimensionInput`](crate::input::UpdateDimensionInput)
pub mod update_dimension_input {

    /// A builder for [`UpdateDimensionInput`](crate::input::UpdateDimensionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) string_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `string_values`.
        ///
        /// To override the contents of this collection use [`set_string_values`](Self::set_string_values).
        ///
        /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
        pub fn string_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.string_values.unwrap_or_default();
            v.push(input.into());
            self.string_values = Some(v);
            self
        }
        /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
        pub fn set_string_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.string_values = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateDimensionInput`](crate::input::UpdateDimensionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateDimensionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateDimensionInput {
                name: self.name,
                string_values: self.string_values,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateDimensionInputOperationOutputAlias = crate::operation::UpdateDimension;
#[doc(hidden)]
pub type UpdateDimensionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateDimensionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDimension`](crate::operation::UpdateDimension)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateDimension,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateDimensionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_340 = &_input.name;
                let input_340 = input_340.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let name = aws_smithy_http::label::fmt_string(input_340, false);
                if name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/dimensions/{name}", name = name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateDimensionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_dimension(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateDimension::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateDimension",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateDimensionInput`](crate::input::UpdateDimensionInput)
    pub fn builder() -> crate::input::update_dimension_input::Builder {
        crate::input::update_dimension_input::Builder::default()
    }
}

/// See [`UpdateDomainConfigurationInput`](crate::input::UpdateDomainConfigurationInput)
pub mod update_domain_configuration_input {

    /// A builder for [`UpdateDomainConfigurationInput`](crate::input::UpdateDomainConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_configuration_name: std::option::Option<std::string::String>,
        pub(crate) authorizer_config: std::option::Option<crate::model::AuthorizerConfig>,
        pub(crate) domain_configuration_status:
            std::option::Option<crate::model::DomainConfigurationStatus>,
        pub(crate) remove_authorizer_config: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the domain configuration to be updated.</p>
        pub fn domain_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_configuration_name = Some(input.into());
            self
        }
        /// <p>The name of the domain configuration to be updated.</p>
        pub fn set_domain_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.domain_configuration_name = input;
            self
        }
        /// <p>An object that specifies the authorization service for a domain.</p>
        pub fn authorizer_config(mut self, input: crate::model::AuthorizerConfig) -> Self {
            self.authorizer_config = Some(input);
            self
        }
        /// <p>An object that specifies the authorization service for a domain.</p>
        pub fn set_authorizer_config(
            mut self,
            input: std::option::Option<crate::model::AuthorizerConfig>,
        ) -> Self {
            self.authorizer_config = input;
            self
        }
        /// <p>The status to which the domain configuration should be updated.</p>
        pub fn domain_configuration_status(
            mut self,
            input: crate::model::DomainConfigurationStatus,
        ) -> Self {
            self.domain_configuration_status = Some(input);
            self
        }
        /// <p>The status to which the domain configuration should be updated.</p>
        pub fn set_domain_configuration_status(
            mut self,
            input: std::option::Option<crate::model::DomainConfigurationStatus>,
        ) -> Self {
            self.domain_configuration_status = input;
            self
        }
        /// <p>Removes the authorization configuration from a domain.</p>
        pub fn remove_authorizer_config(mut self, input: bool) -> Self {
            self.remove_authorizer_config = Some(input);
            self
        }
        /// <p>Removes the authorization configuration from a domain.</p>
        pub fn set_remove_authorizer_config(mut self, input: std::option::Option<bool>) -> Self {
            self.remove_authorizer_config = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateDomainConfigurationInput`](crate::input::UpdateDomainConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateDomainConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateDomainConfigurationInput {
                domain_configuration_name: self.domain_configuration_name,
                authorizer_config: self.authorizer_config,
                domain_configuration_status: self.domain_configuration_status,
                remove_authorizer_config: self.remove_authorizer_config.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateDomainConfigurationInputOperationOutputAlias =
    crate::operation::UpdateDomainConfiguration;
#[doc(hidden)]
pub type UpdateDomainConfigurationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateDomainConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDomainConfiguration`](crate::operation::UpdateDomainConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateDomainConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateDomainConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_341 = &_input.domain_configuration_name;
                let input_341 = input_341.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "domain_configuration_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let domain_configuration_name =
                    aws_smithy_http::label::fmt_string(input_341, false);
                if domain_configuration_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "domain_configuration_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/domainConfigurations/{domainConfigurationName}",
                    domainConfigurationName = domain_configuration_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateDomainConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_domain_configuration(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateDomainConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateDomainConfiguration",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateDomainConfigurationInput`](crate::input::UpdateDomainConfigurationInput)
    pub fn builder() -> crate::input::update_domain_configuration_input::Builder {
        crate::input::update_domain_configuration_input::Builder::default()
    }
}

/// See [`UpdateDynamicThingGroupInput`](crate::input::UpdateDynamicThingGroupInput)
pub mod update_dynamic_thing_group_input {

    /// A builder for [`UpdateDynamicThingGroupInput`](crate::input::UpdateDynamicThingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_group_name: std::option::Option<std::string::String>,
        pub(crate) thing_group_properties: std::option::Option<crate::model::ThingGroupProperties>,
        pub(crate) expected_version: std::option::Option<i64>,
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) query_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the dynamic thing group to update.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_name = Some(input.into());
            self
        }
        /// <p>The name of the dynamic thing group to update.</p>
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_name = input;
            self
        }
        /// <p>The dynamic thing group properties to update.</p>
        pub fn thing_group_properties(mut self, input: crate::model::ThingGroupProperties) -> Self {
            self.thing_group_properties = Some(input);
            self
        }
        /// <p>The dynamic thing group properties to update.</p>
        pub fn set_thing_group_properties(
            mut self,
            input: std::option::Option<crate::model::ThingGroupProperties>,
        ) -> Self {
            self.thing_group_properties = input;
            self
        }
        /// <p>The expected version of the dynamic thing group to update.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the dynamic thing group to update.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// <p>The dynamic thing group index to update.</p> <note>
        /// <p>Currently one index is supported: <code>AWS_Things</code>.</p>
        /// </note>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The dynamic thing group index to update.</p> <note>
        /// <p>Currently one index is supported: <code>AWS_Things</code>.</p>
        /// </note>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>The dynamic thing group search query string to update.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The dynamic thing group search query string to update.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The dynamic thing group query version to update.</p> <note>
        /// <p>Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.</p>
        /// </note>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_version = Some(input.into());
            self
        }
        /// <p>The dynamic thing group query version to update.</p> <note>
        /// <p>Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.</p>
        /// </note>
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_version = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateDynamicThingGroupInput`](crate::input::UpdateDynamicThingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateDynamicThingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateDynamicThingGroupInput {
                thing_group_name: self.thing_group_name,
                thing_group_properties: self.thing_group_properties,
                expected_version: self.expected_version,
                index_name: self.index_name,
                query_string: self.query_string,
                query_version: self.query_version,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateDynamicThingGroupInputOperationOutputAlias =
    crate::operation::UpdateDynamicThingGroup;
#[doc(hidden)]
pub type UpdateDynamicThingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateDynamicThingGroupInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDynamicThingGroup`](crate::operation::UpdateDynamicThingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateDynamicThingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateDynamicThingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_342 = &_input.thing_group_name;
                let input_342 = input_342.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_group_name = aws_smithy_http::label::fmt_string(input_342, false);
                if thing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/dynamic-thing-groups/{thingGroupName}",
                    thingGroupName = thing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateDynamicThingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_dynamic_thing_group(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateDynamicThingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateDynamicThingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateDynamicThingGroupInput`](crate::input::UpdateDynamicThingGroupInput)
    pub fn builder() -> crate::input::update_dynamic_thing_group_input::Builder {
        crate::input::update_dynamic_thing_group_input::Builder::default()
    }
}

/// See [`UpdateEventConfigurationsInput`](crate::input::UpdateEventConfigurationsInput)
pub mod update_event_configurations_input {

    /// A builder for [`UpdateEventConfigurationsInput`](crate::input::UpdateEventConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_configurations: std::option::Option<
            std::collections::HashMap<crate::model::EventType, crate::model::Configuration>,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `event_configurations`.
        ///
        /// To override the contents of this collection use [`set_event_configurations`](Self::set_event_configurations).
        ///
        /// <p>The new event configuration values.</p>
        pub fn event_configurations(
            mut self,
            k: crate::model::EventType,
            v: crate::model::Configuration,
        ) -> Self {
            let mut hash_map = self.event_configurations.unwrap_or_default();
            hash_map.insert(k, v);
            self.event_configurations = Some(hash_map);
            self
        }
        /// <p>The new event configuration values.</p>
        pub fn set_event_configurations(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::EventType, crate::model::Configuration>,
            >,
        ) -> Self {
            self.event_configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateEventConfigurationsInput`](crate::input::UpdateEventConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateEventConfigurationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateEventConfigurationsInput {
                event_configurations: self.event_configurations,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateEventConfigurationsInputOperationOutputAlias =
    crate::operation::UpdateEventConfigurations;
#[doc(hidden)]
pub type UpdateEventConfigurationsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateEventConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`UpdateEventConfigurations`](crate::operation::UpdateEventConfigurations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateEventConfigurations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateEventConfigurationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/event-configurations").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateEventConfigurationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_event_configurations(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateEventConfigurations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateEventConfigurations",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateEventConfigurationsInput`](crate::input::UpdateEventConfigurationsInput)
    pub fn builder() -> crate::input::update_event_configurations_input::Builder {
        crate::input::update_event_configurations_input::Builder::default()
    }
}

/// See [`UpdateFleetMetricInput`](crate::input::UpdateFleetMetricInput)
pub mod update_fleet_metric_input {

    /// A builder for [`UpdateFleetMetricInput`](crate::input::UpdateFleetMetricInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) aggregation_type: std::option::Option<crate::model::AggregationType>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) aggregation_field: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) query_version: std::option::Option<std::string::String>,
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<crate::model::FleetMetricUnit>,
        pub(crate) expected_version: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the fleet metric to update.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet metric to update.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The search query string.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The search query string.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The type of the aggregation query.</p>
        pub fn aggregation_type(mut self, input: crate::model::AggregationType) -> Self {
            self.aggregation_type = Some(input);
            self
        }
        /// <p>The type of the aggregation query.</p>
        pub fn set_aggregation_type(
            mut self,
            input: std::option::Option<crate::model::AggregationType>,
        ) -> Self {
            self.aggregation_type = input;
            self
        }
        /// <p>The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.</p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// <p>The field to aggregate.</p>
        pub fn aggregation_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.aggregation_field = Some(input.into());
            self
        }
        /// <p>The field to aggregate.</p>
        pub fn set_aggregation_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aggregation_field = input;
            self
        }
        /// <p>The description of the fleet metric.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the fleet metric.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The version of the query.</p>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_version = Some(input.into());
            self
        }
        /// <p>The version of the query.</p>
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_version = input;
            self
        }
        /// <p>The name of the index to search.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        /// <p>The name of the index to search.</p>
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>Used to support unit transformation such as milliseconds to seconds. The unit must be supported by <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html">CW metric</a>.</p>
        pub fn unit(mut self, input: crate::model::FleetMetricUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>Used to support unit transformation such as milliseconds to seconds. The unit must be supported by <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html">CW metric</a>.</p>
        pub fn set_unit(
            mut self,
            input: std::option::Option<crate::model::FleetMetricUnit>,
        ) -> Self {
            self.unit = input;
            self
        }
        /// <p>The expected version of the fleet metric record in the registry.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the fleet metric record in the registry.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFleetMetricInput`](crate::input::UpdateFleetMetricInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateFleetMetricInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateFleetMetricInput {
                metric_name: self.metric_name,
                query_string: self.query_string,
                aggregation_type: self.aggregation_type,
                period: self.period,
                aggregation_field: self.aggregation_field,
                description: self.description,
                query_version: self.query_version,
                index_name: self.index_name,
                unit: self.unit,
                expected_version: self.expected_version,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateFleetMetricInputOperationOutputAlias = crate::operation::UpdateFleetMetric;
#[doc(hidden)]
pub type UpdateFleetMetricInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateFleetMetricInput {
    /// Consumes the builder and constructs an Operation<[`UpdateFleetMetric`](crate::operation::UpdateFleetMetric)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateFleetMetric,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateFleetMetricInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_343 = &_input.metric_name;
                let input_343 = input_343.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let metric_name = aws_smithy_http::label::fmt_string(input_343, false);
                if metric_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "metric_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/fleet-metric/{metricName}",
                    metricName = metric_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateFleetMetricInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_fleet_metric(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateFleetMetric::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateFleetMetric",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateFleetMetricInput`](crate::input::UpdateFleetMetricInput)
    pub fn builder() -> crate::input::update_fleet_metric_input::Builder {
        crate::input::update_fleet_metric_input::Builder::default()
    }
}

/// See [`UpdateIndexingConfigurationInput`](crate::input::UpdateIndexingConfigurationInput)
pub mod update_indexing_configuration_input {

    /// A builder for [`UpdateIndexingConfigurationInput`](crate::input::UpdateIndexingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_indexing_configuration:
            std::option::Option<crate::model::ThingIndexingConfiguration>,
        pub(crate) thing_group_indexing_configuration:
            std::option::Option<crate::model::ThingGroupIndexingConfiguration>,
    }
    impl Builder {
        /// <p>Thing indexing configuration.</p>
        pub fn thing_indexing_configuration(
            mut self,
            input: crate::model::ThingIndexingConfiguration,
        ) -> Self {
            self.thing_indexing_configuration = Some(input);
            self
        }
        /// <p>Thing indexing configuration.</p>
        pub fn set_thing_indexing_configuration(
            mut self,
            input: std::option::Option<crate::model::ThingIndexingConfiguration>,
        ) -> Self {
            self.thing_indexing_configuration = input;
            self
        }
        /// <p>Thing group indexing configuration.</p>
        pub fn thing_group_indexing_configuration(
            mut self,
            input: crate::model::ThingGroupIndexingConfiguration,
        ) -> Self {
            self.thing_group_indexing_configuration = Some(input);
            self
        }
        /// <p>Thing group indexing configuration.</p>
        pub fn set_thing_group_indexing_configuration(
            mut self,
            input: std::option::Option<crate::model::ThingGroupIndexingConfiguration>,
        ) -> Self {
            self.thing_group_indexing_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateIndexingConfigurationInput`](crate::input::UpdateIndexingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateIndexingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateIndexingConfigurationInput {
                thing_indexing_configuration: self.thing_indexing_configuration,
                thing_group_indexing_configuration: self.thing_group_indexing_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateIndexingConfigurationInputOperationOutputAlias =
    crate::operation::UpdateIndexingConfiguration;
#[doc(hidden)]
pub type UpdateIndexingConfigurationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateIndexingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateIndexingConfiguration`](crate::operation::UpdateIndexingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateIndexingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateIndexingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/indexing/config").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateIndexingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_indexing_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateIndexingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateIndexingConfiguration",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateIndexingConfigurationInput`](crate::input::UpdateIndexingConfigurationInput)
    pub fn builder() -> crate::input::update_indexing_configuration_input::Builder {
        crate::input::update_indexing_configuration_input::Builder::default()
    }
}

/// See [`UpdateJobInput`](crate::input::UpdateJobInput)
pub mod update_job_input {

    /// A builder for [`UpdateJobInput`](crate::input::UpdateJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) presigned_url_config: std::option::Option<crate::model::PresignedUrlConfig>,
        pub(crate) job_executions_rollout_config:
            std::option::Option<crate::model::JobExecutionsRolloutConfig>,
        pub(crate) abort_config: std::option::Option<crate::model::AbortConfig>,
        pub(crate) timeout_config: std::option::Option<crate::model::TimeoutConfig>,
        pub(crate) namespace_id: std::option::Option<std::string::String>,
        pub(crate) job_executions_retry_config:
            std::option::Option<crate::model::JobExecutionsRetryConfig>,
    }
    impl Builder {
        /// <p>The ID of the job to be updated.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The ID of the job to be updated.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>A short text description of the job.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A short text description of the job.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Configuration information for pre-signed S3 URLs.</p>
        pub fn presigned_url_config(mut self, input: crate::model::PresignedUrlConfig) -> Self {
            self.presigned_url_config = Some(input);
            self
        }
        /// <p>Configuration information for pre-signed S3 URLs.</p>
        pub fn set_presigned_url_config(
            mut self,
            input: std::option::Option<crate::model::PresignedUrlConfig>,
        ) -> Self {
            self.presigned_url_config = input;
            self
        }
        /// <p>Allows you to create a staged rollout of the job.</p>
        pub fn job_executions_rollout_config(
            mut self,
            input: crate::model::JobExecutionsRolloutConfig,
        ) -> Self {
            self.job_executions_rollout_config = Some(input);
            self
        }
        /// <p>Allows you to create a staged rollout of the job.</p>
        pub fn set_job_executions_rollout_config(
            mut self,
            input: std::option::Option<crate::model::JobExecutionsRolloutConfig>,
        ) -> Self {
            self.job_executions_rollout_config = input;
            self
        }
        /// <p>Allows you to create criteria to abort a job.</p>
        pub fn abort_config(mut self, input: crate::model::AbortConfig) -> Self {
            self.abort_config = Some(input);
            self
        }
        /// <p>Allows you to create criteria to abort a job.</p>
        pub fn set_abort_config(
            mut self,
            input: std::option::Option<crate::model::AbortConfig>,
        ) -> Self {
            self.abort_config = input;
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>. </p>
        pub fn timeout_config(mut self, input: crate::model::TimeoutConfig) -> Self {
            self.timeout_config = Some(input);
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>. </p>
        pub fn set_timeout_config(
            mut self,
            input: std::option::Option<crate::model::TimeoutConfig>,
        ) -> Self {
            self.timeout_config = input;
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_id = Some(input.into());
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
        /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace_id = input;
            self
        }
        /// <p>Allows you to create the criteria to retry a job.</p>
        pub fn job_executions_retry_config(
            mut self,
            input: crate::model::JobExecutionsRetryConfig,
        ) -> Self {
            self.job_executions_retry_config = Some(input);
            self
        }
        /// <p>Allows you to create the criteria to retry a job.</p>
        pub fn set_job_executions_retry_config(
            mut self,
            input: std::option::Option<crate::model::JobExecutionsRetryConfig>,
        ) -> Self {
            self.job_executions_retry_config = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateJobInput`](crate::input::UpdateJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UpdateJobInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateJobInput {
                job_id: self.job_id,
                description: self.description,
                presigned_url_config: self.presigned_url_config,
                job_executions_rollout_config: self.job_executions_rollout_config,
                abort_config: self.abort_config,
                timeout_config: self.timeout_config,
                namespace_id: self.namespace_id,
                job_executions_retry_config: self.job_executions_retry_config,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateJobInputOperationOutputAlias = crate::operation::UpdateJob;
#[doc(hidden)]
pub type UpdateJobInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateJobInput {
    /// Consumes the builder and constructs an Operation<[`UpdateJob`](crate::operation::UpdateJob)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateJob,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateJobInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_344 = &_input.job_id;
                let input_344 = input_344.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let job_id = aws_smithy_http::label::fmt_string(input_344, false);
                if job_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "job_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/jobs/{jobId}", jobId = job_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UpdateJobInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_345) = &_input.namespace_id {
                    query.push_kv(
                        "namespaceId",
                        &aws_smithy_http::query::fmt_string(&inner_345),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateJobInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_job(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateJob::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "UpdateJob",
                    "iot",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateJobInput`](crate::input::UpdateJobInput)
    pub fn builder() -> crate::input::update_job_input::Builder {
        crate::input::update_job_input::Builder::default()
    }
}

/// See [`UpdateMitigationActionInput`](crate::input::UpdateMitigationActionInput)
pub mod update_mitigation_action_input {

    /// A builder for [`UpdateMitigationActionInput`](crate::input::UpdateMitigationActionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_name: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) action_params: std::option::Option<crate::model::MitigationActionParams>,
    }
    impl Builder {
        /// <p>The friendly name for the mitigation action. You cannot change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and recreate the mitigation action with the new name.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        /// <p>The friendly name for the mitigation action. You cannot change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and recreate the mitigation action with the new name.</p>
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input;
            self
        }
        /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>Defines the type of action and the parameters for that action.</p>
        pub fn action_params(mut self, input: crate::model::MitigationActionParams) -> Self {
            self.action_params = Some(input);
            self
        }
        /// <p>Defines the type of action and the parameters for that action.</p>
        pub fn set_action_params(
            mut self,
            input: std::option::Option<crate::model::MitigationActionParams>,
        ) -> Self {
            self.action_params = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateMitigationActionInput`](crate::input::UpdateMitigationActionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateMitigationActionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateMitigationActionInput {
                action_name: self.action_name,
                role_arn: self.role_arn,
                action_params: self.action_params,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateMitigationActionInputOperationOutputAlias = crate::operation::UpdateMitigationAction;
#[doc(hidden)]
pub type UpdateMitigationActionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateMitigationActionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateMitigationAction`](crate::operation::UpdateMitigationAction)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateMitigationAction,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateMitigationActionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_346 = &_input.action_name;
                let input_346 = input_346.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "action_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let action_name = aws_smithy_http::label::fmt_string(input_346, false);
                if action_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "action_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/mitigationactions/actions/{actionName}",
                    actionName = action_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateMitigationActionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_mitigation_action(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateMitigationAction::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateMitigationAction",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateMitigationActionInput`](crate::input::UpdateMitigationActionInput)
    pub fn builder() -> crate::input::update_mitigation_action_input::Builder {
        crate::input::update_mitigation_action_input::Builder::default()
    }
}

/// See [`UpdateProvisioningTemplateInput`](crate::input::UpdateProvisioningTemplateInput)
pub mod update_provisioning_template_input {

    /// A builder for [`UpdateProvisioningTemplateInput`](crate::input::UpdateProvisioningTemplateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) default_version_id: std::option::Option<i32>,
        pub(crate) provisioning_role_arn: std::option::Option<std::string::String>,
        pub(crate) pre_provisioning_hook: std::option::Option<crate::model::ProvisioningHook>,
        pub(crate) remove_pre_provisioning_hook: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the fleet provisioning template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet provisioning template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The description of the fleet provisioning template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the fleet provisioning template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>True to enable the fleet provisioning template, otherwise false.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>True to enable the fleet provisioning template, otherwise false.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The ID of the default provisioning template version.</p>
        pub fn default_version_id(mut self, input: i32) -> Self {
            self.default_version_id = Some(input);
            self
        }
        /// <p>The ID of the default provisioning template version.</p>
        pub fn set_default_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.default_version_id = input;
            self
        }
        /// <p>The ARN of the role associated with the provisioning template. This IoT role grants permission to provision a device.</p>
        pub fn provisioning_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the role associated with the provisioning template. This IoT role grants permission to provision a device.</p>
        pub fn set_provisioning_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_role_arn = input;
            self
        }
        /// <p>Updates the pre-provisioning hook template.</p>
        pub fn pre_provisioning_hook(mut self, input: crate::model::ProvisioningHook) -> Self {
            self.pre_provisioning_hook = Some(input);
            self
        }
        /// <p>Updates the pre-provisioning hook template.</p>
        pub fn set_pre_provisioning_hook(
            mut self,
            input: std::option::Option<crate::model::ProvisioningHook>,
        ) -> Self {
            self.pre_provisioning_hook = input;
            self
        }
        /// <p>Removes pre-provisioning hook template.</p>
        pub fn remove_pre_provisioning_hook(mut self, input: bool) -> Self {
            self.remove_pre_provisioning_hook = Some(input);
            self
        }
        /// <p>Removes pre-provisioning hook template.</p>
        pub fn set_remove_pre_provisioning_hook(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.remove_pre_provisioning_hook = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateProvisioningTemplateInput`](crate::input::UpdateProvisioningTemplateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateProvisioningTemplateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateProvisioningTemplateInput {
                template_name: self.template_name,
                description: self.description,
                enabled: self.enabled.unwrap_or_default(),
                default_version_id: self.default_version_id,
                provisioning_role_arn: self.provisioning_role_arn,
                pre_provisioning_hook: self.pre_provisioning_hook,
                remove_pre_provisioning_hook: self.remove_pre_provisioning_hook,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateProvisioningTemplateInputOperationOutputAlias =
    crate::operation::UpdateProvisioningTemplate;
#[doc(hidden)]
pub type UpdateProvisioningTemplateInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateProvisioningTemplateInput {
    /// Consumes the builder and constructs an Operation<[`UpdateProvisioningTemplate`](crate::operation::UpdateProvisioningTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateProvisioningTemplate,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateProvisioningTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_347 = &_input.template_name;
                let input_347 = input_347.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let template_name = aws_smithy_http::label::fmt_string(input_347, false);
                if template_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "template_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/provisioning-templates/{templateName}",
                    templateName = template_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateProvisioningTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_provisioning_template(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateProvisioningTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateProvisioningTemplate",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateProvisioningTemplateInput`](crate::input::UpdateProvisioningTemplateInput)
    pub fn builder() -> crate::input::update_provisioning_template_input::Builder {
        crate::input::update_provisioning_template_input::Builder::default()
    }
}

/// See [`UpdateRoleAliasInput`](crate::input::UpdateRoleAliasInput)
pub mod update_role_alias_input {

    /// A builder for [`UpdateRoleAliasInput`](crate::input::UpdateRoleAliasInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_alias: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) credential_duration_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The role alias to update.</p>
        pub fn role_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_alias = Some(input.into());
            self
        }
        /// <p>The role alias to update.</p>
        pub fn set_role_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_alias = input;
            self
        }
        /// <p>The role ARN.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The role ARN.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The number of seconds the credential will be valid.</p>
        /// <p>This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.</p>
        pub fn credential_duration_seconds(mut self, input: i32) -> Self {
            self.credential_duration_seconds = Some(input);
            self
        }
        /// <p>The number of seconds the credential will be valid.</p>
        /// <p>This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.</p>
        pub fn set_credential_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.credential_duration_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRoleAliasInput`](crate::input::UpdateRoleAliasInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateRoleAliasInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateRoleAliasInput {
                role_alias: self.role_alias,
                role_arn: self.role_arn,
                credential_duration_seconds: self.credential_duration_seconds,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateRoleAliasInputOperationOutputAlias = crate::operation::UpdateRoleAlias;
#[doc(hidden)]
pub type UpdateRoleAliasInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateRoleAliasInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRoleAlias`](crate::operation::UpdateRoleAlias)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateRoleAlias,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateRoleAliasInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_348 = &_input.role_alias;
                let input_348 = input_348.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "role_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let role_alias = aws_smithy_http::label::fmt_string(input_348, false);
                if role_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "role_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/role-aliases/{roleAlias}", roleAlias = role_alias)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateRoleAliasInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_role_alias(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateRoleAlias::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateRoleAlias",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateRoleAliasInput`](crate::input::UpdateRoleAliasInput)
    pub fn builder() -> crate::input::update_role_alias_input::Builder {
        crate::input::update_role_alias_input::Builder::default()
    }
}

/// See [`UpdateScheduledAuditInput`](crate::input::UpdateScheduledAuditInput)
pub mod update_scheduled_audit_input {

    /// A builder for [`UpdateScheduledAuditInput`](crate::input::UpdateScheduledAuditInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) frequency: std::option::Option<crate::model::AuditFrequency>,
        pub(crate) day_of_month: std::option::Option<std::string::String>,
        pub(crate) day_of_week: std::option::Option<crate::model::DayOfWeek>,
        pub(crate) target_check_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) scheduled_audit_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>How often the scheduled audit takes place, either <code>DAILY</code>, <code>WEEKLY</code>, <code>BIWEEKLY</code>, or <code>MONTHLY</code>. The start time of each audit is determined by the system.</p>
        pub fn frequency(mut self, input: crate::model::AuditFrequency) -> Self {
            self.frequency = Some(input);
            self
        }
        /// <p>How often the scheduled audit takes place, either <code>DAILY</code>, <code>WEEKLY</code>, <code>BIWEEKLY</code>, or <code>MONTHLY</code>. The start time of each audit is determined by the system.</p>
        pub fn set_frequency(
            mut self,
            input: std::option::Option<crate::model::AuditFrequency>,
        ) -> Self {
            self.frequency = input;
            self
        }
        /// <p>The day of the month on which the scheduled audit takes place. This can be <code>1</code> through <code>31</code> or <code>LAST</code>. This field is required if the <code>frequency</code> parameter is set to <code>MONTHLY</code>. If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
        pub fn day_of_month(mut self, input: impl Into<std::string::String>) -> Self {
            self.day_of_month = Some(input.into());
            self
        }
        /// <p>The day of the month on which the scheduled audit takes place. This can be <code>1</code> through <code>31</code> or <code>LAST</code>. This field is required if the <code>frequency</code> parameter is set to <code>MONTHLY</code>. If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
        pub fn set_day_of_month(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.day_of_month = input;
            self
        }
        /// <p>The day of the week on which the scheduled audit takes place. This can be one of <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the "frequency" parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
        pub fn day_of_week(mut self, input: crate::model::DayOfWeek) -> Self {
            self.day_of_week = Some(input);
            self
        }
        /// <p>The day of the week on which the scheduled audit takes place. This can be one of <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the "frequency" parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
        pub fn set_day_of_week(
            mut self,
            input: std::option::Option<crate::model::DayOfWeek>,
        ) -> Self {
            self.day_of_week = input;
            self
        }
        /// Appends an item to `target_check_names`.
        ///
        /// To override the contents of this collection use [`set_target_check_names`](Self::set_target_check_names).
        ///
        /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn target_check_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_check_names.unwrap_or_default();
            v.push(input.into());
            self.target_check_names = Some(v);
            self
        }
        /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
        pub fn set_target_check_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_check_names = input;
            self
        }
        /// <p>The name of the scheduled audit. (Max. 128 chars)</p>
        pub fn scheduled_audit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduled_audit_name = Some(input.into());
            self
        }
        /// <p>The name of the scheduled audit. (Max. 128 chars)</p>
        pub fn set_scheduled_audit_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_audit_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateScheduledAuditInput`](crate::input::UpdateScheduledAuditInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateScheduledAuditInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateScheduledAuditInput {
                frequency: self.frequency,
                day_of_month: self.day_of_month,
                day_of_week: self.day_of_week,
                target_check_names: self.target_check_names,
                scheduled_audit_name: self.scheduled_audit_name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateScheduledAuditInputOperationOutputAlias = crate::operation::UpdateScheduledAudit;
#[doc(hidden)]
pub type UpdateScheduledAuditInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateScheduledAuditInput {
    /// Consumes the builder and constructs an Operation<[`UpdateScheduledAudit`](crate::operation::UpdateScheduledAudit)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateScheduledAudit,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateScheduledAuditInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_349 = &_input.scheduled_audit_name;
                let input_349 = input_349.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "scheduled_audit_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let scheduled_audit_name = aws_smithy_http::label::fmt_string(input_349, false);
                if scheduled_audit_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "scheduled_audit_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/audit/scheduledaudits/{scheduledAuditName}",
                    scheduledAuditName = scheduled_audit_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateScheduledAuditInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_scheduled_audit(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateScheduledAudit::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateScheduledAudit",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateScheduledAuditInput`](crate::input::UpdateScheduledAuditInput)
    pub fn builder() -> crate::input::update_scheduled_audit_input::Builder {
        crate::input::update_scheduled_audit_input::Builder::default()
    }
}

/// See [`UpdateSecurityProfileInput`](crate::input::UpdateSecurityProfileInput)
pub mod update_security_profile_input {

    /// A builder for [`UpdateSecurityProfileInput`](crate::input::UpdateSecurityProfileInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_profile_name: std::option::Option<std::string::String>,
        pub(crate) security_profile_description: std::option::Option<std::string::String>,
        pub(crate) behaviors: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
        pub(crate) alert_targets: std::option::Option<
            std::collections::HashMap<crate::model::AlertTargetType, crate::model::AlertTarget>,
        >,
        pub(crate) additional_metrics_to_retain:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) additional_metrics_to_retain_v2:
            std::option::Option<std::vec::Vec<crate::model::MetricToRetain>>,
        pub(crate) delete_behaviors: std::option::Option<bool>,
        pub(crate) delete_alert_targets: std::option::Option<bool>,
        pub(crate) delete_additional_metrics_to_retain: std::option::Option<bool>,
        pub(crate) expected_version: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the security profile you want to update.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_profile_name = Some(input.into());
            self
        }
        /// <p>The name of the security profile you want to update.</p>
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_name = input;
            self
        }
        /// <p>A description of the security profile.</p>
        pub fn security_profile_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.security_profile_description = Some(input.into());
            self
        }
        /// <p>A description of the security profile.</p>
        pub fn set_security_profile_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_profile_description = input;
            self
        }
        /// Appends an item to `behaviors`.
        ///
        /// To override the contents of this collection use [`set_behaviors`](Self::set_behaviors).
        ///
        /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
        pub fn behaviors(mut self, input: crate::model::Behavior) -> Self {
            let mut v = self.behaviors.unwrap_or_default();
            v.push(input);
            self.behaviors = Some(v);
            self
        }
        /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
        pub fn set_behaviors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
        ) -> Self {
            self.behaviors = input;
            self
        }
        /// Adds a key-value pair to `alert_targets`.
        ///
        /// To override the contents of this collection use [`set_alert_targets`](Self::set_alert_targets).
        ///
        /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
        pub fn alert_targets(
            mut self,
            k: crate::model::AlertTargetType,
            v: crate::model::AlertTarget,
        ) -> Self {
            let mut hash_map = self.alert_targets.unwrap_or_default();
            hash_map.insert(k, v);
            self.alert_targets = Some(hash_map);
            self
        }
        /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
        pub fn set_alert_targets(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::AlertTargetType, crate::model::AlertTarget>,
            >,
        ) -> Self {
            self.alert_targets = input;
            self
        }
        /// Appends an item to `additional_metrics_to_retain`.
        ///
        /// To override the contents of this collection use [`set_additional_metrics_to_retain`](Self::set_additional_metrics_to_retain).
        ///
        /// <p> <i>Please use <code>UpdateSecurityProfileRequest$additionalMetricsToRetainV2</code> instead.</i> </p>
        /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn additional_metrics_to_retain(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.additional_metrics_to_retain.unwrap_or_default();
            v.push(input.into());
            self.additional_metrics_to_retain = Some(v);
            self
        }
        /// <p> <i>Please use <code>UpdateSecurityProfileRequest$additionalMetricsToRetainV2</code> instead.</i> </p>
        /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn set_additional_metrics_to_retain(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.additional_metrics_to_retain = input;
            self
        }
        /// Appends an item to `additional_metrics_to_retain_v2`.
        ///
        /// To override the contents of this collection use [`set_additional_metrics_to_retain_v2`](Self::set_additional_metrics_to_retain_v2).
        ///
        /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn additional_metrics_to_retain_v2(
            mut self,
            input: crate::model::MetricToRetain,
        ) -> Self {
            let mut v = self.additional_metrics_to_retain_v2.unwrap_or_default();
            v.push(input);
            self.additional_metrics_to_retain_v2 = Some(v);
            self
        }
        /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn set_additional_metrics_to_retain_v2(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricToRetain>>,
        ) -> Self {
            self.additional_metrics_to_retain_v2 = input;
            self
        }
        /// <p>If true, delete all <code>behaviors</code> defined for this security profile. If any <code>behaviors</code> are defined in the current invocation, an exception occurs.</p>
        pub fn delete_behaviors(mut self, input: bool) -> Self {
            self.delete_behaviors = Some(input);
            self
        }
        /// <p>If true, delete all <code>behaviors</code> defined for this security profile. If any <code>behaviors</code> are defined in the current invocation, an exception occurs.</p>
        pub fn set_delete_behaviors(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_behaviors = input;
            self
        }
        /// <p>If true, delete all <code>alertTargets</code> defined for this security profile. If any <code>alertTargets</code> are defined in the current invocation, an exception occurs.</p>
        pub fn delete_alert_targets(mut self, input: bool) -> Self {
            self.delete_alert_targets = Some(input);
            self
        }
        /// <p>If true, delete all <code>alertTargets</code> defined for this security profile. If any <code>alertTargets</code> are defined in the current invocation, an exception occurs.</p>
        pub fn set_delete_alert_targets(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_alert_targets = input;
            self
        }
        /// <p>If true, delete all <code>additionalMetricsToRetain</code> defined for this security profile. If any <code>additionalMetricsToRetain</code> are defined in the current invocation, an exception occurs.</p>
        pub fn delete_additional_metrics_to_retain(mut self, input: bool) -> Self {
            self.delete_additional_metrics_to_retain = Some(input);
            self
        }
        /// <p>If true, delete all <code>additionalMetricsToRetain</code> defined for this security profile. If any <code>additionalMetricsToRetain</code> are defined in the current invocation, an exception occurs.</p>
        pub fn set_delete_additional_metrics_to_retain(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.delete_additional_metrics_to_retain = input;
            self
        }
        /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSecurityProfileInput`](crate::input::UpdateSecurityProfileInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateSecurityProfileInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateSecurityProfileInput {
                security_profile_name: self.security_profile_name,
                security_profile_description: self.security_profile_description,
                behaviors: self.behaviors,
                alert_targets: self.alert_targets,
                additional_metrics_to_retain: self.additional_metrics_to_retain,
                additional_metrics_to_retain_v2: self.additional_metrics_to_retain_v2,
                delete_behaviors: self.delete_behaviors.unwrap_or_default(),
                delete_alert_targets: self.delete_alert_targets.unwrap_or_default(),
                delete_additional_metrics_to_retain: self
                    .delete_additional_metrics_to_retain
                    .unwrap_or_default(),
                expected_version: self.expected_version,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateSecurityProfileInputOperationOutputAlias = crate::operation::UpdateSecurityProfile;
#[doc(hidden)]
pub type UpdateSecurityProfileInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateSecurityProfileInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSecurityProfile`](crate::operation::UpdateSecurityProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateSecurityProfile,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateSecurityProfileInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_350 = &_input.security_profile_name;
                let input_350 = input_350.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let security_profile_name = aws_smithy_http::label::fmt_string(input_350, false);
                if security_profile_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "security_profile_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/security-profiles/{securityProfileName}",
                    securityProfileName = security_profile_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UpdateSecurityProfileInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_351) = &_input.expected_version {
                    query.push_kv(
                        "expectedVersion",
                        aws_smithy_types::primitive::Encoder::from(*inner_351).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateSecurityProfileInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_security_profile(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateSecurityProfile::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateSecurityProfile",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateSecurityProfileInput`](crate::input::UpdateSecurityProfileInput)
    pub fn builder() -> crate::input::update_security_profile_input::Builder {
        crate::input::update_security_profile_input::Builder::default()
    }
}

/// See [`UpdateStreamInput`](crate::input::UpdateStreamInput)
pub mod update_stream_input {

    /// A builder for [`UpdateStreamInput`](crate::input::UpdateStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) files: std::option::Option<std::vec::Vec<crate::model::StreamFile>>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>The stream ID.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// <p>The description of the stream.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the stream.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `files`.
        ///
        /// To override the contents of this collection use [`set_files`](Self::set_files).
        ///
        /// <p>The files associated with the stream.</p>
        pub fn files(mut self, input: crate::model::StreamFile) -> Self {
            let mut v = self.files.unwrap_or_default();
            v.push(input);
            self.files = Some(v);
            self
        }
        /// <p>The files associated with the stream.</p>
        pub fn set_files(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamFile>>,
        ) -> Self {
            self.files = input;
            self
        }
        /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateStreamInput`](crate::input::UpdateStreamInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateStreamInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateStreamInput {
                stream_id: self.stream_id,
                description: self.description,
                files: self.files,
                role_arn: self.role_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateStreamInputOperationOutputAlias = crate::operation::UpdateStream;
#[doc(hidden)]
pub type UpdateStreamInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateStreamInput {
    /// Consumes the builder and constructs an Operation<[`UpdateStream`](crate::operation::UpdateStream)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateStream,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateStreamInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_352 = &_input.stream_id;
                let input_352 = input_352.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "stream_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let stream_id = aws_smithy_http::label::fmt_string(input_352, false);
                if stream_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "stream_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/streams/{streamId}", streamId = stream_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateStreamInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_stream(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateStream::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateStream",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateStreamInput`](crate::input::UpdateStreamInput)
    pub fn builder() -> crate::input::update_stream_input::Builder {
        crate::input::update_stream_input::Builder::default()
    }
}

/// See [`UpdateThingInput`](crate::input::UpdateThingInput)
pub mod update_thing_input {

    /// A builder for [`UpdateThingInput`](crate::input::UpdateThingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) thing_type_name: std::option::Option<std::string::String>,
        pub(crate) attribute_payload: std::option::Option<crate::model::AttributePayload>,
        pub(crate) expected_version: std::option::Option<i64>,
        pub(crate) remove_thing_type: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the thing to update.</p>
        /// <p>You can't change a thing's name. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The name of the thing to update.</p>
        /// <p>You can't change a thing's name. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// <p>The name of the thing type.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_type_name = Some(input.into());
            self
        }
        /// <p>The name of the thing type.</p>
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_type_name = input;
            self
        }
        /// <p>A list of thing attributes, a JSON string containing name-value pairs. For example:</p>
        /// <p> <code>{\"attributes\":{\"name1\":\"value2\"}}</code> </p>
        /// <p>This data is used to add new attributes or update existing attributes.</p>
        pub fn attribute_payload(mut self, input: crate::model::AttributePayload) -> Self {
            self.attribute_payload = Some(input);
            self
        }
        /// <p>A list of thing attributes, a JSON string containing name-value pairs. For example:</p>
        /// <p> <code>{\"attributes\":{\"name1\":\"value2\"}}</code> </p>
        /// <p>This data is used to add new attributes or update existing attributes.</p>
        pub fn set_attribute_payload(
            mut self,
            input: std::option::Option<crate::model::AttributePayload>,
        ) -> Self {
            self.attribute_payload = input;
            self
        }
        /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>UpdateThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>UpdateThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// <p>Remove a thing type association. If <b>true</b>, the association is removed.</p>
        pub fn remove_thing_type(mut self, input: bool) -> Self {
            self.remove_thing_type = Some(input);
            self
        }
        /// <p>Remove a thing type association. If <b>true</b>, the association is removed.</p>
        pub fn set_remove_thing_type(mut self, input: std::option::Option<bool>) -> Self {
            self.remove_thing_type = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateThingInput`](crate::input::UpdateThingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateThingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateThingInput {
                thing_name: self.thing_name,
                thing_type_name: self.thing_type_name,
                attribute_payload: self.attribute_payload,
                expected_version: self.expected_version,
                remove_thing_type: self.remove_thing_type.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateThingInputOperationOutputAlias = crate::operation::UpdateThing;
#[doc(hidden)]
pub type UpdateThingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateThingInput {
    /// Consumes the builder and constructs an Operation<[`UpdateThing`](crate::operation::UpdateThing)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateThing,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateThingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_353 = &_input.thing_name;
                let input_353 = input_353.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_name = aws_smithy_http::label::fmt_string(input_353, false);
                if thing_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/things/{thingName}", thingName = thing_name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateThingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_thing(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateThing::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateThing",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateThingInput`](crate::input::UpdateThingInput)
    pub fn builder() -> crate::input::update_thing_input::Builder {
        crate::input::update_thing_input::Builder::default()
    }
}

/// See [`UpdateThingGroupInput`](crate::input::UpdateThingGroupInput)
pub mod update_thing_group_input {

    /// A builder for [`UpdateThingGroupInput`](crate::input::UpdateThingGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_group_name: std::option::Option<std::string::String>,
        pub(crate) thing_group_properties: std::option::Option<crate::model::ThingGroupProperties>,
        pub(crate) expected_version: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The thing group to update.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_group_name = Some(input.into());
            self
        }
        /// <p>The thing group to update.</p>
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.thing_group_name = input;
            self
        }
        /// <p>The thing group properties.</p>
        pub fn thing_group_properties(mut self, input: crate::model::ThingGroupProperties) -> Self {
            self.thing_group_properties = Some(input);
            self
        }
        /// <p>The thing group properties.</p>
        pub fn set_thing_group_properties(
            mut self,
            input: std::option::Option<crate::model::ThingGroupProperties>,
        ) -> Self {
            self.thing_group_properties = input;
            self
        }
        /// <p>The expected version of the thing group. If this does not match the version of the thing group being updated, the update will fail.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.expected_version = Some(input);
            self
        }
        /// <p>The expected version of the thing group. If this does not match the version of the thing group being updated, the update will fail.</p>
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.expected_version = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateThingGroupInput`](crate::input::UpdateThingGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateThingGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateThingGroupInput {
                thing_group_name: self.thing_group_name,
                thing_group_properties: self.thing_group_properties,
                expected_version: self.expected_version,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateThingGroupInputOperationOutputAlias = crate::operation::UpdateThingGroup;
#[doc(hidden)]
pub type UpdateThingGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateThingGroupInput {
    /// Consumes the builder and constructs an Operation<[`UpdateThingGroup`](crate::operation::UpdateThingGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateThingGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateThingGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_354 = &_input.thing_group_name;
                let input_354 = input_354.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    },
                )?;
                let thing_group_name = aws_smithy_http::label::fmt_string(input_354, false);
                if thing_group_name.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "thing_group_name",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/thing-groups/{thingGroupName}",
                    thingGroupName = thing_group_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateThingGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_thing_group(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateThingGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateThingGroup",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateThingGroupInput`](crate::input::UpdateThingGroupInput)
    pub fn builder() -> crate::input::update_thing_group_input::Builder {
        crate::input::update_thing_group_input::Builder::default()
    }
}

/// See [`UpdateThingGroupsForThingInput`](crate::input::UpdateThingGroupsForThingInput)
pub mod update_thing_groups_for_thing_input {

    /// A builder for [`UpdateThingGroupsForThingInput`](crate::input::UpdateThingGroupsForThingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_name: std::option::Option<std::string::String>,
        pub(crate) thing_groups_to_add: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) thing_groups_to_remove: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) override_dynamic_groups: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The thing whose group memberships will be updated.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_name = Some(input.into());
            self
        }
        /// <p>The thing whose group memberships will be updated.</p>
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_name = input;
            self
        }
        /// Appends an item to `thing_groups_to_add`.
        ///
        /// To override the contents of this collection use [`set_thing_groups_to_add`](Self::set_thing_groups_to_add).
        ///
        /// <p>The groups to which the thing will be added.</p>
        pub fn thing_groups_to_add(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.thing_groups_to_add.unwrap_or_default();
            v.push(input.into());
            self.thing_groups_to_add = Some(v);
            self
        }
        /// <p>The groups to which the thing will be added.</p>
        pub fn set_thing_groups_to_add(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.thing_groups_to_add = input;
            self
        }
        /// Appends an item to `thing_groups_to_remove`.
        ///
        /// To override the contents of this collection use [`set_thing_groups_to_remove`](Self::set_thing_groups_to_remove).
        ///
        /// <p>The groups from which the thing will be removed.</p>
        pub fn thing_groups_to_remove(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.thing_groups_to_remove.unwrap_or_default();
            v.push(input.into());
            self.thing_groups_to_remove = Some(v);
            self
        }
        /// <p>The groups from which the thing will be removed.</p>
        pub fn set_thing_groups_to_remove(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.thing_groups_to_remove = input;
            self
        }
        /// <p>Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.</p>
        pub fn override_dynamic_groups(mut self, input: bool) -> Self {
            self.override_dynamic_groups = Some(input);
            self
        }
        /// <p>Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.</p>
        pub fn set_override_dynamic_groups(mut self, input: std::option::Option<bool>) -> Self {
            self.override_dynamic_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateThingGroupsForThingInput`](crate::input::UpdateThingGroupsForThingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateThingGroupsForThingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateThingGroupsForThingInput {
                thing_name: self.thing_name,
                thing_groups_to_add: self.thing_groups_to_add,
                thing_groups_to_remove: self.thing_groups_to_remove,
                override_dynamic_groups: self.override_dynamic_groups.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateThingGroupsForThingInputOperationOutputAlias =
    crate::operation::UpdateThingGroupsForThing;
#[doc(hidden)]
pub type UpdateThingGroupsForThingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateThingGroupsForThingInput {
    /// Consumes the builder and constructs an Operation<[`UpdateThingGroupsForThing`](crate::operation::UpdateThingGroupsForThing)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateThingGroupsForThing,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateThingGroupsForThingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/thing-groups/updateThingGroupsForThing")
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateThingGroupsForThingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_thing_groups_for_thing(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateThingGroupsForThing::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateThingGroupsForThing",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateThingGroupsForThingInput`](crate::input::UpdateThingGroupsForThingInput)
    pub fn builder() -> crate::input::update_thing_groups_for_thing_input::Builder {
        crate::input::update_thing_groups_for_thing_input::Builder::default()
    }
}

/// See [`UpdateTopicRuleDestinationInput`](crate::input::UpdateTopicRuleDestinationInput)
pub mod update_topic_rule_destination_input {

    /// A builder for [`UpdateTopicRuleDestinationInput`](crate::input::UpdateTopicRuleDestinationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TopicRuleDestinationStatus>,
    }
    impl Builder {
        /// <p>The ARN of the topic rule destination.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the topic rule destination.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The status of the topic rule destination. Valid values are:</p>
        /// <dl>
        /// <dt>
        /// IN_PROGRESS
        /// </dt>
        /// <dd>
        /// <p>A topic rule destination was created but has not been confirmed. You can set <code>status</code> to <code>IN_PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p>
        /// </dd>
        /// <dt>
        /// ENABLED
        /// </dt>
        /// <dd>
        /// <p>Confirmation was completed, and traffic to this destination is allowed. You can set <code>status</code> to <code>DISABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p>
        /// </dd>
        /// <dt>
        /// DISABLED
        /// </dt>
        /// <dd>
        /// <p>Confirmation was completed, and traffic to this destination is not allowed. You can set <code>status</code> to <code>ENABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p>
        /// </dd>
        /// <dt>
        /// ERROR
        /// </dt>
        /// <dd>
        /// <p>Confirmation could not be completed, for example if the confirmation timed out. You can call <code>GetTopicRuleDestination</code> for details about the error. You can set <code>status</code> to <code>IN_PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p>
        /// </dd>
        /// </dl>
        pub fn status(mut self, input: crate::model::TopicRuleDestinationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the topic rule destination. Valid values are:</p>
        /// <dl>
        /// <dt>
        /// IN_PROGRESS
        /// </dt>
        /// <dd>
        /// <p>A topic rule destination was created but has not been confirmed. You can set <code>status</code> to <code>IN_PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p>
        /// </dd>
        /// <dt>
        /// ENABLED
        /// </dt>
        /// <dd>
        /// <p>Confirmation was completed, and traffic to this destination is allowed. You can set <code>status</code> to <code>DISABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p>
        /// </dd>
        /// <dt>
        /// DISABLED
        /// </dt>
        /// <dd>
        /// <p>Confirmation was completed, and traffic to this destination is not allowed. You can set <code>status</code> to <code>ENABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p>
        /// </dd>
        /// <dt>
        /// ERROR
        /// </dt>
        /// <dd>
        /// <p>Confirmation could not be completed, for example if the confirmation timed out. You can call <code>GetTopicRuleDestination</code> for details about the error. You can set <code>status</code> to <code>IN_PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p>
        /// </dd>
        /// </dl>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TopicRuleDestinationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateTopicRuleDestinationInput`](crate::input::UpdateTopicRuleDestinationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateTopicRuleDestinationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateTopicRuleDestinationInput {
                arn: self.arn,
                status: self.status,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateTopicRuleDestinationInputOperationOutputAlias =
    crate::operation::UpdateTopicRuleDestination;
#[doc(hidden)]
pub type UpdateTopicRuleDestinationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateTopicRuleDestinationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateTopicRuleDestination`](crate::operation::UpdateTopicRuleDestination)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateTopicRuleDestination,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateTopicRuleDestinationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/destinations").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateTopicRuleDestinationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_topic_rule_destination(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateTopicRuleDestination::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateTopicRuleDestination",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateTopicRuleDestinationInput`](crate::input::UpdateTopicRuleDestinationInput)
    pub fn builder() -> crate::input::update_topic_rule_destination_input::Builder {
        crate::input::update_topic_rule_destination_input::Builder::default()
    }
}

/// See [`ValidateSecurityProfileBehaviorsInput`](crate::input::ValidateSecurityProfileBehaviorsInput)
pub mod validate_security_profile_behaviors_input {

    /// A builder for [`ValidateSecurityProfileBehaviorsInput`](crate::input::ValidateSecurityProfileBehaviorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) behaviors: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
    }
    impl Builder {
        /// Appends an item to `behaviors`.
        ///
        /// To override the contents of this collection use [`set_behaviors`](Self::set_behaviors).
        ///
        /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
        pub fn behaviors(mut self, input: crate::model::Behavior) -> Self {
            let mut v = self.behaviors.unwrap_or_default();
            v.push(input);
            self.behaviors = Some(v);
            self
        }
        /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
        pub fn set_behaviors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
        ) -> Self {
            self.behaviors = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidateSecurityProfileBehaviorsInput`](crate::input::ValidateSecurityProfileBehaviorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ValidateSecurityProfileBehaviorsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ValidateSecurityProfileBehaviorsInput {
                behaviors: self.behaviors,
            })
        }
    }
}
#[doc(hidden)]
pub type ValidateSecurityProfileBehaviorsInputOperationOutputAlias =
    crate::operation::ValidateSecurityProfileBehaviors;
#[doc(hidden)]
pub type ValidateSecurityProfileBehaviorsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ValidateSecurityProfileBehaviorsInput {
    /// Consumes the builder and constructs an Operation<[`ValidateSecurityProfileBehaviors`](crate::operation::ValidateSecurityProfileBehaviors)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ValidateSecurityProfileBehaviors,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ValidateSecurityProfileBehaviorsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/security-profile-behaviors/validate")
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ValidateSecurityProfileBehaviorsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_validate_security_profile_behaviors(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ValidateSecurityProfileBehaviors::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ValidateSecurityProfileBehaviors",
            "iot",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ValidateSecurityProfileBehaviorsInput`](crate::input::ValidateSecurityProfileBehaviorsInput)
    pub fn builder() -> crate::input::validate_security_profile_behaviors_input::Builder {
        crate::input::validate_security_profile_behaviors_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateSecurityProfileBehaviorsInput {
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    pub behaviors: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
}
impl ValidateSecurityProfileBehaviorsInput {
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    pub fn behaviors(&self) -> std::option::Option<&[crate::model::Behavior]> {
        self.behaviors.as_deref()
    }
}
impl std::fmt::Debug for ValidateSecurityProfileBehaviorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidateSecurityProfileBehaviorsInput");
        formatter.field("behaviors", &self.behaviors);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateTopicRuleDestinationInput {
    /// <p>The ARN of the topic rule destination.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The status of the topic rule destination. Valid values are:</p>
    /// <dl>
    /// <dt>
    /// IN_PROGRESS
    /// </dt>
    /// <dd>
    /// <p>A topic rule destination was created but has not been confirmed. You can set <code>status</code> to <code>IN_PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p>
    /// </dd>
    /// <dt>
    /// ENABLED
    /// </dt>
    /// <dd>
    /// <p>Confirmation was completed, and traffic to this destination is allowed. You can set <code>status</code> to <code>DISABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p>
    /// </dd>
    /// <dt>
    /// DISABLED
    /// </dt>
    /// <dd>
    /// <p>Confirmation was completed, and traffic to this destination is not allowed. You can set <code>status</code> to <code>ENABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p>
    /// </dd>
    /// <dt>
    /// ERROR
    /// </dt>
    /// <dd>
    /// <p>Confirmation could not be completed, for example if the confirmation timed out. You can call <code>GetTopicRuleDestination</code> for details about the error. You can set <code>status</code> to <code>IN_PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p>
    /// </dd>
    /// </dl>
    pub status: std::option::Option<crate::model::TopicRuleDestinationStatus>,
}
impl UpdateTopicRuleDestinationInput {
    /// <p>The ARN of the topic rule destination.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The status of the topic rule destination. Valid values are:</p>
    /// <dl>
    /// <dt>
    /// IN_PROGRESS
    /// </dt>
    /// <dd>
    /// <p>A topic rule destination was created but has not been confirmed. You can set <code>status</code> to <code>IN_PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p>
    /// </dd>
    /// <dt>
    /// ENABLED
    /// </dt>
    /// <dd>
    /// <p>Confirmation was completed, and traffic to this destination is allowed. You can set <code>status</code> to <code>DISABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p>
    /// </dd>
    /// <dt>
    /// DISABLED
    /// </dt>
    /// <dd>
    /// <p>Confirmation was completed, and traffic to this destination is not allowed. You can set <code>status</code> to <code>ENABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p>
    /// </dd>
    /// <dt>
    /// ERROR
    /// </dt>
    /// <dd>
    /// <p>Confirmation could not be completed, for example if the confirmation timed out. You can call <code>GetTopicRuleDestination</code> for details about the error. You can set <code>status</code> to <code>IN_PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p>
    /// </dd>
    /// </dl>
    pub fn status(&self) -> std::option::Option<&crate::model::TopicRuleDestinationStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for UpdateTopicRuleDestinationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateTopicRuleDestinationInput");
        formatter.field("arn", &self.arn);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateThingGroupsForThingInput {
    /// <p>The thing whose group memberships will be updated.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The groups to which the thing will be added.</p>
    pub thing_groups_to_add: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The groups from which the thing will be removed.</p>
    pub thing_groups_to_remove: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.</p>
    pub override_dynamic_groups: bool,
}
impl UpdateThingGroupsForThingInput {
    /// <p>The thing whose group memberships will be updated.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The groups to which the thing will be added.</p>
    pub fn thing_groups_to_add(&self) -> std::option::Option<&[std::string::String]> {
        self.thing_groups_to_add.as_deref()
    }
    /// <p>The groups from which the thing will be removed.</p>
    pub fn thing_groups_to_remove(&self) -> std::option::Option<&[std::string::String]> {
        self.thing_groups_to_remove.as_deref()
    }
    /// <p>Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.</p>
    pub fn override_dynamic_groups(&self) -> bool {
        self.override_dynamic_groups
    }
}
impl std::fmt::Debug for UpdateThingGroupsForThingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateThingGroupsForThingInput");
        formatter.field("thing_name", &self.thing_name);
        formatter.field("thing_groups_to_add", &self.thing_groups_to_add);
        formatter.field("thing_groups_to_remove", &self.thing_groups_to_remove);
        formatter.field("override_dynamic_groups", &self.override_dynamic_groups);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateThingGroupInput {
    /// <p>The thing group to update.</p>
    pub thing_group_name: std::option::Option<std::string::String>,
    /// <p>The thing group properties.</p>
    pub thing_group_properties: std::option::Option<crate::model::ThingGroupProperties>,
    /// <p>The expected version of the thing group. If this does not match the version of the thing group being updated, the update will fail.</p>
    pub expected_version: std::option::Option<i64>,
}
impl UpdateThingGroupInput {
    /// <p>The thing group to update.</p>
    pub fn thing_group_name(&self) -> std::option::Option<&str> {
        self.thing_group_name.as_deref()
    }
    /// <p>The thing group properties.</p>
    pub fn thing_group_properties(
        &self,
    ) -> std::option::Option<&crate::model::ThingGroupProperties> {
        self.thing_group_properties.as_ref()
    }
    /// <p>The expected version of the thing group. If this does not match the version of the thing group being updated, the update will fail.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
}
impl std::fmt::Debug for UpdateThingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateThingGroupInput");
        formatter.field("thing_group_name", &self.thing_group_name);
        formatter.field("thing_group_properties", &self.thing_group_properties);
        formatter.field("expected_version", &self.expected_version);
        formatter.finish()
    }
}

/// <p>The input for the UpdateThing operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateThingInput {
    /// <p>The name of the thing to update.</p>
    /// <p>You can't change a thing's name. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The name of the thing type.</p>
    pub thing_type_name: std::option::Option<std::string::String>,
    /// <p>A list of thing attributes, a JSON string containing name-value pairs. For example:</p>
    /// <p> <code>{\"attributes\":{\"name1\":\"value2\"}}</code> </p>
    /// <p>This data is used to add new attributes or update existing attributes.</p>
    pub attribute_payload: std::option::Option<crate::model::AttributePayload>,
    /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>UpdateThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
    pub expected_version: std::option::Option<i64>,
    /// <p>Remove a thing type association. If <b>true</b>, the association is removed.</p>
    pub remove_thing_type: bool,
}
impl UpdateThingInput {
    /// <p>The name of the thing to update.</p>
    /// <p>You can't change a thing's name. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The name of the thing type.</p>
    pub fn thing_type_name(&self) -> std::option::Option<&str> {
        self.thing_type_name.as_deref()
    }
    /// <p>A list of thing attributes, a JSON string containing name-value pairs. For example:</p>
    /// <p> <code>{\"attributes\":{\"name1\":\"value2\"}}</code> </p>
    /// <p>This data is used to add new attributes or update existing attributes.</p>
    pub fn attribute_payload(&self) -> std::option::Option<&crate::model::AttributePayload> {
        self.attribute_payload.as_ref()
    }
    /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>UpdateThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
    /// <p>Remove a thing type association. If <b>true</b>, the association is removed.</p>
    pub fn remove_thing_type(&self) -> bool {
        self.remove_thing_type
    }
}
impl std::fmt::Debug for UpdateThingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateThingInput");
        formatter.field("thing_name", &self.thing_name);
        formatter.field("thing_type_name", &self.thing_type_name);
        formatter.field("attribute_payload", &self.attribute_payload);
        formatter.field("expected_version", &self.expected_version);
        formatter.field("remove_thing_type", &self.remove_thing_type);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateStreamInput {
    /// <p>The stream ID.</p>
    pub stream_id: std::option::Option<std::string::String>,
    /// <p>The description of the stream.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The files associated with the stream.</p>
    pub files: std::option::Option<std::vec::Vec<crate::model::StreamFile>>,
    /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
    pub role_arn: std::option::Option<std::string::String>,
}
impl UpdateStreamInput {
    /// <p>The stream ID.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
    /// <p>The description of the stream.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The files associated with the stream.</p>
    pub fn files(&self) -> std::option::Option<&[crate::model::StreamFile]> {
        self.files.as_deref()
    }
    /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl std::fmt::Debug for UpdateStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateStreamInput");
        formatter.field("stream_id", &self.stream_id);
        formatter.field("description", &self.description);
        formatter.field("files", &self.files);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSecurityProfileInput {
    /// <p>The name of the security profile you want to update.</p>
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p>A description of the security profile.</p>
    pub security_profile_description: std::option::Option<std::string::String>,
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    pub behaviors: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
    /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
    pub alert_targets: std::option::Option<
        std::collections::HashMap<crate::model::AlertTargetType, crate::model::AlertTarget>,
    >,
    /// <p> <i>Please use <code>UpdateSecurityProfileRequest$additionalMetricsToRetainV2</code> instead.</i> </p>
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    pub additional_metrics_to_retain: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    pub additional_metrics_to_retain_v2:
        std::option::Option<std::vec::Vec<crate::model::MetricToRetain>>,
    /// <p>If true, delete all <code>behaviors</code> defined for this security profile. If any <code>behaviors</code> are defined in the current invocation, an exception occurs.</p>
    pub delete_behaviors: bool,
    /// <p>If true, delete all <code>alertTargets</code> defined for this security profile. If any <code>alertTargets</code> are defined in the current invocation, an exception occurs.</p>
    pub delete_alert_targets: bool,
    /// <p>If true, delete all <code>additionalMetricsToRetain</code> defined for this security profile. If any <code>additionalMetricsToRetain</code> are defined in the current invocation, an exception occurs.</p>
    pub delete_additional_metrics_to_retain: bool,
    /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.</p>
    pub expected_version: std::option::Option<i64>,
}
impl UpdateSecurityProfileInput {
    /// <p>The name of the security profile you want to update.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p>A description of the security profile.</p>
    pub fn security_profile_description(&self) -> std::option::Option<&str> {
        self.security_profile_description.as_deref()
    }
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    pub fn behaviors(&self) -> std::option::Option<&[crate::model::Behavior]> {
        self.behaviors.as_deref()
    }
    /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
    pub fn alert_targets(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::AlertTargetType, crate::model::AlertTarget>,
    > {
        self.alert_targets.as_ref()
    }
    /// <p> <i>Please use <code>UpdateSecurityProfileRequest$additionalMetricsToRetainV2</code> instead.</i> </p>
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    pub fn additional_metrics_to_retain(&self) -> std::option::Option<&[std::string::String]> {
        self.additional_metrics_to_retain.as_deref()
    }
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    pub fn additional_metrics_to_retain_v2(
        &self,
    ) -> std::option::Option<&[crate::model::MetricToRetain]> {
        self.additional_metrics_to_retain_v2.as_deref()
    }
    /// <p>If true, delete all <code>behaviors</code> defined for this security profile. If any <code>behaviors</code> are defined in the current invocation, an exception occurs.</p>
    pub fn delete_behaviors(&self) -> bool {
        self.delete_behaviors
    }
    /// <p>If true, delete all <code>alertTargets</code> defined for this security profile. If any <code>alertTargets</code> are defined in the current invocation, an exception occurs.</p>
    pub fn delete_alert_targets(&self) -> bool {
        self.delete_alert_targets
    }
    /// <p>If true, delete all <code>additionalMetricsToRetain</code> defined for this security profile. If any <code>additionalMetricsToRetain</code> are defined in the current invocation, an exception occurs.</p>
    pub fn delete_additional_metrics_to_retain(&self) -> bool {
        self.delete_additional_metrics_to_retain
    }
    /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
}
impl std::fmt::Debug for UpdateSecurityProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSecurityProfileInput");
        formatter.field("security_profile_name", &self.security_profile_name);
        formatter.field(
            "security_profile_description",
            &self.security_profile_description,
        );
        formatter.field("behaviors", &self.behaviors);
        formatter.field("alert_targets", &self.alert_targets);
        formatter.field(
            "additional_metrics_to_retain",
            &self.additional_metrics_to_retain,
        );
        formatter.field(
            "additional_metrics_to_retain_v2",
            &self.additional_metrics_to_retain_v2,
        );
        formatter.field("delete_behaviors", &self.delete_behaviors);
        formatter.field("delete_alert_targets", &self.delete_alert_targets);
        formatter.field(
            "delete_additional_metrics_to_retain",
            &self.delete_additional_metrics_to_retain,
        );
        formatter.field("expected_version", &self.expected_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateScheduledAuditInput {
    /// <p>How often the scheduled audit takes place, either <code>DAILY</code>, <code>WEEKLY</code>, <code>BIWEEKLY</code>, or <code>MONTHLY</code>. The start time of each audit is determined by the system.</p>
    pub frequency: std::option::Option<crate::model::AuditFrequency>,
    /// <p>The day of the month on which the scheduled audit takes place. This can be <code>1</code> through <code>31</code> or <code>LAST</code>. This field is required if the <code>frequency</code> parameter is set to <code>MONTHLY</code>. If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
    pub day_of_month: std::option::Option<std::string::String>,
    /// <p>The day of the week on which the scheduled audit takes place. This can be one of <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the "frequency" parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
    pub day_of_week: std::option::Option<crate::model::DayOfWeek>,
    /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub target_check_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the scheduled audit. (Max. 128 chars)</p>
    pub scheduled_audit_name: std::option::Option<std::string::String>,
}
impl UpdateScheduledAuditInput {
    /// <p>How often the scheduled audit takes place, either <code>DAILY</code>, <code>WEEKLY</code>, <code>BIWEEKLY</code>, or <code>MONTHLY</code>. The start time of each audit is determined by the system.</p>
    pub fn frequency(&self) -> std::option::Option<&crate::model::AuditFrequency> {
        self.frequency.as_ref()
    }
    /// <p>The day of the month on which the scheduled audit takes place. This can be <code>1</code> through <code>31</code> or <code>LAST</code>. This field is required if the <code>frequency</code> parameter is set to <code>MONTHLY</code>. If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
    pub fn day_of_month(&self) -> std::option::Option<&str> {
        self.day_of_month.as_deref()
    }
    /// <p>The day of the week on which the scheduled audit takes place. This can be one of <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the "frequency" parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
    pub fn day_of_week(&self) -> std::option::Option<&crate::model::DayOfWeek> {
        self.day_of_week.as_ref()
    }
    /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub fn target_check_names(&self) -> std::option::Option<&[std::string::String]> {
        self.target_check_names.as_deref()
    }
    /// <p>The name of the scheduled audit. (Max. 128 chars)</p>
    pub fn scheduled_audit_name(&self) -> std::option::Option<&str> {
        self.scheduled_audit_name.as_deref()
    }
}
impl std::fmt::Debug for UpdateScheduledAuditInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateScheduledAuditInput");
        formatter.field("frequency", &self.frequency);
        formatter.field("day_of_month", &self.day_of_month);
        formatter.field("day_of_week", &self.day_of_week);
        formatter.field("target_check_names", &self.target_check_names);
        formatter.field("scheduled_audit_name", &self.scheduled_audit_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRoleAliasInput {
    /// <p>The role alias to update.</p>
    pub role_alias: std::option::Option<std::string::String>,
    /// <p>The role ARN.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The number of seconds the credential will be valid.</p>
    /// <p>This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.</p>
    pub credential_duration_seconds: std::option::Option<i32>,
}
impl UpdateRoleAliasInput {
    /// <p>The role alias to update.</p>
    pub fn role_alias(&self) -> std::option::Option<&str> {
        self.role_alias.as_deref()
    }
    /// <p>The role ARN.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The number of seconds the credential will be valid.</p>
    /// <p>This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.</p>
    pub fn credential_duration_seconds(&self) -> std::option::Option<i32> {
        self.credential_duration_seconds
    }
}
impl std::fmt::Debug for UpdateRoleAliasInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRoleAliasInput");
        formatter.field("role_alias", &self.role_alias);
        formatter.field("role_arn", &self.role_arn);
        formatter.field(
            "credential_duration_seconds",
            &self.credential_duration_seconds,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateProvisioningTemplateInput {
    /// <p>The name of the fleet provisioning template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The description of the fleet provisioning template.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>True to enable the fleet provisioning template, otherwise false.</p>
    pub enabled: bool,
    /// <p>The ID of the default provisioning template version.</p>
    pub default_version_id: std::option::Option<i32>,
    /// <p>The ARN of the role associated with the provisioning template. This IoT role grants permission to provision a device.</p>
    pub provisioning_role_arn: std::option::Option<std::string::String>,
    /// <p>Updates the pre-provisioning hook template.</p>
    pub pre_provisioning_hook: std::option::Option<crate::model::ProvisioningHook>,
    /// <p>Removes pre-provisioning hook template.</p>
    pub remove_pre_provisioning_hook: std::option::Option<bool>,
}
impl UpdateProvisioningTemplateInput {
    /// <p>The name of the fleet provisioning template.</p>
    pub fn template_name(&self) -> std::option::Option<&str> {
        self.template_name.as_deref()
    }
    /// <p>The description of the fleet provisioning template.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>True to enable the fleet provisioning template, otherwise false.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>The ID of the default provisioning template version.</p>
    pub fn default_version_id(&self) -> std::option::Option<i32> {
        self.default_version_id
    }
    /// <p>The ARN of the role associated with the provisioning template. This IoT role grants permission to provision a device.</p>
    pub fn provisioning_role_arn(&self) -> std::option::Option<&str> {
        self.provisioning_role_arn.as_deref()
    }
    /// <p>Updates the pre-provisioning hook template.</p>
    pub fn pre_provisioning_hook(&self) -> std::option::Option<&crate::model::ProvisioningHook> {
        self.pre_provisioning_hook.as_ref()
    }
    /// <p>Removes pre-provisioning hook template.</p>
    pub fn remove_pre_provisioning_hook(&self) -> std::option::Option<bool> {
        self.remove_pre_provisioning_hook
    }
}
impl std::fmt::Debug for UpdateProvisioningTemplateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateProvisioningTemplateInput");
        formatter.field("template_name", &self.template_name);
        formatter.field("description", &self.description);
        formatter.field("enabled", &self.enabled);
        formatter.field("default_version_id", &self.default_version_id);
        formatter.field("provisioning_role_arn", &self.provisioning_role_arn);
        formatter.field("pre_provisioning_hook", &self.pre_provisioning_hook);
        formatter.field(
            "remove_pre_provisioning_hook",
            &self.remove_pre_provisioning_hook,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMitigationActionInput {
    /// <p>The friendly name for the mitigation action. You cannot change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and recreate the mitigation action with the new name.</p>
    pub action_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Defines the type of action and the parameters for that action.</p>
    pub action_params: std::option::Option<crate::model::MitigationActionParams>,
}
impl UpdateMitigationActionInput {
    /// <p>The friendly name for the mitigation action. You cannot change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and recreate the mitigation action with the new name.</p>
    pub fn action_name(&self) -> std::option::Option<&str> {
        self.action_name.as_deref()
    }
    /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>Defines the type of action and the parameters for that action.</p>
    pub fn action_params(&self) -> std::option::Option<&crate::model::MitigationActionParams> {
        self.action_params.as_ref()
    }
}
impl std::fmt::Debug for UpdateMitigationActionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMitigationActionInput");
        formatter.field("action_name", &self.action_name);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("action_params", &self.action_params);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateJobInput {
    /// <p>The ID of the job to be updated.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>A short text description of the job.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Configuration information for pre-signed S3 URLs.</p>
    pub presigned_url_config: std::option::Option<crate::model::PresignedUrlConfig>,
    /// <p>Allows you to create a staged rollout of the job.</p>
    pub job_executions_rollout_config:
        std::option::Option<crate::model::JobExecutionsRolloutConfig>,
    /// <p>Allows you to create criteria to abort a job.</p>
    pub abort_config: std::option::Option<crate::model::AbortConfig>,
    /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>. </p>
    pub timeout_config: std::option::Option<crate::model::TimeoutConfig>,
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub namespace_id: std::option::Option<std::string::String>,
    /// <p>Allows you to create the criteria to retry a job.</p>
    pub job_executions_retry_config: std::option::Option<crate::model::JobExecutionsRetryConfig>,
}
impl UpdateJobInput {
    /// <p>The ID of the job to be updated.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>A short text description of the job.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Configuration information for pre-signed S3 URLs.</p>
    pub fn presigned_url_config(&self) -> std::option::Option<&crate::model::PresignedUrlConfig> {
        self.presigned_url_config.as_ref()
    }
    /// <p>Allows you to create a staged rollout of the job.</p>
    pub fn job_executions_rollout_config(
        &self,
    ) -> std::option::Option<&crate::model::JobExecutionsRolloutConfig> {
        self.job_executions_rollout_config.as_ref()
    }
    /// <p>Allows you to create criteria to abort a job.</p>
    pub fn abort_config(&self) -> std::option::Option<&crate::model::AbortConfig> {
        self.abort_config.as_ref()
    }
    /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>. </p>
    pub fn timeout_config(&self) -> std::option::Option<&crate::model::TimeoutConfig> {
        self.timeout_config.as_ref()
    }
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub fn namespace_id(&self) -> std::option::Option<&str> {
        self.namespace_id.as_deref()
    }
    /// <p>Allows you to create the criteria to retry a job.</p>
    pub fn job_executions_retry_config(
        &self,
    ) -> std::option::Option<&crate::model::JobExecutionsRetryConfig> {
        self.job_executions_retry_config.as_ref()
    }
}
impl std::fmt::Debug for UpdateJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateJobInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("description", &self.description);
        formatter.field("presigned_url_config", &self.presigned_url_config);
        formatter.field(
            "job_executions_rollout_config",
            &self.job_executions_rollout_config,
        );
        formatter.field("abort_config", &self.abort_config);
        formatter.field("timeout_config", &self.timeout_config);
        formatter.field("namespace_id", &self.namespace_id);
        formatter.field(
            "job_executions_retry_config",
            &self.job_executions_retry_config,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateIndexingConfigurationInput {
    /// <p>Thing indexing configuration.</p>
    pub thing_indexing_configuration: std::option::Option<crate::model::ThingIndexingConfiguration>,
    /// <p>Thing group indexing configuration.</p>
    pub thing_group_indexing_configuration:
        std::option::Option<crate::model::ThingGroupIndexingConfiguration>,
}
impl UpdateIndexingConfigurationInput {
    /// <p>Thing indexing configuration.</p>
    pub fn thing_indexing_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ThingIndexingConfiguration> {
        self.thing_indexing_configuration.as_ref()
    }
    /// <p>Thing group indexing configuration.</p>
    pub fn thing_group_indexing_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ThingGroupIndexingConfiguration> {
        self.thing_group_indexing_configuration.as_ref()
    }
}
impl std::fmt::Debug for UpdateIndexingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateIndexingConfigurationInput");
        formatter.field(
            "thing_indexing_configuration",
            &self.thing_indexing_configuration,
        );
        formatter.field(
            "thing_group_indexing_configuration",
            &self.thing_group_indexing_configuration,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateFleetMetricInput {
    /// <p>The name of the fleet metric to update.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The search query string.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The type of the aggregation query.</p>
    pub aggregation_type: std::option::Option<crate::model::AggregationType>,
    /// <p>The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.</p>
    pub period: std::option::Option<i32>,
    /// <p>The field to aggregate.</p>
    pub aggregation_field: std::option::Option<std::string::String>,
    /// <p>The description of the fleet metric.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The version of the query.</p>
    pub query_version: std::option::Option<std::string::String>,
    /// <p>The name of the index to search.</p>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>Used to support unit transformation such as milliseconds to seconds. The unit must be supported by <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html">CW metric</a>.</p>
    pub unit: std::option::Option<crate::model::FleetMetricUnit>,
    /// <p>The expected version of the fleet metric record in the registry.</p>
    pub expected_version: std::option::Option<i64>,
}
impl UpdateFleetMetricInput {
    /// <p>The name of the fleet metric to update.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The search query string.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The type of the aggregation query.</p>
    pub fn aggregation_type(&self) -> std::option::Option<&crate::model::AggregationType> {
        self.aggregation_type.as_ref()
    }
    /// <p>The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.</p>
    pub fn period(&self) -> std::option::Option<i32> {
        self.period
    }
    /// <p>The field to aggregate.</p>
    pub fn aggregation_field(&self) -> std::option::Option<&str> {
        self.aggregation_field.as_deref()
    }
    /// <p>The description of the fleet metric.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The version of the query.</p>
    pub fn query_version(&self) -> std::option::Option<&str> {
        self.query_version.as_deref()
    }
    /// <p>The name of the index to search.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>Used to support unit transformation such as milliseconds to seconds. The unit must be supported by <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html">CW metric</a>.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::FleetMetricUnit> {
        self.unit.as_ref()
    }
    /// <p>The expected version of the fleet metric record in the registry.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
}
impl std::fmt::Debug for UpdateFleetMetricInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateFleetMetricInput");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("query_string", &self.query_string);
        formatter.field("aggregation_type", &self.aggregation_type);
        formatter.field("period", &self.period);
        formatter.field("aggregation_field", &self.aggregation_field);
        formatter.field("description", &self.description);
        formatter.field("query_version", &self.query_version);
        formatter.field("index_name", &self.index_name);
        formatter.field("unit", &self.unit);
        formatter.field("expected_version", &self.expected_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEventConfigurationsInput {
    /// <p>The new event configuration values.</p>
    pub event_configurations: std::option::Option<
        std::collections::HashMap<crate::model::EventType, crate::model::Configuration>,
    >,
}
impl UpdateEventConfigurationsInput {
    /// <p>The new event configuration values.</p>
    pub fn event_configurations(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::EventType, crate::model::Configuration>,
    > {
        self.event_configurations.as_ref()
    }
}
impl std::fmt::Debug for UpdateEventConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEventConfigurationsInput");
        formatter.field("event_configurations", &self.event_configurations);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDynamicThingGroupInput {
    /// <p>The name of the dynamic thing group to update.</p>
    pub thing_group_name: std::option::Option<std::string::String>,
    /// <p>The dynamic thing group properties to update.</p>
    pub thing_group_properties: std::option::Option<crate::model::ThingGroupProperties>,
    /// <p>The expected version of the dynamic thing group to update.</p>
    pub expected_version: std::option::Option<i64>,
    /// <p>The dynamic thing group index to update.</p> <note>
    /// <p>Currently one index is supported: <code>AWS_Things</code>.</p>
    /// </note>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The dynamic thing group search query string to update.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The dynamic thing group query version to update.</p> <note>
    /// <p>Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.</p>
    /// </note>
    pub query_version: std::option::Option<std::string::String>,
}
impl UpdateDynamicThingGroupInput {
    /// <p>The name of the dynamic thing group to update.</p>
    pub fn thing_group_name(&self) -> std::option::Option<&str> {
        self.thing_group_name.as_deref()
    }
    /// <p>The dynamic thing group properties to update.</p>
    pub fn thing_group_properties(
        &self,
    ) -> std::option::Option<&crate::model::ThingGroupProperties> {
        self.thing_group_properties.as_ref()
    }
    /// <p>The expected version of the dynamic thing group to update.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
    /// <p>The dynamic thing group index to update.</p> <note>
    /// <p>Currently one index is supported: <code>AWS_Things</code>.</p>
    /// </note>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>The dynamic thing group search query string to update.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The dynamic thing group query version to update.</p> <note>
    /// <p>Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.</p>
    /// </note>
    pub fn query_version(&self) -> std::option::Option<&str> {
        self.query_version.as_deref()
    }
}
impl std::fmt::Debug for UpdateDynamicThingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDynamicThingGroupInput");
        formatter.field("thing_group_name", &self.thing_group_name);
        formatter.field("thing_group_properties", &self.thing_group_properties);
        formatter.field("expected_version", &self.expected_version);
        formatter.field("index_name", &self.index_name);
        formatter.field("query_string", &self.query_string);
        formatter.field("query_version", &self.query_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDomainConfigurationInput {
    /// <p>The name of the domain configuration to be updated.</p>
    pub domain_configuration_name: std::option::Option<std::string::String>,
    /// <p>An object that specifies the authorization service for a domain.</p>
    pub authorizer_config: std::option::Option<crate::model::AuthorizerConfig>,
    /// <p>The status to which the domain configuration should be updated.</p>
    pub domain_configuration_status: std::option::Option<crate::model::DomainConfigurationStatus>,
    /// <p>Removes the authorization configuration from a domain.</p>
    pub remove_authorizer_config: bool,
}
impl UpdateDomainConfigurationInput {
    /// <p>The name of the domain configuration to be updated.</p>
    pub fn domain_configuration_name(&self) -> std::option::Option<&str> {
        self.domain_configuration_name.as_deref()
    }
    /// <p>An object that specifies the authorization service for a domain.</p>
    pub fn authorizer_config(&self) -> std::option::Option<&crate::model::AuthorizerConfig> {
        self.authorizer_config.as_ref()
    }
    /// <p>The status to which the domain configuration should be updated.</p>
    pub fn domain_configuration_status(
        &self,
    ) -> std::option::Option<&crate::model::DomainConfigurationStatus> {
        self.domain_configuration_status.as_ref()
    }
    /// <p>Removes the authorization configuration from a domain.</p>
    pub fn remove_authorizer_config(&self) -> bool {
        self.remove_authorizer_config
    }
}
impl std::fmt::Debug for UpdateDomainConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDomainConfigurationInput");
        formatter.field("domain_configuration_name", &self.domain_configuration_name);
        formatter.field("authorizer_config", &self.authorizer_config);
        formatter.field(
            "domain_configuration_status",
            &self.domain_configuration_status,
        );
        formatter.field("remove_authorizer_config", &self.remove_authorizer_config);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDimensionInput {
    /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
    pub string_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UpdateDimensionInput {
    /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
    pub fn string_values(&self) -> std::option::Option<&[std::string::String]> {
        self.string_values.as_deref()
    }
}
impl std::fmt::Debug for UpdateDimensionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDimensionInput");
        formatter.field("name", &self.name);
        formatter.field("string_values", &self.string_values);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateCustomMetricInput {
    /// <p> The name of the custom metric. Cannot be updated. </p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p> Field represents a friendly name in the console for the custom metric, it doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. Can be updated. </p>
    pub display_name: std::option::Option<std::string::String>,
}
impl UpdateCustomMetricInput {
    /// <p> The name of the custom metric. Cannot be updated. </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p> Field represents a friendly name in the console for the custom metric, it doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. Can be updated. </p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
}
impl std::fmt::Debug for UpdateCustomMetricInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateCustomMetricInput");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("display_name", &self.display_name);
        formatter.finish()
    }
}

/// <p>The input for the UpdateCertificate operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateCertificateInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub certificate_id: std::option::Option<std::string::String>,
    /// <p>The new status.</p>
    /// <p> <b>Note:</b> Setting the status to PENDING_TRANSFER or PENDING_ACTIVATION will result in an exception being thrown. PENDING_TRANSFER and PENDING_ACTIVATION are statuses used internally by IoT. They are not intended for developer use.</p>
    /// <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    pub new_status: std::option::Option<crate::model::CertificateStatus>,
}
impl UpdateCertificateInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub fn certificate_id(&self) -> std::option::Option<&str> {
        self.certificate_id.as_deref()
    }
    /// <p>The new status.</p>
    /// <p> <b>Note:</b> Setting the status to PENDING_TRANSFER or PENDING_ACTIVATION will result in an exception being thrown. PENDING_TRANSFER and PENDING_ACTIVATION are statuses used internally by IoT. They are not intended for developer use.</p>
    /// <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    pub fn new_status(&self) -> std::option::Option<&crate::model::CertificateStatus> {
        self.new_status.as_ref()
    }
}
impl std::fmt::Debug for UpdateCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateCertificateInput");
        formatter.field("certificate_id", &self.certificate_id);
        formatter.field("new_status", &self.new_status);
        formatter.finish()
    }
}

/// <p>The input to the UpdateCACertificate operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateCaCertificateInput {
    /// <p>The CA certificate identifier.</p>
    pub certificate_id: std::option::Option<std::string::String>,
    /// <p>The updated status of the CA certificate.</p>
    /// <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    pub new_status: std::option::Option<crate::model::CaCertificateStatus>,
    /// <p>The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".</p>
    pub new_auto_registration_status: std::option::Option<crate::model::AutoRegistrationStatus>,
    /// <p>Information about the registration configuration.</p>
    pub registration_config: std::option::Option<crate::model::RegistrationConfig>,
    /// <p>If true, removes auto registration.</p>
    pub remove_auto_registration: bool,
}
impl UpdateCaCertificateInput {
    /// <p>The CA certificate identifier.</p>
    pub fn certificate_id(&self) -> std::option::Option<&str> {
        self.certificate_id.as_deref()
    }
    /// <p>The updated status of the CA certificate.</p>
    /// <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    pub fn new_status(&self) -> std::option::Option<&crate::model::CaCertificateStatus> {
        self.new_status.as_ref()
    }
    /// <p>The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".</p>
    pub fn new_auto_registration_status(
        &self,
    ) -> std::option::Option<&crate::model::AutoRegistrationStatus> {
        self.new_auto_registration_status.as_ref()
    }
    /// <p>Information about the registration configuration.</p>
    pub fn registration_config(&self) -> std::option::Option<&crate::model::RegistrationConfig> {
        self.registration_config.as_ref()
    }
    /// <p>If true, removes auto registration.</p>
    pub fn remove_auto_registration(&self) -> bool {
        self.remove_auto_registration
    }
}
impl std::fmt::Debug for UpdateCaCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateCaCertificateInput");
        formatter.field("certificate_id", &self.certificate_id);
        formatter.field("new_status", &self.new_status);
        formatter.field(
            "new_auto_registration_status",
            &self.new_auto_registration_status,
        );
        formatter.field("registration_config", &self.registration_config);
        formatter.field("remove_auto_registration", &self.remove_auto_registration);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateBillingGroupInput {
    /// <p>The name of the billing group.</p>
    pub billing_group_name: std::option::Option<std::string::String>,
    /// <p>The properties of the billing group.</p>
    pub billing_group_properties: std::option::Option<crate::model::BillingGroupProperties>,
    /// <p>The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>UpdateBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.</p>
    pub expected_version: std::option::Option<i64>,
}
impl UpdateBillingGroupInput {
    /// <p>The name of the billing group.</p>
    pub fn billing_group_name(&self) -> std::option::Option<&str> {
        self.billing_group_name.as_deref()
    }
    /// <p>The properties of the billing group.</p>
    pub fn billing_group_properties(
        &self,
    ) -> std::option::Option<&crate::model::BillingGroupProperties> {
        self.billing_group_properties.as_ref()
    }
    /// <p>The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>UpdateBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
}
impl std::fmt::Debug for UpdateBillingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateBillingGroupInput");
        formatter.field("billing_group_name", &self.billing_group_name);
        formatter.field("billing_group_properties", &self.billing_group_properties);
        formatter.field("expected_version", &self.expected_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAuthorizerInput {
    /// <p>The authorizer name.</p>
    pub authorizer_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the authorizer's Lambda function.</p>
    pub authorizer_function_arn: std::option::Option<std::string::String>,
    /// <p>The key used to extract the token from the HTTP headers. </p>
    pub token_key_name: std::option::Option<std::string::String>,
    /// <p>The public keys used to verify the token signature.</p>
    pub token_signing_public_keys:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The status of the update authorizer request.</p>
    pub status: std::option::Option<crate::model::AuthorizerStatus>,
    /// <p>When <code>true</code>, the result from the authorizers Lambda function is cached for the time specified in <code>refreshAfterInSeconds</code>. The cached result is used while the device reuses the same HTTP connection.</p>
    pub enable_caching_for_http: std::option::Option<bool>,
}
impl UpdateAuthorizerInput {
    /// <p>The authorizer name.</p>
    pub fn authorizer_name(&self) -> std::option::Option<&str> {
        self.authorizer_name.as_deref()
    }
    /// <p>The ARN of the authorizer's Lambda function.</p>
    pub fn authorizer_function_arn(&self) -> std::option::Option<&str> {
        self.authorizer_function_arn.as_deref()
    }
    /// <p>The key used to extract the token from the HTTP headers. </p>
    pub fn token_key_name(&self) -> std::option::Option<&str> {
        self.token_key_name.as_deref()
    }
    /// <p>The public keys used to verify the token signature.</p>
    pub fn token_signing_public_keys(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.token_signing_public_keys.as_ref()
    }
    /// <p>The status of the update authorizer request.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AuthorizerStatus> {
        self.status.as_ref()
    }
    /// <p>When <code>true</code>, the result from the authorizers Lambda function is cached for the time specified in <code>refreshAfterInSeconds</code>. The cached result is used while the device reuses the same HTTP connection.</p>
    pub fn enable_caching_for_http(&self) -> std::option::Option<bool> {
        self.enable_caching_for_http
    }
}
impl std::fmt::Debug for UpdateAuthorizerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAuthorizerInput");
        formatter.field("authorizer_name", &self.authorizer_name);
        formatter.field("authorizer_function_arn", &self.authorizer_function_arn);
        formatter.field("token_key_name", &self.token_key_name);
        formatter.field("token_signing_public_keys", &self.token_signing_public_keys);
        formatter.field("status", &self.status);
        formatter.field("enable_caching_for_http", &self.enable_caching_for_http);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAuditSuppressionInput {
    /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub check_name: std::option::Option<std::string::String>,
    /// <p>Information that identifies the noncompliant resource.</p>
    pub resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
    /// <p> The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to. </p>
    pub expiration_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> Indicates whether a suppression should exist indefinitely or not. </p>
    pub suppress_indefinitely: std::option::Option<bool>,
    /// <p> The description of the audit suppression. </p>
    pub description: std::option::Option<std::string::String>,
}
impl UpdateAuditSuppressionInput {
    /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub fn check_name(&self) -> std::option::Option<&str> {
        self.check_name.as_deref()
    }
    /// <p>Information that identifies the noncompliant resource.</p>
    pub fn resource_identifier(&self) -> std::option::Option<&crate::model::ResourceIdentifier> {
        self.resource_identifier.as_ref()
    }
    /// <p> The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to. </p>
    pub fn expiration_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expiration_date.as_ref()
    }
    /// <p> Indicates whether a suppression should exist indefinitely or not. </p>
    pub fn suppress_indefinitely(&self) -> std::option::Option<bool> {
        self.suppress_indefinitely
    }
    /// <p> The description of the audit suppression. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl std::fmt::Debug for UpdateAuditSuppressionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAuditSuppressionInput");
        formatter.field("check_name", &self.check_name);
        formatter.field("resource_identifier", &self.resource_identifier);
        formatter.field("expiration_date", &self.expiration_date);
        formatter.field("suppress_indefinitely", &self.suppress_indefinitely);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAccountAuditConfigurationInput {
    /// <p>The Amazon Resource Name (ARN) of the role that grants permission to IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Information about the targets to which audit notifications are sent.</p>
    pub audit_notification_target_configurations: std::option::Option<
        std::collections::HashMap<
            crate::model::AuditNotificationType,
            crate::model::AuditNotificationTarget,
        >,
    >,
    /// <p>Specifies which audit checks are enabled and disabled for this account. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are currently enabled.</p>
    /// <p>Some data collection might start immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted.</p>
    /// <p>You cannot disable a check if it's used by any scheduled audit. You must first delete the check from the scheduled audit or delete the scheduled audit itself.</p>
    /// <p>On the first call to <code>UpdateAccountAuditConfiguration</code>, this parameter is required and must specify at least one enabled check.</p>
    pub audit_check_configurations: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AuditCheckConfiguration>,
    >,
}
impl UpdateAccountAuditConfigurationInput {
    /// <p>The Amazon Resource Name (ARN) of the role that grants permission to IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>Information about the targets to which audit notifications are sent.</p>
    pub fn audit_notification_target_configurations(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            crate::model::AuditNotificationType,
            crate::model::AuditNotificationTarget,
        >,
    > {
        self.audit_notification_target_configurations.as_ref()
    }
    /// <p>Specifies which audit checks are enabled and disabled for this account. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are currently enabled.</p>
    /// <p>Some data collection might start immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted.</p>
    /// <p>You cannot disable a check if it's used by any scheduled audit. You must first delete the check from the scheduled audit or delete the scheduled audit itself.</p>
    /// <p>On the first call to <code>UpdateAccountAuditConfiguration</code>, this parameter is required and must specify at least one enabled check.</p>
    pub fn audit_check_configurations(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::AuditCheckConfiguration>,
    > {
        self.audit_check_configurations.as_ref()
    }
}
impl std::fmt::Debug for UpdateAccountAuditConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAccountAuditConfigurationInput");
        formatter.field("role_arn", &self.role_arn);
        formatter.field(
            "audit_notification_target_configurations",
            &self.audit_notification_target_configurations,
        );
        formatter.field(
            "audit_check_configurations",
            &self.audit_check_configurations,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The ARN of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A list of the keys of the tags to be removed from the resource.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>A list of the keys of the tags to be removed from the resource.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

/// <p>The input for the TransferCertificate operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransferCertificateInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub certificate_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account.</p>
    pub target_aws_account: std::option::Option<std::string::String>,
    /// <p>The transfer message.</p>
    pub transfer_message: std::option::Option<std::string::String>,
}
impl TransferCertificateInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub fn certificate_id(&self) -> std::option::Option<&str> {
        self.certificate_id.as_deref()
    }
    /// <p>The Amazon Web Services account.</p>
    pub fn target_aws_account(&self) -> std::option::Option<&str> {
        self.target_aws_account.as_deref()
    }
    /// <p>The transfer message.</p>
    pub fn transfer_message(&self) -> std::option::Option<&str> {
        self.transfer_message.as_deref()
    }
}
impl std::fmt::Debug for TransferCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransferCertificateInput");
        formatter.field("certificate_id", &self.certificate_id);
        formatter.field("target_aws_account", &self.target_aws_account);
        formatter.field("transfer_message", &self.transfer_message);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TestInvokeAuthorizerInput {
    /// <p>The custom authorizer name.</p>
    pub authorizer_name: std::option::Option<std::string::String>,
    /// <p>The token returned by your custom authentication service.</p>
    pub token: std::option::Option<std::string::String>,
    /// <p>The signature made with the token and your custom authentication service's private key. This value must be Base-64-encoded.</p>
    pub token_signature: std::option::Option<std::string::String>,
    /// <p>Specifies a test HTTP authorization request.</p>
    pub http_context: std::option::Option<crate::model::HttpContext>,
    /// <p>Specifies a test MQTT authorization request.</p>
    pub mqtt_context: std::option::Option<crate::model::MqttContext>,
    /// <p>Specifies a test TLS authorization request.</p>
    pub tls_context: std::option::Option<crate::model::TlsContext>,
}
impl TestInvokeAuthorizerInput {
    /// <p>The custom authorizer name.</p>
    pub fn authorizer_name(&self) -> std::option::Option<&str> {
        self.authorizer_name.as_deref()
    }
    /// <p>The token returned by your custom authentication service.</p>
    pub fn token(&self) -> std::option::Option<&str> {
        self.token.as_deref()
    }
    /// <p>The signature made with the token and your custom authentication service's private key. This value must be Base-64-encoded.</p>
    pub fn token_signature(&self) -> std::option::Option<&str> {
        self.token_signature.as_deref()
    }
    /// <p>Specifies a test HTTP authorization request.</p>
    pub fn http_context(&self) -> std::option::Option<&crate::model::HttpContext> {
        self.http_context.as_ref()
    }
    /// <p>Specifies a test MQTT authorization request.</p>
    pub fn mqtt_context(&self) -> std::option::Option<&crate::model::MqttContext> {
        self.mqtt_context.as_ref()
    }
    /// <p>Specifies a test TLS authorization request.</p>
    pub fn tls_context(&self) -> std::option::Option<&crate::model::TlsContext> {
        self.tls_context.as_ref()
    }
}
impl std::fmt::Debug for TestInvokeAuthorizerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TestInvokeAuthorizerInput");
        formatter.field("authorizer_name", &self.authorizer_name);
        formatter.field("token", &self.token);
        formatter.field("token_signature", &self.token_signature);
        formatter.field("http_context", &self.http_context);
        formatter.field("mqtt_context", &self.mqtt_context);
        formatter.field("tls_context", &self.tls_context);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TestAuthorizationInput {
    /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    pub principal: std::option::Option<std::string::String>,
    /// <p>The Cognito identity pool ID.</p>
    pub cognito_identity_pool_id: std::option::Option<std::string::String>,
    /// <p>A list of authorization info objects. Simulating authorization will create a response for each <code>authInfo</code> object in the list.</p>
    pub auth_infos: std::option::Option<std::vec::Vec<crate::model::AuthInfo>>,
    /// <p>The MQTT client ID.</p>
    pub client_id: std::option::Option<std::string::String>,
    /// <p>When testing custom authorization, the policies specified here are treated as if they are attached to the principal being authorized.</p>
    pub policy_names_to_add: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>When testing custom authorization, the policies specified here are treated as if they are not attached to the principal being authorized.</p>
    pub policy_names_to_skip: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl TestAuthorizationInput {
    /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    pub fn principal(&self) -> std::option::Option<&str> {
        self.principal.as_deref()
    }
    /// <p>The Cognito identity pool ID.</p>
    pub fn cognito_identity_pool_id(&self) -> std::option::Option<&str> {
        self.cognito_identity_pool_id.as_deref()
    }
    /// <p>A list of authorization info objects. Simulating authorization will create a response for each <code>authInfo</code> object in the list.</p>
    pub fn auth_infos(&self) -> std::option::Option<&[crate::model::AuthInfo]> {
        self.auth_infos.as_deref()
    }
    /// <p>The MQTT client ID.</p>
    pub fn client_id(&self) -> std::option::Option<&str> {
        self.client_id.as_deref()
    }
    /// <p>When testing custom authorization, the policies specified here are treated as if they are attached to the principal being authorized.</p>
    pub fn policy_names_to_add(&self) -> std::option::Option<&[std::string::String]> {
        self.policy_names_to_add.as_deref()
    }
    /// <p>When testing custom authorization, the policies specified here are treated as if they are not attached to the principal being authorized.</p>
    pub fn policy_names_to_skip(&self) -> std::option::Option<&[std::string::String]> {
        self.policy_names_to_skip.as_deref()
    }
}
impl std::fmt::Debug for TestAuthorizationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TestAuthorizationInput");
        formatter.field("principal", &self.principal);
        formatter.field("cognito_identity_pool_id", &self.cognito_identity_pool_id);
        formatter.field("auth_infos", &self.auth_infos);
        formatter.field("client_id", &self.client_id);
        formatter.field("policy_names_to_add", &self.policy_names_to_add);
        formatter.field("policy_names_to_skip", &self.policy_names_to_skip);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The ARN of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The new or modified tags for the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagResourceInput {
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The new or modified tags for the resource.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopThingRegistrationTaskInput {
    /// <p>The bulk thing provisioning task ID.</p>
    pub task_id: std::option::Option<std::string::String>,
}
impl StopThingRegistrationTaskInput {
    /// <p>The bulk thing provisioning task ID.</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
}
impl std::fmt::Debug for StopThingRegistrationTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopThingRegistrationTaskInput");
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartThingRegistrationTaskInput {
    /// <p>The provisioning template.</p>
    pub template_body: std::option::Option<std::string::String>,
    /// <p>The S3 bucket that contains the input file.</p>
    pub input_file_bucket: std::option::Option<std::string::String>,
    /// <p>The name of input file within the S3 bucket. This file contains a newline delimited JSON file. Each line contains the parameter values to provision one device (thing).</p>
    pub input_file_key: std::option::Option<std::string::String>,
    /// <p>The IAM role ARN that grants permission the input file.</p>
    pub role_arn: std::option::Option<std::string::String>,
}
impl StartThingRegistrationTaskInput {
    /// <p>The provisioning template.</p>
    pub fn template_body(&self) -> std::option::Option<&str> {
        self.template_body.as_deref()
    }
    /// <p>The S3 bucket that contains the input file.</p>
    pub fn input_file_bucket(&self) -> std::option::Option<&str> {
        self.input_file_bucket.as_deref()
    }
    /// <p>The name of input file within the S3 bucket. This file contains a newline delimited JSON file. Each line contains the parameter values to provision one device (thing).</p>
    pub fn input_file_key(&self) -> std::option::Option<&str> {
        self.input_file_key.as_deref()
    }
    /// <p>The IAM role ARN that grants permission the input file.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl std::fmt::Debug for StartThingRegistrationTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartThingRegistrationTaskInput");
        formatter.field("template_body", &self.template_body);
        formatter.field("input_file_bucket", &self.input_file_bucket);
        formatter.field("input_file_key", &self.input_file_key);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartOnDemandAuditTaskInput {
    /// <p>Which checks are performed during the audit. The checks you specify must be enabled for your account or an exception occurs. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.</p>
    pub target_check_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl StartOnDemandAuditTaskInput {
    /// <p>Which checks are performed during the audit. The checks you specify must be enabled for your account or an exception occurs. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.</p>
    pub fn target_check_names(&self) -> std::option::Option<&[std::string::String]> {
        self.target_check_names.as_deref()
    }
}
impl std::fmt::Debug for StartOnDemandAuditTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartOnDemandAuditTaskInput");
        formatter.field("target_check_names", &self.target_check_names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartDetectMitigationActionsTaskInput {
    /// <p> The unique identifier of the task. </p>
    pub task_id: std::option::Option<std::string::String>,
    /// <p> Specifies the ML Detect findings to which the mitigation actions are applied. </p>
    pub target: std::option::Option<crate::model::DetectMitigationActionsTaskTarget>,
    /// <p> The actions to be performed when a device has unexpected behavior. </p>
    pub actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> Specifies the time period of which violation events occurred between. </p>
    pub violation_event_occurrence_range:
        std::option::Option<crate::model::ViolationEventOccurrenceRange>,
    /// <p> Specifies to list only active violations. </p>
    pub include_only_active_violations: std::option::Option<bool>,
    /// <p> Specifies to include suppressed alerts. </p>
    pub include_suppressed_alerts: std::option::Option<bool>,
    /// <p> Each mitigation action task must have a unique client request token. If you try to create a new task with the same token as a task that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request. </p>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl StartDetectMitigationActionsTaskInput {
    /// <p> The unique identifier of the task. </p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
    /// <p> Specifies the ML Detect findings to which the mitigation actions are applied. </p>
    pub fn target(&self) -> std::option::Option<&crate::model::DetectMitigationActionsTaskTarget> {
        self.target.as_ref()
    }
    /// <p> The actions to be performed when a device has unexpected behavior. </p>
    pub fn actions(&self) -> std::option::Option<&[std::string::String]> {
        self.actions.as_deref()
    }
    /// <p> Specifies the time period of which violation events occurred between. </p>
    pub fn violation_event_occurrence_range(
        &self,
    ) -> std::option::Option<&crate::model::ViolationEventOccurrenceRange> {
        self.violation_event_occurrence_range.as_ref()
    }
    /// <p> Specifies to list only active violations. </p>
    pub fn include_only_active_violations(&self) -> std::option::Option<bool> {
        self.include_only_active_violations
    }
    /// <p> Specifies to include suppressed alerts. </p>
    pub fn include_suppressed_alerts(&self) -> std::option::Option<bool> {
        self.include_suppressed_alerts
    }
    /// <p> Each mitigation action task must have a unique client request token. If you try to create a new task with the same token as a task that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request. </p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for StartDetectMitigationActionsTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartDetectMitigationActionsTaskInput");
        formatter.field("task_id", &self.task_id);
        formatter.field("target", &self.target);
        formatter.field("actions", &self.actions);
        formatter.field(
            "violation_event_occurrence_range",
            &self.violation_event_occurrence_range,
        );
        formatter.field(
            "include_only_active_violations",
            &self.include_only_active_violations,
        );
        formatter.field("include_suppressed_alerts", &self.include_suppressed_alerts);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartAuditMitigationActionsTaskInput {
    /// <p>A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.</p>
    pub task_id: std::option::Option<std::string::String>,
    /// <p>Specifies the audit findings to which the mitigation actions are applied. You can apply them to a type of audit check, to all findings from an audit, or to a specific set of findings.</p>
    pub target: std::option::Option<crate::model::AuditMitigationActionsTaskTarget>,
    /// <p>For an audit check, specifies which mitigation actions to apply. Those actions must be defined in your Amazon Web Services accounts.</p>
    pub audit_check_to_actions_mapping: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>Each audit mitigation task must have a unique client request token. If you try to start a new task with the same token as a task that already exists, an exception occurs. If you omit this value, a unique client request token is generated automatically.</p>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl StartAuditMitigationActionsTaskInput {
    /// <p>A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
    /// <p>Specifies the audit findings to which the mitigation actions are applied. You can apply them to a type of audit check, to all findings from an audit, or to a specific set of findings.</p>
    pub fn target(&self) -> std::option::Option<&crate::model::AuditMitigationActionsTaskTarget> {
        self.target.as_ref()
    }
    /// <p>For an audit check, specifies which mitigation actions to apply. Those actions must be defined in your Amazon Web Services accounts.</p>
    pub fn audit_check_to_actions_mapping(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    > {
        self.audit_check_to_actions_mapping.as_ref()
    }
    /// <p>Each audit mitigation task must have a unique client request token. If you try to start a new task with the same token as a task that already exists, an exception occurs. If you omit this value, a unique client request token is generated automatically.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for StartAuditMitigationActionsTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartAuditMitigationActionsTaskInput");
        formatter.field("task_id", &self.task_id);
        formatter.field("target", &self.target);
        formatter.field(
            "audit_check_to_actions_mapping",
            &self.audit_check_to_actions_mapping,
        );
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetV2LoggingOptionsInput {
    /// <p>The ARN of the role that allows IoT to write to Cloudwatch logs.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The default logging level.</p>
    pub default_log_level: std::option::Option<crate::model::LogLevel>,
    /// <p>If true all logs are disabled. The default is false.</p>
    pub disable_all_logs: bool,
}
impl SetV2LoggingOptionsInput {
    /// <p>The ARN of the role that allows IoT to write to Cloudwatch logs.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The default logging level.</p>
    pub fn default_log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.default_log_level.as_ref()
    }
    /// <p>If true all logs are disabled. The default is false.</p>
    pub fn disable_all_logs(&self) -> bool {
        self.disable_all_logs
    }
}
impl std::fmt::Debug for SetV2LoggingOptionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SetV2LoggingOptionsInput");
        formatter.field("role_arn", &self.role_arn);
        formatter.field("default_log_level", &self.default_log_level);
        formatter.field("disable_all_logs", &self.disable_all_logs);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetV2LoggingLevelInput {
    /// <p>The log target.</p>
    pub log_target: std::option::Option<crate::model::LogTarget>,
    /// <p>The log level.</p>
    pub log_level: std::option::Option<crate::model::LogLevel>,
}
impl SetV2LoggingLevelInput {
    /// <p>The log target.</p>
    pub fn log_target(&self) -> std::option::Option<&crate::model::LogTarget> {
        self.log_target.as_ref()
    }
    /// <p>The log level.</p>
    pub fn log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level.as_ref()
    }
}
impl std::fmt::Debug for SetV2LoggingLevelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SetV2LoggingLevelInput");
        formatter.field("log_target", &self.log_target);
        formatter.field("log_level", &self.log_level);
        formatter.finish()
    }
}

/// <p>The input for the SetLoggingOptions operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetLoggingOptionsInput {
    /// <p>The logging options payload.</p>
    pub logging_options_payload: std::option::Option<crate::model::LoggingOptionsPayload>,
}
impl SetLoggingOptionsInput {
    /// <p>The logging options payload.</p>
    pub fn logging_options_payload(
        &self,
    ) -> std::option::Option<&crate::model::LoggingOptionsPayload> {
        self.logging_options_payload.as_ref()
    }
}
impl std::fmt::Debug for SetLoggingOptionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SetLoggingOptionsInput");
        formatter.field("logging_options_payload", &self.logging_options_payload);
        formatter.finish()
    }
}

/// <p>The input for the SetDefaultPolicyVersion operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetDefaultPolicyVersionInput {
    /// <p>The policy name.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The policy version ID.</p>
    pub policy_version_id: std::option::Option<std::string::String>,
}
impl SetDefaultPolicyVersionInput {
    /// <p>The policy name.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The policy version ID.</p>
    pub fn policy_version_id(&self) -> std::option::Option<&str> {
        self.policy_version_id.as_deref()
    }
}
impl std::fmt::Debug for SetDefaultPolicyVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SetDefaultPolicyVersionInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_version_id", &self.policy_version_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetDefaultAuthorizerInput {
    /// <p>The authorizer name.</p>
    pub authorizer_name: std::option::Option<std::string::String>,
}
impl SetDefaultAuthorizerInput {
    /// <p>The authorizer name.</p>
    pub fn authorizer_name(&self) -> std::option::Option<&str> {
        self.authorizer_name.as_deref()
    }
}
impl std::fmt::Debug for SetDefaultAuthorizerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SetDefaultAuthorizerInput");
        formatter.field("authorizer_name", &self.authorizer_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchIndexInput {
    /// <p>The search index name.</p>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The search query string.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The query version.</p>
    pub query_version: std::option::Option<std::string::String>,
}
impl SearchIndexInput {
    /// <p>The search index name.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>The search query string.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The query version.</p>
    pub fn query_version(&self) -> std::option::Option<&str> {
        self.query_version.as_deref()
    }
}
impl std::fmt::Debug for SearchIndexInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchIndexInput");
        formatter.field("index_name", &self.index_name);
        formatter.field("query_string", &self.query_string);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("query_version", &self.query_version);
        formatter.finish()
    }
}

/// <p>The input for the ReplaceTopicRule operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplaceTopicRuleInput {
    /// <p>The name of the rule.</p>
    pub rule_name: std::option::Option<std::string::String>,
    /// <p>The rule payload.</p>
    pub topic_rule_payload: std::option::Option<crate::model::TopicRulePayload>,
}
impl ReplaceTopicRuleInput {
    /// <p>The name of the rule.</p>
    pub fn rule_name(&self) -> std::option::Option<&str> {
        self.rule_name.as_deref()
    }
    /// <p>The rule payload.</p>
    pub fn topic_rule_payload(&self) -> std::option::Option<&crate::model::TopicRulePayload> {
        self.topic_rule_payload.as_ref()
    }
}
impl std::fmt::Debug for ReplaceTopicRuleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplaceTopicRuleInput");
        formatter.field("rule_name", &self.rule_name);
        formatter.field("topic_rule_payload", &self.topic_rule_payload);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveThingFromThingGroupInput {
    /// <p>The group name.</p>
    pub thing_group_name: std::option::Option<std::string::String>,
    /// <p>The group ARN.</p>
    pub thing_group_arn: std::option::Option<std::string::String>,
    /// <p>The name of the thing to remove from the group.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the thing to remove from the group.</p>
    pub thing_arn: std::option::Option<std::string::String>,
}
impl RemoveThingFromThingGroupInput {
    /// <p>The group name.</p>
    pub fn thing_group_name(&self) -> std::option::Option<&str> {
        self.thing_group_name.as_deref()
    }
    /// <p>The group ARN.</p>
    pub fn thing_group_arn(&self) -> std::option::Option<&str> {
        self.thing_group_arn.as_deref()
    }
    /// <p>The name of the thing to remove from the group.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The ARN of the thing to remove from the group.</p>
    pub fn thing_arn(&self) -> std::option::Option<&str> {
        self.thing_arn.as_deref()
    }
}
impl std::fmt::Debug for RemoveThingFromThingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemoveThingFromThingGroupInput");
        formatter.field("thing_group_name", &self.thing_group_name);
        formatter.field("thing_group_arn", &self.thing_group_arn);
        formatter.field("thing_name", &self.thing_name);
        formatter.field("thing_arn", &self.thing_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveThingFromBillingGroupInput {
    /// <p>The name of the billing group.</p>
    pub billing_group_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the billing group.</p>
    pub billing_group_arn: std::option::Option<std::string::String>,
    /// <p>The name of the thing to be removed from the billing group.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the thing to be removed from the billing group.</p>
    pub thing_arn: std::option::Option<std::string::String>,
}
impl RemoveThingFromBillingGroupInput {
    /// <p>The name of the billing group.</p>
    pub fn billing_group_name(&self) -> std::option::Option<&str> {
        self.billing_group_name.as_deref()
    }
    /// <p>The ARN of the billing group.</p>
    pub fn billing_group_arn(&self) -> std::option::Option<&str> {
        self.billing_group_arn.as_deref()
    }
    /// <p>The name of the thing to be removed from the billing group.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The ARN of the thing to be removed from the billing group.</p>
    pub fn thing_arn(&self) -> std::option::Option<&str> {
        self.thing_arn.as_deref()
    }
}
impl std::fmt::Debug for RemoveThingFromBillingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemoveThingFromBillingGroupInput");
        formatter.field("billing_group_name", &self.billing_group_name);
        formatter.field("billing_group_arn", &self.billing_group_arn);
        formatter.field("thing_name", &self.thing_name);
        formatter.field("thing_arn", &self.thing_arn);
        formatter.finish()
    }
}

/// <p>The input for the RejectCertificateTransfer operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RejectCertificateTransferInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub certificate_id: std::option::Option<std::string::String>,
    /// <p>The reason the certificate transfer was rejected.</p>
    pub reject_reason: std::option::Option<std::string::String>,
}
impl RejectCertificateTransferInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub fn certificate_id(&self) -> std::option::Option<&str> {
        self.certificate_id.as_deref()
    }
    /// <p>The reason the certificate transfer was rejected.</p>
    pub fn reject_reason(&self) -> std::option::Option<&str> {
        self.reject_reason.as_deref()
    }
}
impl std::fmt::Debug for RejectCertificateTransferInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RejectCertificateTransferInput");
        formatter.field("certificate_id", &self.certificate_id);
        formatter.field("reject_reason", &self.reject_reason);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterThingInput {
    /// <p>The provisioning template. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-w-cert.html">Provisioning Devices That Have Device Certificates</a> for more information.</p>
    pub template_body: std::option::Option<std::string::String>,
    /// <p>The parameters for provisioning a thing. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html">Provisioning Templates</a> for more information.</p>
    pub parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl RegisterThingInput {
    /// <p>The provisioning template. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-w-cert.html">Provisioning Devices That Have Device Certificates</a> for more information.</p>
    pub fn template_body(&self) -> std::option::Option<&str> {
        self.template_body.as_deref()
    }
    /// <p>The parameters for provisioning a thing. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html">Provisioning Templates</a> for more information.</p>
    pub fn parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.parameters.as_ref()
    }
}
impl std::fmt::Debug for RegisterThingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterThingInput");
        formatter.field("template_body", &self.template_body);
        formatter.field("parameters", &self.parameters);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterCertificateWithoutCaInput {
    /// <p>The certificate data, in PEM format.</p>
    pub certificate_pem: std::option::Option<std::string::String>,
    /// <p>The status of the register certificate request.</p>
    pub status: std::option::Option<crate::model::CertificateStatus>,
}
impl RegisterCertificateWithoutCaInput {
    /// <p>The certificate data, in PEM format.</p>
    pub fn certificate_pem(&self) -> std::option::Option<&str> {
        self.certificate_pem.as_deref()
    }
    /// <p>The status of the register certificate request.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::CertificateStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for RegisterCertificateWithoutCaInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterCertificateWithoutCaInput");
        formatter.field("certificate_pem", &self.certificate_pem);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

/// <p>The input to the RegisterCertificate operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterCertificateInput {
    /// <p>The certificate data, in PEM format.</p>
    pub certificate_pem: std::option::Option<std::string::String>,
    /// <p>The CA certificate used to sign the device certificate being registered.</p>
    pub ca_certificate_pem: std::option::Option<std::string::String>,
    /// <p>A boolean value that specifies if the certificate is set to active.</p>
    /// <p>Valid values: <code>ACTIVE | INACTIVE</code> </p>
    pub set_as_active: std::option::Option<bool>,
    /// <p>The status of the register certificate request. Valid values that you can use include <code>ACTIVE</code>, <code>INACTIVE</code>, and <code>REVOKED</code>.</p>
    pub status: std::option::Option<crate::model::CertificateStatus>,
}
impl RegisterCertificateInput {
    /// <p>The certificate data, in PEM format.</p>
    pub fn certificate_pem(&self) -> std::option::Option<&str> {
        self.certificate_pem.as_deref()
    }
    /// <p>The CA certificate used to sign the device certificate being registered.</p>
    pub fn ca_certificate_pem(&self) -> std::option::Option<&str> {
        self.ca_certificate_pem.as_deref()
    }
    /// <p>A boolean value that specifies if the certificate is set to active.</p>
    /// <p>Valid values: <code>ACTIVE | INACTIVE</code> </p>
    pub fn set_as_active(&self) -> std::option::Option<bool> {
        self.set_as_active
    }
    /// <p>The status of the register certificate request. Valid values that you can use include <code>ACTIVE</code>, <code>INACTIVE</code>, and <code>REVOKED</code>.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::CertificateStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for RegisterCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterCertificateInput");
        formatter.field("certificate_pem", &self.certificate_pem);
        formatter.field("ca_certificate_pem", &self.ca_certificate_pem);
        formatter.field("set_as_active", &self.set_as_active);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

/// <p>The input to the RegisterCACertificate operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterCaCertificateInput {
    /// <p>The CA certificate.</p>
    pub ca_certificate: std::option::Option<std::string::String>,
    /// <p>The private key verification certificate.</p>
    pub verification_certificate: std::option::Option<std::string::String>,
    /// <p>A boolean value that specifies if the CA certificate is set to active.</p>
    /// <p>Valid values: <code>ACTIVE | INACTIVE</code> </p>
    pub set_as_active: bool,
    /// <p>Allows this CA certificate to be used for auto registration of device certificates.</p>
    pub allow_auto_registration: bool,
    /// <p>Information about the registration configuration.</p>
    pub registration_config: std::option::Option<crate::model::RegistrationConfig>,
    /// <p>Metadata which can be used to manage the CA certificate.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl RegisterCaCertificateInput {
    /// <p>The CA certificate.</p>
    pub fn ca_certificate(&self) -> std::option::Option<&str> {
        self.ca_certificate.as_deref()
    }
    /// <p>The private key verification certificate.</p>
    pub fn verification_certificate(&self) -> std::option::Option<&str> {
        self.verification_certificate.as_deref()
    }
    /// <p>A boolean value that specifies if the CA certificate is set to active.</p>
    /// <p>Valid values: <code>ACTIVE | INACTIVE</code> </p>
    pub fn set_as_active(&self) -> bool {
        self.set_as_active
    }
    /// <p>Allows this CA certificate to be used for auto registration of device certificates.</p>
    pub fn allow_auto_registration(&self) -> bool {
        self.allow_auto_registration
    }
    /// <p>Information about the registration configuration.</p>
    pub fn registration_config(&self) -> std::option::Option<&crate::model::RegistrationConfig> {
        self.registration_config.as_ref()
    }
    /// <p>Metadata which can be used to manage the CA certificate.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for RegisterCaCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterCaCertificateInput");
        formatter.field("ca_certificate", &self.ca_certificate);
        formatter.field("verification_certificate", &self.verification_certificate);
        formatter.field("set_as_active", &self.set_as_active);
        formatter.field("allow_auto_registration", &self.allow_auto_registration);
        formatter.field("registration_config", &self.registration_config);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutVerificationStateOnViolationInput {
    /// <p>The violation ID.</p>
    pub violation_id: std::option::Option<std::string::String>,
    /// <p>The verification state of the violation.</p>
    pub verification_state: std::option::Option<crate::model::VerificationState>,
    /// <p>The description of the verification state of the violation (detect alarm).</p>
    pub verification_state_description: std::option::Option<std::string::String>,
}
impl PutVerificationStateOnViolationInput {
    /// <p>The violation ID.</p>
    pub fn violation_id(&self) -> std::option::Option<&str> {
        self.violation_id.as_deref()
    }
    /// <p>The verification state of the violation.</p>
    pub fn verification_state(&self) -> std::option::Option<&crate::model::VerificationState> {
        self.verification_state.as_ref()
    }
    /// <p>The description of the verification state of the violation (detect alarm).</p>
    pub fn verification_state_description(&self) -> std::option::Option<&str> {
        self.verification_state_description.as_deref()
    }
}
impl std::fmt::Debug for PutVerificationStateOnViolationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutVerificationStateOnViolationInput");
        formatter.field("violation_id", &self.violation_id);
        formatter.field("verification_state", &self.verification_state);
        formatter.field(
            "verification_state_description",
            &self.verification_state_description,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListViolationEventsInput {
    /// <p>The start time for the alerts to be listed.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end time for the alerts to be listed.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A filter to limit results to those alerts caused by the specified thing.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>A filter to limit results to those alerts generated by the specified security profile.</p>
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p> The criteria for a behavior. </p>
    pub behavior_criteria_type: std::option::Option<crate::model::BehaviorCriteriaType>,
    /// <p> A list of all suppressed alerts. </p>
    pub list_suppressed_alerts: std::option::Option<bool>,
    /// <p>The verification state of the violation (detect alarm).</p>
    pub verification_state: std::option::Option<crate::model::VerificationState>,
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListViolationEventsInput {
    /// <p>The start time for the alerts to be listed.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The end time for the alerts to be listed.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>A filter to limit results to those alerts caused by the specified thing.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>A filter to limit results to those alerts generated by the specified security profile.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p> The criteria for a behavior. </p>
    pub fn behavior_criteria_type(
        &self,
    ) -> std::option::Option<&crate::model::BehaviorCriteriaType> {
        self.behavior_criteria_type.as_ref()
    }
    /// <p> A list of all suppressed alerts. </p>
    pub fn list_suppressed_alerts(&self) -> std::option::Option<bool> {
        self.list_suppressed_alerts
    }
    /// <p>The verification state of the violation (detect alarm).</p>
    pub fn verification_state(&self) -> std::option::Option<&crate::model::VerificationState> {
        self.verification_state.as_ref()
    }
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListViolationEventsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListViolationEventsInput");
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("thing_name", &self.thing_name);
        formatter.field("security_profile_name", &self.security_profile_name);
        formatter.field("behavior_criteria_type", &self.behavior_criteria_type);
        formatter.field("list_suppressed_alerts", &self.list_suppressed_alerts);
        formatter.field("verification_state", &self.verification_state);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListV2LoggingLevelsInput {
    /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
    pub target_type: std::option::Option<crate::model::LogTargetType>,
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListV2LoggingLevelsInput {
    /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
    pub fn target_type(&self) -> std::option::Option<&crate::model::LogTargetType> {
        self.target_type.as_ref()
    }
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListV2LoggingLevelsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListV2LoggingLevelsInput");
        formatter.field("target_type", &self.target_type);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

/// <p>The input for the ListTopicRules operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTopicRulesInput {
    /// <p>The topic.</p>
    pub topic: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Specifies whether the rule is disabled.</p>
    pub rule_disabled: std::option::Option<bool>,
}
impl ListTopicRulesInput {
    /// <p>The topic.</p>
    pub fn topic(&self) -> std::option::Option<&str> {
        self.topic.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>Specifies whether the rule is disabled.</p>
    pub fn rule_disabled(&self) -> std::option::Option<bool> {
        self.rule_disabled
    }
}
impl std::fmt::Debug for ListTopicRulesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTopicRulesInput");
        formatter.field("topic", &self.topic);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("rule_disabled", &self.rule_disabled);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTopicRuleDestinationsInput {
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListTopicRuleDestinationsInput {
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListTopicRuleDestinationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTopicRuleDestinationsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>The input for the ListThingTypes operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListThingTypesInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in this operation.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The name of the thing type.</p>
    pub thing_type_name: std::option::Option<std::string::String>,
}
impl ListThingTypesInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in this operation.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The name of the thing type.</p>
    pub fn thing_type_name(&self) -> std::option::Option<&str> {
        self.thing_type_name.as_deref()
    }
}
impl std::fmt::Debug for ListThingTypesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListThingTypesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("thing_type_name", &self.thing_type_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListThingsInThingGroupInput {
    /// <p>The thing group name.</p>
    pub thing_group_name: std::option::Option<std::string::String>,
    /// <p>When true, list things in this thing group and in all child groups as well.</p>
    pub recursive: bool,
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListThingsInThingGroupInput {
    /// <p>The thing group name.</p>
    pub fn thing_group_name(&self) -> std::option::Option<&str> {
        self.thing_group_name.as_deref()
    }
    /// <p>When true, list things in this thing group and in all child groups as well.</p>
    pub fn recursive(&self) -> bool {
        self.recursive
    }
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListThingsInThingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListThingsInThingGroupInput");
        formatter.field("thing_group_name", &self.thing_group_name);
        formatter.field("recursive", &self.recursive);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListThingsInBillingGroupInput {
    /// <p>The name of the billing group.</p>
    pub billing_group_name: std::option::Option<std::string::String>,
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per request.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListThingsInBillingGroupInput {
    /// <p>The name of the billing group.</p>
    pub fn billing_group_name(&self) -> std::option::Option<&str> {
        self.billing_group_name.as_deref()
    }
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per request.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListThingsInBillingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListThingsInBillingGroupInput");
        formatter.field("billing_group_name", &self.billing_group_name);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

/// <p>The input for the ListThings operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListThingsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in this operation.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The attribute name used to search for things.</p>
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>The attribute value used to search for things.</p>
    pub attribute_value: std::option::Option<std::string::String>,
    /// <p>The name of the thing type used to search for things.</p>
    pub thing_type_name: std::option::Option<std::string::String>,
    /// <p>When <code>true</code>, the action returns the thing resources with attribute values that start with the <code>attributeValue</code> provided.</p>
    /// <p>When <code>false</code>, or not present, the action returns only the thing resources with attribute values that match the entire <code>attributeValue</code> provided. </p>
    pub use_prefix_attribute_value: bool,
}
impl ListThingsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in this operation.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The attribute name used to search for things.</p>
    pub fn attribute_name(&self) -> std::option::Option<&str> {
        self.attribute_name.as_deref()
    }
    /// <p>The attribute value used to search for things.</p>
    pub fn attribute_value(&self) -> std::option::Option<&str> {
        self.attribute_value.as_deref()
    }
    /// <p>The name of the thing type used to search for things.</p>
    pub fn thing_type_name(&self) -> std::option::Option<&str> {
        self.thing_type_name.as_deref()
    }
    /// <p>When <code>true</code>, the action returns the thing resources with attribute values that start with the <code>attributeValue</code> provided.</p>
    /// <p>When <code>false</code>, or not present, the action returns only the thing resources with attribute values that match the entire <code>attributeValue</code> provided. </p>
    pub fn use_prefix_attribute_value(&self) -> bool {
        self.use_prefix_attribute_value
    }
}
impl std::fmt::Debug for ListThingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListThingsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("attribute_name", &self.attribute_name);
        formatter.field("attribute_value", &self.attribute_value);
        formatter.field("thing_type_name", &self.thing_type_name);
        formatter.field(
            "use_prefix_attribute_value",
            &self.use_prefix_attribute_value,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListThingRegistrationTasksInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The status of the bulk thing provisioning task.</p>
    pub status: std::option::Option<crate::model::Status>,
}
impl ListThingRegistrationTasksInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The status of the bulk thing provisioning task.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::Status> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for ListThingRegistrationTasksInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListThingRegistrationTasksInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListThingRegistrationTaskReportsInput {
    /// <p>The id of the task.</p>
    pub task_id: std::option::Option<std::string::String>,
    /// <p>The type of task report.</p>
    pub report_type: std::option::Option<crate::model::ReportType>,
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per request.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListThingRegistrationTaskReportsInput {
    /// <p>The id of the task.</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
    /// <p>The type of task report.</p>
    pub fn report_type(&self) -> std::option::Option<&crate::model::ReportType> {
        self.report_type.as_ref()
    }
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per request.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListThingRegistrationTaskReportsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListThingRegistrationTaskReportsInput");
        formatter.field("task_id", &self.task_id);
        formatter.field("report_type", &self.report_type);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

/// <p>The input for the ListThingPrincipal operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListThingPrincipalsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in this operation.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The name of the thing.</p>
    pub thing_name: std::option::Option<std::string::String>,
}
impl ListThingPrincipalsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in this operation.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The name of the thing.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
}
impl std::fmt::Debug for ListThingPrincipalsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListThingPrincipalsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("thing_name", &self.thing_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListThingGroupsForThingInput {
    /// <p>The thing name.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListThingGroupsForThingInput {
    /// <p>The thing name.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListThingGroupsForThingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListThingGroupsForThingInput");
        formatter.field("thing_name", &self.thing_name);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListThingGroupsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>A filter that limits the results to those with the specified parent group.</p>
    pub parent_group: std::option::Option<std::string::String>,
    /// <p>A filter that limits the results to those with the specified name prefix.</p>
    pub name_prefix_filter: std::option::Option<std::string::String>,
    /// <p>If true, return child groups as well.</p>
    pub recursive: std::option::Option<bool>,
}
impl ListThingGroupsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>A filter that limits the results to those with the specified parent group.</p>
    pub fn parent_group(&self) -> std::option::Option<&str> {
        self.parent_group.as_deref()
    }
    /// <p>A filter that limits the results to those with the specified name prefix.</p>
    pub fn name_prefix_filter(&self) -> std::option::Option<&str> {
        self.name_prefix_filter.as_deref()
    }
    /// <p>If true, return child groups as well.</p>
    pub fn recursive(&self) -> std::option::Option<bool> {
        self.recursive
    }
}
impl std::fmt::Debug for ListThingGroupsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListThingGroupsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("parent_group", &self.parent_group);
        formatter.field("name_prefix_filter", &self.name_prefix_filter);
        formatter.field("recursive", &self.recursive);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTargetsForSecurityProfileInput {
    /// <p>The security profile.</p>
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListTargetsForSecurityProfileInput {
    /// <p>The security profile.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListTargetsForSecurityProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTargetsForSecurityProfileInput");
        formatter.field("security_profile_name", &self.security_profile_name);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTargetsForPolicyInput {
    /// <p>The policy name.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>A marker used to get the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub page_size: std::option::Option<i32>,
}
impl ListTargetsForPolicyInput {
    /// <p>The policy name.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>A marker used to get the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
}
impl std::fmt::Debug for ListTargetsForPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTargetsForPolicyInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("marker", &self.marker);
        formatter.field("page_size", &self.page_size);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>The ARN of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListStreamsInput {
    /// <p>The maximum number of results to return at a time.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>A token used to get the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Set to true to return the list of streams in ascending order.</p>
    pub ascending_order: bool,
}
impl ListStreamsInput {
    /// <p>The maximum number of results to return at a time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>A token used to get the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>Set to true to return the list of streams in ascending order.</p>
    pub fn ascending_order(&self) -> bool {
        self.ascending_order
    }
}
impl std::fmt::Debug for ListStreamsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListStreamsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("ascending_order", &self.ascending_order);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSecurityProfilesForTargetInput {
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>If true, return child groups too.</p>
    pub recursive: bool,
    /// <p>The ARN of the target (thing group) whose attached security profiles you want to get.</p>
    pub security_profile_target_arn: std::option::Option<std::string::String>,
}
impl ListSecurityProfilesForTargetInput {
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>If true, return child groups too.</p>
    pub fn recursive(&self) -> bool {
        self.recursive
    }
    /// <p>The ARN of the target (thing group) whose attached security profiles you want to get.</p>
    pub fn security_profile_target_arn(&self) -> std::option::Option<&str> {
        self.security_profile_target_arn.as_deref()
    }
}
impl std::fmt::Debug for ListSecurityProfilesForTargetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSecurityProfilesForTargetInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("recursive", &self.recursive);
        formatter.field(
            "security_profile_target_arn",
            &self.security_profile_target_arn,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSecurityProfilesInput {
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>A filter to limit results to the security profiles that use the defined dimension. Cannot be used with <code>metricName</code> </p>
    pub dimension_name: std::option::Option<std::string::String>,
    /// <p> The name of the custom metric. Cannot be used with <code>dimensionName</code>. </p>
    pub metric_name: std::option::Option<std::string::String>,
}
impl ListSecurityProfilesInput {
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>A filter to limit results to the security profiles that use the defined dimension. Cannot be used with <code>metricName</code> </p>
    pub fn dimension_name(&self) -> std::option::Option<&str> {
        self.dimension_name.as_deref()
    }
    /// <p> The name of the custom metric. Cannot be used with <code>dimensionName</code>. </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
}
impl std::fmt::Debug for ListSecurityProfilesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSecurityProfilesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("dimension_name", &self.dimension_name);
        formatter.field("metric_name", &self.metric_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListScheduledAuditsInput {
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListScheduledAuditsInput {
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListScheduledAuditsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListScheduledAuditsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRoleAliasesInput {
    /// <p>The maximum number of results to return at one time.</p>
    pub page_size: std::option::Option<i32>,
    /// <p>A marker used to get the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Return the list of role aliases in ascending alphabetical order.</p>
    pub ascending_order: bool,
}
impl ListRoleAliasesInput {
    /// <p>The maximum number of results to return at one time.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
    /// <p>A marker used to get the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>Return the list of role aliases in ascending alphabetical order.</p>
    pub fn ascending_order(&self) -> bool {
        self.ascending_order
    }
}
impl std::fmt::Debug for ListRoleAliasesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRoleAliasesInput");
        formatter.field("page_size", &self.page_size);
        formatter.field("marker", &self.marker);
        formatter.field("ascending_order", &self.ascending_order);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProvisioningTemplateVersionsInput {
    /// <p>The name of the fleet provisioning template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>A token to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListProvisioningTemplateVersionsInput {
    /// <p>The name of the fleet provisioning template.</p>
    pub fn template_name(&self) -> std::option::Option<&str> {
        self.template_name.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>A token to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListProvisioningTemplateVersionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProvisioningTemplateVersionsInput");
        formatter.field("template_name", &self.template_name);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProvisioningTemplatesInput {
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>A token to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListProvisioningTemplatesInput {
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>A token to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListProvisioningTemplatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProvisioningTemplatesInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>The input for the ListPrincipalThings operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPrincipalThingsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in this operation.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The principal.</p>
    pub principal: std::option::Option<std::string::String>,
}
impl ListPrincipalThingsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in this operation.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The principal.</p>
    pub fn principal(&self) -> std::option::Option<&str> {
        self.principal.as_deref()
    }
}
impl std::fmt::Debug for ListPrincipalThingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPrincipalThingsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("principal", &self.principal);
        formatter.finish()
    }
}

/// <p>The input for the ListPrincipalPolicies operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPrincipalPoliciesInput {
    /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    pub principal: std::option::Option<std::string::String>,
    /// <p>The marker for the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>The result page size.</p>
    pub page_size: std::option::Option<i32>,
    /// <p>Specifies the order for results. If true, results are returned in ascending creation order.</p>
    pub ascending_order: bool,
}
impl ListPrincipalPoliciesInput {
    /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    pub fn principal(&self) -> std::option::Option<&str> {
        self.principal.as_deref()
    }
    /// <p>The marker for the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>The result page size.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
    /// <p>Specifies the order for results. If true, results are returned in ascending creation order.</p>
    pub fn ascending_order(&self) -> bool {
        self.ascending_order
    }
}
impl std::fmt::Debug for ListPrincipalPoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPrincipalPoliciesInput");
        formatter.field("principal", &self.principal);
        formatter.field("marker", &self.marker);
        formatter.field("page_size", &self.page_size);
        formatter.field("ascending_order", &self.ascending_order);
        formatter.finish()
    }
}

/// <p>The input for the ListPolicyVersions operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPolicyVersionsInput {
    /// <p>The policy name.</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl ListPolicyVersionsInput {
    /// <p>The policy name.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
}
impl std::fmt::Debug for ListPolicyVersionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPolicyVersionsInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}

/// <p>The input for the ListPolicyPrincipals operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPolicyPrincipalsInput {
    /// <p>The policy name.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The marker for the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>The result page size.</p>
    pub page_size: std::option::Option<i32>,
    /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
    pub ascending_order: bool,
}
impl ListPolicyPrincipalsInput {
    /// <p>The policy name.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The marker for the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>The result page size.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
    /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
    pub fn ascending_order(&self) -> bool {
        self.ascending_order
    }
}
impl std::fmt::Debug for ListPolicyPrincipalsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPolicyPrincipalsInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("marker", &self.marker);
        formatter.field("page_size", &self.page_size);
        formatter.field("ascending_order", &self.ascending_order);
        formatter.finish()
    }
}

/// <p>The input for the ListPolicies operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPoliciesInput {
    /// <p>The marker for the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>The result page size.</p>
    pub page_size: std::option::Option<i32>,
    /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
    pub ascending_order: bool,
}
impl ListPoliciesInput {
    /// <p>The marker for the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>The result page size.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
    /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
    pub fn ascending_order(&self) -> bool {
        self.ascending_order
    }
}
impl std::fmt::Debug for ListPoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPoliciesInput");
        formatter.field("marker", &self.marker);
        formatter.field("page_size", &self.page_size);
        formatter.field("ascending_order", &self.ascending_order);
        formatter.finish()
    }
}

/// <p>The input to the ListOutgoingCertificates operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOutgoingCertificatesInput {
    /// <p>The result page size.</p>
    pub page_size: std::option::Option<i32>,
    /// <p>The marker for the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    pub ascending_order: bool,
}
impl ListOutgoingCertificatesInput {
    /// <p>The result page size.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
    /// <p>The marker for the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    pub fn ascending_order(&self) -> bool {
        self.ascending_order
    }
}
impl std::fmt::Debug for ListOutgoingCertificatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOutgoingCertificatesInput");
        formatter.field("page_size", &self.page_size);
        formatter.field("marker", &self.marker);
        formatter.field("ascending_order", &self.ascending_order);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOtaUpdatesInput {
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>A token used to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The OTA update job status.</p>
    pub ota_update_status: std::option::Option<crate::model::OtaUpdateStatus>,
}
impl ListOtaUpdatesInput {
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>A token used to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The OTA update job status.</p>
    pub fn ota_update_status(&self) -> std::option::Option<&crate::model::OtaUpdateStatus> {
        self.ota_update_status.as_ref()
    }
}
impl std::fmt::Debug for ListOtaUpdatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOtaUpdatesInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("ota_update_status", &self.ota_update_status);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMitigationActionsInput {
    /// <p>Specify a value to limit the result to mitigation actions with a specific action type.</p>
    pub action_type: std::option::Option<crate::model::MitigationActionType>,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListMitigationActionsInput {
    /// <p>Specify a value to limit the result to mitigation actions with a specific action type.</p>
    pub fn action_type(&self) -> std::option::Option<&crate::model::MitigationActionType> {
        self.action_type.as_ref()
    }
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListMitigationActionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMitigationActionsInput");
        formatter.field("action_type", &self.action_type);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMetricValuesInput {
    /// <p>The name of the thing for which security profile metric values are returned.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The name of the security profile metric for which values are returned.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The dimension name.</p>
    pub dimension_name: std::option::Option<std::string::String>,
    /// <p>The dimension value operator.</p>
    pub dimension_value_operator: std::option::Option<crate::model::DimensionValueOperator>,
    /// <p>The start of the time period for which metric values are returned.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end of the time period for which metric values are returned.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListMetricValuesInput {
    /// <p>The name of the thing for which security profile metric values are returned.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The name of the security profile metric for which values are returned.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The dimension name.</p>
    pub fn dimension_name(&self) -> std::option::Option<&str> {
        self.dimension_name.as_deref()
    }
    /// <p>The dimension value operator.</p>
    pub fn dimension_value_operator(
        &self,
    ) -> std::option::Option<&crate::model::DimensionValueOperator> {
        self.dimension_value_operator.as_ref()
    }
    /// <p>The start of the time period for which metric values are returned.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The end of the time period for which metric values are returned.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListMetricValuesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMetricValuesInput");
        formatter.field("thing_name", &self.thing_name);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("dimension_name", &self.dimension_name);
        formatter.field("dimension_value_operator", &self.dimension_value_operator);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListManagedJobTemplatesInput {
    /// <p>An optional parameter for template name. If specified, only the versions of the managed job templates that have the specified template name will be returned.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>Maximum number of entries that can be returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListManagedJobTemplatesInput {
    /// <p>An optional parameter for template name. If specified, only the versions of the managed job templates that have the specified template name will be returned.</p>
    pub fn template_name(&self) -> std::option::Option<&str> {
        self.template_name.as_deref()
    }
    /// <p>Maximum number of entries that can be returned.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListManagedJobTemplatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListManagedJobTemplatesInput");
        formatter.field("template_name", &self.template_name);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJobTemplatesInput {
    /// <p>The maximum number of results to return in the list.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to use to return the next set of results in the list.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListJobTemplatesInput {
    /// <p>The maximum number of results to return in the list.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to use to return the next set of results in the list.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListJobTemplatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJobTemplatesInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJobsInput {
    /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
    pub status: std::option::Option<crate::model::JobStatus>,
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. </p> <note>
    /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
    /// </note>
    pub target_selection: std::option::Option<crate::model::TargetSelection>,
    /// <p>The maximum number of results to return per request.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter that limits the returned jobs to those for the specified group.</p>
    pub thing_group_name: std::option::Option<std::string::String>,
    /// <p>A filter that limits the returned jobs to those for the specified group.</p>
    pub thing_group_id: std::option::Option<std::string::String>,
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub namespace_id: std::option::Option<std::string::String>,
}
impl ListJobsInput {
    /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.status.as_ref()
    }
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. </p> <note>
    /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
    /// </note>
    pub fn target_selection(&self) -> std::option::Option<&crate::model::TargetSelection> {
        self.target_selection.as_ref()
    }
    /// <p>The maximum number of results to return per request.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>A filter that limits the returned jobs to those for the specified group.</p>
    pub fn thing_group_name(&self) -> std::option::Option<&str> {
        self.thing_group_name.as_deref()
    }
    /// <p>A filter that limits the returned jobs to those for the specified group.</p>
    pub fn thing_group_id(&self) -> std::option::Option<&str> {
        self.thing_group_id.as_deref()
    }
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub fn namespace_id(&self) -> std::option::Option<&str> {
        self.namespace_id.as_deref()
    }
}
impl std::fmt::Debug for ListJobsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJobsInput");
        formatter.field("status", &self.status);
        formatter.field("target_selection", &self.target_selection);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("thing_group_name", &self.thing_group_name);
        formatter.field("thing_group_id", &self.thing_group_id);
        formatter.field("namespace_id", &self.namespace_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJobExecutionsForThingInput {
    /// <p>The thing name.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
    pub status: std::option::Option<crate::model::JobExecutionStatus>,
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub namespace_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to be returned per request.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl ListJobExecutionsForThingInput {
    /// <p>The thing name.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::JobExecutionStatus> {
        self.status.as_ref()
    }
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub fn namespace_id(&self) -> std::option::Option<&str> {
        self.namespace_id.as_deref()
    }
    /// <p>The maximum number of results to be returned per request.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for ListJobExecutionsForThingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJobExecutionsForThingInput");
        formatter.field("thing_name", &self.thing_name);
        formatter.field("status", &self.status);
        formatter.field("namespace_id", &self.namespace_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJobExecutionsForJobInput {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The status of the job.</p>
    pub status: std::option::Option<crate::model::JobExecutionStatus>,
    /// <p>The maximum number of results to be returned per request.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListJobExecutionsForJobInput {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The status of the job.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::JobExecutionStatus> {
        self.status.as_ref()
    }
    /// <p>The maximum number of results to be returned per request.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListJobExecutionsForJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJobExecutionsForJobInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("status", &self.status);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListIndicesInput {
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListIndicesInput {
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListIndicesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListIndicesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFleetMetricsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <code>null</code> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in this operation.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListFleetMetricsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <code>null</code> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in this operation.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListFleetMetricsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListFleetMetricsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDomainConfigurationsInput {
    /// <p>The marker for the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>The result page size.</p>
    pub page_size: std::option::Option<i32>,
    /// <p>The type of service delivered by the endpoint.</p>
    pub service_type: std::option::Option<crate::model::ServiceType>,
}
impl ListDomainConfigurationsInput {
    /// <p>The marker for the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>The result page size.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
    /// <p>The type of service delivered by the endpoint.</p>
    pub fn service_type(&self) -> std::option::Option<&crate::model::ServiceType> {
        self.service_type.as_ref()
    }
}
impl std::fmt::Debug for ListDomainConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDomainConfigurationsInput");
        formatter.field("marker", &self.marker);
        formatter.field("page_size", &self.page_size);
        formatter.field("service_type", &self.service_type);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDimensionsInput {
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to retrieve at one time.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListDimensionsInput {
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to retrieve at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListDimensionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDimensionsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDetectMitigationActionsTasksInput {
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub max_results: std::option::Option<i32>,
    /// <p> The token for the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p> A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both. </p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The end of the time period for which ML Detect mitigation actions tasks are returned. </p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ListDetectMitigationActionsTasksInput {
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> The token for the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both. </p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p> The end of the time period for which ML Detect mitigation actions tasks are returned. </p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
}
impl std::fmt::Debug for ListDetectMitigationActionsTasksInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDetectMitigationActionsTasksInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDetectMitigationActionsExecutionsInput {
    /// <p> The unique identifier of the task. </p>
    pub task_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier of the violation. </p>
    pub violation_id: std::option::Option<std::string::String>,
    /// <p> The name of the thing whose mitigation actions are listed. </p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p> A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both. </p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The end of the time period for which ML Detect mitigation actions executions are returned. </p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The maximum number of results to return at one time. The default is 25. </p>
    pub max_results: std::option::Option<i32>,
    /// <p> The token for the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDetectMitigationActionsExecutionsInput {
    /// <p> The unique identifier of the task. </p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
    /// <p> The unique identifier of the violation. </p>
    pub fn violation_id(&self) -> std::option::Option<&str> {
        self.violation_id.as_deref()
    }
    /// <p> The name of the thing whose mitigation actions are listed. </p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p> A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both. </p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p> The end of the time period for which ML Detect mitigation actions executions are returned. </p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p> The maximum number of results to return at one time. The default is 25. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> The token for the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListDetectMitigationActionsExecutionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDetectMitigationActionsExecutionsInput");
        formatter.field("task_id", &self.task_id);
        formatter.field("violation_id", &self.violation_id);
        formatter.field("thing_name", &self.thing_name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCustomMetricsInput {
    /// <p> The token for the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of results to return at one time. The default is 25. </p>
    pub max_results: std::option::Option<i32>,
}
impl ListCustomMetricsInput {
    /// <p> The token for the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of results to return at one time. The default is 25. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListCustomMetricsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCustomMetricsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

/// <p>The input to the ListCertificatesByCA operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCertificatesByCaInput {
    /// <p>The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.</p>
    pub ca_certificate_id: std::option::Option<std::string::String>,
    /// <p>The result page size.</p>
    pub page_size: std::option::Option<i32>,
    /// <p>The marker for the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    pub ascending_order: bool,
}
impl ListCertificatesByCaInput {
    /// <p>The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.</p>
    pub fn ca_certificate_id(&self) -> std::option::Option<&str> {
        self.ca_certificate_id.as_deref()
    }
    /// <p>The result page size.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
    /// <p>The marker for the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    pub fn ascending_order(&self) -> bool {
        self.ascending_order
    }
}
impl std::fmt::Debug for ListCertificatesByCaInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCertificatesByCaInput");
        formatter.field("ca_certificate_id", &self.ca_certificate_id);
        formatter.field("page_size", &self.page_size);
        formatter.field("marker", &self.marker);
        formatter.field("ascending_order", &self.ascending_order);
        formatter.finish()
    }
}

/// <p>The input for the ListCertificates operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCertificatesInput {
    /// <p>The result page size.</p>
    pub page_size: std::option::Option<i32>,
    /// <p>The marker for the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    pub ascending_order: bool,
}
impl ListCertificatesInput {
    /// <p>The result page size.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
    /// <p>The marker for the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    pub fn ascending_order(&self) -> bool {
        self.ascending_order
    }
}
impl std::fmt::Debug for ListCertificatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCertificatesInput");
        formatter.field("page_size", &self.page_size);
        formatter.field("marker", &self.marker);
        formatter.field("ascending_order", &self.ascending_order);
        formatter.finish()
    }
}

/// <p>Input for the ListCACertificates operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCaCertificatesInput {
    /// <p>The result page size.</p>
    pub page_size: std::option::Option<i32>,
    /// <p>The marker for the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Determines the order of the results.</p>
    pub ascending_order: bool,
}
impl ListCaCertificatesInput {
    /// <p>The result page size.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
    /// <p>The marker for the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>Determines the order of the results.</p>
    pub fn ascending_order(&self) -> bool {
        self.ascending_order
    }
}
impl std::fmt::Debug for ListCaCertificatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCaCertificatesInput");
        formatter.field("page_size", &self.page_size);
        formatter.field("marker", &self.marker);
        formatter.field("ascending_order", &self.ascending_order);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBillingGroupsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per request.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>Limit the results to billing groups whose names have the given prefix.</p>
    pub name_prefix_filter: std::option::Option<std::string::String>,
}
impl ListBillingGroupsInput {
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return per request.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Limit the results to billing groups whose names have the given prefix.</p>
    pub fn name_prefix_filter(&self) -> std::option::Option<&str> {
        self.name_prefix_filter.as_deref()
    }
}
impl std::fmt::Debug for ListBillingGroupsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBillingGroupsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("name_prefix_filter", &self.name_prefix_filter);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAuthorizersInput {
    /// <p>The maximum number of results to return at one time.</p>
    pub page_size: std::option::Option<i32>,
    /// <p>A marker used to get the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>Return the list of authorizers in ascending alphabetical order.</p>
    pub ascending_order: bool,
    /// <p>The status of the list authorizers request.</p>
    pub status: std::option::Option<crate::model::AuthorizerStatus>,
}
impl ListAuthorizersInput {
    /// <p>The maximum number of results to return at one time.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
    /// <p>A marker used to get the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>Return the list of authorizers in ascending alphabetical order.</p>
    pub fn ascending_order(&self) -> bool {
        self.ascending_order
    }
    /// <p>The status of the list authorizers request.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AuthorizerStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for ListAuthorizersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAuthorizersInput");
        formatter.field("page_size", &self.page_size);
        formatter.field("marker", &self.marker);
        formatter.field("ascending_order", &self.ascending_order);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAuditTasksInput {
    /// <p>The beginning of the time period. Audit information is retained for a limited time (90 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end of the time period.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".</p>
    pub task_type: std::option::Option<crate::model::AuditTaskType>,
    /// <p>A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".</p>
    pub task_status: std::option::Option<crate::model::AuditTaskStatus>,
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListAuditTasksInput {
    /// <p>The beginning of the time period. Audit information is retained for a limited time (90 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The end of the time period.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".</p>
    pub fn task_type(&self) -> std::option::Option<&crate::model::AuditTaskType> {
        self.task_type.as_ref()
    }
    /// <p>A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".</p>
    pub fn task_status(&self) -> std::option::Option<&crate::model::AuditTaskStatus> {
        self.task_status.as_ref()
    }
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListAuditTasksInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAuditTasksInput");
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("task_type", &self.task_type);
        formatter.field("task_status", &self.task_status);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAuditSuppressionsInput {
    /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub check_name: std::option::Option<std::string::String>,
    /// <p>Information that identifies the noncompliant resource.</p>
    pub resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
    /// <p> Determines whether suppressions are listed in ascending order by expiration date or not. If parameter isn't provided, <code>ascendingOrder=true</code>. </p>
    pub ascending_order: bool,
    /// <p> The token for the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of results to return at one time. The default is 25. </p>
    pub max_results: std::option::Option<i32>,
}
impl ListAuditSuppressionsInput {
    /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub fn check_name(&self) -> std::option::Option<&str> {
        self.check_name.as_deref()
    }
    /// <p>Information that identifies the noncompliant resource.</p>
    pub fn resource_identifier(&self) -> std::option::Option<&crate::model::ResourceIdentifier> {
        self.resource_identifier.as_ref()
    }
    /// <p> Determines whether suppressions are listed in ascending order by expiration date or not. If parameter isn't provided, <code>ascendingOrder=true</code>. </p>
    pub fn ascending_order(&self) -> bool {
        self.ascending_order
    }
    /// <p> The token for the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of results to return at one time. The default is 25. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListAuditSuppressionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAuditSuppressionsInput");
        formatter.field("check_name", &self.check_name);
        formatter.field("resource_identifier", &self.resource_identifier);
        formatter.field("ascending_order", &self.ascending_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAuditMitigationActionsTasksInput {
    /// <p>Specify this filter to limit results to tasks that were applied to results for a specific audit.</p>
    pub audit_task_id: std::option::Option<std::string::String>,
    /// <p>Specify this filter to limit results to tasks that were applied to a specific audit finding.</p>
    pub finding_id: std::option::Option<std::string::String>,
    /// <p>Specify this filter to limit results to tasks that are in a specific state.</p>
    pub task_status: std::option::Option<crate::model::AuditMitigationActionsTaskStatus>,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Specify this filter to limit results to tasks that began on or after a specific date and time.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ListAuditMitigationActionsTasksInput {
    /// <p>Specify this filter to limit results to tasks that were applied to results for a specific audit.</p>
    pub fn audit_task_id(&self) -> std::option::Option<&str> {
        self.audit_task_id.as_deref()
    }
    /// <p>Specify this filter to limit results to tasks that were applied to a specific audit finding.</p>
    pub fn finding_id(&self) -> std::option::Option<&str> {
        self.finding_id.as_deref()
    }
    /// <p>Specify this filter to limit results to tasks that are in a specific state.</p>
    pub fn task_status(
        &self,
    ) -> std::option::Option<&crate::model::AuditMitigationActionsTaskStatus> {
        self.task_status.as_ref()
    }
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>Specify this filter to limit results to tasks that began on or after a specific date and time.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
}
impl std::fmt::Debug for ListAuditMitigationActionsTasksInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAuditMitigationActionsTasksInput");
        formatter.field("audit_task_id", &self.audit_task_id);
        formatter.field("finding_id", &self.finding_id);
        formatter.field("task_status", &self.task_status);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAuditMitigationActionsExecutionsInput {
    /// <p>Specify this filter to limit results to actions for a specific audit mitigation actions task.</p>
    pub task_id: std::option::Option<std::string::String>,
    /// <p>Specify this filter to limit results to those with a specific status.</p>
    pub action_status: std::option::Option<crate::model::AuditMitigationActionsExecutionStatus>,
    /// <p>Specify this filter to limit results to those that were applied to a specific audit finding.</p>
    pub finding_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListAuditMitigationActionsExecutionsInput {
    /// <p>Specify this filter to limit results to actions for a specific audit mitigation actions task.</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
    /// <p>Specify this filter to limit results to those with a specific status.</p>
    pub fn action_status(
        &self,
    ) -> std::option::Option<&crate::model::AuditMitigationActionsExecutionStatus> {
        self.action_status.as_ref()
    }
    /// <p>Specify this filter to limit results to those that were applied to a specific audit finding.</p>
    pub fn finding_id(&self) -> std::option::Option<&str> {
        self.finding_id.as_deref()
    }
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListAuditMitigationActionsExecutionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAuditMitigationActionsExecutionsInput");
        formatter.field("task_id", &self.task_id);
        formatter.field("action_status", &self.action_status);
        formatter.field("finding_id", &self.finding_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAuditFindingsInput {
    /// <p>A filter to limit results to the audit with the specified ID. You must specify either the taskId or the startTime and endTime, but not both.</p>
    pub task_id: std::option::Option<std::string::String>,
    /// <p>A filter to limit results to the findings for the specified audit check.</p>
    pub check_name: std::option::Option<std::string::String>,
    /// <p>Information identifying the noncompliant resource.</p>
    pub resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A filter to limit results to those found before the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> Boolean flag indicating whether only the suppressed findings or the unsuppressed findings should be listed. If this parameter isn't provided, the response will list both suppressed and unsuppressed findings. </p>
    pub list_suppressed_findings: bool,
}
impl ListAuditFindingsInput {
    /// <p>A filter to limit results to the audit with the specified ID. You must specify either the taskId or the startTime and endTime, but not both.</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
    /// <p>A filter to limit results to the findings for the specified audit check.</p>
    pub fn check_name(&self) -> std::option::Option<&str> {
        self.check_name.as_deref()
    }
    /// <p>Information identifying the noncompliant resource.</p>
    pub fn resource_identifier(&self) -> std::option::Option<&crate::model::ResourceIdentifier> {
        self.resource_identifier.as_ref()
    }
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>A filter to limit results to those found before the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p> Boolean flag indicating whether only the suppressed findings or the unsuppressed findings should be listed. If this parameter isn't provided, the response will list both suppressed and unsuppressed findings. </p>
    pub fn list_suppressed_findings(&self) -> bool {
        self.list_suppressed_findings
    }
}
impl std::fmt::Debug for ListAuditFindingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAuditFindingsInput");
        formatter.field("task_id", &self.task_id);
        formatter.field("check_name", &self.check_name);
        formatter.field("resource_identifier", &self.resource_identifier);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("list_suppressed_findings", &self.list_suppressed_findings);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAttachedPoliciesInput {
    /// <p>The group or principal for which the policies will be listed. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    pub target: std::option::Option<std::string::String>,
    /// <p>When true, recursively list attached policies.</p>
    pub recursive: bool,
    /// <p>The token to retrieve the next set of results.</p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to be returned per request.</p>
    pub page_size: std::option::Option<i32>,
}
impl ListAttachedPoliciesInput {
    /// <p>The group or principal for which the policies will be listed. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    pub fn target(&self) -> std::option::Option<&str> {
        self.target.as_deref()
    }
    /// <p>When true, recursively list attached policies.</p>
    pub fn recursive(&self) -> bool {
        self.recursive
    }
    /// <p>The token to retrieve the next set of results.</p>
    pub fn marker(&self) -> std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>The maximum number of results to be returned per request.</p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
}
impl std::fmt::Debug for ListAttachedPoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAttachedPoliciesInput");
        formatter.field("target", &self.target);
        formatter.field("recursive", &self.recursive);
        formatter.field("marker", &self.marker);
        formatter.field("page_size", &self.page_size);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListActiveViolationsInput {
    /// <p>The name of the thing whose active violations are listed.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The name of the Device Defender security profile for which violations are listed.</p>
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p> The criteria for a behavior. </p>
    pub behavior_criteria_type: std::option::Option<crate::model::BehaviorCriteriaType>,
    /// <p> A list of all suppressed alerts. </p>
    pub list_suppressed_alerts: std::option::Option<bool>,
    /// <p>The verification state of the violation (detect alarm).</p>
    pub verification_state: std::option::Option<crate::model::VerificationState>,
    /// <p>The token for the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return at one time.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListActiveViolationsInput {
    /// <p>The name of the thing whose active violations are listed.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The name of the Device Defender security profile for which violations are listed.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p> The criteria for a behavior. </p>
    pub fn behavior_criteria_type(
        &self,
    ) -> std::option::Option<&crate::model::BehaviorCriteriaType> {
        self.behavior_criteria_type.as_ref()
    }
    /// <p> A list of all suppressed alerts. </p>
    pub fn list_suppressed_alerts(&self) -> std::option::Option<bool> {
        self.list_suppressed_alerts
    }
    /// <p>The verification state of the violation (detect alarm).</p>
    pub fn verification_state(&self) -> std::option::Option<&crate::model::VerificationState> {
        self.verification_state.as_ref()
    }
    /// <p>The token for the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return at one time.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListActiveViolationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListActiveViolationsInput");
        formatter.field("thing_name", &self.thing_name);
        formatter.field("security_profile_name", &self.security_profile_name);
        formatter.field("behavior_criteria_type", &self.behavior_criteria_type);
        formatter.field("list_suppressed_alerts", &self.list_suppressed_alerts);
        formatter.field("verification_state", &self.verification_state);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetV2LoggingOptionsInput {}
impl std::fmt::Debug for GetV2LoggingOptionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetV2LoggingOptionsInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTopicRuleDestinationInput {
    /// <p>The ARN of the topic rule destination.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl GetTopicRuleDestinationInput {
    /// <p>The ARN of the topic rule destination.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for GetTopicRuleDestinationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetTopicRuleDestinationInput");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}

/// <p>The input for the GetTopicRule operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTopicRuleInput {
    /// <p>The name of the rule.</p>
    pub rule_name: std::option::Option<std::string::String>,
}
impl GetTopicRuleInput {
    /// <p>The name of the rule.</p>
    pub fn rule_name(&self) -> std::option::Option<&str> {
        self.rule_name.as_deref()
    }
}
impl std::fmt::Debug for GetTopicRuleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetTopicRuleInput");
        formatter.field("rule_name", &self.rule_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetStatisticsInput {
    /// <p>The name of the index to search. The default value is <code>AWS_Things</code>.</p>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The query used to search. You can specify "*" for the query string to get the count of all indexed things in your Amazon Web Services account.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The aggregation field name.</p>
    pub aggregation_field: std::option::Option<std::string::String>,
    /// <p>The version of the query used to search.</p>
    pub query_version: std::option::Option<std::string::String>,
}
impl GetStatisticsInput {
    /// <p>The name of the index to search. The default value is <code>AWS_Things</code>.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>The query used to search. You can specify "*" for the query string to get the count of all indexed things in your Amazon Web Services account.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The aggregation field name.</p>
    pub fn aggregation_field(&self) -> std::option::Option<&str> {
        self.aggregation_field.as_deref()
    }
    /// <p>The version of the query used to search.</p>
    pub fn query_version(&self) -> std::option::Option<&str> {
        self.query_version.as_deref()
    }
}
impl std::fmt::Debug for GetStatisticsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetStatisticsInput");
        formatter.field("index_name", &self.index_name);
        formatter.field("query_string", &self.query_string);
        formatter.field("aggregation_field", &self.aggregation_field);
        formatter.field("query_version", &self.query_version);
        formatter.finish()
    }
}

/// <p>The input to the GetRegistrationCode operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRegistrationCodeInput {}
impl std::fmt::Debug for GetRegistrationCodeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRegistrationCodeInput");
        formatter.finish()
    }
}

/// <p>The input for the GetPolicyVersion operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPolicyVersionInput {
    /// <p>The name of the policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The policy version ID.</p>
    pub policy_version_id: std::option::Option<std::string::String>,
}
impl GetPolicyVersionInput {
    /// <p>The name of the policy.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The policy version ID.</p>
    pub fn policy_version_id(&self) -> std::option::Option<&str> {
        self.policy_version_id.as_deref()
    }
}
impl std::fmt::Debug for GetPolicyVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPolicyVersionInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_version_id", &self.policy_version_id);
        formatter.finish()
    }
}

/// <p>The input for the GetPolicy operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPolicyInput {
    /// <p>The name of the policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl GetPolicyInput {
    /// <p>The name of the policy.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
}
impl std::fmt::Debug for GetPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPolicyInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPercentilesInput {
    /// <p>The name of the index to search.</p>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The search query string.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The field to aggregate.</p>
    pub aggregation_field: std::option::Option<std::string::String>,
    /// <p>The query version.</p>
    pub query_version: std::option::Option<std::string::String>,
    /// <p>The percentile groups returned.</p>
    pub percents: std::option::Option<std::vec::Vec<f64>>,
}
impl GetPercentilesInput {
    /// <p>The name of the index to search.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>The search query string.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The field to aggregate.</p>
    pub fn aggregation_field(&self) -> std::option::Option<&str> {
        self.aggregation_field.as_deref()
    }
    /// <p>The query version.</p>
    pub fn query_version(&self) -> std::option::Option<&str> {
        self.query_version.as_deref()
    }
    /// <p>The percentile groups returned.</p>
    pub fn percents(&self) -> std::option::Option<&[f64]> {
        self.percents.as_deref()
    }
}
impl std::fmt::Debug for GetPercentilesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPercentilesInput");
        formatter.field("index_name", &self.index_name);
        formatter.field("query_string", &self.query_string);
        formatter.field("aggregation_field", &self.aggregation_field);
        formatter.field("query_version", &self.query_version);
        formatter.field("percents", &self.percents);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOtaUpdateInput {
    /// <p>The OTA update ID.</p>
    pub ota_update_id: std::option::Option<std::string::String>,
}
impl GetOtaUpdateInput {
    /// <p>The OTA update ID.</p>
    pub fn ota_update_id(&self) -> std::option::Option<&str> {
        self.ota_update_id.as_deref()
    }
}
impl std::fmt::Debug for GetOtaUpdateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOtaUpdateInput");
        formatter.field("ota_update_id", &self.ota_update_id);
        formatter.finish()
    }
}

/// <p>The input for the GetLoggingOptions operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLoggingOptionsInput {}
impl std::fmt::Debug for GetLoggingOptionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLoggingOptionsInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetJobDocumentInput {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl GetJobDocumentInput {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for GetJobDocumentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetJobDocumentInput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetIndexingConfigurationInput {}
impl std::fmt::Debug for GetIndexingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetIndexingConfigurationInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetEffectivePoliciesInput {
    /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    pub principal: std::option::Option<std::string::String>,
    /// <p>The Cognito identity pool ID.</p>
    pub cognito_identity_pool_id: std::option::Option<std::string::String>,
    /// <p>The thing name.</p>
    pub thing_name: std::option::Option<std::string::String>,
}
impl GetEffectivePoliciesInput {
    /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    pub fn principal(&self) -> std::option::Option<&str> {
        self.principal.as_deref()
    }
    /// <p>The Cognito identity pool ID.</p>
    pub fn cognito_identity_pool_id(&self) -> std::option::Option<&str> {
        self.cognito_identity_pool_id.as_deref()
    }
    /// <p>The thing name.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
}
impl std::fmt::Debug for GetEffectivePoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetEffectivePoliciesInput");
        formatter.field("principal", &self.principal);
        formatter.field("cognito_identity_pool_id", &self.cognito_identity_pool_id);
        formatter.field("thing_name", &self.thing_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCardinalityInput {
    /// <p>The name of the index to search.</p>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The search query string.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The field to aggregate.</p>
    pub aggregation_field: std::option::Option<std::string::String>,
    /// <p>The query version.</p>
    pub query_version: std::option::Option<std::string::String>,
}
impl GetCardinalityInput {
    /// <p>The name of the index to search.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>The search query string.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The field to aggregate.</p>
    pub fn aggregation_field(&self) -> std::option::Option<&str> {
        self.aggregation_field.as_deref()
    }
    /// <p>The query version.</p>
    pub fn query_version(&self) -> std::option::Option<&str> {
        self.query_version.as_deref()
    }
}
impl std::fmt::Debug for GetCardinalityInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCardinalityInput");
        formatter.field("index_name", &self.index_name);
        formatter.field("query_string", &self.query_string);
        formatter.field("aggregation_field", &self.aggregation_field);
        formatter.field("query_version", &self.query_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketsAggregationInput {
    /// <p>The name of the index to search.</p>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The search query string.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The aggregation field.</p>
    pub aggregation_field: std::option::Option<std::string::String>,
    /// <p>The version of the query.</p>
    pub query_version: std::option::Option<std::string::String>,
    /// <p>The basic control of the response shape and the bucket aggregation type to perform. </p>
    pub buckets_aggregation_type: std::option::Option<crate::model::BucketsAggregationType>,
}
impl GetBucketsAggregationInput {
    /// <p>The name of the index to search.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>The search query string.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The aggregation field.</p>
    pub fn aggregation_field(&self) -> std::option::Option<&str> {
        self.aggregation_field.as_deref()
    }
    /// <p>The version of the query.</p>
    pub fn query_version(&self) -> std::option::Option<&str> {
        self.query_version.as_deref()
    }
    /// <p>The basic control of the response shape and the bucket aggregation type to perform. </p>
    pub fn buckets_aggregation_type(
        &self,
    ) -> std::option::Option<&crate::model::BucketsAggregationType> {
        self.buckets_aggregation_type.as_ref()
    }
}
impl std::fmt::Debug for GetBucketsAggregationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketsAggregationInput");
        formatter.field("index_name", &self.index_name);
        formatter.field("query_string", &self.query_string);
        formatter.field("aggregation_field", &self.aggregation_field);
        formatter.field("query_version", &self.query_version);
        formatter.field("buckets_aggregation_type", &self.buckets_aggregation_type);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBehaviorModelTrainingSummariesInput {
    /// <p> The name of the security profile. </p>
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p> The maximum number of results to return at one time. The default is 25. </p>
    pub max_results: std::option::Option<i32>,
    /// <p> The token for the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetBehaviorModelTrainingSummariesInput {
    /// <p> The name of the security profile. </p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p> The maximum number of results to return at one time. The default is 25. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> The token for the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetBehaviorModelTrainingSummariesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBehaviorModelTrainingSummariesInput");
        formatter.field("security_profile_name", &self.security_profile_name);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>The input for the EnableTopicRuleRequest operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableTopicRuleInput {
    /// <p>The name of the topic rule to enable.</p>
    pub rule_name: std::option::Option<std::string::String>,
}
impl EnableTopicRuleInput {
    /// <p>The name of the topic rule to enable.</p>
    pub fn rule_name(&self) -> std::option::Option<&str> {
        self.rule_name.as_deref()
    }
}
impl std::fmt::Debug for EnableTopicRuleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableTopicRuleInput");
        formatter.field("rule_name", &self.rule_name);
        formatter.finish()
    }
}

/// <p>The input for the DisableTopicRuleRequest operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableTopicRuleInput {
    /// <p>The name of the rule to disable.</p>
    pub rule_name: std::option::Option<std::string::String>,
}
impl DisableTopicRuleInput {
    /// <p>The name of the rule to disable.</p>
    pub fn rule_name(&self) -> std::option::Option<&str> {
        self.rule_name.as_deref()
    }
}
impl std::fmt::Debug for DisableTopicRuleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableTopicRuleInput");
        formatter.field("rule_name", &self.rule_name);
        formatter.finish()
    }
}

/// <p>The input for the DetachThingPrincipal operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetachThingPrincipalInput {
    /// <p>The name of the thing.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.</p>
    pub principal: std::option::Option<std::string::String>,
}
impl DetachThingPrincipalInput {
    /// <p>The name of the thing.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.</p>
    pub fn principal(&self) -> std::option::Option<&str> {
        self.principal.as_deref()
    }
}
impl std::fmt::Debug for DetachThingPrincipalInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetachThingPrincipalInput");
        formatter.field("thing_name", &self.thing_name);
        formatter.field("principal", &self.principal);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetachSecurityProfileInput {
    /// <p>The security profile that is detached.</p>
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the thing group from which the security profile is detached.</p>
    pub security_profile_target_arn: std::option::Option<std::string::String>,
}
impl DetachSecurityProfileInput {
    /// <p>The security profile that is detached.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p>The ARN of the thing group from which the security profile is detached.</p>
    pub fn security_profile_target_arn(&self) -> std::option::Option<&str> {
        self.security_profile_target_arn.as_deref()
    }
}
impl std::fmt::Debug for DetachSecurityProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetachSecurityProfileInput");
        formatter.field("security_profile_name", &self.security_profile_name);
        formatter.field(
            "security_profile_target_arn",
            &self.security_profile_target_arn,
        );
        formatter.finish()
    }
}

/// <p>The input for the DetachPrincipalPolicy operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetachPrincipalPolicyInput {
    /// <p>The name of the policy to detach.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The principal.</p>
    /// <p>Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    pub principal: std::option::Option<std::string::String>,
}
impl DetachPrincipalPolicyInput {
    /// <p>The name of the policy to detach.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The principal.</p>
    /// <p>Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
    pub fn principal(&self) -> std::option::Option<&str> {
        self.principal.as_deref()
    }
}
impl std::fmt::Debug for DetachPrincipalPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetachPrincipalPolicyInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("principal", &self.principal);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetachPolicyInput {
    /// <p>The policy to detach.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The target from which the policy will be detached.</p>
    pub target: std::option::Option<std::string::String>,
}
impl DetachPolicyInput {
    /// <p>The policy to detach.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The target from which the policy will be detached.</p>
    pub fn target(&self) -> std::option::Option<&str> {
        self.target.as_deref()
    }
}
impl std::fmt::Debug for DetachPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetachPolicyInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("target", &self.target);
        formatter.finish()
    }
}

/// <p>The input for the DescribeThingType operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeThingTypeInput {
    /// <p>The name of the thing type.</p>
    pub thing_type_name: std::option::Option<std::string::String>,
}
impl DescribeThingTypeInput {
    /// <p>The name of the thing type.</p>
    pub fn thing_type_name(&self) -> std::option::Option<&str> {
        self.thing_type_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeThingTypeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeThingTypeInput");
        formatter.field("thing_type_name", &self.thing_type_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeThingRegistrationTaskInput {
    /// <p>The task ID.</p>
    pub task_id: std::option::Option<std::string::String>,
}
impl DescribeThingRegistrationTaskInput {
    /// <p>The task ID.</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
}
impl std::fmt::Debug for DescribeThingRegistrationTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeThingRegistrationTaskInput");
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeThingGroupInput {
    /// <p>The name of the thing group.</p>
    pub thing_group_name: std::option::Option<std::string::String>,
}
impl DescribeThingGroupInput {
    /// <p>The name of the thing group.</p>
    pub fn thing_group_name(&self) -> std::option::Option<&str> {
        self.thing_group_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeThingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeThingGroupInput");
        formatter.field("thing_group_name", &self.thing_group_name);
        formatter.finish()
    }
}

/// <p>The input for the DescribeThing operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeThingInput {
    /// <p>The name of the thing.</p>
    pub thing_name: std::option::Option<std::string::String>,
}
impl DescribeThingInput {
    /// <p>The name of the thing.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeThingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeThingInput");
        formatter.field("thing_name", &self.thing_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeStreamInput {
    /// <p>The stream ID.</p>
    pub stream_id: std::option::Option<std::string::String>,
}
impl DescribeStreamInput {
    /// <p>The stream ID.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
}
impl std::fmt::Debug for DescribeStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeStreamInput");
        formatter.field("stream_id", &self.stream_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSecurityProfileInput {
    /// <p>The name of the security profile whose information you want to get.</p>
    pub security_profile_name: std::option::Option<std::string::String>,
}
impl DescribeSecurityProfileInput {
    /// <p>The name of the security profile whose information you want to get.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeSecurityProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSecurityProfileInput");
        formatter.field("security_profile_name", &self.security_profile_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeScheduledAuditInput {
    /// <p>The name of the scheduled audit whose information you want to get.</p>
    pub scheduled_audit_name: std::option::Option<std::string::String>,
}
impl DescribeScheduledAuditInput {
    /// <p>The name of the scheduled audit whose information you want to get.</p>
    pub fn scheduled_audit_name(&self) -> std::option::Option<&str> {
        self.scheduled_audit_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeScheduledAuditInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeScheduledAuditInput");
        formatter.field("scheduled_audit_name", &self.scheduled_audit_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeRoleAliasInput {
    /// <p>The role alias to describe.</p>
    pub role_alias: std::option::Option<std::string::String>,
}
impl DescribeRoleAliasInput {
    /// <p>The role alias to describe.</p>
    pub fn role_alias(&self) -> std::option::Option<&str> {
        self.role_alias.as_deref()
    }
}
impl std::fmt::Debug for DescribeRoleAliasInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeRoleAliasInput");
        formatter.field("role_alias", &self.role_alias);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProvisioningTemplateVersionInput {
    /// <p>The template name.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The fleet provisioning template version ID.</p>
    pub version_id: std::option::Option<i32>,
}
impl DescribeProvisioningTemplateVersionInput {
    /// <p>The template name.</p>
    pub fn template_name(&self) -> std::option::Option<&str> {
        self.template_name.as_deref()
    }
    /// <p>The fleet provisioning template version ID.</p>
    pub fn version_id(&self) -> std::option::Option<i32> {
        self.version_id
    }
}
impl std::fmt::Debug for DescribeProvisioningTemplateVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProvisioningTemplateVersionInput");
        formatter.field("template_name", &self.template_name);
        formatter.field("version_id", &self.version_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeProvisioningTemplateInput {
    /// <p>The name of the fleet provisioning template.</p>
    pub template_name: std::option::Option<std::string::String>,
}
impl DescribeProvisioningTemplateInput {
    /// <p>The name of the fleet provisioning template.</p>
    pub fn template_name(&self) -> std::option::Option<&str> {
        self.template_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeProvisioningTemplateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeProvisioningTemplateInput");
        formatter.field("template_name", &self.template_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMitigationActionInput {
    /// <p>The friendly name that uniquely identifies the mitigation action.</p>
    pub action_name: std::option::Option<std::string::String>,
}
impl DescribeMitigationActionInput {
    /// <p>The friendly name that uniquely identifies the mitigation action.</p>
    pub fn action_name(&self) -> std::option::Option<&str> {
        self.action_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeMitigationActionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMitigationActionInput");
        formatter.field("action_name", &self.action_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeManagedJobTemplateInput {
    /// <p>The unique name of a managed job template, which is required.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>An optional parameter to specify version of a managed template. If not specified, the pre-defined default version is returned.</p>
    pub template_version: std::option::Option<std::string::String>,
}
impl DescribeManagedJobTemplateInput {
    /// <p>The unique name of a managed job template, which is required.</p>
    pub fn template_name(&self) -> std::option::Option<&str> {
        self.template_name.as_deref()
    }
    /// <p>An optional parameter to specify version of a managed template. If not specified, the pre-defined default version is returned.</p>
    pub fn template_version(&self) -> std::option::Option<&str> {
        self.template_version.as_deref()
    }
}
impl std::fmt::Debug for DescribeManagedJobTemplateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeManagedJobTemplateInput");
        formatter.field("template_name", &self.template_name);
        formatter.field("template_version", &self.template_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJobTemplateInput {
    /// <p>The unique identifier of the job template.</p>
    pub job_template_id: std::option::Option<std::string::String>,
}
impl DescribeJobTemplateInput {
    /// <p>The unique identifier of the job template.</p>
    pub fn job_template_id(&self) -> std::option::Option<&str> {
        self.job_template_id.as_deref()
    }
}
impl std::fmt::Debug for DescribeJobTemplateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJobTemplateInput");
        formatter.field("job_template_id", &self.job_template_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJobExecutionInput {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The name of the thing on which the job execution is running.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.</p>
    pub execution_number: std::option::Option<i64>,
}
impl DescribeJobExecutionInput {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The name of the thing on which the job execution is running.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.</p>
    pub fn execution_number(&self) -> std::option::Option<i64> {
        self.execution_number
    }
}
impl std::fmt::Debug for DescribeJobExecutionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJobExecutionInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("thing_name", &self.thing_name);
        formatter.field("execution_number", &self.execution_number);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeJobInput {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl DescribeJobInput {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for DescribeJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeJobInput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeIndexInput {
    /// <p>The index name.</p>
    pub index_name: std::option::Option<std::string::String>,
}
impl DescribeIndexInput {
    /// <p>The index name.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeIndexInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeIndexInput");
        formatter.field("index_name", &self.index_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeFleetMetricInput {
    /// <p>The name of the fleet metric to describe.</p>
    pub metric_name: std::option::Option<std::string::String>,
}
impl DescribeFleetMetricInput {
    /// <p>The name of the fleet metric to describe.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeFleetMetricInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeFleetMetricInput");
        formatter.field("metric_name", &self.metric_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEventConfigurationsInput {}
impl std::fmt::Debug for DescribeEventConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEventConfigurationsInput");
        formatter.finish()
    }
}

/// <p>The input for the DescribeEndpoint operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEndpointInput {
    /// <p>The endpoint type. Valid endpoint types include:</p>
    /// <ul>
    /// <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>iot:CredentialProvider</code> - Returns an IoT credentials provider API endpoint.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>iot:Jobs</code> - Returns an IoT device management Jobs API endpoint.</p> </li>
    /// </ul>
    /// <p>We strongly recommend that customers use the newer <code>iot:Data-ATS</code> endpoint type to avoid issues related to the widespread distrust of Symantec certificate authorities.</p>
    pub endpoint_type: std::option::Option<std::string::String>,
}
impl DescribeEndpointInput {
    /// <p>The endpoint type. Valid endpoint types include:</p>
    /// <ul>
    /// <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>iot:CredentialProvider</code> - Returns an IoT credentials provider API endpoint.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>iot:Jobs</code> - Returns an IoT device management Jobs API endpoint.</p> </li>
    /// </ul>
    /// <p>We strongly recommend that customers use the newer <code>iot:Data-ATS</code> endpoint type to avoid issues related to the widespread distrust of Symantec certificate authorities.</p>
    pub fn endpoint_type(&self) -> std::option::Option<&str> {
        self.endpoint_type.as_deref()
    }
}
impl std::fmt::Debug for DescribeEndpointInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEndpointInput");
        formatter.field("endpoint_type", &self.endpoint_type);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDomainConfigurationInput {
    /// <p>The name of the domain configuration.</p>
    pub domain_configuration_name: std::option::Option<std::string::String>,
}
impl DescribeDomainConfigurationInput {
    /// <p>The name of the domain configuration.</p>
    pub fn domain_configuration_name(&self) -> std::option::Option<&str> {
        self.domain_configuration_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeDomainConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDomainConfigurationInput");
        formatter.field("domain_configuration_name", &self.domain_configuration_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDimensionInput {
    /// <p>The unique identifier for the dimension.</p>
    pub name: std::option::Option<std::string::String>,
}
impl DescribeDimensionInput {
    /// <p>The unique identifier for the dimension.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for DescribeDimensionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDimensionInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDetectMitigationActionsTaskInput {
    /// <p> The unique identifier of the task. </p>
    pub task_id: std::option::Option<std::string::String>,
}
impl DescribeDetectMitigationActionsTaskInput {
    /// <p> The unique identifier of the task. </p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
}
impl std::fmt::Debug for DescribeDetectMitigationActionsTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDetectMitigationActionsTaskInput");
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDefaultAuthorizerInput {}
impl std::fmt::Debug for DescribeDefaultAuthorizerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDefaultAuthorizerInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeCustomMetricInput {
    /// <p> The name of the custom metric. </p>
    pub metric_name: std::option::Option<std::string::String>,
}
impl DescribeCustomMetricInput {
    /// <p> The name of the custom metric. </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeCustomMetricInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeCustomMetricInput");
        formatter.field("metric_name", &self.metric_name);
        formatter.finish()
    }
}

/// <p>The input for the DescribeCertificate operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeCertificateInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub certificate_id: std::option::Option<std::string::String>,
}
impl DescribeCertificateInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub fn certificate_id(&self) -> std::option::Option<&str> {
        self.certificate_id.as_deref()
    }
}
impl std::fmt::Debug for DescribeCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeCertificateInput");
        formatter.field("certificate_id", &self.certificate_id);
        formatter.finish()
    }
}

/// <p>The input for the DescribeCACertificate operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeCaCertificateInput {
    /// <p>The CA certificate identifier.</p>
    pub certificate_id: std::option::Option<std::string::String>,
}
impl DescribeCaCertificateInput {
    /// <p>The CA certificate identifier.</p>
    pub fn certificate_id(&self) -> std::option::Option<&str> {
        self.certificate_id.as_deref()
    }
}
impl std::fmt::Debug for DescribeCaCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeCaCertificateInput");
        formatter.field("certificate_id", &self.certificate_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeBillingGroupInput {
    /// <p>The name of the billing group.</p>
    pub billing_group_name: std::option::Option<std::string::String>,
}
impl DescribeBillingGroupInput {
    /// <p>The name of the billing group.</p>
    pub fn billing_group_name(&self) -> std::option::Option<&str> {
        self.billing_group_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeBillingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeBillingGroupInput");
        formatter.field("billing_group_name", &self.billing_group_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAuthorizerInput {
    /// <p>The name of the authorizer to describe.</p>
    pub authorizer_name: std::option::Option<std::string::String>,
}
impl DescribeAuthorizerInput {
    /// <p>The name of the authorizer to describe.</p>
    pub fn authorizer_name(&self) -> std::option::Option<&str> {
        self.authorizer_name.as_deref()
    }
}
impl std::fmt::Debug for DescribeAuthorizerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAuthorizerInput");
        formatter.field("authorizer_name", &self.authorizer_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAuditTaskInput {
    /// <p>The ID of the audit whose information you want to get.</p>
    pub task_id: std::option::Option<std::string::String>,
}
impl DescribeAuditTaskInput {
    /// <p>The ID of the audit whose information you want to get.</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
}
impl std::fmt::Debug for DescribeAuditTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAuditTaskInput");
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAuditSuppressionInput {
    /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub check_name: std::option::Option<std::string::String>,
    /// <p>Information that identifies the noncompliant resource.</p>
    pub resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
}
impl DescribeAuditSuppressionInput {
    /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub fn check_name(&self) -> std::option::Option<&str> {
        self.check_name.as_deref()
    }
    /// <p>Information that identifies the noncompliant resource.</p>
    pub fn resource_identifier(&self) -> std::option::Option<&crate::model::ResourceIdentifier> {
        self.resource_identifier.as_ref()
    }
}
impl std::fmt::Debug for DescribeAuditSuppressionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAuditSuppressionInput");
        formatter.field("check_name", &self.check_name);
        formatter.field("resource_identifier", &self.resource_identifier);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAuditMitigationActionsTaskInput {
    /// <p>The unique identifier for the audit mitigation task.</p>
    pub task_id: std::option::Option<std::string::String>,
}
impl DescribeAuditMitigationActionsTaskInput {
    /// <p>The unique identifier for the audit mitigation task.</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
}
impl std::fmt::Debug for DescribeAuditMitigationActionsTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAuditMitigationActionsTaskInput");
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAuditFindingInput {
    /// <p>A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.</p>
    pub finding_id: std::option::Option<std::string::String>,
}
impl DescribeAuditFindingInput {
    /// <p>A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.</p>
    pub fn finding_id(&self) -> std::option::Option<&str> {
        self.finding_id.as_deref()
    }
}
impl std::fmt::Debug for DescribeAuditFindingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAuditFindingInput");
        formatter.field("finding_id", &self.finding_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAccountAuditConfigurationInput {}
impl std::fmt::Debug for DescribeAccountAuditConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAccountAuditConfigurationInput");
        formatter.finish()
    }
}

/// <p>The input for the DeprecateThingType operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeprecateThingTypeInput {
    /// <p>The name of the thing type to deprecate.</p>
    pub thing_type_name: std::option::Option<std::string::String>,
    /// <p>Whether to undeprecate a deprecated thing type. If <b>true</b>, the thing type will not be deprecated anymore and you can associate it with things.</p>
    pub undo_deprecate: bool,
}
impl DeprecateThingTypeInput {
    /// <p>The name of the thing type to deprecate.</p>
    pub fn thing_type_name(&self) -> std::option::Option<&str> {
        self.thing_type_name.as_deref()
    }
    /// <p>Whether to undeprecate a deprecated thing type. If <b>true</b>, the thing type will not be deprecated anymore and you can associate it with things.</p>
    pub fn undo_deprecate(&self) -> bool {
        self.undo_deprecate
    }
}
impl std::fmt::Debug for DeprecateThingTypeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeprecateThingTypeInput");
        formatter.field("thing_type_name", &self.thing_type_name);
        formatter.field("undo_deprecate", &self.undo_deprecate);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteV2LoggingLevelInput {
    /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
    pub target_type: std::option::Option<crate::model::LogTargetType>,
    /// <p>The name of the resource for which you are configuring logging.</p>
    pub target_name: std::option::Option<std::string::String>,
}
impl DeleteV2LoggingLevelInput {
    /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
    pub fn target_type(&self) -> std::option::Option<&crate::model::LogTargetType> {
        self.target_type.as_ref()
    }
    /// <p>The name of the resource for which you are configuring logging.</p>
    pub fn target_name(&self) -> std::option::Option<&str> {
        self.target_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteV2LoggingLevelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteV2LoggingLevelInput");
        formatter.field("target_type", &self.target_type);
        formatter.field("target_name", &self.target_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteTopicRuleDestinationInput {
    /// <p>The ARN of the topic rule destination to delete.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl DeleteTopicRuleDestinationInput {
    /// <p>The ARN of the topic rule destination to delete.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for DeleteTopicRuleDestinationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteTopicRuleDestinationInput");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}

/// <p>The input for the DeleteTopicRule operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteTopicRuleInput {
    /// <p>The name of the rule.</p>
    pub rule_name: std::option::Option<std::string::String>,
}
impl DeleteTopicRuleInput {
    /// <p>The name of the rule.</p>
    pub fn rule_name(&self) -> std::option::Option<&str> {
        self.rule_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteTopicRuleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteTopicRuleInput");
        formatter.field("rule_name", &self.rule_name);
        formatter.finish()
    }
}

/// <p>The input for the DeleteThingType operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteThingTypeInput {
    /// <p>The name of the thing type.</p>
    pub thing_type_name: std::option::Option<std::string::String>,
}
impl DeleteThingTypeInput {
    /// <p>The name of the thing type.</p>
    pub fn thing_type_name(&self) -> std::option::Option<&str> {
        self.thing_type_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteThingTypeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteThingTypeInput");
        formatter.field("thing_type_name", &self.thing_type_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteThingGroupInput {
    /// <p>The name of the thing group to delete.</p>
    pub thing_group_name: std::option::Option<std::string::String>,
    /// <p>The expected version of the thing group to delete.</p>
    pub expected_version: std::option::Option<i64>,
}
impl DeleteThingGroupInput {
    /// <p>The name of the thing group to delete.</p>
    pub fn thing_group_name(&self) -> std::option::Option<&str> {
        self.thing_group_name.as_deref()
    }
    /// <p>The expected version of the thing group to delete.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
}
impl std::fmt::Debug for DeleteThingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteThingGroupInput");
        formatter.field("thing_group_name", &self.thing_group_name);
        formatter.field("expected_version", &self.expected_version);
        formatter.finish()
    }
}

/// <p>The input for the DeleteThing operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteThingInput {
    /// <p>The name of the thing to delete.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
    pub expected_version: std::option::Option<i64>,
}
impl DeleteThingInput {
    /// <p>The name of the thing to delete.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
}
impl std::fmt::Debug for DeleteThingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteThingInput");
        formatter.field("thing_name", &self.thing_name);
        formatter.field("expected_version", &self.expected_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteStreamInput {
    /// <p>The stream ID.</p>
    pub stream_id: std::option::Option<std::string::String>,
}
impl DeleteStreamInput {
    /// <p>The stream ID.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteStreamInput");
        formatter.field("stream_id", &self.stream_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSecurityProfileInput {
    /// <p>The name of the security profile to be deleted.</p>
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.</p>
    pub expected_version: std::option::Option<i64>,
}
impl DeleteSecurityProfileInput {
    /// <p>The name of the security profile to be deleted.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
}
impl std::fmt::Debug for DeleteSecurityProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSecurityProfileInput");
        formatter.field("security_profile_name", &self.security_profile_name);
        formatter.field("expected_version", &self.expected_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteScheduledAuditInput {
    /// <p>The name of the scheduled audit you want to delete.</p>
    pub scheduled_audit_name: std::option::Option<std::string::String>,
}
impl DeleteScheduledAuditInput {
    /// <p>The name of the scheduled audit you want to delete.</p>
    pub fn scheduled_audit_name(&self) -> std::option::Option<&str> {
        self.scheduled_audit_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteScheduledAuditInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteScheduledAuditInput");
        formatter.field("scheduled_audit_name", &self.scheduled_audit_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRoleAliasInput {
    /// <p>The role alias to delete.</p>
    pub role_alias: std::option::Option<std::string::String>,
}
impl DeleteRoleAliasInput {
    /// <p>The role alias to delete.</p>
    pub fn role_alias(&self) -> std::option::Option<&str> {
        self.role_alias.as_deref()
    }
}
impl std::fmt::Debug for DeleteRoleAliasInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRoleAliasInput");
        formatter.field("role_alias", &self.role_alias);
        formatter.finish()
    }
}

/// <p>The input for the DeleteRegistrationCode operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRegistrationCodeInput {}
impl std::fmt::Debug for DeleteRegistrationCodeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRegistrationCodeInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProvisioningTemplateVersionInput {
    /// <p>The name of the fleet provisioning template version to delete.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The fleet provisioning template version ID to delete.</p>
    pub version_id: std::option::Option<i32>,
}
impl DeleteProvisioningTemplateVersionInput {
    /// <p>The name of the fleet provisioning template version to delete.</p>
    pub fn template_name(&self) -> std::option::Option<&str> {
        self.template_name.as_deref()
    }
    /// <p>The fleet provisioning template version ID to delete.</p>
    pub fn version_id(&self) -> std::option::Option<i32> {
        self.version_id
    }
}
impl std::fmt::Debug for DeleteProvisioningTemplateVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProvisioningTemplateVersionInput");
        formatter.field("template_name", &self.template_name);
        formatter.field("version_id", &self.version_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProvisioningTemplateInput {
    /// <p>The name of the fleet provision template to delete.</p>
    pub template_name: std::option::Option<std::string::String>,
}
impl DeleteProvisioningTemplateInput {
    /// <p>The name of the fleet provision template to delete.</p>
    pub fn template_name(&self) -> std::option::Option<&str> {
        self.template_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteProvisioningTemplateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProvisioningTemplateInput");
        formatter.field("template_name", &self.template_name);
        formatter.finish()
    }
}

/// <p>The input for the DeletePolicyVersion operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePolicyVersionInput {
    /// <p>The name of the policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The policy version ID.</p>
    pub policy_version_id: std::option::Option<std::string::String>,
}
impl DeletePolicyVersionInput {
    /// <p>The name of the policy.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The policy version ID.</p>
    pub fn policy_version_id(&self) -> std::option::Option<&str> {
        self.policy_version_id.as_deref()
    }
}
impl std::fmt::Debug for DeletePolicyVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePolicyVersionInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_version_id", &self.policy_version_id);
        formatter.finish()
    }
}

/// <p>The input for the DeletePolicy operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePolicyInput {
    /// <p>The name of the policy to delete.</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl DeletePolicyInput {
    /// <p>The name of the policy to delete.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
}
impl std::fmt::Debug for DeletePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePolicyInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteOtaUpdateInput {
    /// <p>The ID of the OTA update to delete.</p>
    pub ota_update_id: std::option::Option<std::string::String>,
    /// <p>When true, the stream created by the OTAUpdate process is deleted when the OTA update is deleted. Ignored if the stream specified in the OTAUpdate is supplied by the user.</p>
    pub delete_stream: bool,
    /// <p>When true, deletes the IoT job created by the OTAUpdate process even if it is "IN_PROGRESS". Otherwise, if the job is not in a terminal state ("COMPLETED" or "CANCELED") an exception will occur. The default is false.</p>
    pub force_delete_aws_job: bool,
}
impl DeleteOtaUpdateInput {
    /// <p>The ID of the OTA update to delete.</p>
    pub fn ota_update_id(&self) -> std::option::Option<&str> {
        self.ota_update_id.as_deref()
    }
    /// <p>When true, the stream created by the OTAUpdate process is deleted when the OTA update is deleted. Ignored if the stream specified in the OTAUpdate is supplied by the user.</p>
    pub fn delete_stream(&self) -> bool {
        self.delete_stream
    }
    /// <p>When true, deletes the IoT job created by the OTAUpdate process even if it is "IN_PROGRESS". Otherwise, if the job is not in a terminal state ("COMPLETED" or "CANCELED") an exception will occur. The default is false.</p>
    pub fn force_delete_aws_job(&self) -> bool {
        self.force_delete_aws_job
    }
}
impl std::fmt::Debug for DeleteOtaUpdateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteOtaUpdateInput");
        formatter.field("ota_update_id", &self.ota_update_id);
        formatter.field("delete_stream", &self.delete_stream);
        formatter.field("force_delete_aws_job", &self.force_delete_aws_job);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMitigationActionInput {
    /// <p>The name of the mitigation action that you want to delete.</p>
    pub action_name: std::option::Option<std::string::String>,
}
impl DeleteMitigationActionInput {
    /// <p>The name of the mitigation action that you want to delete.</p>
    pub fn action_name(&self) -> std::option::Option<&str> {
        self.action_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteMitigationActionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMitigationActionInput");
        formatter.field("action_name", &self.action_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteJobTemplateInput {
    /// <p>The unique identifier of the job template to delete.</p>
    pub job_template_id: std::option::Option<std::string::String>,
}
impl DeleteJobTemplateInput {
    /// <p>The unique identifier of the job template to delete.</p>
    pub fn job_template_id(&self) -> std::option::Option<&str> {
        self.job_template_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteJobTemplateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteJobTemplateInput");
        formatter.field("job_template_id", &self.job_template_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteJobExecutionInput {
    /// <p>The ID of the job whose execution on a particular device will be deleted.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The name of the thing whose job execution will be deleted.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p>
    /// <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
    pub execution_number: std::option::Option<i64>,
    /// <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note>
    /// <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
    /// </note>
    pub force: bool,
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub namespace_id: std::option::Option<std::string::String>,
}
impl DeleteJobExecutionInput {
    /// <p>The ID of the job whose execution on a particular device will be deleted.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The name of the thing whose job execution will be deleted.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p>
    /// <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
    pub fn execution_number(&self) -> std::option::Option<i64> {
        self.execution_number
    }
    /// <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note>
    /// <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
    /// </note>
    pub fn force(&self) -> bool {
        self.force
    }
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub fn namespace_id(&self) -> std::option::Option<&str> {
        self.namespace_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteJobExecutionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteJobExecutionInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("thing_name", &self.thing_name);
        formatter.field("execution_number", &self.execution_number);
        formatter.field("force", &self.force);
        formatter.field("namespace_id", &self.namespace_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteJobInput {
    /// <p>The ID of the job to be deleted.</p>
    /// <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note>
    /// <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p>
    /// </note>
    pub force: bool,
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub namespace_id: std::option::Option<std::string::String>,
}
impl DeleteJobInput {
    /// <p>The ID of the job to be deleted.</p>
    /// <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note>
    /// <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p>
    /// </note>
    pub fn force(&self) -> bool {
        self.force
    }
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub fn namespace_id(&self) -> std::option::Option<&str> {
        self.namespace_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteJobInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("force", &self.force);
        formatter.field("namespace_id", &self.namespace_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFleetMetricInput {
    /// <p>The name of the fleet metric to delete.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The expected version of the fleet metric to delete.</p>
    pub expected_version: std::option::Option<i64>,
}
impl DeleteFleetMetricInput {
    /// <p>The name of the fleet metric to delete.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The expected version of the fleet metric to delete.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
}
impl std::fmt::Debug for DeleteFleetMetricInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFleetMetricInput");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("expected_version", &self.expected_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDynamicThingGroupInput {
    /// <p>The name of the dynamic thing group to delete.</p>
    pub thing_group_name: std::option::Option<std::string::String>,
    /// <p>The expected version of the dynamic thing group to delete.</p>
    pub expected_version: std::option::Option<i64>,
}
impl DeleteDynamicThingGroupInput {
    /// <p>The name of the dynamic thing group to delete.</p>
    pub fn thing_group_name(&self) -> std::option::Option<&str> {
        self.thing_group_name.as_deref()
    }
    /// <p>The expected version of the dynamic thing group to delete.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
}
impl std::fmt::Debug for DeleteDynamicThingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDynamicThingGroupInput");
        formatter.field("thing_group_name", &self.thing_group_name);
        formatter.field("expected_version", &self.expected_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDomainConfigurationInput {
    /// <p>The name of the domain configuration to be deleted.</p>
    pub domain_configuration_name: std::option::Option<std::string::String>,
}
impl DeleteDomainConfigurationInput {
    /// <p>The name of the domain configuration to be deleted.</p>
    pub fn domain_configuration_name(&self) -> std::option::Option<&str> {
        self.domain_configuration_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteDomainConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDomainConfigurationInput");
        formatter.field("domain_configuration_name", &self.domain_configuration_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDimensionInput {
    /// <p>The unique identifier for the dimension that you want to delete.</p>
    pub name: std::option::Option<std::string::String>,
}
impl DeleteDimensionInput {
    /// <p>The unique identifier for the dimension that you want to delete.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for DeleteDimensionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDimensionInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCustomMetricInput {
    /// <p> The name of the custom metric. </p>
    pub metric_name: std::option::Option<std::string::String>,
}
impl DeleteCustomMetricInput {
    /// <p> The name of the custom metric. </p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteCustomMetricInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCustomMetricInput");
        formatter.field("metric_name", &self.metric_name);
        formatter.finish()
    }
}

/// <p>The input for the DeleteCertificate operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCertificateInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub certificate_id: std::option::Option<std::string::String>,
    /// <p>Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.</p>
    pub force_delete: bool,
}
impl DeleteCertificateInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub fn certificate_id(&self) -> std::option::Option<&str> {
        self.certificate_id.as_deref()
    }
    /// <p>Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.</p>
    pub fn force_delete(&self) -> bool {
        self.force_delete
    }
}
impl std::fmt::Debug for DeleteCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCertificateInput");
        formatter.field("certificate_id", &self.certificate_id);
        formatter.field("force_delete", &self.force_delete);
        formatter.finish()
    }
}

/// <p>Input for the DeleteCACertificate operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCaCertificateInput {
    /// <p>The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub certificate_id: std::option::Option<std::string::String>,
}
impl DeleteCaCertificateInput {
    /// <p>The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub fn certificate_id(&self) -> std::option::Option<&str> {
        self.certificate_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteCaCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCaCertificateInput");
        formatter.field("certificate_id", &self.certificate_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBillingGroupInput {
    /// <p>The name of the billing group.</p>
    pub billing_group_name: std::option::Option<std::string::String>,
    /// <p>The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.</p>
    pub expected_version: std::option::Option<i64>,
}
impl DeleteBillingGroupInput {
    /// <p>The name of the billing group.</p>
    pub fn billing_group_name(&self) -> std::option::Option<&str> {
        self.billing_group_name.as_deref()
    }
    /// <p>The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
}
impl std::fmt::Debug for DeleteBillingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBillingGroupInput");
        formatter.field("billing_group_name", &self.billing_group_name);
        formatter.field("expected_version", &self.expected_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAuthorizerInput {
    /// <p>The name of the authorizer to delete.</p>
    pub authorizer_name: std::option::Option<std::string::String>,
}
impl DeleteAuthorizerInput {
    /// <p>The name of the authorizer to delete.</p>
    pub fn authorizer_name(&self) -> std::option::Option<&str> {
        self.authorizer_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteAuthorizerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAuthorizerInput");
        formatter.field("authorizer_name", &self.authorizer_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAuditSuppressionInput {
    /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub check_name: std::option::Option<std::string::String>,
    /// <p>Information that identifies the noncompliant resource.</p>
    pub resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
}
impl DeleteAuditSuppressionInput {
    /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub fn check_name(&self) -> std::option::Option<&str> {
        self.check_name.as_deref()
    }
    /// <p>Information that identifies the noncompliant resource.</p>
    pub fn resource_identifier(&self) -> std::option::Option<&crate::model::ResourceIdentifier> {
        self.resource_identifier.as_ref()
    }
}
impl std::fmt::Debug for DeleteAuditSuppressionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAuditSuppressionInput");
        formatter.field("check_name", &self.check_name);
        formatter.field("resource_identifier", &self.resource_identifier);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAccountAuditConfigurationInput {
    /// <p>If true, all scheduled audits are deleted.</p>
    pub delete_scheduled_audits: bool,
}
impl DeleteAccountAuditConfigurationInput {
    /// <p>If true, all scheduled audits are deleted.</p>
    pub fn delete_scheduled_audits(&self) -> bool {
        self.delete_scheduled_audits
    }
}
impl std::fmt::Debug for DeleteAccountAuditConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAccountAuditConfigurationInput");
        formatter.field("delete_scheduled_audits", &self.delete_scheduled_audits);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTopicRuleDestinationInput {
    /// <p>The topic rule destination configuration.</p>
    pub destination_configuration:
        std::option::Option<crate::model::TopicRuleDestinationConfiguration>,
}
impl CreateTopicRuleDestinationInput {
    /// <p>The topic rule destination configuration.</p>
    pub fn destination_configuration(
        &self,
    ) -> std::option::Option<&crate::model::TopicRuleDestinationConfiguration> {
        self.destination_configuration.as_ref()
    }
}
impl std::fmt::Debug for CreateTopicRuleDestinationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTopicRuleDestinationInput");
        formatter.field("destination_configuration", &self.destination_configuration);
        formatter.finish()
    }
}

/// <p>The input for the CreateTopicRule operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTopicRuleInput {
    /// <p>The name of the rule.</p>
    pub rule_name: std::option::Option<std::string::String>,
    /// <p>The rule payload.</p>
    pub topic_rule_payload: std::option::Option<crate::model::TopicRulePayload>,
    /// <p>Metadata which can be used to manage the topic rule.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub tags: std::option::Option<std::string::String>,
}
impl CreateTopicRuleInput {
    /// <p>The name of the rule.</p>
    pub fn rule_name(&self) -> std::option::Option<&str> {
        self.rule_name.as_deref()
    }
    /// <p>The rule payload.</p>
    pub fn topic_rule_payload(&self) -> std::option::Option<&crate::model::TopicRulePayload> {
        self.topic_rule_payload.as_ref()
    }
    /// <p>Metadata which can be used to manage the topic rule.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub fn tags(&self) -> std::option::Option<&str> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateTopicRuleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTopicRuleInput");
        formatter.field("rule_name", &self.rule_name);
        formatter.field("topic_rule_payload", &self.topic_rule_payload);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>The input for the CreateThingType operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateThingTypeInput {
    /// <p>The name of the thing type.</p>
    pub thing_type_name: std::option::Option<std::string::String>,
    /// <p>The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.</p>
    pub thing_type_properties: std::option::Option<crate::model::ThingTypeProperties>,
    /// <p>Metadata which can be used to manage the thing type.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateThingTypeInput {
    /// <p>The name of the thing type.</p>
    pub fn thing_type_name(&self) -> std::option::Option<&str> {
        self.thing_type_name.as_deref()
    }
    /// <p>The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.</p>
    pub fn thing_type_properties(&self) -> std::option::Option<&crate::model::ThingTypeProperties> {
        self.thing_type_properties.as_ref()
    }
    /// <p>Metadata which can be used to manage the thing type.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateThingTypeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateThingTypeInput");
        formatter.field("thing_type_name", &self.thing_type_name);
        formatter.field("thing_type_properties", &self.thing_type_properties);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateThingGroupInput {
    /// <p>The thing group name to create.</p>
    pub thing_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the parent thing group.</p>
    pub parent_group_name: std::option::Option<std::string::String>,
    /// <p>The thing group properties.</p>
    pub thing_group_properties: std::option::Option<crate::model::ThingGroupProperties>,
    /// <p>Metadata which can be used to manage the thing group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateThingGroupInput {
    /// <p>The thing group name to create.</p>
    pub fn thing_group_name(&self) -> std::option::Option<&str> {
        self.thing_group_name.as_deref()
    }
    /// <p>The name of the parent thing group.</p>
    pub fn parent_group_name(&self) -> std::option::Option<&str> {
        self.parent_group_name.as_deref()
    }
    /// <p>The thing group properties.</p>
    pub fn thing_group_properties(
        &self,
    ) -> std::option::Option<&crate::model::ThingGroupProperties> {
        self.thing_group_properties.as_ref()
    }
    /// <p>Metadata which can be used to manage the thing group.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateThingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateThingGroupInput");
        formatter.field("thing_group_name", &self.thing_group_name);
        formatter.field("parent_group_name", &self.parent_group_name);
        formatter.field("thing_group_properties", &self.thing_group_properties);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>The input for the CreateThing operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateThingInput {
    /// <p>The name of the thing to create.</p>
    /// <p>You can't change a thing's name after you create it. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The name of the thing type associated with the new thing.</p>
    pub thing_type_name: std::option::Option<std::string::String>,
    /// <p>The attribute payload, which consists of up to three name/value pairs in a JSON document. For example:</p>
    /// <p> <code>{\"attributes\":{\"string1\":\"string2\"}}</code> </p>
    pub attribute_payload: std::option::Option<crate::model::AttributePayload>,
    /// <p>The name of the billing group the thing will be added to.</p>
    pub billing_group_name: std::option::Option<std::string::String>,
}
impl CreateThingInput {
    /// <p>The name of the thing to create.</p>
    /// <p>You can't change a thing's name after you create it. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The name of the thing type associated with the new thing.</p>
    pub fn thing_type_name(&self) -> std::option::Option<&str> {
        self.thing_type_name.as_deref()
    }
    /// <p>The attribute payload, which consists of up to three name/value pairs in a JSON document. For example:</p>
    /// <p> <code>{\"attributes\":{\"string1\":\"string2\"}}</code> </p>
    pub fn attribute_payload(&self) -> std::option::Option<&crate::model::AttributePayload> {
        self.attribute_payload.as_ref()
    }
    /// <p>The name of the billing group the thing will be added to.</p>
    pub fn billing_group_name(&self) -> std::option::Option<&str> {
        self.billing_group_name.as_deref()
    }
}
impl std::fmt::Debug for CreateThingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateThingInput");
        formatter.field("thing_name", &self.thing_name);
        formatter.field("thing_type_name", &self.thing_type_name);
        formatter.field("attribute_payload", &self.attribute_payload);
        formatter.field("billing_group_name", &self.billing_group_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateStreamInput {
    /// <p>The stream ID.</p>
    pub stream_id: std::option::Option<std::string::String>,
    /// <p>A description of the stream.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The files to stream.</p>
    pub files: std::option::Option<std::vec::Vec<crate::model::StreamFile>>,
    /// <p>An IAM role that allows the IoT service principal to access your S3 files.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Metadata which can be used to manage streams.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateStreamInput {
    /// <p>The stream ID.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
    /// <p>A description of the stream.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The files to stream.</p>
    pub fn files(&self) -> std::option::Option<&[crate::model::StreamFile]> {
        self.files.as_deref()
    }
    /// <p>An IAM role that allows the IoT service principal to access your S3 files.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>Metadata which can be used to manage streams.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateStreamInput");
        formatter.field("stream_id", &self.stream_id);
        formatter.field("description", &self.description);
        formatter.field("files", &self.files);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSecurityProfileInput {
    /// <p>The name you are giving to the security profile.</p>
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p>A description of the security profile.</p>
    pub security_profile_description: std::option::Option<std::string::String>,
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    pub behaviors: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
    /// <p>Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.</p>
    pub alert_targets: std::option::Option<
        std::collections::HashMap<crate::model::AlertTargetType, crate::model::AlertTarget>,
    >,
    /// <p> <i>Please use <code>CreateSecurityProfileRequest$additionalMetricsToRetainV2</code> instead.</i> </p>
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    pub additional_metrics_to_retain: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    pub additional_metrics_to_retain_v2:
        std::option::Option<std::vec::Vec<crate::model::MetricToRetain>>,
    /// <p>Metadata that can be used to manage the security profile.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateSecurityProfileInput {
    /// <p>The name you are giving to the security profile.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p>A description of the security profile.</p>
    pub fn security_profile_description(&self) -> std::option::Option<&str> {
        self.security_profile_description.as_deref()
    }
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    pub fn behaviors(&self) -> std::option::Option<&[crate::model::Behavior]> {
        self.behaviors.as_deref()
    }
    /// <p>Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.</p>
    pub fn alert_targets(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::AlertTargetType, crate::model::AlertTarget>,
    > {
        self.alert_targets.as_ref()
    }
    /// <p> <i>Please use <code>CreateSecurityProfileRequest$additionalMetricsToRetainV2</code> instead.</i> </p>
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    pub fn additional_metrics_to_retain(&self) -> std::option::Option<&[std::string::String]> {
        self.additional_metrics_to_retain.as_deref()
    }
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
    pub fn additional_metrics_to_retain_v2(
        &self,
    ) -> std::option::Option<&[crate::model::MetricToRetain]> {
        self.additional_metrics_to_retain_v2.as_deref()
    }
    /// <p>Metadata that can be used to manage the security profile.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateSecurityProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSecurityProfileInput");
        formatter.field("security_profile_name", &self.security_profile_name);
        formatter.field(
            "security_profile_description",
            &self.security_profile_description,
        );
        formatter.field("behaviors", &self.behaviors);
        formatter.field("alert_targets", &self.alert_targets);
        formatter.field(
            "additional_metrics_to_retain",
            &self.additional_metrics_to_retain,
        );
        formatter.field(
            "additional_metrics_to_retain_v2",
            &self.additional_metrics_to_retain_v2,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateScheduledAuditInput {
    /// <p>How often the scheduled audit takes place, either <code>DAILY</code>, <code>WEEKLY</code>, <code>BIWEEKLY</code> or <code>MONTHLY</code>. The start time of each audit is determined by the system.</p>
    pub frequency: std::option::Option<crate::model::AuditFrequency>,
    /// <p>The day of the month on which the scheduled audit takes place. This can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to <code>MONTHLY</code>. If days 29 to 31 are specified, and the month doesn't have that many days, the audit takes place on the <code>LAST</code> day of the month.</p>
    pub day_of_month: std::option::Option<std::string::String>,
    /// <p>The day of the week on which the scheduled audit takes place, either <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the <code>frequency</code> parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
    pub day_of_week: std::option::Option<crate::model::DayOfWeek>,
    /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub target_check_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name you want to give to the scheduled audit. (Max. 128 chars)</p>
    pub scheduled_audit_name: std::option::Option<std::string::String>,
    /// <p>Metadata that can be used to manage the scheduled audit.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateScheduledAuditInput {
    /// <p>How often the scheduled audit takes place, either <code>DAILY</code>, <code>WEEKLY</code>, <code>BIWEEKLY</code> or <code>MONTHLY</code>. The start time of each audit is determined by the system.</p>
    pub fn frequency(&self) -> std::option::Option<&crate::model::AuditFrequency> {
        self.frequency.as_ref()
    }
    /// <p>The day of the month on which the scheduled audit takes place. This can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to <code>MONTHLY</code>. If days 29 to 31 are specified, and the month doesn't have that many days, the audit takes place on the <code>LAST</code> day of the month.</p>
    pub fn day_of_month(&self) -> std::option::Option<&str> {
        self.day_of_month.as_deref()
    }
    /// <p>The day of the week on which the scheduled audit takes place, either <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the <code>frequency</code> parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
    pub fn day_of_week(&self) -> std::option::Option<&crate::model::DayOfWeek> {
        self.day_of_week.as_ref()
    }
    /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub fn target_check_names(&self) -> std::option::Option<&[std::string::String]> {
        self.target_check_names.as_deref()
    }
    /// <p>The name you want to give to the scheduled audit. (Max. 128 chars)</p>
    pub fn scheduled_audit_name(&self) -> std::option::Option<&str> {
        self.scheduled_audit_name.as_deref()
    }
    /// <p>Metadata that can be used to manage the scheduled audit.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateScheduledAuditInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateScheduledAuditInput");
        formatter.field("frequency", &self.frequency);
        formatter.field("day_of_month", &self.day_of_month);
        formatter.field("day_of_week", &self.day_of_week);
        formatter.field("target_check_names", &self.target_check_names);
        formatter.field("scheduled_audit_name", &self.scheduled_audit_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRoleAliasInput {
    /// <p>The role alias that points to a role ARN. This allows you to change the role without having to update the device.</p>
    pub role_alias: std::option::Option<std::string::String>,
    /// <p>The role ARN.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>How long (in seconds) the credentials will be valid. The default value is 3,600 seconds.</p>
    /// <p>This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.</p>
    pub credential_duration_seconds: std::option::Option<i32>,
    /// <p>Metadata which can be used to manage the role alias.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateRoleAliasInput {
    /// <p>The role alias that points to a role ARN. This allows you to change the role without having to update the device.</p>
    pub fn role_alias(&self) -> std::option::Option<&str> {
        self.role_alias.as_deref()
    }
    /// <p>The role ARN.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>How long (in seconds) the credentials will be valid. The default value is 3,600 seconds.</p>
    /// <p>This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.</p>
    pub fn credential_duration_seconds(&self) -> std::option::Option<i32> {
        self.credential_duration_seconds
    }
    /// <p>Metadata which can be used to manage the role alias.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateRoleAliasInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRoleAliasInput");
        formatter.field("role_alias", &self.role_alias);
        formatter.field("role_arn", &self.role_arn);
        formatter.field(
            "credential_duration_seconds",
            &self.credential_duration_seconds,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProvisioningTemplateVersionInput {
    /// <p>The name of the fleet provisioning template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The JSON formatted contents of the fleet provisioning template.</p>
    pub template_body: std::option::Option<std::string::String>,
    /// <p>Sets a fleet provision template version as the default version.</p>
    pub set_as_default: bool,
}
impl CreateProvisioningTemplateVersionInput {
    /// <p>The name of the fleet provisioning template.</p>
    pub fn template_name(&self) -> std::option::Option<&str> {
        self.template_name.as_deref()
    }
    /// <p>The JSON formatted contents of the fleet provisioning template.</p>
    pub fn template_body(&self) -> std::option::Option<&str> {
        self.template_body.as_deref()
    }
    /// <p>Sets a fleet provision template version as the default version.</p>
    pub fn set_as_default(&self) -> bool {
        self.set_as_default
    }
}
impl std::fmt::Debug for CreateProvisioningTemplateVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProvisioningTemplateVersionInput");
        formatter.field("template_name", &self.template_name);
        formatter.field("template_body", &self.template_body);
        formatter.field("set_as_default", &self.set_as_default);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProvisioningTemplateInput {
    /// <p>The name of the fleet provisioning template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The description of the fleet provisioning template.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The JSON formatted contents of the fleet provisioning template.</p>
    pub template_body: std::option::Option<std::string::String>,
    /// <p>True to enable the fleet provisioning template, otherwise false.</p>
    pub enabled: bool,
    /// <p>The role ARN for the role associated with the fleet provisioning template. This IoT role grants permission to provision a device.</p>
    pub provisioning_role_arn: std::option::Option<std::string::String>,
    /// <p>Creates a pre-provisioning hook template.</p>
    pub pre_provisioning_hook: std::option::Option<crate::model::ProvisioningHook>,
    /// <p>Metadata which can be used to manage the fleet provisioning template.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateProvisioningTemplateInput {
    /// <p>The name of the fleet provisioning template.</p>
    pub fn template_name(&self) -> std::option::Option<&str> {
        self.template_name.as_deref()
    }
    /// <p>The description of the fleet provisioning template.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The JSON formatted contents of the fleet provisioning template.</p>
    pub fn template_body(&self) -> std::option::Option<&str> {
        self.template_body.as_deref()
    }
    /// <p>True to enable the fleet provisioning template, otherwise false.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>The role ARN for the role associated with the fleet provisioning template. This IoT role grants permission to provision a device.</p>
    pub fn provisioning_role_arn(&self) -> std::option::Option<&str> {
        self.provisioning_role_arn.as_deref()
    }
    /// <p>Creates a pre-provisioning hook template.</p>
    pub fn pre_provisioning_hook(&self) -> std::option::Option<&crate::model::ProvisioningHook> {
        self.pre_provisioning_hook.as_ref()
    }
    /// <p>Metadata which can be used to manage the fleet provisioning template.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateProvisioningTemplateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProvisioningTemplateInput");
        formatter.field("template_name", &self.template_name);
        formatter.field("description", &self.description);
        formatter.field("template_body", &self.template_body);
        formatter.field("enabled", &self.enabled);
        formatter.field("provisioning_role_arn", &self.provisioning_role_arn);
        formatter.field("pre_provisioning_hook", &self.pre_provisioning_hook);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProvisioningClaimInput {
    /// <p>The name of the provisioning template to use.</p>
    pub template_name: std::option::Option<std::string::String>,
}
impl CreateProvisioningClaimInput {
    /// <p>The name of the provisioning template to use.</p>
    pub fn template_name(&self) -> std::option::Option<&str> {
        self.template_name.as_deref()
    }
}
impl std::fmt::Debug for CreateProvisioningClaimInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProvisioningClaimInput");
        formatter.field("template_name", &self.template_name);
        formatter.finish()
    }
}

/// <p>The input for the CreatePolicyVersion operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePolicyVersionInput {
    /// <p>The policy name.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespace.</p>
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
    pub set_as_default: bool,
}
impl CreatePolicyVersionInput {
    /// <p>The policy name.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespace.</p>
    pub fn policy_document(&self) -> std::option::Option<&str> {
        self.policy_document.as_deref()
    }
    /// <p>Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
    pub fn set_as_default(&self) -> bool {
        self.set_as_default
    }
}
impl std::fmt::Debug for CreatePolicyVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePolicyVersionInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_document", &self.policy_document);
        formatter.field("set_as_default", &self.set_as_default);
        formatter.finish()
    }
}

/// <p>The input for the CreatePolicy operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePolicyInput {
    /// <p>The policy name.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The JSON document that describes the policy. <b>policyDocument</b> must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.</p>
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>Metadata which can be used to manage the policy.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreatePolicyInput {
    /// <p>The policy name.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The JSON document that describes the policy. <b>policyDocument</b> must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.</p>
    pub fn policy_document(&self) -> std::option::Option<&str> {
        self.policy_document.as_deref()
    }
    /// <p>Metadata which can be used to manage the policy.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreatePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePolicyInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_document", &self.policy_document);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateOtaUpdateInput {
    /// <p>The ID of the OTA update to be created.</p>
    pub ota_update_id: std::option::Option<std::string::String>,
    /// <p>The description of the OTA update.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The devices targeted to receive OTA updates.</p>
    pub targets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.</p>
    pub protocols: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
    /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
    pub target_selection: std::option::Option<crate::model::TargetSelection>,
    /// <p>Configuration for the rollout of OTA updates.</p>
    pub aws_job_executions_rollout_config:
        std::option::Option<crate::model::AwsJobExecutionsRolloutConfig>,
    /// <p>Configuration information for pre-signed URLs.</p>
    pub aws_job_presigned_url_config: std::option::Option<crate::model::AwsJobPresignedUrlConfig>,
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    pub aws_job_abort_config: std::option::Option<crate::model::AwsJobAbortConfig>,
    /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    pub aws_job_timeout_config: std::option::Option<crate::model::AwsJobTimeoutConfig>,
    /// <p>The files to be streamed by the OTA update.</p>
    pub files: std::option::Option<std::vec::Vec<crate::model::OtaUpdateFile>>,
    /// <p>The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A list of additional OTA update parameters which are name-value pairs.</p>
    pub additional_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Metadata which can be used to manage updates.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateOtaUpdateInput {
    /// <p>The ID of the OTA update to be created.</p>
    pub fn ota_update_id(&self) -> std::option::Option<&str> {
        self.ota_update_id.as_deref()
    }
    /// <p>The description of the OTA update.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The devices targeted to receive OTA updates.</p>
    pub fn targets(&self) -> std::option::Option<&[std::string::String]> {
        self.targets.as_deref()
    }
    /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.</p>
    pub fn protocols(&self) -> std::option::Option<&[crate::model::Protocol]> {
        self.protocols.as_deref()
    }
    /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
    pub fn target_selection(&self) -> std::option::Option<&crate::model::TargetSelection> {
        self.target_selection.as_ref()
    }
    /// <p>Configuration for the rollout of OTA updates.</p>
    pub fn aws_job_executions_rollout_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsJobExecutionsRolloutConfig> {
        self.aws_job_executions_rollout_config.as_ref()
    }
    /// <p>Configuration information for pre-signed URLs.</p>
    pub fn aws_job_presigned_url_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsJobPresignedUrlConfig> {
        self.aws_job_presigned_url_config.as_ref()
    }
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    pub fn aws_job_abort_config(&self) -> std::option::Option<&crate::model::AwsJobAbortConfig> {
        self.aws_job_abort_config.as_ref()
    }
    /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    pub fn aws_job_timeout_config(
        &self,
    ) -> std::option::Option<&crate::model::AwsJobTimeoutConfig> {
        self.aws_job_timeout_config.as_ref()
    }
    /// <p>The files to be streamed by the OTA update.</p>
    pub fn files(&self) -> std::option::Option<&[crate::model::OtaUpdateFile]> {
        self.files.as_deref()
    }
    /// <p>The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>A list of additional OTA update parameters which are name-value pairs.</p>
    pub fn additional_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.additional_parameters.as_ref()
    }
    /// <p>Metadata which can be used to manage updates.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateOtaUpdateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateOtaUpdateInput");
        formatter.field("ota_update_id", &self.ota_update_id);
        formatter.field("description", &self.description);
        formatter.field("targets", &self.targets);
        formatter.field("protocols", &self.protocols);
        formatter.field("target_selection", &self.target_selection);
        formatter.field(
            "aws_job_executions_rollout_config",
            &self.aws_job_executions_rollout_config,
        );
        formatter.field(
            "aws_job_presigned_url_config",
            &self.aws_job_presigned_url_config,
        );
        formatter.field("aws_job_abort_config", &self.aws_job_abort_config);
        formatter.field("aws_job_timeout_config", &self.aws_job_timeout_config);
        formatter.field("files", &self.files);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("additional_parameters", &self.additional_parameters);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMitigationActionInput {
    /// <p>A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).</p>
    pub action_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Defines the type of action and the parameters for that action.</p>
    pub action_params: std::option::Option<crate::model::MitigationActionParams>,
    /// <p>Metadata that can be used to manage the mitigation action.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateMitigationActionInput {
    /// <p>A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).</p>
    pub fn action_name(&self) -> std::option::Option<&str> {
        self.action_name.as_deref()
    }
    /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>Defines the type of action and the parameters for that action.</p>
    pub fn action_params(&self) -> std::option::Option<&crate::model::MitigationActionParams> {
        self.action_params.as_ref()
    }
    /// <p>Metadata that can be used to manage the mitigation action.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateMitigationActionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMitigationActionInput");
        formatter.field("action_name", &self.action_name);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("action_params", &self.action_params);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>The input for the CreateKeysAndCertificate operation.</p>
/// <p>Requires permission to access the <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions">CreateKeysAndCertificateRequest</a> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateKeysAndCertificateInput {
    /// <p>Specifies whether the certificate is active.</p>
    pub set_as_active: bool,
}
impl CreateKeysAndCertificateInput {
    /// <p>Specifies whether the certificate is active.</p>
    pub fn set_as_active(&self) -> bool {
        self.set_as_active
    }
}
impl std::fmt::Debug for CreateKeysAndCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateKeysAndCertificateInput");
        formatter.field("set_as_active", &self.set_as_active);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateJobTemplateInput {
    /// <p>A unique identifier for the job template. We recommend using a UUID. Alpha-numeric characters, "-", and "_" are valid for use here.</p>
    pub job_template_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the job to use as the basis for the job template.</p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>An S3 link to the job document to use in the template. Required if you don't specify a value for <code>document</code>.</p> <note>
    /// <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
    /// <p>The placeholder link is of the following form:</p>
    /// <p> <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code> </p>
    /// <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
    /// </note>
    pub document_source: std::option::Option<std::string::String>,
    /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
    pub document: std::option::Option<std::string::String>,
    /// <p>A description of the job document.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Configuration for pre-signed S3 URLs.</p>
    pub presigned_url_config: std::option::Option<crate::model::PresignedUrlConfig>,
    /// <p>Allows you to create a staged rollout of a job.</p>
    pub job_executions_rollout_config:
        std::option::Option<crate::model::JobExecutionsRolloutConfig>,
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    pub abort_config: std::option::Option<crate::model::AbortConfig>,
    /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    pub timeout_config: std::option::Option<crate::model::TimeoutConfig>,
    /// <p>Metadata that can be used to manage the job template.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Allows you to create the criteria to retry a job.</p>
    pub job_executions_retry_config: std::option::Option<crate::model::JobExecutionsRetryConfig>,
}
impl CreateJobTemplateInput {
    /// <p>A unique identifier for the job template. We recommend using a UUID. Alpha-numeric characters, "-", and "_" are valid for use here.</p>
    pub fn job_template_id(&self) -> std::option::Option<&str> {
        self.job_template_id.as_deref()
    }
    /// <p>The ARN of the job to use as the basis for the job template.</p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>An S3 link to the job document to use in the template. Required if you don't specify a value for <code>document</code>.</p> <note>
    /// <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
    /// <p>The placeholder link is of the following form:</p>
    /// <p> <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code> </p>
    /// <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
    /// </note>
    pub fn document_source(&self) -> std::option::Option<&str> {
        self.document_source.as_deref()
    }
    /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
    pub fn document(&self) -> std::option::Option<&str> {
        self.document.as_deref()
    }
    /// <p>A description of the job document.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Configuration for pre-signed S3 URLs.</p>
    pub fn presigned_url_config(&self) -> std::option::Option<&crate::model::PresignedUrlConfig> {
        self.presigned_url_config.as_ref()
    }
    /// <p>Allows you to create a staged rollout of a job.</p>
    pub fn job_executions_rollout_config(
        &self,
    ) -> std::option::Option<&crate::model::JobExecutionsRolloutConfig> {
        self.job_executions_rollout_config.as_ref()
    }
    /// <p>The criteria that determine when and how a job abort takes place.</p>
    pub fn abort_config(&self) -> std::option::Option<&crate::model::AbortConfig> {
        self.abort_config.as_ref()
    }
    /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    pub fn timeout_config(&self) -> std::option::Option<&crate::model::TimeoutConfig> {
        self.timeout_config.as_ref()
    }
    /// <p>Metadata that can be used to manage the job template.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>Allows you to create the criteria to retry a job.</p>
    pub fn job_executions_retry_config(
        &self,
    ) -> std::option::Option<&crate::model::JobExecutionsRetryConfig> {
        self.job_executions_retry_config.as_ref()
    }
}
impl std::fmt::Debug for CreateJobTemplateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateJobTemplateInput");
        formatter.field("job_template_id", &self.job_template_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("document_source", &self.document_source);
        formatter.field("document", &self.document);
        formatter.field("description", &self.description);
        formatter.field("presigned_url_config", &self.presigned_url_config);
        formatter.field(
            "job_executions_rollout_config",
            &self.job_executions_rollout_config,
        );
        formatter.field("abort_config", &self.abort_config);
        formatter.field("timeout_config", &self.timeout_config);
        formatter.field("tags", &self.tags);
        formatter.field(
            "job_executions_retry_config",
            &self.job_executions_retry_config,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateJobInput {
    /// <p>A job identifier which must be unique for your Amazon Web Services account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>A list of things and thing groups to which the job should be sent.</p>
    pub targets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An S3 link to the job document. Required if you don't specify a value for <code>document</code>.</p> <note>
    /// <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
    /// <p>The placeholder link is of the following form:</p>
    /// <p> <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code> </p>
    /// <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
    /// </note>
    pub document_source: std::option::Option<std::string::String>,
    /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
    pub document: std::option::Option<std::string::String>,
    /// <p>A short text description of the job.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Configuration information for pre-signed S3 URLs.</p>
    pub presigned_url_config: std::option::Option<crate::model::PresignedUrlConfig>,
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p> <note>
    /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
    /// </note>
    pub target_selection: std::option::Option<crate::model::TargetSelection>,
    /// <p>Allows you to create a staged rollout of the job.</p>
    pub job_executions_rollout_config:
        std::option::Option<crate::model::JobExecutionsRolloutConfig>,
    /// <p>Allows you to create the criteria to abort a job.</p>
    pub abort_config: std::option::Option<crate::model::AbortConfig>,
    /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    pub timeout_config: std::option::Option<crate::model::TimeoutConfig>,
    /// <p>Metadata which can be used to manage the job.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub namespace_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the job template used to create the job.</p>
    pub job_template_arn: std::option::Option<std::string::String>,
    /// <p>Allows you to create the criteria to retry a job.</p>
    pub job_executions_retry_config: std::option::Option<crate::model::JobExecutionsRetryConfig>,
    /// <p>Parameters of an Amazon Web Services managed template that you can specify to create the job document.</p> <note>
    /// <p> <code>documentParameters</code> can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.</p>
    /// </note>
    pub document_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateJobInput {
    /// <p>A job identifier which must be unique for your Amazon Web Services account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>A list of things and thing groups to which the job should be sent.</p>
    pub fn targets(&self) -> std::option::Option<&[std::string::String]> {
        self.targets.as_deref()
    }
    /// <p>An S3 link to the job document. Required if you don't specify a value for <code>document</code>.</p> <note>
    /// <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
    /// <p>The placeholder link is of the following form:</p>
    /// <p> <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code> </p>
    /// <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
    /// </note>
    pub fn document_source(&self) -> std::option::Option<&str> {
        self.document_source.as_deref()
    }
    /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
    pub fn document(&self) -> std::option::Option<&str> {
        self.document.as_deref()
    }
    /// <p>A short text description of the job.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Configuration information for pre-signed S3 URLs.</p>
    pub fn presigned_url_config(&self) -> std::option::Option<&crate::model::PresignedUrlConfig> {
        self.presigned_url_config.as_ref()
    }
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p> <note>
    /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
    /// </note>
    pub fn target_selection(&self) -> std::option::Option<&crate::model::TargetSelection> {
        self.target_selection.as_ref()
    }
    /// <p>Allows you to create a staged rollout of the job.</p>
    pub fn job_executions_rollout_config(
        &self,
    ) -> std::option::Option<&crate::model::JobExecutionsRolloutConfig> {
        self.job_executions_rollout_config.as_ref()
    }
    /// <p>Allows you to create the criteria to abort a job.</p>
    pub fn abort_config(&self) -> std::option::Option<&crate::model::AbortConfig> {
        self.abort_config.as_ref()
    }
    /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    pub fn timeout_config(&self) -> std::option::Option<&crate::model::TimeoutConfig> {
        self.timeout_config.as_ref()
    }
    /// <p>Metadata which can be used to manage the job.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub fn namespace_id(&self) -> std::option::Option<&str> {
        self.namespace_id.as_deref()
    }
    /// <p>The ARN of the job template used to create the job.</p>
    pub fn job_template_arn(&self) -> std::option::Option<&str> {
        self.job_template_arn.as_deref()
    }
    /// <p>Allows you to create the criteria to retry a job.</p>
    pub fn job_executions_retry_config(
        &self,
    ) -> std::option::Option<&crate::model::JobExecutionsRetryConfig> {
        self.job_executions_retry_config.as_ref()
    }
    /// <p>Parameters of an Amazon Web Services managed template that you can specify to create the job document.</p> <note>
    /// <p> <code>documentParameters</code> can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.</p>
    /// </note>
    pub fn document_parameters(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.document_parameters.as_ref()
    }
}
impl std::fmt::Debug for CreateJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateJobInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("targets", &self.targets);
        formatter.field("document_source", &self.document_source);
        formatter.field("document", &self.document);
        formatter.field("description", &self.description);
        formatter.field("presigned_url_config", &self.presigned_url_config);
        formatter.field("target_selection", &self.target_selection);
        formatter.field(
            "job_executions_rollout_config",
            &self.job_executions_rollout_config,
        );
        formatter.field("abort_config", &self.abort_config);
        formatter.field("timeout_config", &self.timeout_config);
        formatter.field("tags", &self.tags);
        formatter.field("namespace_id", &self.namespace_id);
        formatter.field("job_template_arn", &self.job_template_arn);
        formatter.field(
            "job_executions_retry_config",
            &self.job_executions_retry_config,
        );
        formatter.field("document_parameters", &self.document_parameters);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateFleetMetricInput {
    /// <p>The name of the fleet metric to create.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The search query string.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The type of the aggregation query.</p>
    pub aggregation_type: std::option::Option<crate::model::AggregationType>,
    /// <p>The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.</p>
    pub period: std::option::Option<i32>,
    /// <p>The field to aggregate.</p>
    pub aggregation_field: std::option::Option<std::string::String>,
    /// <p>The fleet metric description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The query version.</p>
    pub query_version: std::option::Option<std::string::String>,
    /// <p>The name of the index to search.</p>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>Used to support unit transformation such as milliseconds to seconds. The unit must be supported by <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html">CW metric</a>. Default to null.</p>
    pub unit: std::option::Option<crate::model::FleetMetricUnit>,
    /// <p>Metadata, which can be used to manage the fleet metric.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateFleetMetricInput {
    /// <p>The name of the fleet metric to create.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The search query string.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The type of the aggregation query.</p>
    pub fn aggregation_type(&self) -> std::option::Option<&crate::model::AggregationType> {
        self.aggregation_type.as_ref()
    }
    /// <p>The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.</p>
    pub fn period(&self) -> std::option::Option<i32> {
        self.period
    }
    /// <p>The field to aggregate.</p>
    pub fn aggregation_field(&self) -> std::option::Option<&str> {
        self.aggregation_field.as_deref()
    }
    /// <p>The fleet metric description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The query version.</p>
    pub fn query_version(&self) -> std::option::Option<&str> {
        self.query_version.as_deref()
    }
    /// <p>The name of the index to search.</p>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>Used to support unit transformation such as milliseconds to seconds. The unit must be supported by <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html">CW metric</a>. Default to null.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::FleetMetricUnit> {
        self.unit.as_ref()
    }
    /// <p>Metadata, which can be used to manage the fleet metric.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateFleetMetricInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateFleetMetricInput");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("query_string", &self.query_string);
        formatter.field("aggregation_type", &self.aggregation_type);
        formatter.field("period", &self.period);
        formatter.field("aggregation_field", &self.aggregation_field);
        formatter.field("description", &self.description);
        formatter.field("query_version", &self.query_version);
        formatter.field("index_name", &self.index_name);
        formatter.field("unit", &self.unit);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDynamicThingGroupInput {
    /// <p>The dynamic thing group name to create.</p>
    pub thing_group_name: std::option::Option<std::string::String>,
    /// <p>The dynamic thing group properties.</p>
    pub thing_group_properties: std::option::Option<crate::model::ThingGroupProperties>,
    /// <p>The dynamic thing group index name.</p> <note>
    /// <p>Currently one index is supported: <code>AWS_Things</code>.</p>
    /// </note>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The dynamic thing group search query string.</p>
    /// <p>See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html">Query Syntax</a> for information about query string syntax.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The dynamic thing group query version.</p> <note>
    /// <p>Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.</p>
    /// </note>
    pub query_version: std::option::Option<std::string::String>,
    /// <p>Metadata which can be used to manage the dynamic thing group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateDynamicThingGroupInput {
    /// <p>The dynamic thing group name to create.</p>
    pub fn thing_group_name(&self) -> std::option::Option<&str> {
        self.thing_group_name.as_deref()
    }
    /// <p>The dynamic thing group properties.</p>
    pub fn thing_group_properties(
        &self,
    ) -> std::option::Option<&crate::model::ThingGroupProperties> {
        self.thing_group_properties.as_ref()
    }
    /// <p>The dynamic thing group index name.</p> <note>
    /// <p>Currently one index is supported: <code>AWS_Things</code>.</p>
    /// </note>
    pub fn index_name(&self) -> std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>The dynamic thing group search query string.</p>
    /// <p>See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html">Query Syntax</a> for information about query string syntax.</p>
    pub fn query_string(&self) -> std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The dynamic thing group query version.</p> <note>
    /// <p>Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.</p>
    /// </note>
    pub fn query_version(&self) -> std::option::Option<&str> {
        self.query_version.as_deref()
    }
    /// <p>Metadata which can be used to manage the dynamic thing group.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateDynamicThingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDynamicThingGroupInput");
        formatter.field("thing_group_name", &self.thing_group_name);
        formatter.field("thing_group_properties", &self.thing_group_properties);
        formatter.field("index_name", &self.index_name);
        formatter.field("query_string", &self.query_string);
        formatter.field("query_version", &self.query_version);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDomainConfigurationInput {
    /// <p>The name of the domain configuration. This value must be unique to a region.</p>
    pub domain_configuration_name: std::option::Option<std::string::String>,
    /// <p>The name of the domain.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for Amazon Web Services-managed domains.</p>
    pub server_certificate_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for Amazon Web Services-managed domains.</p>
    pub validation_certificate_arn: std::option::Option<std::string::String>,
    /// <p>An object that specifies the authorization service for a domain.</p>
    pub authorizer_config: std::option::Option<crate::model::AuthorizerConfig>,
    /// <p>The type of service delivered by the endpoint.</p> <note>
    /// <p>Amazon Web Services IoT Core currently supports only the <code>DATA</code> service type.</p>
    /// </note>
    pub service_type: std::option::Option<crate::model::ServiceType>,
    /// <p>Metadata which can be used to manage the domain configuration.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateDomainConfigurationInput {
    /// <p>The name of the domain configuration. This value must be unique to a region.</p>
    pub fn domain_configuration_name(&self) -> std::option::Option<&str> {
        self.domain_configuration_name.as_deref()
    }
    /// <p>The name of the domain.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for Amazon Web Services-managed domains.</p>
    pub fn server_certificate_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.server_certificate_arns.as_deref()
    }
    /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for Amazon Web Services-managed domains.</p>
    pub fn validation_certificate_arn(&self) -> std::option::Option<&str> {
        self.validation_certificate_arn.as_deref()
    }
    /// <p>An object that specifies the authorization service for a domain.</p>
    pub fn authorizer_config(&self) -> std::option::Option<&crate::model::AuthorizerConfig> {
        self.authorizer_config.as_ref()
    }
    /// <p>The type of service delivered by the endpoint.</p> <note>
    /// <p>Amazon Web Services IoT Core currently supports only the <code>DATA</code> service type.</p>
    /// </note>
    pub fn service_type(&self) -> std::option::Option<&crate::model::ServiceType> {
        self.service_type.as_ref()
    }
    /// <p>Metadata which can be used to manage the domain configuration.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateDomainConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDomainConfigurationInput");
        formatter.field("domain_configuration_name", &self.domain_configuration_name);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("server_certificate_arns", &self.server_certificate_arns);
        formatter.field(
            "validation_certificate_arn",
            &self.validation_certificate_arn,
        );
        formatter.field("authorizer_config", &self.authorizer_config);
        formatter.field("service_type", &self.service_type);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDimensionInput {
    /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the type of dimension. Supported types: <code>TOPIC_FILTER.</code> </p>
    pub r#type: std::option::Option<crate::model::DimensionType>,
    /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
    pub string_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Metadata that can be used to manage the dimension.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Each dimension must have a unique client request token. If you try to create a new dimension with the same token as a dimension that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.</p>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl CreateDimensionInput {
    /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the type of dimension. Supported types: <code>TOPIC_FILTER.</code> </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DimensionType> {
        self.r#type.as_ref()
    }
    /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
    pub fn string_values(&self) -> std::option::Option<&[std::string::String]> {
        self.string_values.as_deref()
    }
    /// <p>Metadata that can be used to manage the dimension.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>Each dimension must have a unique client request token. If you try to create a new dimension with the same token as a dimension that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for CreateDimensionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDimensionInput");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("string_values", &self.string_values);
        formatter.field("tags", &self.tags);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCustomMetricInput {
    /// <p> The name of the custom metric. This will be used in the metric report submitted from the device/thing. The name can't begin with <code>aws:</code>. You can't change the name after you define it.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p> The friendly name in the console for the custom metric. This name doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. You can update the friendly name after you define it.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p> The type of the custom metric. </p> <important>
    /// <p>The type <code>number</code> only takes a single metric value as an input, but when you submit the metrics value in the DeviceMetrics report, you must pass it as an array with a single value.</p>
    /// </important>
    pub metric_type: std::option::Option<crate::model::CustomMetricType>,
    /// <p> Metadata that can be used to manage the custom metric. </p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Each custom metric must have a unique client request token. If you try to create a new custom metric that already exists with a different token, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request. </p>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl CreateCustomMetricInput {
    /// <p> The name of the custom metric. This will be used in the metric report submitted from the device/thing. The name can't begin with <code>aws:</code>. You can't change the name after you define it.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p> The friendly name in the console for the custom metric. This name doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. You can update the friendly name after you define it.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p> The type of the custom metric. </p> <important>
    /// <p>The type <code>number</code> only takes a single metric value as an input, but when you submit the metrics value in the DeviceMetrics report, you must pass it as an array with a single value.</p>
    /// </important>
    pub fn metric_type(&self) -> std::option::Option<&crate::model::CustomMetricType> {
        self.metric_type.as_ref()
    }
    /// <p> Metadata that can be used to manage the custom metric. </p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>Each custom metric must have a unique client request token. If you try to create a new custom metric that already exists with a different token, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request. </p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for CreateCustomMetricInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCustomMetricInput");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("metric_type", &self.metric_type);
        formatter.field("tags", &self.tags);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

/// <p>The input for the CreateCertificateFromCsr operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCertificateFromCsrInput {
    /// <p>The certificate signing request (CSR).</p>
    pub certificate_signing_request: std::option::Option<std::string::String>,
    /// <p>Specifies whether the certificate is active.</p>
    pub set_as_active: bool,
}
impl CreateCertificateFromCsrInput {
    /// <p>The certificate signing request (CSR).</p>
    pub fn certificate_signing_request(&self) -> std::option::Option<&str> {
        self.certificate_signing_request.as_deref()
    }
    /// <p>Specifies whether the certificate is active.</p>
    pub fn set_as_active(&self) -> bool {
        self.set_as_active
    }
}
impl std::fmt::Debug for CreateCertificateFromCsrInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCertificateFromCsrInput");
        formatter.field(
            "certificate_signing_request",
            &self.certificate_signing_request,
        );
        formatter.field("set_as_active", &self.set_as_active);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateBillingGroupInput {
    /// <p>The name you wish to give to the billing group.</p>
    pub billing_group_name: std::option::Option<std::string::String>,
    /// <p>The properties of the billing group.</p>
    pub billing_group_properties: std::option::Option<crate::model::BillingGroupProperties>,
    /// <p>Metadata which can be used to manage the billing group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateBillingGroupInput {
    /// <p>The name you wish to give to the billing group.</p>
    pub fn billing_group_name(&self) -> std::option::Option<&str> {
        self.billing_group_name.as_deref()
    }
    /// <p>The properties of the billing group.</p>
    pub fn billing_group_properties(
        &self,
    ) -> std::option::Option<&crate::model::BillingGroupProperties> {
        self.billing_group_properties.as_ref()
    }
    /// <p>Metadata which can be used to manage the billing group.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateBillingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateBillingGroupInput");
        formatter.field("billing_group_name", &self.billing_group_name);
        formatter.field("billing_group_properties", &self.billing_group_properties);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAuthorizerInput {
    /// <p>The authorizer name.</p>
    pub authorizer_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the authorizer's Lambda function.</p>
    pub authorizer_function_arn: std::option::Option<std::string::String>,
    /// <p>The name of the token key used to extract the token from the HTTP headers.</p>
    pub token_key_name: std::option::Option<std::string::String>,
    /// <p>The public keys used to verify the digital signature returned by your custom authentication service.</p>
    pub token_signing_public_keys:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The status of the create authorizer request.</p>
    pub status: std::option::Option<crate::model::AuthorizerStatus>,
    /// <p>Metadata which can be used to manage the custom authorizer.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Specifies whether IoT validates the token signature in an authorization request.</p>
    pub signing_disabled: std::option::Option<bool>,
    /// <p>When <code>true</code>, the result from the authorizers Lambda function is cached for clients that use persistent HTTP connections. The results are cached for the time specified by the Lambda function in <code>refreshAfterInSeconds</code>. This value does not affect authorization of clients that use MQTT connections.</p>
    /// <p>The default value is <code>false</code>.</p>
    pub enable_caching_for_http: std::option::Option<bool>,
}
impl CreateAuthorizerInput {
    /// <p>The authorizer name.</p>
    pub fn authorizer_name(&self) -> std::option::Option<&str> {
        self.authorizer_name.as_deref()
    }
    /// <p>The ARN of the authorizer's Lambda function.</p>
    pub fn authorizer_function_arn(&self) -> std::option::Option<&str> {
        self.authorizer_function_arn.as_deref()
    }
    /// <p>The name of the token key used to extract the token from the HTTP headers.</p>
    pub fn token_key_name(&self) -> std::option::Option<&str> {
        self.token_key_name.as_deref()
    }
    /// <p>The public keys used to verify the digital signature returned by your custom authentication service.</p>
    pub fn token_signing_public_keys(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.token_signing_public_keys.as_ref()
    }
    /// <p>The status of the create authorizer request.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AuthorizerStatus> {
        self.status.as_ref()
    }
    /// <p>Metadata which can be used to manage the custom authorizer.</p> <note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>Specifies whether IoT validates the token signature in an authorization request.</p>
    pub fn signing_disabled(&self) -> std::option::Option<bool> {
        self.signing_disabled
    }
    /// <p>When <code>true</code>, the result from the authorizers Lambda function is cached for clients that use persistent HTTP connections. The results are cached for the time specified by the Lambda function in <code>refreshAfterInSeconds</code>. This value does not affect authorization of clients that use MQTT connections.</p>
    /// <p>The default value is <code>false</code>.</p>
    pub fn enable_caching_for_http(&self) -> std::option::Option<bool> {
        self.enable_caching_for_http
    }
}
impl std::fmt::Debug for CreateAuthorizerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAuthorizerInput");
        formatter.field("authorizer_name", &self.authorizer_name);
        formatter.field("authorizer_function_arn", &self.authorizer_function_arn);
        formatter.field("token_key_name", &self.token_key_name);
        formatter.field("token_signing_public_keys", &self.token_signing_public_keys);
        formatter.field("status", &self.status);
        formatter.field("tags", &self.tags);
        formatter.field("signing_disabled", &self.signing_disabled);
        formatter.field("enable_caching_for_http", &self.enable_caching_for_http);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAuditSuppressionInput {
    /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub check_name: std::option::Option<std::string::String>,
    /// <p>Information that identifies the noncompliant resource.</p>
    pub resource_identifier: std::option::Option<crate::model::ResourceIdentifier>,
    /// <p> The epoch timestamp in seconds at which this suppression expires. </p>
    pub expiration_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> Indicates whether a suppression should exist indefinitely or not. </p>
    pub suppress_indefinitely: std::option::Option<bool>,
    /// <p> The description of the audit suppression. </p>
    pub description: std::option::Option<std::string::String>,
    /// <p> Each audit supression must have a unique client request token. If you try to create a new audit suppression with the same token as one that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.</p>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl CreateAuditSuppressionInput {
    /// <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    pub fn check_name(&self) -> std::option::Option<&str> {
        self.check_name.as_deref()
    }
    /// <p>Information that identifies the noncompliant resource.</p>
    pub fn resource_identifier(&self) -> std::option::Option<&crate::model::ResourceIdentifier> {
        self.resource_identifier.as_ref()
    }
    /// <p> The epoch timestamp in seconds at which this suppression expires. </p>
    pub fn expiration_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expiration_date.as_ref()
    }
    /// <p> Indicates whether a suppression should exist indefinitely or not. </p>
    pub fn suppress_indefinitely(&self) -> std::option::Option<bool> {
        self.suppress_indefinitely
    }
    /// <p> The description of the audit suppression. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> Each audit supression must have a unique client request token. If you try to create a new audit suppression with the same token as one that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for CreateAuditSuppressionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAuditSuppressionInput");
        formatter.field("check_name", &self.check_name);
        formatter.field("resource_identifier", &self.resource_identifier);
        formatter.field("expiration_date", &self.expiration_date);
        formatter.field("suppress_indefinitely", &self.suppress_indefinitely);
        formatter.field("description", &self.description);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConfirmTopicRuleDestinationInput {
    /// <p>The token used to confirm ownership or access to the topic rule confirmation URL.</p>
    pub confirmation_token: std::option::Option<std::string::String>,
}
impl ConfirmTopicRuleDestinationInput {
    /// <p>The token used to confirm ownership or access to the topic rule confirmation URL.</p>
    pub fn confirmation_token(&self) -> std::option::Option<&str> {
        self.confirmation_token.as_deref()
    }
}
impl std::fmt::Debug for ConfirmTopicRuleDestinationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConfirmTopicRuleDestinationInput");
        formatter.field("confirmation_token", &self.confirmation_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClearDefaultAuthorizerInput {}
impl std::fmt::Debug for ClearDefaultAuthorizerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClearDefaultAuthorizerInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelJobExecutionInput {
    /// <p>The ID of the job to be canceled.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The name of the thing whose execution of the job will be canceled.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p>
    /// <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
    pub force: bool,
    /// <p>(Optional) The expected current version of the job execution. Each time you update the job execution, its version is incremented. If the version of the job execution stored in Jobs does not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that contains the current job execution status data is returned. (This makes it unnecessary to perform a separate DescribeJobExecution request in order to obtain the job execution status data.)</p>
    pub expected_version: std::option::Option<i64>,
    /// <p>A collection of name/value pairs that describe the status of the job execution. If not specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.</p>
    pub status_details:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CancelJobExecutionInput {
    /// <p>The ID of the job to be canceled.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The name of the thing whose execution of the job will be canceled.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p>
    /// <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
    pub fn force(&self) -> bool {
        self.force
    }
    /// <p>(Optional) The expected current version of the job execution. Each time you update the job execution, its version is incremented. If the version of the job execution stored in Jobs does not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that contains the current job execution status data is returned. (This makes it unnecessary to perform a separate DescribeJobExecution request in order to obtain the job execution status data.)</p>
    pub fn expected_version(&self) -> std::option::Option<i64> {
        self.expected_version
    }
    /// <p>A collection of name/value pairs that describe the status of the job execution. If not specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.</p>
    pub fn status_details(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.status_details.as_ref()
    }
}
impl std::fmt::Debug for CancelJobExecutionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelJobExecutionInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("thing_name", &self.thing_name);
        formatter.field("force", &self.force);
        formatter.field("expected_version", &self.expected_version);
        formatter.field("status_details", &self.status_details);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelJobInput {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>(Optional)A reason code string that explains why the job was canceled.</p>
    pub reason_code: std::option::Option<std::string::String>,
    /// <p>An optional comment string describing why the job was canceled.</p>
    pub comment: std::option::Option<std::string::String>,
    /// <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p>
    /// <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
    pub force: bool,
}
impl CancelJobInput {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>(Optional)A reason code string that explains why the job was canceled.</p>
    pub fn reason_code(&self) -> std::option::Option<&str> {
        self.reason_code.as_deref()
    }
    /// <p>An optional comment string describing why the job was canceled.</p>
    pub fn comment(&self) -> std::option::Option<&str> {
        self.comment.as_deref()
    }
    /// <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p>
    /// <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
    pub fn force(&self) -> bool {
        self.force
    }
}
impl std::fmt::Debug for CancelJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelJobInput");
        formatter.field("job_id", &self.job_id);
        formatter.field("reason_code", &self.reason_code);
        formatter.field("comment", &self.comment);
        formatter.field("force", &self.force);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelDetectMitigationActionsTaskInput {
    /// <p> The unique identifier of the task. </p>
    pub task_id: std::option::Option<std::string::String>,
}
impl CancelDetectMitigationActionsTaskInput {
    /// <p> The unique identifier of the task. </p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
}
impl std::fmt::Debug for CancelDetectMitigationActionsTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelDetectMitigationActionsTaskInput");
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

/// <p>The input for the CancelCertificateTransfer operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelCertificateTransferInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub certificate_id: std::option::Option<std::string::String>,
}
impl CancelCertificateTransferInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub fn certificate_id(&self) -> std::option::Option<&str> {
        self.certificate_id.as_deref()
    }
}
impl std::fmt::Debug for CancelCertificateTransferInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelCertificateTransferInput");
        formatter.field("certificate_id", &self.certificate_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelAuditTaskInput {
    /// <p>The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".</p>
    pub task_id: std::option::Option<std::string::String>,
}
impl CancelAuditTaskInput {
    /// <p>The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".</p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
}
impl std::fmt::Debug for CancelAuditTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelAuditTaskInput");
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelAuditMitigationActionsTaskInput {
    /// <p>The unique identifier for the task that you want to cancel. </p>
    pub task_id: std::option::Option<std::string::String>,
}
impl CancelAuditMitigationActionsTaskInput {
    /// <p>The unique identifier for the task that you want to cancel. </p>
    pub fn task_id(&self) -> std::option::Option<&str> {
        self.task_id.as_deref()
    }
}
impl std::fmt::Debug for CancelAuditMitigationActionsTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelAuditMitigationActionsTaskInput");
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

/// <p>The input for the AttachThingPrincipal operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachThingPrincipalInput {
    /// <p>The name of the thing.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
    pub principal: std::option::Option<std::string::String>,
}
impl AttachThingPrincipalInput {
    /// <p>The name of the thing.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
    pub fn principal(&self) -> std::option::Option<&str> {
        self.principal.as_deref()
    }
}
impl std::fmt::Debug for AttachThingPrincipalInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachThingPrincipalInput");
        formatter.field("thing_name", &self.thing_name);
        formatter.field("principal", &self.principal);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachSecurityProfileInput {
    /// <p>The security profile that is attached.</p>
    pub security_profile_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the target (thing group) to which the security profile is attached.</p>
    pub security_profile_target_arn: std::option::Option<std::string::String>,
}
impl AttachSecurityProfileInput {
    /// <p>The security profile that is attached.</p>
    pub fn security_profile_name(&self) -> std::option::Option<&str> {
        self.security_profile_name.as_deref()
    }
    /// <p>The ARN of the target (thing group) to which the security profile is attached.</p>
    pub fn security_profile_target_arn(&self) -> std::option::Option<&str> {
        self.security_profile_target_arn.as_deref()
    }
}
impl std::fmt::Debug for AttachSecurityProfileInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachSecurityProfileInput");
        formatter.field("security_profile_name", &self.security_profile_name);
        formatter.field(
            "security_profile_target_arn",
            &self.security_profile_target_arn,
        );
        formatter.finish()
    }
}

/// <p>The input for the AttachPrincipalPolicy operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachPrincipalPolicyInput {
    /// <p>The policy name.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
    pub principal: std::option::Option<std::string::String>,
}
impl AttachPrincipalPolicyInput {
    /// <p>The policy name.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
    pub fn principal(&self) -> std::option::Option<&str> {
        self.principal.as_deref()
    }
}
impl std::fmt::Debug for AttachPrincipalPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachPrincipalPolicyInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("principal", &self.principal);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachPolicyInput {
    /// <p>The name of the policy to attach.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/iot/latest/developerguide/security-iam.html">identity</a> to which the policy is attached. For example, a thing group or a certificate.</p>
    pub target: std::option::Option<std::string::String>,
}
impl AttachPolicyInput {
    /// <p>The name of the policy to attach.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The <a href="https://docs.aws.amazon.com/iot/latest/developerguide/security-iam.html">identity</a> to which the policy is attached. For example, a thing group or a certificate.</p>
    pub fn target(&self) -> std::option::Option<&str> {
        self.target.as_deref()
    }
}
impl std::fmt::Debug for AttachPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachPolicyInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("target", &self.target);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateTargetsWithJobInput {
    /// <p>A list of thing group ARNs that define the targets of the job.</p>
    pub targets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>An optional comment string describing why the job was associated with the targets.</p>
    pub comment: std::option::Option<std::string::String>,
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub namespace_id: std::option::Option<std::string::String>,
}
impl AssociateTargetsWithJobInput {
    /// <p>A list of thing group ARNs that define the targets of the job.</p>
    pub fn targets(&self) -> std::option::Option<&[std::string::String]> {
        self.targets.as_deref()
    }
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>An optional comment string describing why the job was associated with the targets.</p>
    pub fn comment(&self) -> std::option::Option<&str> {
        self.comment.as_deref()
    }
    /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
    /// <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format.</p>
    /// <p> <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code> </p> <note>
    /// <p>The <code>namespaceId</code> feature is in public preview.</p>
    /// </note>
    pub fn namespace_id(&self) -> std::option::Option<&str> {
        self.namespace_id.as_deref()
    }
}
impl std::fmt::Debug for AssociateTargetsWithJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateTargetsWithJobInput");
        formatter.field("targets", &self.targets);
        formatter.field("job_id", &self.job_id);
        formatter.field("comment", &self.comment);
        formatter.field("namespace_id", &self.namespace_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddThingToThingGroupInput {
    /// <p>The name of the group to which you are adding a thing.</p>
    pub thing_group_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the group to which you are adding a thing.</p>
    pub thing_group_arn: std::option::Option<std::string::String>,
    /// <p>The name of the thing to add to a group.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the thing to add to a group.</p>
    pub thing_arn: std::option::Option<std::string::String>,
    /// <p>Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.</p>
    pub override_dynamic_groups: bool,
}
impl AddThingToThingGroupInput {
    /// <p>The name of the group to which you are adding a thing.</p>
    pub fn thing_group_name(&self) -> std::option::Option<&str> {
        self.thing_group_name.as_deref()
    }
    /// <p>The ARN of the group to which you are adding a thing.</p>
    pub fn thing_group_arn(&self) -> std::option::Option<&str> {
        self.thing_group_arn.as_deref()
    }
    /// <p>The name of the thing to add to a group.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The ARN of the thing to add to a group.</p>
    pub fn thing_arn(&self) -> std::option::Option<&str> {
        self.thing_arn.as_deref()
    }
    /// <p>Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.</p>
    pub fn override_dynamic_groups(&self) -> bool {
        self.override_dynamic_groups
    }
}
impl std::fmt::Debug for AddThingToThingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddThingToThingGroupInput");
        formatter.field("thing_group_name", &self.thing_group_name);
        formatter.field("thing_group_arn", &self.thing_group_arn);
        formatter.field("thing_name", &self.thing_name);
        formatter.field("thing_arn", &self.thing_arn);
        formatter.field("override_dynamic_groups", &self.override_dynamic_groups);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddThingToBillingGroupInput {
    /// <p>The name of the billing group.</p> <note>
    /// <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p>
    /// </note>
    pub billing_group_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the billing group.</p>
    pub billing_group_arn: std::option::Option<std::string::String>,
    /// <p>The name of the thing to be added to the billing group.</p>
    pub thing_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the thing to be added to the billing group.</p>
    pub thing_arn: std::option::Option<std::string::String>,
}
impl AddThingToBillingGroupInput {
    /// <p>The name of the billing group.</p> <note>
    /// <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p>
    /// </note>
    pub fn billing_group_name(&self) -> std::option::Option<&str> {
        self.billing_group_name.as_deref()
    }
    /// <p>The ARN of the billing group.</p>
    pub fn billing_group_arn(&self) -> std::option::Option<&str> {
        self.billing_group_arn.as_deref()
    }
    /// <p>The name of the thing to be added to the billing group.</p>
    pub fn thing_name(&self) -> std::option::Option<&str> {
        self.thing_name.as_deref()
    }
    /// <p>The ARN of the thing to be added to the billing group.</p>
    pub fn thing_arn(&self) -> std::option::Option<&str> {
        self.thing_arn.as_deref()
    }
}
impl std::fmt::Debug for AddThingToBillingGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddThingToBillingGroupInput");
        formatter.field("billing_group_name", &self.billing_group_name);
        formatter.field("billing_group_arn", &self.billing_group_arn);
        formatter.field("thing_name", &self.thing_name);
        formatter.field("thing_arn", &self.thing_arn);
        formatter.finish()
    }
}

/// <p>The input for the AcceptCertificateTransfer operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AcceptCertificateTransferInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub certificate_id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the certificate is active.</p>
    pub set_as_active: bool,
}
impl AcceptCertificateTransferInput {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    pub fn certificate_id(&self) -> std::option::Option<&str> {
        self.certificate_id.as_deref()
    }
    /// <p>Specifies whether the certificate is active.</p>
    pub fn set_as_active(&self) -> bool {
        self.set_as_active
    }
}
impl std::fmt::Debug for AcceptCertificateTransferInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AcceptCertificateTransferInput");
        formatter.field("certificate_id", &self.certificate_id);
        formatter.field("set_as_active", &self.set_as_active);
        formatter.finish()
    }
}
