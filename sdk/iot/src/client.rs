// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn accept_certificate_transfer(&self) -> fluent_builders::AcceptCertificateTransfer<C> {
        fluent_builders::AcceptCertificateTransfer::new(self.handle.clone())
    }
    pub fn add_thing_to_billing_group(&self) -> fluent_builders::AddThingToBillingGroup<C> {
        fluent_builders::AddThingToBillingGroup::new(self.handle.clone())
    }
    pub fn add_thing_to_thing_group(&self) -> fluent_builders::AddThingToThingGroup<C> {
        fluent_builders::AddThingToThingGroup::new(self.handle.clone())
    }
    pub fn associate_targets_with_job(&self) -> fluent_builders::AssociateTargetsWithJob<C> {
        fluent_builders::AssociateTargetsWithJob::new(self.handle.clone())
    }
    pub fn attach_policy(&self) -> fluent_builders::AttachPolicy<C> {
        fluent_builders::AttachPolicy::new(self.handle.clone())
    }
    pub fn attach_principal_policy(&self) -> fluent_builders::AttachPrincipalPolicy<C> {
        fluent_builders::AttachPrincipalPolicy::new(self.handle.clone())
    }
    pub fn attach_security_profile(&self) -> fluent_builders::AttachSecurityProfile<C> {
        fluent_builders::AttachSecurityProfile::new(self.handle.clone())
    }
    pub fn attach_thing_principal(&self) -> fluent_builders::AttachThingPrincipal<C> {
        fluent_builders::AttachThingPrincipal::new(self.handle.clone())
    }
    pub fn cancel_audit_mitigation_actions_task(
        &self,
    ) -> fluent_builders::CancelAuditMitigationActionsTask<C> {
        fluent_builders::CancelAuditMitigationActionsTask::new(self.handle.clone())
    }
    pub fn cancel_audit_task(&self) -> fluent_builders::CancelAuditTask<C> {
        fluent_builders::CancelAuditTask::new(self.handle.clone())
    }
    pub fn cancel_certificate_transfer(&self) -> fluent_builders::CancelCertificateTransfer<C> {
        fluent_builders::CancelCertificateTransfer::new(self.handle.clone())
    }
    pub fn cancel_detect_mitigation_actions_task(
        &self,
    ) -> fluent_builders::CancelDetectMitigationActionsTask<C> {
        fluent_builders::CancelDetectMitigationActionsTask::new(self.handle.clone())
    }
    pub fn cancel_job(&self) -> fluent_builders::CancelJob<C> {
        fluent_builders::CancelJob::new(self.handle.clone())
    }
    pub fn cancel_job_execution(&self) -> fluent_builders::CancelJobExecution<C> {
        fluent_builders::CancelJobExecution::new(self.handle.clone())
    }
    pub fn clear_default_authorizer(&self) -> fluent_builders::ClearDefaultAuthorizer<C> {
        fluent_builders::ClearDefaultAuthorizer::new(self.handle.clone())
    }
    pub fn confirm_topic_rule_destination(
        &self,
    ) -> fluent_builders::ConfirmTopicRuleDestination<C> {
        fluent_builders::ConfirmTopicRuleDestination::new(self.handle.clone())
    }
    pub fn create_audit_suppression(&self) -> fluent_builders::CreateAuditSuppression<C> {
        fluent_builders::CreateAuditSuppression::new(self.handle.clone())
    }
    pub fn create_authorizer(&self) -> fluent_builders::CreateAuthorizer<C> {
        fluent_builders::CreateAuthorizer::new(self.handle.clone())
    }
    pub fn create_billing_group(&self) -> fluent_builders::CreateBillingGroup<C> {
        fluent_builders::CreateBillingGroup::new(self.handle.clone())
    }
    pub fn create_certificate_from_csr(&self) -> fluent_builders::CreateCertificateFromCsr<C> {
        fluent_builders::CreateCertificateFromCsr::new(self.handle.clone())
    }
    pub fn create_custom_metric(&self) -> fluent_builders::CreateCustomMetric<C> {
        fluent_builders::CreateCustomMetric::new(self.handle.clone())
    }
    pub fn create_dimension(&self) -> fluent_builders::CreateDimension<C> {
        fluent_builders::CreateDimension::new(self.handle.clone())
    }
    pub fn create_domain_configuration(&self) -> fluent_builders::CreateDomainConfiguration<C> {
        fluent_builders::CreateDomainConfiguration::new(self.handle.clone())
    }
    pub fn create_dynamic_thing_group(&self) -> fluent_builders::CreateDynamicThingGroup<C> {
        fluent_builders::CreateDynamicThingGroup::new(self.handle.clone())
    }
    pub fn create_job(&self) -> fluent_builders::CreateJob<C> {
        fluent_builders::CreateJob::new(self.handle.clone())
    }
    pub fn create_job_template(&self) -> fluent_builders::CreateJobTemplate<C> {
        fluent_builders::CreateJobTemplate::new(self.handle.clone())
    }
    pub fn create_keys_and_certificate(&self) -> fluent_builders::CreateKeysAndCertificate<C> {
        fluent_builders::CreateKeysAndCertificate::new(self.handle.clone())
    }
    pub fn create_mitigation_action(&self) -> fluent_builders::CreateMitigationAction<C> {
        fluent_builders::CreateMitigationAction::new(self.handle.clone())
    }
    pub fn create_ota_update(&self) -> fluent_builders::CreateOTAUpdate<C> {
        fluent_builders::CreateOTAUpdate::new(self.handle.clone())
    }
    pub fn create_policy(&self) -> fluent_builders::CreatePolicy<C> {
        fluent_builders::CreatePolicy::new(self.handle.clone())
    }
    pub fn create_policy_version(&self) -> fluent_builders::CreatePolicyVersion<C> {
        fluent_builders::CreatePolicyVersion::new(self.handle.clone())
    }
    pub fn create_provisioning_claim(&self) -> fluent_builders::CreateProvisioningClaim<C> {
        fluent_builders::CreateProvisioningClaim::new(self.handle.clone())
    }
    pub fn create_provisioning_template(&self) -> fluent_builders::CreateProvisioningTemplate<C> {
        fluent_builders::CreateProvisioningTemplate::new(self.handle.clone())
    }
    pub fn create_provisioning_template_version(
        &self,
    ) -> fluent_builders::CreateProvisioningTemplateVersion<C> {
        fluent_builders::CreateProvisioningTemplateVersion::new(self.handle.clone())
    }
    pub fn create_role_alias(&self) -> fluent_builders::CreateRoleAlias<C> {
        fluent_builders::CreateRoleAlias::new(self.handle.clone())
    }
    pub fn create_scheduled_audit(&self) -> fluent_builders::CreateScheduledAudit<C> {
        fluent_builders::CreateScheduledAudit::new(self.handle.clone())
    }
    pub fn create_security_profile(&self) -> fluent_builders::CreateSecurityProfile<C> {
        fluent_builders::CreateSecurityProfile::new(self.handle.clone())
    }
    pub fn create_stream(&self) -> fluent_builders::CreateStream<C> {
        fluent_builders::CreateStream::new(self.handle.clone())
    }
    pub fn create_thing(&self) -> fluent_builders::CreateThing<C> {
        fluent_builders::CreateThing::new(self.handle.clone())
    }
    pub fn create_thing_group(&self) -> fluent_builders::CreateThingGroup<C> {
        fluent_builders::CreateThingGroup::new(self.handle.clone())
    }
    pub fn create_thing_type(&self) -> fluent_builders::CreateThingType<C> {
        fluent_builders::CreateThingType::new(self.handle.clone())
    }
    pub fn create_topic_rule(&self) -> fluent_builders::CreateTopicRule<C> {
        fluent_builders::CreateTopicRule::new(self.handle.clone())
    }
    pub fn create_topic_rule_destination(&self) -> fluent_builders::CreateTopicRuleDestination<C> {
        fluent_builders::CreateTopicRuleDestination::new(self.handle.clone())
    }
    pub fn delete_account_audit_configuration(
        &self,
    ) -> fluent_builders::DeleteAccountAuditConfiguration<C> {
        fluent_builders::DeleteAccountAuditConfiguration::new(self.handle.clone())
    }
    pub fn delete_audit_suppression(&self) -> fluent_builders::DeleteAuditSuppression<C> {
        fluent_builders::DeleteAuditSuppression::new(self.handle.clone())
    }
    pub fn delete_authorizer(&self) -> fluent_builders::DeleteAuthorizer<C> {
        fluent_builders::DeleteAuthorizer::new(self.handle.clone())
    }
    pub fn delete_billing_group(&self) -> fluent_builders::DeleteBillingGroup<C> {
        fluent_builders::DeleteBillingGroup::new(self.handle.clone())
    }
    pub fn delete_ca_certificate(&self) -> fluent_builders::DeleteCACertificate<C> {
        fluent_builders::DeleteCACertificate::new(self.handle.clone())
    }
    pub fn delete_certificate(&self) -> fluent_builders::DeleteCertificate<C> {
        fluent_builders::DeleteCertificate::new(self.handle.clone())
    }
    pub fn delete_custom_metric(&self) -> fluent_builders::DeleteCustomMetric<C> {
        fluent_builders::DeleteCustomMetric::new(self.handle.clone())
    }
    pub fn delete_dimension(&self) -> fluent_builders::DeleteDimension<C> {
        fluent_builders::DeleteDimension::new(self.handle.clone())
    }
    pub fn delete_domain_configuration(&self) -> fluent_builders::DeleteDomainConfiguration<C> {
        fluent_builders::DeleteDomainConfiguration::new(self.handle.clone())
    }
    pub fn delete_dynamic_thing_group(&self) -> fluent_builders::DeleteDynamicThingGroup<C> {
        fluent_builders::DeleteDynamicThingGroup::new(self.handle.clone())
    }
    pub fn delete_job(&self) -> fluent_builders::DeleteJob<C> {
        fluent_builders::DeleteJob::new(self.handle.clone())
    }
    pub fn delete_job_execution(&self) -> fluent_builders::DeleteJobExecution<C> {
        fluent_builders::DeleteJobExecution::new(self.handle.clone())
    }
    pub fn delete_job_template(&self) -> fluent_builders::DeleteJobTemplate<C> {
        fluent_builders::DeleteJobTemplate::new(self.handle.clone())
    }
    pub fn delete_mitigation_action(&self) -> fluent_builders::DeleteMitigationAction<C> {
        fluent_builders::DeleteMitigationAction::new(self.handle.clone())
    }
    pub fn delete_ota_update(&self) -> fluent_builders::DeleteOTAUpdate<C> {
        fluent_builders::DeleteOTAUpdate::new(self.handle.clone())
    }
    pub fn delete_policy(&self) -> fluent_builders::DeletePolicy<C> {
        fluent_builders::DeletePolicy::new(self.handle.clone())
    }
    pub fn delete_policy_version(&self) -> fluent_builders::DeletePolicyVersion<C> {
        fluent_builders::DeletePolicyVersion::new(self.handle.clone())
    }
    pub fn delete_provisioning_template(&self) -> fluent_builders::DeleteProvisioningTemplate<C> {
        fluent_builders::DeleteProvisioningTemplate::new(self.handle.clone())
    }
    pub fn delete_provisioning_template_version(
        &self,
    ) -> fluent_builders::DeleteProvisioningTemplateVersion<C> {
        fluent_builders::DeleteProvisioningTemplateVersion::new(self.handle.clone())
    }
    pub fn delete_registration_code(&self) -> fluent_builders::DeleteRegistrationCode<C> {
        fluent_builders::DeleteRegistrationCode::new(self.handle.clone())
    }
    pub fn delete_role_alias(&self) -> fluent_builders::DeleteRoleAlias<C> {
        fluent_builders::DeleteRoleAlias::new(self.handle.clone())
    }
    pub fn delete_scheduled_audit(&self) -> fluent_builders::DeleteScheduledAudit<C> {
        fluent_builders::DeleteScheduledAudit::new(self.handle.clone())
    }
    pub fn delete_security_profile(&self) -> fluent_builders::DeleteSecurityProfile<C> {
        fluent_builders::DeleteSecurityProfile::new(self.handle.clone())
    }
    pub fn delete_stream(&self) -> fluent_builders::DeleteStream<C> {
        fluent_builders::DeleteStream::new(self.handle.clone())
    }
    pub fn delete_thing(&self) -> fluent_builders::DeleteThing<C> {
        fluent_builders::DeleteThing::new(self.handle.clone())
    }
    pub fn delete_thing_group(&self) -> fluent_builders::DeleteThingGroup<C> {
        fluent_builders::DeleteThingGroup::new(self.handle.clone())
    }
    pub fn delete_thing_type(&self) -> fluent_builders::DeleteThingType<C> {
        fluent_builders::DeleteThingType::new(self.handle.clone())
    }
    pub fn delete_topic_rule(&self) -> fluent_builders::DeleteTopicRule<C> {
        fluent_builders::DeleteTopicRule::new(self.handle.clone())
    }
    pub fn delete_topic_rule_destination(&self) -> fluent_builders::DeleteTopicRuleDestination<C> {
        fluent_builders::DeleteTopicRuleDestination::new(self.handle.clone())
    }
    pub fn delete_v2_logging_level(&self) -> fluent_builders::DeleteV2LoggingLevel<C> {
        fluent_builders::DeleteV2LoggingLevel::new(self.handle.clone())
    }
    pub fn deprecate_thing_type(&self) -> fluent_builders::DeprecateThingType<C> {
        fluent_builders::DeprecateThingType::new(self.handle.clone())
    }
    pub fn describe_account_audit_configuration(
        &self,
    ) -> fluent_builders::DescribeAccountAuditConfiguration<C> {
        fluent_builders::DescribeAccountAuditConfiguration::new(self.handle.clone())
    }
    pub fn describe_audit_finding(&self) -> fluent_builders::DescribeAuditFinding<C> {
        fluent_builders::DescribeAuditFinding::new(self.handle.clone())
    }
    pub fn describe_audit_mitigation_actions_task(
        &self,
    ) -> fluent_builders::DescribeAuditMitigationActionsTask<C> {
        fluent_builders::DescribeAuditMitigationActionsTask::new(self.handle.clone())
    }
    pub fn describe_audit_suppression(&self) -> fluent_builders::DescribeAuditSuppression<C> {
        fluent_builders::DescribeAuditSuppression::new(self.handle.clone())
    }
    pub fn describe_audit_task(&self) -> fluent_builders::DescribeAuditTask<C> {
        fluent_builders::DescribeAuditTask::new(self.handle.clone())
    }
    pub fn describe_authorizer(&self) -> fluent_builders::DescribeAuthorizer<C> {
        fluent_builders::DescribeAuthorizer::new(self.handle.clone())
    }
    pub fn describe_billing_group(&self) -> fluent_builders::DescribeBillingGroup<C> {
        fluent_builders::DescribeBillingGroup::new(self.handle.clone())
    }
    pub fn describe_ca_certificate(&self) -> fluent_builders::DescribeCACertificate<C> {
        fluent_builders::DescribeCACertificate::new(self.handle.clone())
    }
    pub fn describe_certificate(&self) -> fluent_builders::DescribeCertificate<C> {
        fluent_builders::DescribeCertificate::new(self.handle.clone())
    }
    pub fn describe_custom_metric(&self) -> fluent_builders::DescribeCustomMetric<C> {
        fluent_builders::DescribeCustomMetric::new(self.handle.clone())
    }
    pub fn describe_default_authorizer(&self) -> fluent_builders::DescribeDefaultAuthorizer<C> {
        fluent_builders::DescribeDefaultAuthorizer::new(self.handle.clone())
    }
    pub fn describe_detect_mitigation_actions_task(
        &self,
    ) -> fluent_builders::DescribeDetectMitigationActionsTask<C> {
        fluent_builders::DescribeDetectMitigationActionsTask::new(self.handle.clone())
    }
    pub fn describe_dimension(&self) -> fluent_builders::DescribeDimension<C> {
        fluent_builders::DescribeDimension::new(self.handle.clone())
    }
    pub fn describe_domain_configuration(&self) -> fluent_builders::DescribeDomainConfiguration<C> {
        fluent_builders::DescribeDomainConfiguration::new(self.handle.clone())
    }
    pub fn describe_endpoint(&self) -> fluent_builders::DescribeEndpoint<C> {
        fluent_builders::DescribeEndpoint::new(self.handle.clone())
    }
    pub fn describe_event_configurations(&self) -> fluent_builders::DescribeEventConfigurations<C> {
        fluent_builders::DescribeEventConfigurations::new(self.handle.clone())
    }
    pub fn describe_index(&self) -> fluent_builders::DescribeIndex<C> {
        fluent_builders::DescribeIndex::new(self.handle.clone())
    }
    pub fn describe_job(&self) -> fluent_builders::DescribeJob<C> {
        fluent_builders::DescribeJob::new(self.handle.clone())
    }
    pub fn describe_job_execution(&self) -> fluent_builders::DescribeJobExecution<C> {
        fluent_builders::DescribeJobExecution::new(self.handle.clone())
    }
    pub fn describe_job_template(&self) -> fluent_builders::DescribeJobTemplate<C> {
        fluent_builders::DescribeJobTemplate::new(self.handle.clone())
    }
    pub fn describe_mitigation_action(&self) -> fluent_builders::DescribeMitigationAction<C> {
        fluent_builders::DescribeMitigationAction::new(self.handle.clone())
    }
    pub fn describe_provisioning_template(
        &self,
    ) -> fluent_builders::DescribeProvisioningTemplate<C> {
        fluent_builders::DescribeProvisioningTemplate::new(self.handle.clone())
    }
    pub fn describe_provisioning_template_version(
        &self,
    ) -> fluent_builders::DescribeProvisioningTemplateVersion<C> {
        fluent_builders::DescribeProvisioningTemplateVersion::new(self.handle.clone())
    }
    pub fn describe_role_alias(&self) -> fluent_builders::DescribeRoleAlias<C> {
        fluent_builders::DescribeRoleAlias::new(self.handle.clone())
    }
    pub fn describe_scheduled_audit(&self) -> fluent_builders::DescribeScheduledAudit<C> {
        fluent_builders::DescribeScheduledAudit::new(self.handle.clone())
    }
    pub fn describe_security_profile(&self) -> fluent_builders::DescribeSecurityProfile<C> {
        fluent_builders::DescribeSecurityProfile::new(self.handle.clone())
    }
    pub fn describe_stream(&self) -> fluent_builders::DescribeStream<C> {
        fluent_builders::DescribeStream::new(self.handle.clone())
    }
    pub fn describe_thing(&self) -> fluent_builders::DescribeThing<C> {
        fluent_builders::DescribeThing::new(self.handle.clone())
    }
    pub fn describe_thing_group(&self) -> fluent_builders::DescribeThingGroup<C> {
        fluent_builders::DescribeThingGroup::new(self.handle.clone())
    }
    pub fn describe_thing_registration_task(
        &self,
    ) -> fluent_builders::DescribeThingRegistrationTask<C> {
        fluent_builders::DescribeThingRegistrationTask::new(self.handle.clone())
    }
    pub fn describe_thing_type(&self) -> fluent_builders::DescribeThingType<C> {
        fluent_builders::DescribeThingType::new(self.handle.clone())
    }
    pub fn detach_policy(&self) -> fluent_builders::DetachPolicy<C> {
        fluent_builders::DetachPolicy::new(self.handle.clone())
    }
    pub fn detach_principal_policy(&self) -> fluent_builders::DetachPrincipalPolicy<C> {
        fluent_builders::DetachPrincipalPolicy::new(self.handle.clone())
    }
    pub fn detach_security_profile(&self) -> fluent_builders::DetachSecurityProfile<C> {
        fluent_builders::DetachSecurityProfile::new(self.handle.clone())
    }
    pub fn detach_thing_principal(&self) -> fluent_builders::DetachThingPrincipal<C> {
        fluent_builders::DetachThingPrincipal::new(self.handle.clone())
    }
    pub fn disable_topic_rule(&self) -> fluent_builders::DisableTopicRule<C> {
        fluent_builders::DisableTopicRule::new(self.handle.clone())
    }
    pub fn enable_topic_rule(&self) -> fluent_builders::EnableTopicRule<C> {
        fluent_builders::EnableTopicRule::new(self.handle.clone())
    }
    pub fn get_behavior_model_training_summaries(
        &self,
    ) -> fluent_builders::GetBehaviorModelTrainingSummaries<C> {
        fluent_builders::GetBehaviorModelTrainingSummaries::new(self.handle.clone())
    }
    pub fn get_cardinality(&self) -> fluent_builders::GetCardinality<C> {
        fluent_builders::GetCardinality::new(self.handle.clone())
    }
    pub fn get_effective_policies(&self) -> fluent_builders::GetEffectivePolicies<C> {
        fluent_builders::GetEffectivePolicies::new(self.handle.clone())
    }
    pub fn get_indexing_configuration(&self) -> fluent_builders::GetIndexingConfiguration<C> {
        fluent_builders::GetIndexingConfiguration::new(self.handle.clone())
    }
    pub fn get_job_document(&self) -> fluent_builders::GetJobDocument<C> {
        fluent_builders::GetJobDocument::new(self.handle.clone())
    }
    pub fn get_logging_options(&self) -> fluent_builders::GetLoggingOptions<C> {
        fluent_builders::GetLoggingOptions::new(self.handle.clone())
    }
    pub fn get_ota_update(&self) -> fluent_builders::GetOTAUpdate<C> {
        fluent_builders::GetOTAUpdate::new(self.handle.clone())
    }
    pub fn get_percentiles(&self) -> fluent_builders::GetPercentiles<C> {
        fluent_builders::GetPercentiles::new(self.handle.clone())
    }
    pub fn get_policy(&self) -> fluent_builders::GetPolicy<C> {
        fluent_builders::GetPolicy::new(self.handle.clone())
    }
    pub fn get_policy_version(&self) -> fluent_builders::GetPolicyVersion<C> {
        fluent_builders::GetPolicyVersion::new(self.handle.clone())
    }
    pub fn get_registration_code(&self) -> fluent_builders::GetRegistrationCode<C> {
        fluent_builders::GetRegistrationCode::new(self.handle.clone())
    }
    pub fn get_statistics(&self) -> fluent_builders::GetStatistics<C> {
        fluent_builders::GetStatistics::new(self.handle.clone())
    }
    pub fn get_topic_rule(&self) -> fluent_builders::GetTopicRule<C> {
        fluent_builders::GetTopicRule::new(self.handle.clone())
    }
    pub fn get_topic_rule_destination(&self) -> fluent_builders::GetTopicRuleDestination<C> {
        fluent_builders::GetTopicRuleDestination::new(self.handle.clone())
    }
    pub fn get_v2_logging_options(&self) -> fluent_builders::GetV2LoggingOptions<C> {
        fluent_builders::GetV2LoggingOptions::new(self.handle.clone())
    }
    pub fn list_active_violations(&self) -> fluent_builders::ListActiveViolations<C> {
        fluent_builders::ListActiveViolations::new(self.handle.clone())
    }
    pub fn list_attached_policies(&self) -> fluent_builders::ListAttachedPolicies<C> {
        fluent_builders::ListAttachedPolicies::new(self.handle.clone())
    }
    pub fn list_audit_findings(&self) -> fluent_builders::ListAuditFindings<C> {
        fluent_builders::ListAuditFindings::new(self.handle.clone())
    }
    pub fn list_audit_mitigation_actions_executions(
        &self,
    ) -> fluent_builders::ListAuditMitigationActionsExecutions<C> {
        fluent_builders::ListAuditMitigationActionsExecutions::new(self.handle.clone())
    }
    pub fn list_audit_mitigation_actions_tasks(
        &self,
    ) -> fluent_builders::ListAuditMitigationActionsTasks<C> {
        fluent_builders::ListAuditMitigationActionsTasks::new(self.handle.clone())
    }
    pub fn list_audit_suppressions(&self) -> fluent_builders::ListAuditSuppressions<C> {
        fluent_builders::ListAuditSuppressions::new(self.handle.clone())
    }
    pub fn list_audit_tasks(&self) -> fluent_builders::ListAuditTasks<C> {
        fluent_builders::ListAuditTasks::new(self.handle.clone())
    }
    pub fn list_authorizers(&self) -> fluent_builders::ListAuthorizers<C> {
        fluent_builders::ListAuthorizers::new(self.handle.clone())
    }
    pub fn list_billing_groups(&self) -> fluent_builders::ListBillingGroups<C> {
        fluent_builders::ListBillingGroups::new(self.handle.clone())
    }
    pub fn list_ca_certificates(&self) -> fluent_builders::ListCACertificates<C> {
        fluent_builders::ListCACertificates::new(self.handle.clone())
    }
    pub fn list_certificates(&self) -> fluent_builders::ListCertificates<C> {
        fluent_builders::ListCertificates::new(self.handle.clone())
    }
    pub fn list_certificates_by_ca(&self) -> fluent_builders::ListCertificatesByCA<C> {
        fluent_builders::ListCertificatesByCA::new(self.handle.clone())
    }
    pub fn list_custom_metrics(&self) -> fluent_builders::ListCustomMetrics<C> {
        fluent_builders::ListCustomMetrics::new(self.handle.clone())
    }
    pub fn list_detect_mitigation_actions_executions(
        &self,
    ) -> fluent_builders::ListDetectMitigationActionsExecutions<C> {
        fluent_builders::ListDetectMitigationActionsExecutions::new(self.handle.clone())
    }
    pub fn list_detect_mitigation_actions_tasks(
        &self,
    ) -> fluent_builders::ListDetectMitigationActionsTasks<C> {
        fluent_builders::ListDetectMitigationActionsTasks::new(self.handle.clone())
    }
    pub fn list_dimensions(&self) -> fluent_builders::ListDimensions<C> {
        fluent_builders::ListDimensions::new(self.handle.clone())
    }
    pub fn list_domain_configurations(&self) -> fluent_builders::ListDomainConfigurations<C> {
        fluent_builders::ListDomainConfigurations::new(self.handle.clone())
    }
    pub fn list_indices(&self) -> fluent_builders::ListIndices<C> {
        fluent_builders::ListIndices::new(self.handle.clone())
    }
    pub fn list_job_executions_for_job(&self) -> fluent_builders::ListJobExecutionsForJob<C> {
        fluent_builders::ListJobExecutionsForJob::new(self.handle.clone())
    }
    pub fn list_job_executions_for_thing(&self) -> fluent_builders::ListJobExecutionsForThing<C> {
        fluent_builders::ListJobExecutionsForThing::new(self.handle.clone())
    }
    pub fn list_jobs(&self) -> fluent_builders::ListJobs<C> {
        fluent_builders::ListJobs::new(self.handle.clone())
    }
    pub fn list_job_templates(&self) -> fluent_builders::ListJobTemplates<C> {
        fluent_builders::ListJobTemplates::new(self.handle.clone())
    }
    pub fn list_mitigation_actions(&self) -> fluent_builders::ListMitigationActions<C> {
        fluent_builders::ListMitigationActions::new(self.handle.clone())
    }
    pub fn list_ota_updates(&self) -> fluent_builders::ListOTAUpdates<C> {
        fluent_builders::ListOTAUpdates::new(self.handle.clone())
    }
    pub fn list_outgoing_certificates(&self) -> fluent_builders::ListOutgoingCertificates<C> {
        fluent_builders::ListOutgoingCertificates::new(self.handle.clone())
    }
    pub fn list_policies(&self) -> fluent_builders::ListPolicies<C> {
        fluent_builders::ListPolicies::new(self.handle.clone())
    }
    pub fn list_policy_principals(&self) -> fluent_builders::ListPolicyPrincipals<C> {
        fluent_builders::ListPolicyPrincipals::new(self.handle.clone())
    }
    pub fn list_policy_versions(&self) -> fluent_builders::ListPolicyVersions<C> {
        fluent_builders::ListPolicyVersions::new(self.handle.clone())
    }
    pub fn list_principal_policies(&self) -> fluent_builders::ListPrincipalPolicies<C> {
        fluent_builders::ListPrincipalPolicies::new(self.handle.clone())
    }
    pub fn list_principal_things(&self) -> fluent_builders::ListPrincipalThings<C> {
        fluent_builders::ListPrincipalThings::new(self.handle.clone())
    }
    pub fn list_provisioning_templates(&self) -> fluent_builders::ListProvisioningTemplates<C> {
        fluent_builders::ListProvisioningTemplates::new(self.handle.clone())
    }
    pub fn list_provisioning_template_versions(
        &self,
    ) -> fluent_builders::ListProvisioningTemplateVersions<C> {
        fluent_builders::ListProvisioningTemplateVersions::new(self.handle.clone())
    }
    pub fn list_role_aliases(&self) -> fluent_builders::ListRoleAliases<C> {
        fluent_builders::ListRoleAliases::new(self.handle.clone())
    }
    pub fn list_scheduled_audits(&self) -> fluent_builders::ListScheduledAudits<C> {
        fluent_builders::ListScheduledAudits::new(self.handle.clone())
    }
    pub fn list_security_profiles(&self) -> fluent_builders::ListSecurityProfiles<C> {
        fluent_builders::ListSecurityProfiles::new(self.handle.clone())
    }
    pub fn list_security_profiles_for_target(
        &self,
    ) -> fluent_builders::ListSecurityProfilesForTarget<C> {
        fluent_builders::ListSecurityProfilesForTarget::new(self.handle.clone())
    }
    pub fn list_streams(&self) -> fluent_builders::ListStreams<C> {
        fluent_builders::ListStreams::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_targets_for_policy(&self) -> fluent_builders::ListTargetsForPolicy<C> {
        fluent_builders::ListTargetsForPolicy::new(self.handle.clone())
    }
    pub fn list_targets_for_security_profile(
        &self,
    ) -> fluent_builders::ListTargetsForSecurityProfile<C> {
        fluent_builders::ListTargetsForSecurityProfile::new(self.handle.clone())
    }
    pub fn list_thing_groups(&self) -> fluent_builders::ListThingGroups<C> {
        fluent_builders::ListThingGroups::new(self.handle.clone())
    }
    pub fn list_thing_groups_for_thing(&self) -> fluent_builders::ListThingGroupsForThing<C> {
        fluent_builders::ListThingGroupsForThing::new(self.handle.clone())
    }
    pub fn list_thing_principals(&self) -> fluent_builders::ListThingPrincipals<C> {
        fluent_builders::ListThingPrincipals::new(self.handle.clone())
    }
    pub fn list_thing_registration_task_reports(
        &self,
    ) -> fluent_builders::ListThingRegistrationTaskReports<C> {
        fluent_builders::ListThingRegistrationTaskReports::new(self.handle.clone())
    }
    pub fn list_thing_registration_tasks(&self) -> fluent_builders::ListThingRegistrationTasks<C> {
        fluent_builders::ListThingRegistrationTasks::new(self.handle.clone())
    }
    pub fn list_things(&self) -> fluent_builders::ListThings<C> {
        fluent_builders::ListThings::new(self.handle.clone())
    }
    pub fn list_things_in_billing_group(&self) -> fluent_builders::ListThingsInBillingGroup<C> {
        fluent_builders::ListThingsInBillingGroup::new(self.handle.clone())
    }
    pub fn list_things_in_thing_group(&self) -> fluent_builders::ListThingsInThingGroup<C> {
        fluent_builders::ListThingsInThingGroup::new(self.handle.clone())
    }
    pub fn list_thing_types(&self) -> fluent_builders::ListThingTypes<C> {
        fluent_builders::ListThingTypes::new(self.handle.clone())
    }
    pub fn list_topic_rule_destinations(&self) -> fluent_builders::ListTopicRuleDestinations<C> {
        fluent_builders::ListTopicRuleDestinations::new(self.handle.clone())
    }
    pub fn list_topic_rules(&self) -> fluent_builders::ListTopicRules<C> {
        fluent_builders::ListTopicRules::new(self.handle.clone())
    }
    pub fn list_v2_logging_levels(&self) -> fluent_builders::ListV2LoggingLevels<C> {
        fluent_builders::ListV2LoggingLevels::new(self.handle.clone())
    }
    pub fn list_violation_events(&self) -> fluent_builders::ListViolationEvents<C> {
        fluent_builders::ListViolationEvents::new(self.handle.clone())
    }
    pub fn register_ca_certificate(&self) -> fluent_builders::RegisterCACertificate<C> {
        fluent_builders::RegisterCACertificate::new(self.handle.clone())
    }
    pub fn register_certificate(&self) -> fluent_builders::RegisterCertificate<C> {
        fluent_builders::RegisterCertificate::new(self.handle.clone())
    }
    pub fn register_certificate_without_ca(
        &self,
    ) -> fluent_builders::RegisterCertificateWithoutCA<C> {
        fluent_builders::RegisterCertificateWithoutCA::new(self.handle.clone())
    }
    pub fn register_thing(&self) -> fluent_builders::RegisterThing<C> {
        fluent_builders::RegisterThing::new(self.handle.clone())
    }
    pub fn reject_certificate_transfer(&self) -> fluent_builders::RejectCertificateTransfer<C> {
        fluent_builders::RejectCertificateTransfer::new(self.handle.clone())
    }
    pub fn remove_thing_from_billing_group(
        &self,
    ) -> fluent_builders::RemoveThingFromBillingGroup<C> {
        fluent_builders::RemoveThingFromBillingGroup::new(self.handle.clone())
    }
    pub fn remove_thing_from_thing_group(&self) -> fluent_builders::RemoveThingFromThingGroup<C> {
        fluent_builders::RemoveThingFromThingGroup::new(self.handle.clone())
    }
    pub fn replace_topic_rule(&self) -> fluent_builders::ReplaceTopicRule<C> {
        fluent_builders::ReplaceTopicRule::new(self.handle.clone())
    }
    pub fn search_index(&self) -> fluent_builders::SearchIndex<C> {
        fluent_builders::SearchIndex::new(self.handle.clone())
    }
    pub fn set_default_authorizer(&self) -> fluent_builders::SetDefaultAuthorizer<C> {
        fluent_builders::SetDefaultAuthorizer::new(self.handle.clone())
    }
    pub fn set_default_policy_version(&self) -> fluent_builders::SetDefaultPolicyVersion<C> {
        fluent_builders::SetDefaultPolicyVersion::new(self.handle.clone())
    }
    pub fn set_logging_options(&self) -> fluent_builders::SetLoggingOptions<C> {
        fluent_builders::SetLoggingOptions::new(self.handle.clone())
    }
    pub fn set_v2_logging_level(&self) -> fluent_builders::SetV2LoggingLevel<C> {
        fluent_builders::SetV2LoggingLevel::new(self.handle.clone())
    }
    pub fn set_v2_logging_options(&self) -> fluent_builders::SetV2LoggingOptions<C> {
        fluent_builders::SetV2LoggingOptions::new(self.handle.clone())
    }
    pub fn start_audit_mitigation_actions_task(
        &self,
    ) -> fluent_builders::StartAuditMitigationActionsTask<C> {
        fluent_builders::StartAuditMitigationActionsTask::new(self.handle.clone())
    }
    pub fn start_detect_mitigation_actions_task(
        &self,
    ) -> fluent_builders::StartDetectMitigationActionsTask<C> {
        fluent_builders::StartDetectMitigationActionsTask::new(self.handle.clone())
    }
    pub fn start_on_demand_audit_task(&self) -> fluent_builders::StartOnDemandAuditTask<C> {
        fluent_builders::StartOnDemandAuditTask::new(self.handle.clone())
    }
    pub fn start_thing_registration_task(&self) -> fluent_builders::StartThingRegistrationTask<C> {
        fluent_builders::StartThingRegistrationTask::new(self.handle.clone())
    }
    pub fn stop_thing_registration_task(&self) -> fluent_builders::StopThingRegistrationTask<C> {
        fluent_builders::StopThingRegistrationTask::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn test_authorization(&self) -> fluent_builders::TestAuthorization<C> {
        fluent_builders::TestAuthorization::new(self.handle.clone())
    }
    pub fn test_invoke_authorizer(&self) -> fluent_builders::TestInvokeAuthorizer<C> {
        fluent_builders::TestInvokeAuthorizer::new(self.handle.clone())
    }
    pub fn transfer_certificate(&self) -> fluent_builders::TransferCertificate<C> {
        fluent_builders::TransferCertificate::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_account_audit_configuration(
        &self,
    ) -> fluent_builders::UpdateAccountAuditConfiguration<C> {
        fluent_builders::UpdateAccountAuditConfiguration::new(self.handle.clone())
    }
    pub fn update_audit_suppression(&self) -> fluent_builders::UpdateAuditSuppression<C> {
        fluent_builders::UpdateAuditSuppression::new(self.handle.clone())
    }
    pub fn update_authorizer(&self) -> fluent_builders::UpdateAuthorizer<C> {
        fluent_builders::UpdateAuthorizer::new(self.handle.clone())
    }
    pub fn update_billing_group(&self) -> fluent_builders::UpdateBillingGroup<C> {
        fluent_builders::UpdateBillingGroup::new(self.handle.clone())
    }
    pub fn update_ca_certificate(&self) -> fluent_builders::UpdateCACertificate<C> {
        fluent_builders::UpdateCACertificate::new(self.handle.clone())
    }
    pub fn update_certificate(&self) -> fluent_builders::UpdateCertificate<C> {
        fluent_builders::UpdateCertificate::new(self.handle.clone())
    }
    pub fn update_custom_metric(&self) -> fluent_builders::UpdateCustomMetric<C> {
        fluent_builders::UpdateCustomMetric::new(self.handle.clone())
    }
    pub fn update_dimension(&self) -> fluent_builders::UpdateDimension<C> {
        fluent_builders::UpdateDimension::new(self.handle.clone())
    }
    pub fn update_domain_configuration(&self) -> fluent_builders::UpdateDomainConfiguration<C> {
        fluent_builders::UpdateDomainConfiguration::new(self.handle.clone())
    }
    pub fn update_dynamic_thing_group(&self) -> fluent_builders::UpdateDynamicThingGroup<C> {
        fluent_builders::UpdateDynamicThingGroup::new(self.handle.clone())
    }
    pub fn update_event_configurations(&self) -> fluent_builders::UpdateEventConfigurations<C> {
        fluent_builders::UpdateEventConfigurations::new(self.handle.clone())
    }
    pub fn update_indexing_configuration(&self) -> fluent_builders::UpdateIndexingConfiguration<C> {
        fluent_builders::UpdateIndexingConfiguration::new(self.handle.clone())
    }
    pub fn update_job(&self) -> fluent_builders::UpdateJob<C> {
        fluent_builders::UpdateJob::new(self.handle.clone())
    }
    pub fn update_mitigation_action(&self) -> fluent_builders::UpdateMitigationAction<C> {
        fluent_builders::UpdateMitigationAction::new(self.handle.clone())
    }
    pub fn update_provisioning_template(&self) -> fluent_builders::UpdateProvisioningTemplate<C> {
        fluent_builders::UpdateProvisioningTemplate::new(self.handle.clone())
    }
    pub fn update_role_alias(&self) -> fluent_builders::UpdateRoleAlias<C> {
        fluent_builders::UpdateRoleAlias::new(self.handle.clone())
    }
    pub fn update_scheduled_audit(&self) -> fluent_builders::UpdateScheduledAudit<C> {
        fluent_builders::UpdateScheduledAudit::new(self.handle.clone())
    }
    pub fn update_security_profile(&self) -> fluent_builders::UpdateSecurityProfile<C> {
        fluent_builders::UpdateSecurityProfile::new(self.handle.clone())
    }
    pub fn update_stream(&self) -> fluent_builders::UpdateStream<C> {
        fluent_builders::UpdateStream::new(self.handle.clone())
    }
    pub fn update_thing(&self) -> fluent_builders::UpdateThing<C> {
        fluent_builders::UpdateThing::new(self.handle.clone())
    }
    pub fn update_thing_group(&self) -> fluent_builders::UpdateThingGroup<C> {
        fluent_builders::UpdateThingGroup::new(self.handle.clone())
    }
    pub fn update_thing_groups_for_thing(&self) -> fluent_builders::UpdateThingGroupsForThing<C> {
        fluent_builders::UpdateThingGroupsForThing::new(self.handle.clone())
    }
    pub fn update_topic_rule_destination(&self) -> fluent_builders::UpdateTopicRuleDestination<C> {
        fluent_builders::UpdateTopicRuleDestination::new(self.handle.clone())
    }
    pub fn validate_security_profile_behaviors(
        &self,
    ) -> fluent_builders::ValidateSecurityProfileBehaviors<C> {
        fluent_builders::ValidateSecurityProfileBehaviors::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcceptCertificateTransfer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_certificate_transfer_input::Builder,
    }
    impl<C> AcceptCertificateTransfer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptCertificateTransferOutput,
            smithy_http::result::SdkError<crate::error::AcceptCertificateTransferError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
        /// certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(input);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
        /// <p>Specifies whether the certificate is active.</p>
        pub fn set_as_active(mut self, input: bool) -> Self {
            self.inner = self.inner.set_as_active(input);
            self
        }
        pub fn set_set_as_active(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_set_as_active(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddThingToBillingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_thing_to_billing_group_input::Builder,
    }
    impl<C> AddThingToBillingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddThingToBillingGroupOutput,
            smithy_http::result::SdkError<crate::error::AddThingToBillingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.billing_group_name(input);
            self
        }
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_name(input);
            self
        }
        /// <p>The ARN of the billing group.</p>
        pub fn billing_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.billing_group_arn(input);
            self
        }
        pub fn set_billing_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_arn(input);
            self
        }
        /// <p>The name of the thing to be added to the billing group.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>The ARN of the thing to be added to the billing group.</p>
        pub fn thing_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_arn(input);
            self
        }
        pub fn set_thing_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddThingToThingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_thing_to_thing_group_input::Builder,
    }
    impl<C> AddThingToThingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddThingToThingGroupOutput,
            smithy_http::result::SdkError<crate::error::AddThingToThingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the group to which you are adding a thing.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_name(input);
            self
        }
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_name(input);
            self
        }
        /// <p>The ARN of the group to which you are adding a thing.</p>
        pub fn thing_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_arn(input);
            self
        }
        pub fn set_thing_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_arn(input);
            self
        }
        /// <p>The name of the thing to add to a group.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>The ARN of the thing to add to a group.</p>
        pub fn thing_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_arn(input);
            self
        }
        pub fn set_thing_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_arn(input);
            self
        }
        /// <p>Override dynamic thing groups with static thing groups when 10-group limit is
        /// reached. If a thing belongs to 10 thing groups, and one or more of those groups are
        /// dynamic thing groups, adding a thing to a static group removes the thing from the last
        /// dynamic group.</p>
        pub fn override_dynamic_groups(mut self, input: bool) -> Self {
            self.inner = self.inner.override_dynamic_groups(input);
            self
        }
        pub fn set_override_dynamic_groups(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_override_dynamic_groups(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateTargetsWithJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_targets_with_job_input::Builder,
    }
    impl<C> AssociateTargetsWithJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateTargetsWithJobOutput,
            smithy_http::result::SdkError<crate::error::AssociateTargetsWithJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of thing group ARNs that define the targets of the job.</p>
        pub fn targets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>An optional comment string describing why the job was associated with the targets.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment(input);
            self
        }
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment(input);
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
        /// contain the value in the following format.</p>
        /// <p>
        /// <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
        /// </p>
        /// <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace_id(input);
            self
        }
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_policy_input::Builder,
    }
    impl<C> AttachPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachPolicyOutput,
            smithy_http::result::SdkError<crate::error::AttachPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the policy to attach.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/iot/latest/developerguide/security-iam.html">identity</a> to which the policy is attached. For example, a thing group or a certificate.</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target(input);
            self
        }
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachPrincipalPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_principal_policy_input::Builder,
    }
    impl<C> AttachPrincipalPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachPrincipalPolicyOutput,
            smithy_http::result::SdkError<crate::error::AttachPrincipalPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate
        /// operation) or an Amazon Cognito ID.</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal(input);
            self
        }
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachSecurityProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_security_profile_input::Builder,
    }
    impl<C> AttachSecurityProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachSecurityProfileOutput,
            smithy_http::result::SdkError<crate::error::AttachSecurityProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The security profile that is attached.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_profile_name(input);
            self
        }
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_name(input);
            self
        }
        /// <p>The ARN of the target (thing group) to which the security profile is attached.</p>
        pub fn security_profile_target_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.security_profile_target_arn(input);
            self
        }
        pub fn set_security_profile_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_target_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachThingPrincipal<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_thing_principal_input::Builder,
    }
    impl<C> AttachThingPrincipal<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachThingPrincipalOutput,
            smithy_http::result::SdkError<crate::error::AttachThingPrincipalError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>The principal, which can be a certificate ARN (as returned from the
        /// CreateCertificate operation) or an Amazon Cognito ID.</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal(input);
            self
        }
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelAuditMitigationActionsTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_audit_mitigation_actions_task_input::Builder,
    }
    impl<C> CancelAuditMitigationActionsTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelAuditMitigationActionsTaskOutput,
            smithy_http::result::SdkError<crate::error::CancelAuditMitigationActionsTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the task that you want to cancel. </p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelAuditTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_audit_task_input::Builder,
    }
    impl<C> CancelAuditTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelAuditTaskOutput,
            smithy_http::result::SdkError<crate::error::CancelAuditTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the audit you want to cancel. You can only cancel an
        /// audit that is "IN_PROGRESS".</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelCertificateTransfer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_certificate_transfer_input::Builder,
    }
    impl<C> CancelCertificateTransfer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelCertificateTransferOutput,
            smithy_http::result::SdkError<crate::error::CancelCertificateTransferError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
        /// certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(input);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelDetectMitigationActionsTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_detect_mitigation_actions_task_input::Builder,
    }
    impl<C> CancelDetectMitigationActionsTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelDetectMitigationActionsTaskOutput,
            smithy_http::result::SdkError<crate::error::CancelDetectMitigationActionsTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The unique identifier of the task.
        /// </p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_job_input::Builder,
    }
    impl<C> CancelJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelJobOutput,
            smithy_http::result::SdkError<crate::error::CancelJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>(Optional)A reason code string that explains why the job was canceled.</p>
        pub fn reason_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason_code(input);
            self
        }
        pub fn set_reason_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason_code(input);
            self
        }
        /// <p>An optional comment string describing why the job was canceled.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment(input);
            self
        }
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment(input);
            self
        }
        /// <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED"
        /// are canceled, otherwise only job executions with status "QUEUED" are canceled. The default
        /// is <code>false</code>.</p>
        /// <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing
        /// the job to be unable to update the job execution status.  Use caution and ensure that each
        /// device executing a job which is canceled is able to recover to a valid state.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelJobExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_job_execution_input::Builder,
    }
    impl<C> CancelJobExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelJobExecutionOutput,
            smithy_http::result::SdkError<crate::error::CancelJobExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the job to be canceled.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The name of the thing whose execution of the job will be canceled.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>(Optional) If <code>true</code> the job execution will be canceled if it has status
        /// IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status
        /// QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set
        /// <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code>
        /// will be thrown. The default is <code>false</code>.</p>
        /// <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable
        /// to update the job execution status.  Use caution and ensure that the device is able to
        /// recover to a valid state.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
        /// <p>(Optional) The expected current version of the job execution. Each time you update the job
        /// execution, its version is incremented. If the version of the job execution stored in Jobs does
        /// not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that
        /// contains the current job execution status data is returned. (This makes it unnecessary to
        /// perform a separate DescribeJobExecution request in order to obtain the job execution status
        /// data.)</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.inner = self.inner.expected_version(input);
            self
        }
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expected_version(input);
            self
        }
        /// <p>A collection of name/value pairs that describe the status of the job execution. If not
        /// specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.</p>
        pub fn status_details(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.status_details(k, v);
            self
        }
        pub fn set_status_details(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_status_details(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ClearDefaultAuthorizer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::clear_default_authorizer_input::Builder,
    }
    impl<C> ClearDefaultAuthorizer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ClearDefaultAuthorizerOutput,
            smithy_http::result::SdkError<crate::error::ClearDefaultAuthorizerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ConfirmTopicRuleDestination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::confirm_topic_rule_destination_input::Builder,
    }
    impl<C> ConfirmTopicRuleDestination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ConfirmTopicRuleDestinationOutput,
            smithy_http::result::SdkError<crate::error::ConfirmTopicRuleDestinationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token used to confirm ownership or access to the topic rule confirmation URL.</p>
        pub fn confirmation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.confirmation_token(input);
            self
        }
        pub fn set_confirmation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_confirmation_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAuditSuppression<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_audit_suppression_input::Builder,
    }
    impl<C> CreateAuditSuppression<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAuditSuppressionOutput,
            smithy_http::result::SdkError<crate::error::CreateAuditSuppressionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An audit check name. Checks must be enabled
        /// for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
        /// of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
        /// to select which checks are enabled.)</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.check_name(input);
            self
        }
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_check_name(input);
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.inner = self.inner.resource_identifier(input);
            self
        }
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.inner = self.inner.set_resource_identifier(input);
            self
        }
        /// <p>
        /// The epoch timestamp in seconds at which this suppression expires.
        /// </p>
        pub fn expiration_date(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.expiration_date(input);
            self
        }
        pub fn set_expiration_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_expiration_date(input);
            self
        }
        /// <p>
        /// Indicates whether a suppression should exist indefinitely or not.
        /// </p>
        pub fn suppress_indefinitely(mut self, input: bool) -> Self {
            self.inner = self.inner.suppress_indefinitely(input);
            self
        }
        pub fn set_suppress_indefinitely(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_suppress_indefinitely(input);
            self
        }
        /// <p>
        /// The description of the audit suppression.
        /// </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>
        /// The epoch timestamp in seconds at which this suppression expires.
        /// </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAuthorizer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_authorizer_input::Builder,
    }
    impl<C> CreateAuthorizer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAuthorizerOutput,
            smithy_http::result::SdkError<crate::error::CreateAuthorizerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The authorizer name.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authorizer_name(input);
            self
        }
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authorizer_name(input);
            self
        }
        /// <p>The ARN of the authorizer's Lambda function.</p>
        pub fn authorizer_function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authorizer_function_arn(input);
            self
        }
        pub fn set_authorizer_function_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authorizer_function_arn(input);
            self
        }
        /// <p>The name of the token key used to extract the token from the HTTP headers.</p>
        pub fn token_key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token_key_name(input);
            self
        }
        pub fn set_token_key_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_token_key_name(input);
            self
        }
        /// <p>The public keys used to verify the digital signature returned by your custom
        /// authentication service.</p>
        pub fn token_signing_public_keys(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.token_signing_public_keys(k, v);
            self
        }
        pub fn set_token_signing_public_keys(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_token_signing_public_keys(input);
            self
        }
        /// <p>The status of the create authorizer request.</p>
        pub fn status(mut self, input: crate::model::AuthorizerStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AuthorizerStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>Metadata which can be used to manage the custom authorizer.</p>
        /// <note>
        /// <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &&tags
        /// "key1=value1&key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags":
        /// "key1=value1&key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Specifies whether AWS IoT validates the token signature in an authorization request.</p>
        pub fn signing_disabled(mut self, input: bool) -> Self {
            self.inner = self.inner.signing_disabled(input);
            self
        }
        pub fn set_signing_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_signing_disabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateBillingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_billing_group_input::Builder,
    }
    impl<C> CreateBillingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateBillingGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateBillingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name you wish to give to the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.billing_group_name(input);
            self
        }
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_name(input);
            self
        }
        /// <p>The properties of the billing group.</p>
        pub fn billing_group_properties(
            mut self,
            input: crate::model::BillingGroupProperties,
        ) -> Self {
            self.inner = self.inner.billing_group_properties(input);
            self
        }
        pub fn set_billing_group_properties(
            mut self,
            input: std::option::Option<crate::model::BillingGroupProperties>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_properties(input);
            self
        }
        /// <p>Metadata which can be used to manage the billing group.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCertificateFromCsr<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_certificate_from_csr_input::Builder,
    }
    impl<C> CreateCertificateFromCsr<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCertificateFromCsrOutput,
            smithy_http::result::SdkError<crate::error::CreateCertificateFromCsrError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The certificate signing request (CSR).</p>
        pub fn certificate_signing_request(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.certificate_signing_request(input);
            self
        }
        pub fn set_certificate_signing_request(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_signing_request(input);
            self
        }
        /// <p>Specifies whether the certificate is active.</p>
        pub fn set_as_active(mut self, input: bool) -> Self {
            self.inner = self.inner.set_as_active(input);
            self
        }
        pub fn set_set_as_active(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_set_as_active(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCustomMetric<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_custom_metric_input::Builder,
    }
    impl<C> CreateCustomMetric<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCustomMetricOutput,
            smithy_http::result::SdkError<crate::error::CreateCustomMetricError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The name of the custom metric. This will be used in the metric report submitted from the device/thing. Shouldn't begin with <code>aws:</code>.
        /// Cannot be updated
        /// once defined.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>
        /// Field
        /// represents a friendly name in the console for the custom metric;
        /// it
        /// doesn't have to be unique. Don't use this name as the metric identifier in
        /// the device metric report. Can be updated once defined.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.display_name(input);
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_display_name(input);
            self
        }
        /// <p>
        /// The type of the custom metric. Types include <code>string-list</code>, <code>ip-address-list</code>, <code>number-list</code>, and <code>number</code>.
        /// </p>
        pub fn metric_type(mut self, input: crate::model::CustomMetricType) -> Self {
            self.inner = self.inner.metric_type(input);
            self
        }
        pub fn set_metric_type(
            mut self,
            input: std::option::Option<crate::model::CustomMetricType>,
        ) -> Self {
            self.inner = self.inner.set_metric_type(input);
            self
        }
        /// <p>
        /// Metadata that can be used to manage the custom metric.
        /// </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Each custom
        /// metric must have a unique client request token. If you try to create a new custom metric that
        /// already exists with a different token,
        /// an exception
        /// occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDimension<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_dimension_input::Builder,
    }
    impl<C> CreateDimension<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDimensionOutput,
            smithy_http::result::SdkError<crate::error::CreateDimensionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies the type of dimension. Supported types: <code>TOPIC_FILTER.</code>
        /// </p>
        pub fn r#type(mut self, input: crate::model::DimensionType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::DimensionType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
        pub fn string_values(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.string_values(inp);
            self
        }
        pub fn set_string_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_string_values(input);
            self
        }
        /// <p>Metadata that can be used to manage the dimension.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Each dimension must have a unique client request token. If you try to create a new dimension with the same token as a dimension that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDomainConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_domain_configuration_input::Builder,
    }
    impl<C> CreateDomainConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDomainConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateDomainConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain configuration. This value must be unique to a region.</p>
        pub fn domain_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_configuration_name(input);
            self
        }
        pub fn set_domain_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_domain_configuration_name(input);
            self
        }
        /// <p>The name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The ARNs of the certificates that AWS IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN.
        /// This value is not required for AWS-managed domains.</p>
        pub fn server_certificate_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_certificate_arns(inp);
            self
        }
        pub fn set_server_certificate_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_server_certificate_arns(input);
            self
        }
        /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority.
        /// This value is not required for AWS-managed domains.</p>
        pub fn validation_certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.validation_certificate_arn(input);
            self
        }
        pub fn set_validation_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_validation_certificate_arn(input);
            self
        }
        /// <p>An object that specifies the authorization service for a domain.</p>
        pub fn authorizer_config(mut self, input: crate::model::AuthorizerConfig) -> Self {
            self.inner = self.inner.authorizer_config(input);
            self
        }
        pub fn set_authorizer_config(
            mut self,
            input: std::option::Option<crate::model::AuthorizerConfig>,
        ) -> Self {
            self.inner = self.inner.set_authorizer_config(input);
            self
        }
        /// <p>The type of service delivered by the endpoint.</p>
        /// <note>
        /// <p>AWS IoT Core currently supports only the <code>DATA</code> service type.</p>
        /// </note>
        pub fn service_type(mut self, input: crate::model::ServiceType) -> Self {
            self.inner = self.inner.service_type(input);
            self
        }
        pub fn set_service_type(
            mut self,
            input: std::option::Option<crate::model::ServiceType>,
        ) -> Self {
            self.inner = self.inner.set_service_type(input);
            self
        }
        /// <p>Metadata which can be used to manage the domain configuration.</p>
        /// <note>
        /// <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &&tags
        /// "key1=value1&key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags":
        /// "key1=value1&key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDynamicThingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_dynamic_thing_group_input::Builder,
    }
    impl<C> CreateDynamicThingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDynamicThingGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateDynamicThingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The dynamic thing group name to create.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_name(input);
            self
        }
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_name(input);
            self
        }
        /// <p>The dynamic thing group properties.</p>
        pub fn thing_group_properties(mut self, input: crate::model::ThingGroupProperties) -> Self {
            self.inner = self.inner.thing_group_properties(input);
            self
        }
        pub fn set_thing_group_properties(
            mut self,
            input: std::option::Option<crate::model::ThingGroupProperties>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_properties(input);
            self
        }
        /// <p>The dynamic thing group index name.</p>
        /// <note>
        /// <p>Currently one index is supported: "AWS_Things".</p>
        /// </note>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>The dynamic thing group search query string.</p>
        /// <p>See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html">Query Syntax</a> for information about query string syntax.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(input);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
        /// <p>The dynamic thing group query version.</p>
        /// <note>
        /// <p>Currently one query version is supported: "2017-09-30". If not specified, the
        /// query version defaults to this value.</p>
        /// </note>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_version(input);
            self
        }
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_version(input);
            self
        }
        /// <p>Metadata which can be used to manage the dynamic thing group.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_job_input::Builder,
    }
    impl<C> CreateJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateJobOutput,
            smithy_http::result::SdkError<crate::error::CreateJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric
        /// characters, "-" and "_" are valid for use here.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>A list of things and thing groups to which the job should be sent.</p>
        pub fn targets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
        /// <p>An S3 link to the job document. Required if you don't specify a value for <code>document</code>.</p>
        /// <note>
        /// <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
        /// <p>The placeholder link is of the following form:</p>
        /// <p>
        /// <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code>
        /// </p>
        /// <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
        /// </note>
        pub fn document_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_source(input);
            self
        }
        pub fn set_document_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_source(input);
            self
        }
        /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
        pub fn document(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document(input);
            self
        }
        pub fn set_document(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_document(input);
            self
        }
        /// <p>A short text description of the job.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Configuration information for pre-signed S3 URLs.</p>
        pub fn presigned_url_config(mut self, input: crate::model::PresignedUrlConfig) -> Self {
            self.inner = self.inner.presigned_url_config(input);
            self
        }
        pub fn set_presigned_url_config(
            mut self,
            input: std::option::Option<crate::model::PresignedUrlConfig>,
        ) -> Self {
            self.inner = self.inner.set_presigned_url_config(input);
            self
        }
        /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things
        /// specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing
        /// when a change is detected in a target. For example, a job will run on a thing when the thing is added to a
        /// target group, even after the job was completed by all things originally in the group.</p>
        pub fn target_selection(mut self, input: crate::model::TargetSelection) -> Self {
            self.inner = self.inner.target_selection(input);
            self
        }
        pub fn set_target_selection(
            mut self,
            input: std::option::Option<crate::model::TargetSelection>,
        ) -> Self {
            self.inner = self.inner.set_target_selection(input);
            self
        }
        /// <p>Allows you to create a staged rollout of the job.</p>
        pub fn job_executions_rollout_config(
            mut self,
            input: crate::model::JobExecutionsRolloutConfig,
        ) -> Self {
            self.inner = self.inner.job_executions_rollout_config(input);
            self
        }
        pub fn set_job_executions_rollout_config(
            mut self,
            input: std::option::Option<crate::model::JobExecutionsRolloutConfig>,
        ) -> Self {
            self.inner = self.inner.set_job_executions_rollout_config(input);
            self
        }
        /// <p>Allows you to create criteria to abort a job.</p>
        pub fn abort_config(mut self, input: crate::model::AbortConfig) -> Self {
            self.inner = self.inner.abort_config(input);
            self
        }
        pub fn set_abort_config(
            mut self,
            input: std::option::Option<crate::model::AbortConfig>,
        ) -> Self {
            self.inner = self.inner.set_abort_config(input);
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer
        /// is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job
        /// execution status is not set to another terminal state before the time expires, it will be
        /// automatically set to <code>TIMED_OUT</code>.</p>
        pub fn timeout_config(mut self, input: crate::model::TimeoutConfig) -> Self {
            self.inner = self.inner.timeout_config(input);
            self
        }
        pub fn set_timeout_config(
            mut self,
            input: std::option::Option<crate::model::TimeoutConfig>,
        ) -> Self {
            self.inner = self.inner.set_timeout_config(input);
            self
        }
        /// <p>Metadata which can be used to manage the job.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
        /// contain the value in the following format.</p>
        /// <p>
        /// <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
        /// </p>
        /// <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace_id(input);
            self
        }
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace_id(input);
            self
        }
        /// <p>The ARN of the job template used to create the job.</p>
        pub fn job_template_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_template_arn(input);
            self
        }
        pub fn set_job_template_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_job_template_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateJobTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_job_template_input::Builder,
    }
    impl<C> CreateJobTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateJobTemplateOutput,
            smithy_http::result::SdkError<crate::error::CreateJobTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the job template. We recommend using a UUID. Alpha-numeric
        /// characters, "-", and "_" are valid for use here.</p>
        pub fn job_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_template_id(input);
            self
        }
        pub fn set_job_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_job_template_id(input);
            self
        }
        /// <p>The ARN of the job to use as the basis for the job template.</p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_arn(input);
            self
        }
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_arn(input);
            self
        }
        /// <p>An S3 link to the job document to use in the template. Required if you don't specify a value for <code>document</code>.</p>
        /// <note>
        /// <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p>
        /// <p>The placeholder link is of the following form:</p>
        /// <p>
        /// <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code>
        /// </p>
        /// <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p>
        /// </note>
        pub fn document_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document_source(input);
            self
        }
        pub fn set_document_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_document_source(input);
            self
        }
        /// <p>The job document. Required if you don't specify a value for <code>documentSource</code>.</p>
        pub fn document(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document(input);
            self
        }
        pub fn set_document(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_document(input);
            self
        }
        /// <p>A description of the job document.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Configuration for pre-signed S3 URLs.</p>
        pub fn presigned_url_config(mut self, input: crate::model::PresignedUrlConfig) -> Self {
            self.inner = self.inner.presigned_url_config(input);
            self
        }
        pub fn set_presigned_url_config(
            mut self,
            input: std::option::Option<crate::model::PresignedUrlConfig>,
        ) -> Self {
            self.inner = self.inner.set_presigned_url_config(input);
            self
        }
        /// <p>Allows you to create a staged rollout of a job.</p>
        pub fn job_executions_rollout_config(
            mut self,
            input: crate::model::JobExecutionsRolloutConfig,
        ) -> Self {
            self.inner = self.inner.job_executions_rollout_config(input);
            self
        }
        pub fn set_job_executions_rollout_config(
            mut self,
            input: std::option::Option<crate::model::JobExecutionsRolloutConfig>,
        ) -> Self {
            self.inner = self.inner.set_job_executions_rollout_config(input);
            self
        }
        /// <p>The criteria that determine when and how a job abort takes place.</p>
        pub fn abort_config(mut self, input: crate::model::AbortConfig) -> Self {
            self.inner = self.inner.abort_config(input);
            self
        }
        pub fn set_abort_config(
            mut self,
            input: std::option::Option<crate::model::AbortConfig>,
        ) -> Self {
            self.inner = self.inner.set_abort_config(input);
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job.  A timer
        /// is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job
        /// execution status is not set to another terminal state before the timer expires, it will
        /// be automatically set to <code>TIMED_OUT</code>.</p>
        pub fn timeout_config(mut self, input: crate::model::TimeoutConfig) -> Self {
            self.inner = self.inner.timeout_config(input);
            self
        }
        pub fn set_timeout_config(
            mut self,
            input: std::option::Option<crate::model::TimeoutConfig>,
        ) -> Self {
            self.inner = self.inner.set_timeout_config(input);
            self
        }
        /// <p>Metadata that can be used to manage the job template.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateKeysAndCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_keys_and_certificate_input::Builder,
    }
    impl<C> CreateKeysAndCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateKeysAndCertificateOutput,
            smithy_http::result::SdkError<crate::error::CreateKeysAndCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies whether the certificate is active.</p>
        pub fn set_as_active(mut self, input: bool) -> Self {
            self.inner = self.inner.set_as_active(input);
            self
        }
        pub fn set_set_as_active(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_set_as_active(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMitigationAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_mitigation_action_input::Builder,
    }
    impl<C> CreateMitigationAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateMitigationActionOutput,
            smithy_http::result::SdkError<crate::error::CreateMitigationActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action_name(input);
            self
        }
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_action_name(input);
            self
        }
        /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>Defines the type of action and the parameters for that action.</p>
        pub fn action_params(mut self, input: crate::model::MitigationActionParams) -> Self {
            self.inner = self.inner.action_params(input);
            self
        }
        pub fn set_action_params(
            mut self,
            input: std::option::Option<crate::model::MitigationActionParams>,
        ) -> Self {
            self.inner = self.inner.set_action_params(input);
            self
        }
        /// <p>Metadata that can be used to manage the mitigation action.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateOTAUpdate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_ota_update_input::Builder,
    }
    impl<C> CreateOTAUpdate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateOtaUpdateOutput,
            smithy_http::result::SdkError<crate::error::CreateOTAUpdateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the OTA update to be created.</p>
        pub fn ota_update_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ota_update_id(input);
            self
        }
        pub fn set_ota_update_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ota_update_id(input);
            self
        }
        /// <p>The description of the OTA update.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The devices targeted to receive OTA updates.</p>
        pub fn targets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
        /// <p>The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both
        /// HTTP and MQTT are specified, the target device can choose the protocol.</p>
        pub fn protocols(mut self, inp: impl Into<crate::model::Protocol>) -> Self {
            self.inner = self.inner.protocols(inp);
            self
        }
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
        ) -> Self {
            self.inner = self.inner.set_protocols(input);
            self
        }
        /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things
        /// specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a
        /// thing when a change is detected in a target. For example, an update will run on a thing when the thing is
        /// added to a target group, even after the update was completed by all things originally in the group. Valid
        /// values: CONTINUOUS | SNAPSHOT.</p>
        pub fn target_selection(mut self, input: crate::model::TargetSelection) -> Self {
            self.inner = self.inner.target_selection(input);
            self
        }
        pub fn set_target_selection(
            mut self,
            input: std::option::Option<crate::model::TargetSelection>,
        ) -> Self {
            self.inner = self.inner.set_target_selection(input);
            self
        }
        /// <p>Configuration for the rollout of OTA updates.</p>
        pub fn aws_job_executions_rollout_config(
            mut self,
            input: crate::model::AwsJobExecutionsRolloutConfig,
        ) -> Self {
            self.inner = self.inner.aws_job_executions_rollout_config(input);
            self
        }
        pub fn set_aws_job_executions_rollout_config(
            mut self,
            input: std::option::Option<crate::model::AwsJobExecutionsRolloutConfig>,
        ) -> Self {
            self.inner = self.inner.set_aws_job_executions_rollout_config(input);
            self
        }
        /// <p>Configuration information for pre-signed URLs.</p>
        pub fn aws_job_presigned_url_config(
            mut self,
            input: crate::model::AwsJobPresignedUrlConfig,
        ) -> Self {
            self.inner = self.inner.aws_job_presigned_url_config(input);
            self
        }
        pub fn set_aws_job_presigned_url_config(
            mut self,
            input: std::option::Option<crate::model::AwsJobPresignedUrlConfig>,
        ) -> Self {
            self.inner = self.inner.set_aws_job_presigned_url_config(input);
            self
        }
        /// <p>The criteria that determine when and how a job abort takes place.</p>
        pub fn aws_job_abort_config(mut self, input: crate::model::AwsJobAbortConfig) -> Self {
            self.inner = self.inner.aws_job_abort_config(input);
            self
        }
        pub fn set_aws_job_abort_config(
            mut self,
            input: std::option::Option<crate::model::AwsJobAbortConfig>,
        ) -> Self {
            self.inner = self.inner.set_aws_job_abort_config(input);
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job.  A timer is
        /// started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution
        /// status is not set to another terminal state before the timer expires, it will be automatically
        /// set to <code>TIMED_OUT</code>.</p>
        pub fn aws_job_timeout_config(mut self, input: crate::model::AwsJobTimeoutConfig) -> Self {
            self.inner = self.inner.aws_job_timeout_config(input);
            self
        }
        pub fn set_aws_job_timeout_config(
            mut self,
            input: std::option::Option<crate::model::AwsJobTimeoutConfig>,
        ) -> Self {
            self.inner = self.inner.set_aws_job_timeout_config(input);
            self
        }
        /// <p>The files to be streamed by the OTA update.</p>
        pub fn files(mut self, inp: impl Into<crate::model::OtaUpdateFile>) -> Self {
            self.inner = self.inner.files(inp);
            self
        }
        pub fn set_files(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OtaUpdateFile>>,
        ) -> Self {
            self.inner = self.inner.set_files(input);
            self
        }
        /// <p>The IAM role that grants AWS IoT access to the Amazon S3, AWS IoT jobs and AWS Code Signing resources
        /// to create an OTA update job.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>A list of additional OTA update parameters which are name-value pairs.</p>
        pub fn additional_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.additional_parameters(k, v);
            self
        }
        pub fn set_additional_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_additional_parameters(input);
            self
        }
        /// <p>Metadata which can be used to manage updates.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_policy_input::Builder,
    }
    impl<C> CreatePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePolicyOutput,
            smithy_http::result::SdkError<crate::error::CreatePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The JSON document that describes the policy. <b>policyDocument</b> must have a minimum length of 1, with a maximum length of
        /// 2048, excluding whitespace.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(input);
            self
        }
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(input);
            self
        }
        /// <p>Metadata which can be used to manage the policy.</p>
        /// <note>
        /// <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &&tags
        /// "key1=value1&key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags":
        /// "key1=value1&key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePolicyVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_policy_version_input::Builder,
    }
    impl<C> CreatePolicyVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePolicyVersionOutput,
            smithy_http::result::SdkError<crate::error::CreatePolicyVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The JSON document that describes the policy. Minimum length of 1. Maximum length of
        /// 2048, excluding whitespace.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(input);
            self
        }
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(input);
            self
        }
        /// <p>Specifies whether the policy version is set as the default. When this parameter is
        /// true, the new policy version becomes the operative version (that is, the version that is in
        /// effect for the certificates to which the policy is attached).</p>
        pub fn set_as_default(mut self, input: bool) -> Self {
            self.inner = self.inner.set_as_default(input);
            self
        }
        pub fn set_set_as_default(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_set_as_default(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateProvisioningClaim<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_provisioning_claim_input::Builder,
    }
    impl<C> CreateProvisioningClaim<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateProvisioningClaimOutput,
            smithy_http::result::SdkError<crate::error::CreateProvisioningClaimError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the provisioning template to use.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateProvisioningTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_provisioning_template_input::Builder,
    }
    impl<C> CreateProvisioningTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateProvisioningTemplateOutput,
            smithy_http::result::SdkError<crate::error::CreateProvisioningTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the fleet provisioning template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
        /// <p>The description of the fleet provisioning template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The JSON formatted contents of the fleet provisioning template.</p>
        pub fn template_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_body(input);
            self
        }
        pub fn set_template_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_body(input);
            self
        }
        /// <p>True to enable the fleet provisioning template, otherwise false.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enabled(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(input);
            self
        }
        /// <p>The role ARN for the role associated with the fleet provisioning template. This IoT role
        /// grants permission to provision a device.</p>
        pub fn provisioning_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.provisioning_role_arn(input);
            self
        }
        pub fn set_provisioning_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_provisioning_role_arn(input);
            self
        }
        /// <p>Creates a pre-provisioning hook template.</p>
        pub fn pre_provisioning_hook(mut self, input: crate::model::ProvisioningHook) -> Self {
            self.inner = self.inner.pre_provisioning_hook(input);
            self
        }
        pub fn set_pre_provisioning_hook(
            mut self,
            input: std::option::Option<crate::model::ProvisioningHook>,
        ) -> Self {
            self.inner = self.inner.set_pre_provisioning_hook(input);
            self
        }
        /// <p>Metadata which can be used to manage the fleet provisioning template.</p>
        /// <note>
        /// <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &&tags
        /// "key1=value1&key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags":
        /// "key1=value1&key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateProvisioningTemplateVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_provisioning_template_version_input::Builder,
    }
    impl<C> CreateProvisioningTemplateVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateProvisioningTemplateVersionOutput,
            smithy_http::result::SdkError<crate::error::CreateProvisioningTemplateVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the fleet provisioning template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
        /// <p>The JSON formatted contents of the fleet provisioning template.</p>
        pub fn template_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_body(input);
            self
        }
        pub fn set_template_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_body(input);
            self
        }
        /// <p>Sets a fleet provision template version as the default version.</p>
        pub fn set_as_default(mut self, input: bool) -> Self {
            self.inner = self.inner.set_as_default(input);
            self
        }
        pub fn set_set_as_default(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_set_as_default(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRoleAlias<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_role_alias_input::Builder,
    }
    impl<C> CreateRoleAlias<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRoleAliasOutput,
            smithy_http::result::SdkError<crate::error::CreateRoleAliasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The role alias that points to a role ARN. This allows you to change the role without
        /// having to update the device.</p>
        pub fn role_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_alias(input);
            self
        }
        pub fn set_role_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_alias(input);
            self
        }
        /// <p>The role ARN.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>How long (in seconds) the credentials will be valid.</p>
        pub fn credential_duration_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.credential_duration_seconds(input);
            self
        }
        pub fn set_credential_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_credential_duration_seconds(input);
            self
        }
        /// <p>Metadata which can be used to manage the role alias.</p>
        /// <note>
        /// <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &&tags
        /// "key1=value1&key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags":
        /// "key1=value1&key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateScheduledAudit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_scheduled_audit_input::Builder,
    }
    impl<C> CreateScheduledAudit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateScheduledAuditOutput,
            smithy_http::result::SdkError<crate::error::CreateScheduledAuditError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>How often the scheduled audit takes
        /// place, either
        /// <code>DAILY</code>,
        /// <code>WEEKLY</code>, <code>BIWEEKLY</code> or <code>MONTHLY</code>. The start time of each audit is
        /// determined by the system.</p>
        pub fn frequency(mut self, input: crate::model::AuditFrequency) -> Self {
            self.inner = self.inner.frequency(input);
            self
        }
        pub fn set_frequency(
            mut self,
            input: std::option::Option<crate::model::AuditFrequency>,
        ) -> Self {
            self.inner = self.inner.set_frequency(input);
            self
        }
        /// <p>The day of the month on which the scheduled audit takes place.
        /// This
        /// can be "1" through "31" or "LAST". This field is required if the "frequency"
        /// parameter is set to <code>MONTHLY</code>. If days
        /// 29
        /// to 31 are specified, and the month
        /// doesn't
        /// have that many days, the audit takes place on the <code>LAST</code> day of the month.</p>
        pub fn day_of_month(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.day_of_month(input);
            self
        }
        pub fn set_day_of_month(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_day_of_month(input);
            self
        }
        /// <p>The day of the week on which the scheduled audit takes
        /// place,
        /// either
        /// <code>SUN</code>,
        /// <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the <code>frequency</code>
        /// parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
        pub fn day_of_week(mut self, input: crate::model::DayOfWeek) -> Self {
            self.inner = self.inner.day_of_week(input);
            self
        }
        pub fn set_day_of_week(
            mut self,
            input: std::option::Option<crate::model::DayOfWeek>,
        ) -> Self {
            self.inner = self.inner.set_day_of_week(input);
            self
        }
        /// <p>Which checks are performed during the scheduled audit. Checks must be enabled
        /// for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
        /// of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
        /// to select which checks are enabled.)</p>
        pub fn target_check_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_check_names(inp);
            self
        }
        pub fn set_target_check_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_target_check_names(input);
            self
        }
        /// <p>The name you want to give to the scheduled audit. (Max. 128 chars)</p>
        pub fn scheduled_audit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_audit_name(input);
            self
        }
        pub fn set_scheduled_audit_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_audit_name(input);
            self
        }
        /// <p>Metadata that can be used to manage the scheduled audit.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSecurityProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_security_profile_input::Builder,
    }
    impl<C> CreateSecurityProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSecurityProfileOutput,
            smithy_http::result::SdkError<crate::error::CreateSecurityProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name you are giving to the security profile.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_profile_name(input);
            self
        }
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_name(input);
            self
        }
        /// <p>A description of the security profile.</p>
        pub fn security_profile_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.security_profile_description(input);
            self
        }
        pub fn set_security_profile_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_description(input);
            self
        }
        /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
        pub fn behaviors(mut self, inp: impl Into<crate::model::Behavior>) -> Self {
            self.inner = self.inner.behaviors(inp);
            self
        }
        pub fn set_behaviors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
        ) -> Self {
            self.inner = self.inner.set_behaviors(input);
            self
        }
        /// <p>Specifies the destinations to which alerts are sent. (Alerts are always sent to the
        /// console.) Alerts are generated when a device (thing) violates a behavior.</p>
        pub fn alert_targets(
            mut self,
            k: impl Into<crate::model::AlertTargetType>,
            v: impl Into<crate::model::AlertTarget>,
        ) -> Self {
            self.inner = self.inner.alert_targets(k, v);
            self
        }
        pub fn set_alert_targets(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::AlertTargetType, crate::model::AlertTarget>,
            >,
        ) -> Self {
            self.inner = self.inner.set_alert_targets(input);
            self
        }
        /// <p>
        /// <i>Please use <a>CreateSecurityProfileRequest$additionalMetricsToRetainV2</a> instead.</i>
        /// </p>
        /// <p>A list of metrics whose data is retained (stored). By default, data is retained
        /// for any metric used in the profile's <code>behaviors</code>, but it is also retained for
        /// any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn additional_metrics_to_retain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.additional_metrics_to_retain(inp);
            self
        }
        pub fn set_additional_metrics_to_retain(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_additional_metrics_to_retain(input);
            self
        }
        /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn additional_metrics_to_retain_v2(
            mut self,
            inp: impl Into<crate::model::MetricToRetain>,
        ) -> Self {
            self.inner = self.inner.additional_metrics_to_retain_v2(inp);
            self
        }
        pub fn set_additional_metrics_to_retain_v2(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricToRetain>>,
        ) -> Self {
            self.inner = self.inner.set_additional_metrics_to_retain_v2(input);
            self
        }
        /// <p>Metadata that can be used to manage the security profile.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_stream_input::Builder,
    }
    impl<C> CreateStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_id(input);
            self
        }
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_id(input);
            self
        }
        /// <p>A description of the stream.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The files to stream.</p>
        pub fn files(mut self, inp: impl Into<crate::model::StreamFile>) -> Self {
            self.inner = self.inner.files(inp);
            self
        }
        pub fn set_files(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamFile>>,
        ) -> Self {
            self.inner = self.inner.set_files(input);
            self
        }
        /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>Metadata which can be used to manage streams.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateThing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_thing_input::Builder,
    }
    impl<C> CreateThing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateThingOutput,
            smithy_http::result::SdkError<crate::error::CreateThingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing to create.</p>
        /// <p>You can't change a thing's name after you create it. To change a thing's name, you must create a
        /// new thing, give it the new name, and then delete the old thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>The name of the thing type associated with the new thing.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_type_name(input);
            self
        }
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_type_name(input);
            self
        }
        /// <p>The attribute payload, which consists of up to three name/value pairs in a JSON
        /// document. For example:</p>
        /// <p>
        /// <code>{\"attributes\":{\"string1\":\"string2\"}}</code>
        /// </p>
        pub fn attribute_payload(mut self, input: crate::model::AttributePayload) -> Self {
            self.inner = self.inner.attribute_payload(input);
            self
        }
        pub fn set_attribute_payload(
            mut self,
            input: std::option::Option<crate::model::AttributePayload>,
        ) -> Self {
            self.inner = self.inner.set_attribute_payload(input);
            self
        }
        /// <p>The name of the billing group the thing will be added to.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.billing_group_name(input);
            self
        }
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateThingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_thing_group_input::Builder,
    }
    impl<C> CreateThingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateThingGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateThingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The thing group name to create.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_name(input);
            self
        }
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_name(input);
            self
        }
        /// <p>The name of the parent thing group.</p>
        pub fn parent_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parent_group_name(input);
            self
        }
        pub fn set_parent_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_parent_group_name(input);
            self
        }
        /// <p>The thing group properties.</p>
        pub fn thing_group_properties(mut self, input: crate::model::ThingGroupProperties) -> Self {
            self.inner = self.inner.thing_group_properties(input);
            self
        }
        pub fn set_thing_group_properties(
            mut self,
            input: std::option::Option<crate::model::ThingGroupProperties>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_properties(input);
            self
        }
        /// <p>Metadata which can be used to manage the thing group.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateThingType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_thing_type_input::Builder,
    }
    impl<C> CreateThingType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateThingTypeOutput,
            smithy_http::result::SdkError<crate::error::CreateThingTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing type.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_type_name(input);
            self
        }
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_type_name(input);
            self
        }
        /// <p>The ThingTypeProperties for the thing type to create. It contains information about
        /// the new thing type including a description, and a list of searchable thing attribute
        /// names.</p>
        pub fn thing_type_properties(mut self, input: crate::model::ThingTypeProperties) -> Self {
            self.inner = self.inner.thing_type_properties(input);
            self
        }
        pub fn set_thing_type_properties(
            mut self,
            input: std::option::Option<crate::model::ThingTypeProperties>,
        ) -> Self {
            self.inner = self.inner.set_thing_type_properties(input);
            self
        }
        /// <p>Metadata which can be used to manage the thing type.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTopicRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_topic_rule_input::Builder,
    }
    impl<C> CreateTopicRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTopicRuleOutput,
            smithy_http::result::SdkError<crate::error::CreateTopicRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
        /// <p>The rule payload.</p>
        pub fn topic_rule_payload(mut self, input: crate::model::TopicRulePayload) -> Self {
            self.inner = self.inner.topic_rule_payload(input);
            self
        }
        pub fn set_topic_rule_payload(
            mut self,
            input: std::option::Option<crate::model::TopicRulePayload>,
        ) -> Self {
            self.inner = self.inner.set_topic_rule_payload(input);
            self
        }
        /// <p>Metadata which can be used to manage the topic rule.</p>
        /// <note>
        /// <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: --tags
        /// "key1=value1&key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags":
        /// "key1=value1&key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tags(input);
            self
        }
        pub fn set_tags(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTopicRuleDestination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_topic_rule_destination_input::Builder,
    }
    impl<C> CreateTopicRuleDestination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTopicRuleDestinationOutput,
            smithy_http::result::SdkError<crate::error::CreateTopicRuleDestinationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The topic rule destination configuration.</p>
        pub fn destination_configuration(
            mut self,
            input: crate::model::TopicRuleDestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.destination_configuration(input);
            self
        }
        pub fn set_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::TopicRuleDestinationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_destination_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccountAuditConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_account_audit_configuration_input::Builder,
    }
    impl<C> DeleteAccountAuditConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAccountAuditConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteAccountAuditConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If true, all scheduled audits are deleted.</p>
        pub fn delete_scheduled_audits(mut self, input: bool) -> Self {
            self.inner = self.inner.delete_scheduled_audits(input);
            self
        }
        pub fn set_delete_scheduled_audits(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_delete_scheduled_audits(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAuditSuppression<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_audit_suppression_input::Builder,
    }
    impl<C> DeleteAuditSuppression<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAuditSuppressionOutput,
            smithy_http::result::SdkError<crate::error::DeleteAuditSuppressionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An audit check name. Checks must be enabled
        /// for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
        /// of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
        /// to select which checks are enabled.)</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.check_name(input);
            self
        }
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_check_name(input);
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.inner = self.inner.resource_identifier(input);
            self
        }
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.inner = self.inner.set_resource_identifier(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAuthorizer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_authorizer_input::Builder,
    }
    impl<C> DeleteAuthorizer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAuthorizerOutput,
            smithy_http::result::SdkError<crate::error::DeleteAuthorizerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the authorizer to delete.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authorizer_name(input);
            self
        }
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authorizer_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBillingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_billing_group_input::Builder,
    }
    impl<C> DeleteBillingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBillingGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteBillingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.billing_group_name(input);
            self
        }
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_name(input);
            self
        }
        /// <p>The expected version of the billing group. If the version of the billing group does
        /// not match the expected version specified in the request, the
        /// <code>DeleteBillingGroup</code> request is rejected with a
        /// <code>VersionConflictException</code>.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.inner = self.inner.expected_version(input);
            self
        }
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expected_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCACertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_ca_certificate_input::Builder,
    }
    impl<C> DeleteCACertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCaCertificateOutput,
            smithy_http::result::SdkError<crate::error::DeleteCACertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the certificate to delete. (The last part of the certificate ARN contains
        /// the certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(input);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_certificate_input::Builder,
    }
    impl<C> DeleteCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCertificateOutput,
            smithy_http::result::SdkError<crate::error::DeleteCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
        /// certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(input);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
        /// <p>Forces the deletion of a certificate if it is inactive and is not attached to an IoT
        /// thing.</p>
        pub fn force_delete(mut self, input: bool) -> Self {
            self.inner = self.inner.force_delete(input);
            self
        }
        pub fn set_force_delete(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_delete(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCustomMetric<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_custom_metric_input::Builder,
    }
    impl<C> DeleteCustomMetric<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCustomMetricOutput,
            smithy_http::result::SdkError<crate::error::DeleteCustomMetricError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the custom metric.
        /// </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDimension<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_dimension_input::Builder,
    }
    impl<C> DeleteDimension<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDimensionOutput,
            smithy_http::result::SdkError<crate::error::DeleteDimensionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the dimension that you want to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDomainConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_domain_configuration_input::Builder,
    }
    impl<C> DeleteDomainConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDomainConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteDomainConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain configuration to be deleted.</p>
        pub fn domain_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_configuration_name(input);
            self
        }
        pub fn set_domain_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_domain_configuration_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDynamicThingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_dynamic_thing_group_input::Builder,
    }
    impl<C> DeleteDynamicThingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDynamicThingGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteDynamicThingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the dynamic thing group to delete.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_name(input);
            self
        }
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_name(input);
            self
        }
        /// <p>The expected version of the dynamic thing group to delete.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.inner = self.inner.expected_version(input);
            self
        }
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expected_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_job_input::Builder,
    }
    impl<C> DeleteJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteJobOutput,
            smithy_http::result::SdkError<crate::error::DeleteJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the job to be deleted.</p>
        /// <p>After a job deletion is completed, you may reuse this jobId when you create a new job.
        /// However, this is not recommended, and you must ensure that your devices are not using the
        /// jobId to refer to the deleted job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can
        /// only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception
        /// will occur. The default is false.</p>
        /// <note>
        /// <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing
        /// the job to be unable to access job information or update the job execution status.
        /// Use caution and ensure that each device executing a job which is deleted is able to recover to
        /// a valid state.</p>
        /// </note>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
        /// contain the value in the following format.</p>
        /// <p>
        /// <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
        /// </p>
        /// <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace_id(input);
            self
        }
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteJobExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_job_execution_input::Builder,
    }
    impl<C> DeleteJobExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteJobExecutionOutput,
            smithy_http::result::SdkError<crate::error::DeleteJobExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the job whose execution on a particular device will be deleted.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The name of the thing whose job execution will be deleted.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the
        /// execution of a particular job on a particular device.</p>
        /// <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused
        /// by IoT, so be sure you get and use the correct value here.</p>
        pub fn execution_number(mut self, input: i64) -> Self {
            self.inner = self.inner.execution_number(input);
            self
        }
        pub fn set_execution_number(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_execution_number(input);
            self
        }
        /// <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise,
        /// you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED",
        /// "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p>
        /// <note>
        /// <p>Deleting a job execution which is "IN_PROGRESS", will cause the device
        /// to be unable to access job information or update the job execution status.
        /// Use caution and ensure that the device is able to recover to a valid state.</p>
        /// </note>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
        /// contain the value in the following format.</p>
        /// <p>
        /// <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
        /// </p>
        /// <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace_id(input);
            self
        }
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteJobTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_job_template_input::Builder,
    }
    impl<C> DeleteJobTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteJobTemplateOutput,
            smithy_http::result::SdkError<crate::error::DeleteJobTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the job template to delete.</p>
        pub fn job_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_template_id(input);
            self
        }
        pub fn set_job_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_job_template_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMitigationAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_mitigation_action_input::Builder,
    }
    impl<C> DeleteMitigationAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMitigationActionOutput,
            smithy_http::result::SdkError<crate::error::DeleteMitigationActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the mitigation action that you want to delete.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action_name(input);
            self
        }
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_action_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteOTAUpdate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_ota_update_input::Builder,
    }
    impl<C> DeleteOTAUpdate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteOtaUpdateOutput,
            smithy_http::result::SdkError<crate::error::DeleteOTAUpdateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the OTA update to delete.</p>
        pub fn ota_update_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ota_update_id(input);
            self
        }
        pub fn set_ota_update_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ota_update_id(input);
            self
        }
        /// <p>When true, the stream created by the OTAUpdate process is deleted when the OTA update is deleted.
        /// Ignored if the stream specified in the OTAUpdate is supplied by the user.</p>
        pub fn delete_stream(mut self, input: bool) -> Self {
            self.inner = self.inner.delete_stream(input);
            self
        }
        pub fn set_delete_stream(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_delete_stream(input);
            self
        }
        /// <p>When true, deletes the AWS job created by the OTAUpdate process even if it is "IN_PROGRESS". Otherwise, if the
        /// job is not in a terminal state ("COMPLETED" or "CANCELED") an exception will occur. The default is false.</p>
        pub fn force_delete_aws_job(mut self, input: bool) -> Self {
            self.inner = self.inner.force_delete_aws_job(input);
            self
        }
        pub fn set_force_delete_aws_job(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_delete_aws_job(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_policy_input::Builder,
    }
    impl<C> DeletePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeletePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the policy to delete.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePolicyVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_policy_version_input::Builder,
    }
    impl<C> DeletePolicyVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePolicyVersionOutput,
            smithy_http::result::SdkError<crate::error::DeletePolicyVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The policy version ID.</p>
        pub fn policy_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_version_id(input);
            self
        }
        pub fn set_policy_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteProvisioningTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_provisioning_template_input::Builder,
    }
    impl<C> DeleteProvisioningTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteProvisioningTemplateOutput,
            smithy_http::result::SdkError<crate::error::DeleteProvisioningTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the fleet provision template to delete.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteProvisioningTemplateVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_provisioning_template_version_input::Builder,
    }
    impl<C> DeleteProvisioningTemplateVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteProvisioningTemplateVersionOutput,
            smithy_http::result::SdkError<crate::error::DeleteProvisioningTemplateVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the fleet provisioning template version to delete.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
        /// <p>The fleet provisioning template version ID to delete.</p>
        pub fn version_id(mut self, input: i32) -> Self {
            self.inner = self.inner.version_id(input);
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRegistrationCode<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_registration_code_input::Builder,
    }
    impl<C> DeleteRegistrationCode<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRegistrationCodeOutput,
            smithy_http::result::SdkError<crate::error::DeleteRegistrationCodeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRoleAlias<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_role_alias_input::Builder,
    }
    impl<C> DeleteRoleAlias<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRoleAliasOutput,
            smithy_http::result::SdkError<crate::error::DeleteRoleAliasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The role alias to delete.</p>
        pub fn role_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_alias(input);
            self
        }
        pub fn set_role_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_alias(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteScheduledAudit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_scheduled_audit_input::Builder,
    }
    impl<C> DeleteScheduledAudit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteScheduledAuditOutput,
            smithy_http::result::SdkError<crate::error::DeleteScheduledAuditError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the scheduled audit you want to delete.</p>
        pub fn scheduled_audit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_audit_name(input);
            self
        }
        pub fn set_scheduled_audit_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_audit_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSecurityProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_security_profile_input::Builder,
    }
    impl<C> DeleteSecurityProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSecurityProfileOutput,
            smithy_http::result::SdkError<crate::error::DeleteSecurityProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the security profile to be deleted.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_profile_name(input);
            self
        }
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_name(input);
            self
        }
        /// <p>The expected version of the security profile. A new version is generated whenever
        /// the security profile is updated. If you specify a value that is different from the actual
        /// version, a <code>VersionConflictException</code> is thrown.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.inner = self.inner.expected_version(input);
            self
        }
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expected_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_stream_input::Builder,
    }
    impl<C> DeleteStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStreamOutput,
            smithy_http::result::SdkError<crate::error::DeleteStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_id(input);
            self
        }
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteThing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_thing_input::Builder,
    }
    impl<C> DeleteThing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteThingOutput,
            smithy_http::result::SdkError<crate::error::DeleteThingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing to delete.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>The expected version of the thing record in the registry. If the version of the
        /// record in the registry does not match the expected version specified in the request, the
        /// <code>DeleteThing</code> request is rejected with a
        /// <code>VersionConflictException</code>.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.inner = self.inner.expected_version(input);
            self
        }
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expected_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteThingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_thing_group_input::Builder,
    }
    impl<C> DeleteThingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteThingGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteThingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing group to delete.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_name(input);
            self
        }
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_name(input);
            self
        }
        /// <p>The expected version of the thing group to delete.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.inner = self.inner.expected_version(input);
            self
        }
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expected_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteThingType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_thing_type_input::Builder,
    }
    impl<C> DeleteThingType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteThingTypeOutput,
            smithy_http::result::SdkError<crate::error::DeleteThingTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing type.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_type_name(input);
            self
        }
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_type_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTopicRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_topic_rule_input::Builder,
    }
    impl<C> DeleteTopicRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTopicRuleOutput,
            smithy_http::result::SdkError<crate::error::DeleteTopicRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTopicRuleDestination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_topic_rule_destination_input::Builder,
    }
    impl<C> DeleteTopicRuleDestination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTopicRuleDestinationOutput,
            smithy_http::result::SdkError<crate::error::DeleteTopicRuleDestinationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic rule destination to delete.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteV2LoggingLevel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_v2_logging_level_input::Builder,
    }
    impl<C> DeleteV2LoggingLevel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteV2LoggingLevelOutput,
            smithy_http::result::SdkError<crate::error::DeleteV2LoggingLevelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of resource for which you are configuring logging. Must be
        /// <code>THING_Group</code>.</p>
        pub fn target_type(mut self, input: crate::model::LogTargetType) -> Self {
            self.inner = self.inner.target_type(input);
            self
        }
        pub fn set_target_type(
            mut self,
            input: std::option::Option<crate::model::LogTargetType>,
        ) -> Self {
            self.inner = self.inner.set_target_type(input);
            self
        }
        /// <p>The name of the resource for which you are configuring logging.</p>
        pub fn target_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_name(input);
            self
        }
        pub fn set_target_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeprecateThingType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deprecate_thing_type_input::Builder,
    }
    impl<C> DeprecateThingType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeprecateThingTypeOutput,
            smithy_http::result::SdkError<crate::error::DeprecateThingTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing type to deprecate.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_type_name(input);
            self
        }
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_type_name(input);
            self
        }
        /// <p>Whether to undeprecate a deprecated thing type. If <b>true</b>, the thing type will not be deprecated anymore and you can
        /// associate it with things.</p>
        pub fn undo_deprecate(mut self, input: bool) -> Self {
            self.inner = self.inner.undo_deprecate(input);
            self
        }
        pub fn set_undo_deprecate(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_undo_deprecate(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAccountAuditConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_account_audit_configuration_input::Builder,
    }
    impl<C> DescribeAccountAuditConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAccountAuditConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DescribeAccountAuditConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAuditFinding<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_audit_finding_input::Builder,
    }
    impl<C> DescribeAuditFinding<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAuditFindingOutput,
            smithy_http::result::SdkError<crate::error::DescribeAuditFindingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.</p>
        pub fn finding_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.finding_id(input);
            self
        }
        pub fn set_finding_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_finding_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAuditMitigationActionsTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_audit_mitigation_actions_task_input::Builder,
    }
    impl<C> DescribeAuditMitigationActionsTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAuditMitigationActionsTaskOutput,
            smithy_http::result::SdkError<crate::error::DescribeAuditMitigationActionsTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the audit mitigation task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAuditSuppression<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_audit_suppression_input::Builder,
    }
    impl<C> DescribeAuditSuppression<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAuditSuppressionOutput,
            smithy_http::result::SdkError<crate::error::DescribeAuditSuppressionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An audit check name. Checks must be enabled
        /// for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
        /// of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
        /// to select which checks are enabled.)</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.check_name(input);
            self
        }
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_check_name(input);
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.inner = self.inner.resource_identifier(input);
            self
        }
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.inner = self.inner.set_resource_identifier(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAuditTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_audit_task_input::Builder,
    }
    impl<C> DescribeAuditTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAuditTaskOutput,
            smithy_http::result::SdkError<crate::error::DescribeAuditTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the audit whose information you want to get.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAuthorizer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_authorizer_input::Builder,
    }
    impl<C> DescribeAuthorizer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAuthorizerOutput,
            smithy_http::result::SdkError<crate::error::DescribeAuthorizerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the authorizer to describe.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authorizer_name(input);
            self
        }
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authorizer_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBillingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_billing_group_input::Builder,
    }
    impl<C> DescribeBillingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBillingGroupOutput,
            smithy_http::result::SdkError<crate::error::DescribeBillingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.billing_group_name(input);
            self
        }
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCACertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_ca_certificate_input::Builder,
    }
    impl<C> DescribeCACertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCaCertificateOutput,
            smithy_http::result::SdkError<crate::error::DescribeCACertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The CA certificate identifier.</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(input);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_certificate_input::Builder,
    }
    impl<C> DescribeCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCertificateOutput,
            smithy_http::result::SdkError<crate::error::DescribeCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
        /// certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(input);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCustomMetric<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_custom_metric_input::Builder,
    }
    impl<C> DescribeCustomMetric<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCustomMetricOutput,
            smithy_http::result::SdkError<crate::error::DescribeCustomMetricError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the custom metric.
        /// </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDefaultAuthorizer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_default_authorizer_input::Builder,
    }
    impl<C> DescribeDefaultAuthorizer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDefaultAuthorizerOutput,
            smithy_http::result::SdkError<crate::error::DescribeDefaultAuthorizerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDetectMitigationActionsTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_detect_mitigation_actions_task_input::Builder,
    }
    impl<C> DescribeDetectMitigationActionsTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDetectMitigationActionsTaskOutput,
            smithy_http::result::SdkError<crate::error::DescribeDetectMitigationActionsTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The unique identifier of the task.
        /// </p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDimension<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_dimension_input::Builder,
    }
    impl<C> DescribeDimension<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDimensionOutput,
            smithy_http::result::SdkError<crate::error::DescribeDimensionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the dimension.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDomainConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_domain_configuration_input::Builder,
    }
    impl<C> DescribeDomainConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDomainConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DescribeDomainConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain configuration.</p>
        pub fn domain_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_configuration_name(input);
            self
        }
        pub fn set_domain_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_domain_configuration_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_endpoint_input::Builder,
    }
    impl<C> DescribeEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEndpointOutput,
            smithy_http::result::SdkError<crate::error::DescribeEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The endpoint type. Valid endpoint types include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p>
        /// </li>
        /// </ul>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p>
        /// </li>
        /// </ul>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API
        /// endpoint.</p>
        /// </li>
        /// </ul>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API
        /// endpoint.</p>
        /// </li>
        /// </ul>
        /// <p>We strongly recommend that customers use the newer <code>iot:Data-ATS</code> endpoint type to avoid
        /// issues related to the widespread distrust of Symantec certificate authorities.</p>
        pub fn endpoint_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.endpoint_type(input);
            self
        }
        pub fn set_endpoint_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEventConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_event_configurations_input::Builder,
    }
    impl<C> DescribeEventConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEventConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeEventConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeIndex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_index_input::Builder,
    }
    impl<C> DescribeIndex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeIndexOutput,
            smithy_http::result::SdkError<crate::error::DescribeIndexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The index name.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_job_input::Builder,
    }
    impl<C> DescribeJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeJobOutput,
            smithy_http::result::SdkError<crate::error::DescribeJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeJobExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_job_execution_input::Builder,
    }
    impl<C> DescribeJobExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeJobExecutionOutput,
            smithy_http::result::SdkError<crate::error::DescribeJobExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The name of the thing on which the job execution is running.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>A string (consisting of the digits "0" through "9" which is used to specify a particular job execution
        /// on a particular device.</p>
        pub fn execution_number(mut self, input: i64) -> Self {
            self.inner = self.inner.execution_number(input);
            self
        }
        pub fn set_execution_number(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_execution_number(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeJobTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_job_template_input::Builder,
    }
    impl<C> DescribeJobTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeJobTemplateOutput,
            smithy_http::result::SdkError<crate::error::DescribeJobTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the job template.</p>
        pub fn job_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_template_id(input);
            self
        }
        pub fn set_job_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_job_template_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMitigationAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_mitigation_action_input::Builder,
    }
    impl<C> DescribeMitigationAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMitigationActionOutput,
            smithy_http::result::SdkError<crate::error::DescribeMitigationActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The friendly name that uniquely identifies the mitigation action.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action_name(input);
            self
        }
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_action_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeProvisioningTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_provisioning_template_input::Builder,
    }
    impl<C> DescribeProvisioningTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeProvisioningTemplateOutput,
            smithy_http::result::SdkError<crate::error::DescribeProvisioningTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the fleet provisioning template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeProvisioningTemplateVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_provisioning_template_version_input::Builder,
    }
    impl<C> DescribeProvisioningTemplateVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeProvisioningTemplateVersionOutput,
            smithy_http::result::SdkError<crate::error::DescribeProvisioningTemplateVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The template name.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
        /// <p>The fleet provisioning template version ID.</p>
        pub fn version_id(mut self, input: i32) -> Self {
            self.inner = self.inner.version_id(input);
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRoleAlias<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_role_alias_input::Builder,
    }
    impl<C> DescribeRoleAlias<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRoleAliasOutput,
            smithy_http::result::SdkError<crate::error::DescribeRoleAliasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The role alias to describe.</p>
        pub fn role_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_alias(input);
            self
        }
        pub fn set_role_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_alias(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScheduledAudit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_scheduled_audit_input::Builder,
    }
    impl<C> DescribeScheduledAudit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScheduledAuditOutput,
            smithy_http::result::SdkError<crate::error::DescribeScheduledAuditError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the scheduled audit whose information you want to get.</p>
        pub fn scheduled_audit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_audit_name(input);
            self
        }
        pub fn set_scheduled_audit_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_audit_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSecurityProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_security_profile_input::Builder,
    }
    impl<C> DescribeSecurityProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSecurityProfileOutput,
            smithy_http::result::SdkError<crate::error::DescribeSecurityProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the security profile
        /// whose information you want to get.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_profile_name(input);
            self
        }
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_stream_input::Builder,
    }
    impl<C> DescribeStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeStreamOutput,
            smithy_http::result::SdkError<crate::error::DescribeStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_id(input);
            self
        }
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeThing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_thing_input::Builder,
    }
    impl<C> DescribeThing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeThingOutput,
            smithy_http::result::SdkError<crate::error::DescribeThingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeThingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_thing_group_input::Builder,
    }
    impl<C> DescribeThingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeThingGroupOutput,
            smithy_http::result::SdkError<crate::error::DescribeThingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing group.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_name(input);
            self
        }
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeThingRegistrationTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_thing_registration_task_input::Builder,
    }
    impl<C> DescribeThingRegistrationTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeThingRegistrationTaskOutput,
            smithy_http::result::SdkError<crate::error::DescribeThingRegistrationTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The task ID.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeThingType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_thing_type_input::Builder,
    }
    impl<C> DescribeThingType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeThingTypeOutput,
            smithy_http::result::SdkError<crate::error::DescribeThingTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing type.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_type_name(input);
            self
        }
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_type_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_policy_input::Builder,
    }
    impl<C> DetachPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachPolicyOutput,
            smithy_http::result::SdkError<crate::error::DetachPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The policy to detach.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The target from which the policy will be detached.</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target(input);
            self
        }
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachPrincipalPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_principal_policy_input::Builder,
    }
    impl<C> DetachPrincipalPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachPrincipalPolicyOutput,
            smithy_http::result::SdkError<crate::error::DetachPrincipalPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the policy to detach.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The principal.</p>
        /// <p>Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal(input);
            self
        }
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachSecurityProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_security_profile_input::Builder,
    }
    impl<C> DetachSecurityProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachSecurityProfileOutput,
            smithy_http::result::SdkError<crate::error::DetachSecurityProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The security profile that is detached.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_profile_name(input);
            self
        }
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_name(input);
            self
        }
        /// <p>The ARN of the thing group from which the security profile is detached.</p>
        pub fn security_profile_target_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.security_profile_target_arn(input);
            self
        }
        pub fn set_security_profile_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_target_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachThingPrincipal<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_thing_principal_input::Builder,
    }
    impl<C> DetachThingPrincipal<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachThingPrincipalOutput,
            smithy_http::result::SdkError<crate::error::DetachThingPrincipalError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>If the principal is a certificate, this value must be ARN of the certificate. If
        /// the principal is an Amazon Cognito identity, this value must be the ID of the Amazon
        /// Cognito identity.</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal(input);
            self
        }
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableTopicRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_topic_rule_input::Builder,
    }
    impl<C> DisableTopicRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableTopicRuleOutput,
            smithy_http::result::SdkError<crate::error::DisableTopicRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule to disable.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableTopicRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_topic_rule_input::Builder,
    }
    impl<C> EnableTopicRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableTopicRuleOutput,
            smithy_http::result::SdkError<crate::error::EnableTopicRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the topic rule to enable.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBehaviorModelTrainingSummaries<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_behavior_model_training_summaries_input::Builder,
    }
    impl<C> GetBehaviorModelTrainingSummaries<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBehaviorModelTrainingSummariesOutput,
            smithy_http::result::SdkError<crate::error::GetBehaviorModelTrainingSummariesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The name of the security profile.
        /// </p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_profile_name(input);
            self
        }
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_name(input);
            self
        }
        /// <p>
        /// The maximum number of results to return at one time. The default is 25.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// The token for the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCardinality<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_cardinality_input::Builder,
    }
    impl<C> GetCardinality<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCardinalityOutput,
            smithy_http::result::SdkError<crate::error::GetCardinalityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the index to search.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>The search query.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(input);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
        /// <p>The field to aggregate.</p>
        pub fn aggregation_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.aggregation_field(input);
            self
        }
        pub fn set_aggregation_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_aggregation_field(input);
            self
        }
        /// <p>The query version.</p>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_version(input);
            self
        }
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetEffectivePolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_effective_policies_input::Builder,
    }
    impl<C> GetEffectivePolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetEffectivePoliciesOutput,
            smithy_http::result::SdkError<crate::error::GetEffectivePoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal(input);
            self
        }
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal(input);
            self
        }
        /// <p>The Cognito identity pool ID.</p>
        pub fn cognito_identity_pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cognito_identity_pool_id(input);
            self
        }
        pub fn set_cognito_identity_pool_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cognito_identity_pool_id(input);
            self
        }
        /// <p>The thing name.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetIndexingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_indexing_configuration_input::Builder,
    }
    impl<C> GetIndexingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetIndexingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetIndexingConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJobDocument<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_job_document_input::Builder,
    }
    impl<C> GetJobDocument<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobDocumentOutput,
            smithy_http::result::SdkError<crate::error::GetJobDocumentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLoggingOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_logging_options_input::Builder,
    }
    impl<C> GetLoggingOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLoggingOptionsOutput,
            smithy_http::result::SdkError<crate::error::GetLoggingOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOTAUpdate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_ota_update_input::Builder,
    }
    impl<C> GetOTAUpdate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOtaUpdateOutput,
            smithy_http::result::SdkError<crate::error::GetOTAUpdateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The OTA update ID.</p>
        pub fn ota_update_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ota_update_id(input);
            self
        }
        pub fn set_ota_update_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ota_update_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPercentiles<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_percentiles_input::Builder,
    }
    impl<C> GetPercentiles<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPercentilesOutput,
            smithy_http::result::SdkError<crate::error::GetPercentilesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the index to search.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>The query string.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(input);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
        /// <p>The field to aggregate.</p>
        pub fn aggregation_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.aggregation_field(input);
            self
        }
        pub fn set_aggregation_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_aggregation_field(input);
            self
        }
        /// <p>The query version.</p>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_version(input);
            self
        }
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_version(input);
            self
        }
        /// <p>The percentile groups returned.</p>
        pub fn percents(mut self, inp: impl Into<f64>) -> Self {
            self.inner = self.inner.percents(inp);
            self
        }
        pub fn set_percents(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.inner = self.inner.set_percents(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_policy_input::Builder,
    }
    impl<C> GetPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPolicyVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_policy_version_input::Builder,
    }
    impl<C> GetPolicyVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPolicyVersionOutput,
            smithy_http::result::SdkError<crate::error::GetPolicyVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The policy version ID.</p>
        pub fn policy_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_version_id(input);
            self
        }
        pub fn set_policy_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRegistrationCode<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_registration_code_input::Builder,
    }
    impl<C> GetRegistrationCode<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRegistrationCodeOutput,
            smithy_http::result::SdkError<crate::error::GetRegistrationCodeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStatistics<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_statistics_input::Builder,
    }
    impl<C> GetStatistics<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStatisticsOutput,
            smithy_http::result::SdkError<crate::error::GetStatisticsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the index to search. The default value is <code>AWS_Things</code>.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>The query used to search. You can specify "*" for the query string to get the count of all
        /// indexed things in your AWS account.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(input);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
        /// <p>The aggregation field name.</p>
        pub fn aggregation_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.aggregation_field(input);
            self
        }
        pub fn set_aggregation_field(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_aggregation_field(input);
            self
        }
        /// <p>The version of the query used to search.</p>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_version(input);
            self
        }
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTopicRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_topic_rule_input::Builder,
    }
    impl<C> GetTopicRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTopicRuleOutput,
            smithy_http::result::SdkError<crate::error::GetTopicRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTopicRuleDestination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_topic_rule_destination_input::Builder,
    }
    impl<C> GetTopicRuleDestination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTopicRuleDestinationOutput,
            smithy_http::result::SdkError<crate::error::GetTopicRuleDestinationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic rule destination.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetV2LoggingOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_v2_logging_options_input::Builder,
    }
    impl<C> GetV2LoggingOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetV2LoggingOptionsOutput,
            smithy_http::result::SdkError<crate::error::GetV2LoggingOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListActiveViolations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_active_violations_input::Builder,
    }
    impl<C> ListActiveViolations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListActiveViolationsOutput,
            smithy_http::result::SdkError<crate::error::ListActiveViolationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing whose active violations are listed.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>The name of the Device Defender security profile for which violations are listed.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_profile_name(input);
            self
        }
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_name(input);
            self
        }
        /// <p>
        /// The criteria for a behavior.
        /// </p>
        pub fn behavior_criteria_type(mut self, input: crate::model::BehaviorCriteriaType) -> Self {
            self.inner = self.inner.behavior_criteria_type(input);
            self
        }
        pub fn set_behavior_criteria_type(
            mut self,
            input: std::option::Option<crate::model::BehaviorCriteriaType>,
        ) -> Self {
            self.inner = self.inner.set_behavior_criteria_type(input);
            self
        }
        /// <p>
        /// A list of all suppressed alerts.
        /// </p>
        pub fn list_suppressed_alerts(mut self, input: bool) -> Self {
            self.inner = self.inner.list_suppressed_alerts(input);
            self
        }
        pub fn set_list_suppressed_alerts(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_list_suppressed_alerts(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAttachedPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_attached_policies_input::Builder,
    }
    impl<C> ListAttachedPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAttachedPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListAttachedPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The group or principal for which the policies will be listed. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target(input);
            self
        }
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target(input);
            self
        }
        /// <p>When true, recursively list attached policies.</p>
        pub fn recursive(mut self, input: bool) -> Self {
            self.inner = self.inner.recursive(input);
            self
        }
        pub fn set_recursive(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_recursive(input);
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAuditFindings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_audit_findings_input::Builder,
    }
    impl<C> ListAuditFindings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAuditFindingsOutput,
            smithy_http::result::SdkError<crate::error::ListAuditFindingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A filter to limit results to the audit with the specified ID. You must
        /// specify either the taskId or the startTime and endTime, but not both.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
        /// <p>A filter to limit results to the findings for the specified audit check.</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.check_name(input);
            self
        }
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_check_name(input);
            self
        }
        /// <p>Information identifying the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.inner = self.inner.resource_identifier(input);
            self
        }
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.inner = self.inner.set_resource_identifier(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A filter to limit results to those found after the specified time. You must
        /// specify either the startTime and endTime or the taskId, but not both.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>A filter to limit results to those found before the specified time. You must
        /// specify either the startTime and endTime or the taskId, but not both.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>
        /// Boolean flag indicating whether only the suppressed findings or the unsuppressed findings should be listed. If this parameter isn't provided, the response will list both suppressed and unsuppressed findings.
        /// </p>
        pub fn list_suppressed_findings(mut self, input: bool) -> Self {
            self.inner = self.inner.list_suppressed_findings(input);
            self
        }
        pub fn set_list_suppressed_findings(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_list_suppressed_findings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAuditMitigationActionsExecutions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_audit_mitigation_actions_executions_input::Builder,
    }
    impl<C> ListAuditMitigationActionsExecutions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAuditMitigationActionsExecutionsOutput,
            smithy_http::result::SdkError<crate::error::ListAuditMitigationActionsExecutionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specify this filter to limit results to actions for a specific audit mitigation actions task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
        /// <p>Specify this filter to limit results to those with a specific status.</p>
        pub fn action_status(
            mut self,
            input: crate::model::AuditMitigationActionsExecutionStatus,
        ) -> Self {
            self.inner = self.inner.action_status(input);
            self
        }
        pub fn set_action_status(
            mut self,
            input: std::option::Option<crate::model::AuditMitigationActionsExecutionStatus>,
        ) -> Self {
            self.inner = self.inner.set_action_status(input);
            self
        }
        /// <p>Specify this filter to limit results to those that were applied to a specific audit finding.</p>
        pub fn finding_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.finding_id(input);
            self
        }
        pub fn set_finding_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_finding_id(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAuditMitigationActionsTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_audit_mitigation_actions_tasks_input::Builder,
    }
    impl<C> ListAuditMitigationActionsTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAuditMitigationActionsTasksOutput,
            smithy_http::result::SdkError<crate::error::ListAuditMitigationActionsTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specify this filter to limit results to tasks that were applied to results for a specific audit.</p>
        pub fn audit_task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.audit_task_id(input);
            self
        }
        pub fn set_audit_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_audit_task_id(input);
            self
        }
        /// <p>Specify this filter to limit results to tasks that were applied to a specific audit finding.</p>
        pub fn finding_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.finding_id(input);
            self
        }
        pub fn set_finding_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_finding_id(input);
            self
        }
        /// <p>Specify this filter to limit results to tasks that are in a specific state.</p>
        pub fn task_status(
            mut self,
            input: crate::model::AuditMitigationActionsTaskStatus,
        ) -> Self {
            self.inner = self.inner.task_status(input);
            self
        }
        pub fn set_task_status(
            mut self,
            input: std::option::Option<crate::model::AuditMitigationActionsTaskStatus>,
        ) -> Self {
            self.inner = self.inner.set_task_status(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Specify this filter to limit results to tasks that began on or after a specific date and time.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAuditSuppressions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_audit_suppressions_input::Builder,
    }
    impl<C> ListAuditSuppressions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAuditSuppressionsOutput,
            smithy_http::result::SdkError<crate::error::ListAuditSuppressionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An audit check name. Checks must be enabled
        /// for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
        /// of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
        /// to select which checks are enabled.)</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.check_name(input);
            self
        }
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_check_name(input);
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.inner = self.inner.resource_identifier(input);
            self
        }
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.inner = self.inner.set_resource_identifier(input);
            self
        }
        /// <p>
        /// Determines whether suppressions are listed in ascending order by expiration date or not. If parameter isn't provided, <code>ascendingOrder=true</code>.
        /// </p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.inner = self.inner.ascending_order(input);
            self
        }
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ascending_order(input);
            self
        }
        /// <p>
        /// The token for the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>
        /// The maximum number of results to return at one time. The default is 25.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAuditTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_audit_tasks_input::Builder,
    }
    impl<C> ListAuditTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAuditTasksOutput,
            smithy_http::result::SdkError<crate::error::ListAuditTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The beginning of the time period. Audit information is retained for a
        /// limited time (90 days). Requesting a start time prior to what is retained
        /// results in an "InvalidRequestException".</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time period.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>A filter to limit the output to the specified type of audit: can be one of
        /// "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".</p>
        pub fn task_type(mut self, input: crate::model::AuditTaskType) -> Self {
            self.inner = self.inner.task_type(input);
            self
        }
        pub fn set_task_type(
            mut self,
            input: std::option::Option<crate::model::AuditTaskType>,
        ) -> Self {
            self.inner = self.inner.set_task_type(input);
            self
        }
        /// <p>A filter to limit the output to audits with the specified completion
        /// status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".</p>
        pub fn task_status(mut self, input: crate::model::AuditTaskStatus) -> Self {
            self.inner = self.inner.task_status(input);
            self
        }
        pub fn set_task_status(
            mut self,
            input: std::option::Option<crate::model::AuditTaskStatus>,
        ) -> Self {
            self.inner = self.inner.set_task_status(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAuthorizers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_authorizers_input::Builder,
    }
    impl<C> ListAuthorizers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAuthorizersOutput,
            smithy_http::result::SdkError<crate::error::ListAuthorizersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>A marker used to get the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Return the list of authorizers in ascending alphabetical order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.inner = self.inner.ascending_order(input);
            self
        }
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ascending_order(input);
            self
        }
        /// <p>The status of the list authorizers request.</p>
        pub fn status(mut self, input: crate::model::AuthorizerStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AuthorizerStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBillingGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_billing_groups_input::Builder,
    }
    impl<C> ListBillingGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListBillingGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListBillingGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Limit the results to billing groups whose names have the given prefix.</p>
        pub fn name_prefix_filter(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name_prefix_filter(input);
            self
        }
        pub fn set_name_prefix_filter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_name_prefix_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCACertificates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_ca_certificates_input::Builder,
    }
    impl<C> ListCACertificates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCaCertificatesOutput,
            smithy_http::result::SdkError<crate::error::ListCACertificatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Determines the order of the results.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.inner = self.inner.ascending_order(input);
            self
        }
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ascending_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCertificates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_certificates_input::Builder,
    }
    impl<C> ListCertificates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCertificatesOutput,
            smithy_http::result::SdkError<crate::error::ListCertificatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Specifies the order for results. If True, the results are returned in ascending
        /// order, based on the creation date.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.inner = self.inner.ascending_order(input);
            self
        }
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ascending_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCertificatesByCA<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_certificates_by_ca_input::Builder,
    }
    impl<C> ListCertificatesByCA<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCertificatesByCaOutput,
            smithy_http::result::SdkError<crate::error::ListCertificatesByCAError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the CA certificate. This operation will list all registered device
        /// certificate that were signed by this CA certificate.</p>
        pub fn ca_certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ca_certificate_id(input);
            self
        }
        pub fn set_ca_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ca_certificate_id(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Specifies the order for results. If True, the results are returned in ascending
        /// order, based on the creation date.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.inner = self.inner.ascending_order(input);
            self
        }
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ascending_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCustomMetrics<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_custom_metrics_input::Builder,
    }
    impl<C> ListCustomMetrics<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCustomMetricsOutput,
            smithy_http::result::SdkError<crate::error::ListCustomMetricsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The token for the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>
        /// The maximum number of results to return at one time. The default is 25.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDetectMitigationActionsExecutions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_detect_mitigation_actions_executions_input::Builder,
    }
    impl<C> ListDetectMitigationActionsExecutions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDetectMitigationActionsExecutionsOutput,
            smithy_http::result::SdkError<crate::error::ListDetectMitigationActionsExecutionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The unique identifier of the task.
        /// </p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
        /// <p>
        /// The unique identifier of the violation.
        /// </p>
        pub fn violation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.violation_id(input);
            self
        }
        pub fn set_violation_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_violation_id(input);
            self
        }
        /// <p>
        /// The name of the thing whose mitigation actions are listed.
        /// </p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>
        /// A filter to limit results to those found after the specified time. You must
        /// specify either the startTime and endTime or the taskId, but not both.
        /// </p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>
        /// The end of the time period for which ML Detect mitigation actions executions are returned.
        /// </p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>
        /// The maximum number of results to return at one time. The default is 25.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// The token for the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDetectMitigationActionsTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_detect_mitigation_actions_tasks_input::Builder,
    }
    impl<C> ListDetectMitigationActionsTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDetectMitigationActionsTasksOutput,
            smithy_http::result::SdkError<crate::error::ListDetectMitigationActionsTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// The token for the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>
        /// A filter to limit results to those found after the specified time. You must
        /// specify either the startTime and endTime or the taskId, but not both.
        /// </p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>
        /// The end of the time period for which ML Detect mitigation actions tasks are returned.
        /// </p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDimensions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_dimensions_input::Builder,
    }
    impl<C> ListDimensions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDimensionsOutput,
            smithy_http::result::SdkError<crate::error::ListDimensionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to retrieve at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDomainConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_domain_configurations_input::Builder,
    }
    impl<C> ListDomainConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDomainConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListDomainConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>The type of service delivered by the endpoint.</p>
        pub fn service_type(mut self, input: crate::model::ServiceType) -> Self {
            self.inner = self.inner.service_type(input);
            self
        }
        pub fn set_service_type(
            mut self,
            input: std::option::Option<crate::model::ServiceType>,
        ) -> Self {
            self.inner = self.inner.set_service_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListIndices<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_indices_input::Builder,
    }
    impl<C> ListIndices<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListIndicesOutput,
            smithy_http::result::SdkError<crate::error::ListIndicesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobExecutionsForJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_job_executions_for_job_input::Builder,
    }
    impl<C> ListJobExecutionsForJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListJobExecutionsForJobOutput,
            smithy_http::result::SdkError<crate::error::ListJobExecutionsForJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier you assigned to this job when it was created.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The status of the job.</p>
        pub fn status(mut self, input: crate::model::JobExecutionStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::JobExecutionStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobExecutionsForThing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_job_executions_for_thing_input::Builder,
    }
    impl<C> ListJobExecutionsForThing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListJobExecutionsForThingOutput,
            smithy_http::result::SdkError<crate::error::ListJobExecutionsForThingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The thing name.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
        pub fn status(mut self, input: crate::model::JobExecutionStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::JobExecutionStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
        /// contain the value in the following format.</p>
        /// <p>
        /// <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
        /// </p>
        /// <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace_id(input);
            self
        }
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace_id(input);
            self
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_jobs_input::Builder,
    }
    impl<C> ListJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListJobsOutput,
            smithy_http::result::SdkError<crate::error::ListJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
        pub fn status(mut self, input: crate::model::JobStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::JobStatus>) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things
        /// specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing
        /// when a change is detected in a target. For example, a job will run on a thing when the thing is added to a
        /// target group, even after the job was completed by all things originally in the group. </p>
        pub fn target_selection(mut self, input: crate::model::TargetSelection) -> Self {
            self.inner = self.inner.target_selection(input);
            self
        }
        pub fn set_target_selection(
            mut self,
            input: std::option::Option<crate::model::TargetSelection>,
        ) -> Self {
            self.inner = self.inner.set_target_selection(input);
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A filter that limits the returned jobs to those for the specified group.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_name(input);
            self
        }
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_name(input);
            self
        }
        /// <p>A filter that limits the returned jobs to those for the specified group.</p>
        pub fn thing_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_id(input);
            self
        }
        pub fn set_thing_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_id(input);
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
        /// contain the value in the following format.</p>
        /// <p>
        /// <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
        /// </p>
        /// <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace_id(input);
            self
        }
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobTemplates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_job_templates_input::Builder,
    }
    impl<C> ListJobTemplates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListJobTemplatesOutput,
            smithy_http::result::SdkError<crate::error::ListJobTemplatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return in the list.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to use to return the next set of results in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMitigationActions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_mitigation_actions_input::Builder,
    }
    impl<C> ListMitigationActions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListMitigationActionsOutput,
            smithy_http::result::SdkError<crate::error::ListMitigationActionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specify a value to limit the result to mitigation actions with a specific action type.</p>
        pub fn action_type(mut self, input: crate::model::MitigationActionType) -> Self {
            self.inner = self.inner.action_type(input);
            self
        }
        pub fn set_action_type(
            mut self,
            input: std::option::Option<crate::model::MitigationActionType>,
        ) -> Self {
            self.inner = self.inner.set_action_type(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOTAUpdates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_ota_updates_input::Builder,
    }
    impl<C> ListOTAUpdates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOtaUpdatesOutput,
            smithy_http::result::SdkError<crate::error::ListOTAUpdatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token used to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The OTA update job status.</p>
        pub fn ota_update_status(mut self, input: crate::model::OtaUpdateStatus) -> Self {
            self.inner = self.inner.ota_update_status(input);
            self
        }
        pub fn set_ota_update_status(
            mut self,
            input: std::option::Option<crate::model::OtaUpdateStatus>,
        ) -> Self {
            self.inner = self.inner.set_ota_update_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOutgoingCertificates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_outgoing_certificates_input::Builder,
    }
    impl<C> ListOutgoingCertificates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOutgoingCertificatesOutput,
            smithy_http::result::SdkError<crate::error::ListOutgoingCertificatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Specifies the order for results. If True, the results are returned in ascending
        /// order, based on the creation date.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.inner = self.inner.ascending_order(input);
            self
        }
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ascending_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_policies_input::Builder,
    }
    impl<C> ListPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>Specifies the order for results. If true, the results are returned in ascending
        /// creation order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.inner = self.inner.ascending_order(input);
            self
        }
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ascending_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPolicyPrincipals<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_policy_principals_input::Builder,
    }
    impl<C> ListPolicyPrincipals<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPolicyPrincipalsOutput,
            smithy_http::result::SdkError<crate::error::ListPolicyPrincipalsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>Specifies the order for results. If true, the results are returned in ascending
        /// creation order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.inner = self.inner.ascending_order(input);
            self
        }
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ascending_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPolicyVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_policy_versions_input::Builder,
    }
    impl<C> ListPolicyVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPolicyVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListPolicyVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPrincipalPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_principal_policies_input::Builder,
    }
    impl<C> ListPrincipalPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPrincipalPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListPrincipalPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal(input);
            self
        }
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal(input);
            self
        }
        /// <p>The marker for the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The result page size.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>Specifies the order for results. If true, results are returned in ascending creation
        /// order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.inner = self.inner.ascending_order(input);
            self
        }
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ascending_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPrincipalThings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_principal_things_input::Builder,
    }
    impl<C> ListPrincipalThings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPrincipalThingsOutput,
            smithy_http::result::SdkError<crate::error::ListPrincipalThingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The principal.</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal(input);
            self
        }
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListProvisioningTemplates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_provisioning_templates_input::Builder,
    }
    impl<C> ListProvisioningTemplates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListProvisioningTemplatesOutput,
            smithy_http::result::SdkError<crate::error::ListProvisioningTemplatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListProvisioningTemplateVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_provisioning_template_versions_input::Builder,
    }
    impl<C> ListProvisioningTemplateVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListProvisioningTemplateVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListProvisioningTemplateVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the fleet provisioning template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRoleAliases<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_role_aliases_input::Builder,
    }
    impl<C> ListRoleAliases<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRoleAliasesOutput,
            smithy_http::result::SdkError<crate::error::ListRoleAliasesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>A marker used to get the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Return the list of role aliases in ascending alphabetical order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.inner = self.inner.ascending_order(input);
            self
        }
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ascending_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListScheduledAudits<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_scheduled_audits_input::Builder,
    }
    impl<C> ListScheduledAudits<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListScheduledAuditsOutput,
            smithy_http::result::SdkError<crate::error::ListScheduledAuditsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time. The default is 25.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSecurityProfiles<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_security_profiles_input::Builder,
    }
    impl<C> ListSecurityProfiles<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSecurityProfilesOutput,
            smithy_http::result::SdkError<crate::error::ListSecurityProfilesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A filter to limit results to the security profiles that use the defined dimension.
        /// Cannot be used with <code>metricName</code>
        /// </p>
        pub fn dimension_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dimension_name(input);
            self
        }
        pub fn set_dimension_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dimension_name(input);
            self
        }
        /// <p> The name of the custom metric.
        /// Cannot be used with <code>dimensionName</code>. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSecurityProfilesForTarget<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_security_profiles_for_target_input::Builder,
    }
    impl<C> ListSecurityProfilesForTarget<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSecurityProfilesForTargetOutput,
            smithy_http::result::SdkError<crate::error::ListSecurityProfilesForTargetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>If true, return child groups too.</p>
        pub fn recursive(mut self, input: bool) -> Self {
            self.inner = self.inner.recursive(input);
            self
        }
        pub fn set_recursive(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_recursive(input);
            self
        }
        /// <p>The ARN of the target (thing group) whose attached security profiles you want to get.</p>
        pub fn security_profile_target_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.security_profile_target_arn(input);
            self
        }
        pub fn set_security_profile_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_target_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStreams<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_streams_input::Builder,
    }
    impl<C> ListStreams<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStreamsOutput,
            smithy_http::result::SdkError<crate::error::ListStreamsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return at a time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token used to get the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Set to true to return the list of streams in ascending order.</p>
        pub fn ascending_order(mut self, input: bool) -> Self {
            self.inner = self.inner.ascending_order(input);
            self
        }
        pub fn set_ascending_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ascending_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTargetsForPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_targets_for_policy_input::Builder,
    }
    impl<C> ListTargetsForPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTargetsForPolicyOutput,
            smithy_http::result::SdkError<crate::error::ListTargetsForPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>A marker used to get the next set of results.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTargetsForSecurityProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_targets_for_security_profile_input::Builder,
    }
    impl<C> ListTargetsForSecurityProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTargetsForSecurityProfileOutput,
            smithy_http::result::SdkError<crate::error::ListTargetsForSecurityProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The security profile.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_profile_name(input);
            self
        }
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_name(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListThingGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_thing_groups_input::Builder,
    }
    impl<C> ListThingGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListThingGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListThingGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A filter that limits the results to those with the specified parent group.</p>
        pub fn parent_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parent_group(input);
            self
        }
        pub fn set_parent_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_parent_group(input);
            self
        }
        /// <p>A filter that limits the results to those with the specified name prefix.</p>
        pub fn name_prefix_filter(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name_prefix_filter(input);
            self
        }
        pub fn set_name_prefix_filter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_name_prefix_filter(input);
            self
        }
        /// <p>If true, return child groups as well.</p>
        pub fn recursive(mut self, input: bool) -> Self {
            self.inner = self.inner.recursive(input);
            self
        }
        pub fn set_recursive(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_recursive(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListThingGroupsForThing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_thing_groups_for_thing_input::Builder,
    }
    impl<C> ListThingGroupsForThing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListThingGroupsForThingOutput,
            smithy_http::result::SdkError<crate::error::ListThingGroupsForThingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The thing name.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListThingPrincipals<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_thing_principals_input::Builder,
    }
    impl<C> ListThingPrincipals<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListThingPrincipalsOutput,
            smithy_http::result::SdkError<crate::error::ListThingPrincipalsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The name of the thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListThingRegistrationTaskReports<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_thing_registration_task_reports_input::Builder,
    }
    impl<C> ListThingRegistrationTaskReports<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListThingRegistrationTaskReportsOutput,
            smithy_http::result::SdkError<crate::error::ListThingRegistrationTaskReportsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The id of the task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
        /// <p>The type of task report.</p>
        pub fn report_type(mut self, input: crate::model::ReportType) -> Self {
            self.inner = self.inner.report_type(input);
            self
        }
        pub fn set_report_type(
            mut self,
            input: std::option::Option<crate::model::ReportType>,
        ) -> Self {
            self.inner = self.inner.set_report_type(input);
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListThingRegistrationTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_thing_registration_tasks_input::Builder,
    }
    impl<C> ListThingRegistrationTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListThingRegistrationTasksOutput,
            smithy_http::result::SdkError<crate::error::ListThingRegistrationTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The status of the bulk thing provisioning task.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListThings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_things_input::Builder,
    }
    impl<C> ListThings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListThingsOutput,
            smithy_http::result::SdkError<crate::error::ListThingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The attribute name used to search for things.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attribute_name(input);
            self
        }
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_attribute_name(input);
            self
        }
        /// <p>The attribute value used to search for things.</p>
        pub fn attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attribute_value(input);
            self
        }
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_attribute_value(input);
            self
        }
        /// <p>The name of the thing type used to search for things.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_type_name(input);
            self
        }
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_type_name(input);
            self
        }
        /// <p>When <code>true</code>, the action returns the thing resources with attribute values
        /// that start with the <code>attributeValue</code> provided.</p>
        /// <p>When <code>false</code>, or not present, the action returns only the thing
        /// resources with attribute values that match the entire <code>attributeValue</code>
        /// provided. </p>
        pub fn use_prefix_attribute_value(mut self, input: bool) -> Self {
            self.inner = self.inner.use_prefix_attribute_value(input);
            self
        }
        pub fn set_use_prefix_attribute_value(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_use_prefix_attribute_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListThingsInBillingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_things_in_billing_group_input::Builder,
    }
    impl<C> ListThingsInBillingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListThingsInBillingGroupOutput,
            smithy_http::result::SdkError<crate::error::ListThingsInBillingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.billing_group_name(input);
            self
        }
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_name(input);
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListThingsInThingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_things_in_thing_group_input::Builder,
    }
    impl<C> ListThingsInThingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListThingsInThingGroupOutput,
            smithy_http::result::SdkError<crate::error::ListThingsInThingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The thing group name.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_name(input);
            self
        }
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_name(input);
            self
        }
        /// <p>When true, list things in this thing group and in all child groups as
        /// well.</p>
        pub fn recursive(mut self, input: bool) -> Self {
            self.inner = self.inner.recursive(input);
            self
        }
        pub fn set_recursive(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_recursive(input);
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListThingTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_thing_types_input::Builder,
    }
    impl<C> ListThingTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListThingTypesOutput,
            smithy_http::result::SdkError<crate::error::ListThingTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in this operation.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The name of the thing type.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_type_name(input);
            self
        }
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_type_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTopicRuleDestinations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_topic_rule_destinations_input::Builder,
    }
    impl<C> ListTopicRuleDestinations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTopicRuleDestinationsOutput,
            smithy_http::result::SdkError<crate::error::ListTopicRuleDestinationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTopicRules<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_topic_rules_input::Builder,
    }
    impl<C> ListTopicRules<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTopicRulesOutput,
            smithy_http::result::SdkError<crate::error::ListTopicRulesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The topic.</p>
        pub fn topic(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic(input);
            self
        }
        pub fn set_topic(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Specifies whether the rule is disabled.</p>
        pub fn rule_disabled(mut self, input: bool) -> Self {
            self.inner = self.inner.rule_disabled(input);
            self
        }
        pub fn set_rule_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_rule_disabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListV2LoggingLevels<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_v2_logging_levels_input::Builder,
    }
    impl<C> ListV2LoggingLevels<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListV2LoggingLevelsOutput,
            smithy_http::result::SdkError<crate::error::ListV2LoggingLevelsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of resource for which you are configuring logging. Must be
        /// <code>THING_Group</code>.</p>
        pub fn target_type(mut self, input: crate::model::LogTargetType) -> Self {
            self.inner = self.inner.target_type(input);
            self
        }
        pub fn set_target_type(
            mut self,
            input: std::option::Option<crate::model::LogTargetType>,
        ) -> Self {
            self.inner = self.inner.set_target_type(input);
            self
        }
        /// <p>To retrieve the next set of results, the <code>nextToken</code>
        /// value from a previous response; otherwise <b>null</b> to receive
        /// the first set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListViolationEvents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_violation_events_input::Builder,
    }
    impl<C> ListViolationEvents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListViolationEventsOutput,
            smithy_http::result::SdkError<crate::error::ListViolationEventsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The start time for the alerts to be listed.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end time for the alerts to be listed.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>A filter to limit results to those alerts caused by the specified thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>A filter to limit results to those alerts generated by the specified security profile.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_profile_name(input);
            self
        }
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_name(input);
            self
        }
        /// <p>
        /// The criteria for a behavior.
        /// </p>
        pub fn behavior_criteria_type(mut self, input: crate::model::BehaviorCriteriaType) -> Self {
            self.inner = self.inner.behavior_criteria_type(input);
            self
        }
        pub fn set_behavior_criteria_type(
            mut self,
            input: std::option::Option<crate::model::BehaviorCriteriaType>,
        ) -> Self {
            self.inner = self.inner.set_behavior_criteria_type(input);
            self
        }
        /// <p>
        /// A list of all suppressed alerts.
        /// </p>
        pub fn list_suppressed_alerts(mut self, input: bool) -> Self {
            self.inner = self.inner.list_suppressed_alerts(input);
            self
        }
        pub fn set_list_suppressed_alerts(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_list_suppressed_alerts(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterCACertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_ca_certificate_input::Builder,
    }
    impl<C> RegisterCACertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterCaCertificateOutput,
            smithy_http::result::SdkError<crate::error::RegisterCACertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The CA certificate.</p>
        pub fn ca_certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ca_certificate(input);
            self
        }
        pub fn set_ca_certificate(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ca_certificate(input);
            self
        }
        /// <p>The private key verification certificate.</p>
        pub fn verification_certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.verification_certificate(input);
            self
        }
        pub fn set_verification_certificate(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_verification_certificate(input);
            self
        }
        /// <p>A boolean value that specifies if the CA certificate is set to active.</p>
        pub fn set_as_active(mut self, input: bool) -> Self {
            self.inner = self.inner.set_as_active(input);
            self
        }
        pub fn set_set_as_active(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_set_as_active(input);
            self
        }
        /// <p>Allows this CA certificate to be used for auto registration of device
        /// certificates.</p>
        pub fn allow_auto_registration(mut self, input: bool) -> Self {
            self.inner = self.inner.allow_auto_registration(input);
            self
        }
        pub fn set_allow_auto_registration(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_allow_auto_registration(input);
            self
        }
        /// <p>Information about the registration configuration.</p>
        pub fn registration_config(mut self, input: crate::model::RegistrationConfig) -> Self {
            self.inner = self.inner.registration_config(input);
            self
        }
        pub fn set_registration_config(
            mut self,
            input: std::option::Option<crate::model::RegistrationConfig>,
        ) -> Self {
            self.inner = self.inner.set_registration_config(input);
            self
        }
        /// <p>Metadata which can be used to manage the CA certificate.</p>
        /// <note>
        /// <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
        /// <p>For the CLI command-line parameter use format: &&tags
        /// "key1=value1&key2=value2..."</p>
        /// <p>For the cli-input-json file use format: "tags":
        /// "key1=value1&key2=value2..."</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_certificate_input::Builder,
    }
    impl<C> RegisterCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterCertificateOutput,
            smithy_http::result::SdkError<crate::error::RegisterCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The certificate data, in PEM format.</p>
        pub fn certificate_pem(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_pem(input);
            self
        }
        pub fn set_certificate_pem(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_pem(input);
            self
        }
        /// <p>The CA certificate used to sign the device certificate being registered.</p>
        pub fn ca_certificate_pem(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ca_certificate_pem(input);
            self
        }
        pub fn set_ca_certificate_pem(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ca_certificate_pem(input);
            self
        }
        /// <p>A boolean value that specifies if the certificate is set to active.</p>
        pub fn set_as_active(mut self, input: bool) -> Self {
            self.inner = self.inner.set_as_active(input);
            self
        }
        pub fn set_set_as_active(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_set_as_active(input);
            self
        }
        /// <p>The status of the register certificate request.</p>
        pub fn status(mut self, input: crate::model::CertificateStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CertificateStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterCertificateWithoutCA<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_certificate_without_ca_input::Builder,
    }
    impl<C> RegisterCertificateWithoutCA<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterCertificateWithoutCaOutput,
            smithy_http::result::SdkError<crate::error::RegisterCertificateWithoutCAError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The certificate data, in PEM format.</p>
        pub fn certificate_pem(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_pem(input);
            self
        }
        pub fn set_certificate_pem(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_pem(input);
            self
        }
        /// <p>The status of the register certificate request.</p>
        pub fn status(mut self, input: crate::model::CertificateStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CertificateStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterThing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_thing_input::Builder,
    }
    impl<C> RegisterThing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterThingOutput,
            smithy_http::result::SdkError<crate::error::RegisterThingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The provisioning template. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-w-cert.html">Provisioning Devices That Have Device Certificates</a> for more information.</p>
        pub fn template_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_body(input);
            self
        }
        pub fn set_template_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_body(input);
            self
        }
        /// <p>The parameters for provisioning a thing. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html">Provisioning Templates</a> for more information.</p>
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.parameters(k, v);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_parameters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectCertificateTransfer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reject_certificate_transfer_input::Builder,
    }
    impl<C> RejectCertificateTransfer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectCertificateTransferOutput,
            smithy_http::result::SdkError<crate::error::RejectCertificateTransferError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
        /// certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(input);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
        /// <p>The reason the certificate transfer was rejected.</p>
        pub fn reject_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reject_reason(input);
            self
        }
        pub fn set_reject_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reject_reason(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveThingFromBillingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_thing_from_billing_group_input::Builder,
    }
    impl<C> RemoveThingFromBillingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveThingFromBillingGroupOutput,
            smithy_http::result::SdkError<crate::error::RemoveThingFromBillingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.billing_group_name(input);
            self
        }
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_name(input);
            self
        }
        /// <p>The ARN of the billing group.</p>
        pub fn billing_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.billing_group_arn(input);
            self
        }
        pub fn set_billing_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_arn(input);
            self
        }
        /// <p>The name of the thing to be removed from the billing group.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>The ARN of the thing to be removed from the billing group.</p>
        pub fn thing_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_arn(input);
            self
        }
        pub fn set_thing_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveThingFromThingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_thing_from_thing_group_input::Builder,
    }
    impl<C> RemoveThingFromThingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveThingFromThingGroupOutput,
            smithy_http::result::SdkError<crate::error::RemoveThingFromThingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The group name.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_name(input);
            self
        }
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_name(input);
            self
        }
        /// <p>The group ARN.</p>
        pub fn thing_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_arn(input);
            self
        }
        pub fn set_thing_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_arn(input);
            self
        }
        /// <p>The name of the thing to remove from the group.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>The ARN of the thing to remove from the group.</p>
        pub fn thing_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_arn(input);
            self
        }
        pub fn set_thing_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReplaceTopicRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::replace_topic_rule_input::Builder,
    }
    impl<C> ReplaceTopicRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReplaceTopicRuleOutput,
            smithy_http::result::SdkError<crate::error::ReplaceTopicRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
        /// <p>The rule payload.</p>
        pub fn topic_rule_payload(mut self, input: crate::model::TopicRulePayload) -> Self {
            self.inner = self.inner.topic_rule_payload(input);
            self
        }
        pub fn set_topic_rule_payload(
            mut self,
            input: std::option::Option<crate::model::TopicRulePayload>,
        ) -> Self {
            self.inner = self.inner.set_topic_rule_payload(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchIndex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::search_index_input::Builder,
    }
    impl<C> SearchIndex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchIndexOutput,
            smithy_http::result::SdkError<crate::error::SearchIndexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The search index name.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>The search query string.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(input);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
        /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return at one time.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The query version.</p>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_version(input);
            self
        }
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetDefaultAuthorizer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_default_authorizer_input::Builder,
    }
    impl<C> SetDefaultAuthorizer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetDefaultAuthorizerOutput,
            smithy_http::result::SdkError<crate::error::SetDefaultAuthorizerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The authorizer name.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authorizer_name(input);
            self
        }
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authorizer_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetDefaultPolicyVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_default_policy_version_input::Builder,
    }
    impl<C> SetDefaultPolicyVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetDefaultPolicyVersionOutput,
            smithy_http::result::SdkError<crate::error::SetDefaultPolicyVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The policy name.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The policy version ID.</p>
        pub fn policy_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_version_id(input);
            self
        }
        pub fn set_policy_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetLoggingOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_logging_options_input::Builder,
    }
    impl<C> SetLoggingOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetLoggingOptionsOutput,
            smithy_http::result::SdkError<crate::error::SetLoggingOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The logging options payload.</p>
        pub fn logging_options_payload(
            mut self,
            input: crate::model::LoggingOptionsPayload,
        ) -> Self {
            self.inner = self.inner.logging_options_payload(input);
            self
        }
        pub fn set_logging_options_payload(
            mut self,
            input: std::option::Option<crate::model::LoggingOptionsPayload>,
        ) -> Self {
            self.inner = self.inner.set_logging_options_payload(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetV2LoggingLevel<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_v2_logging_level_input::Builder,
    }
    impl<C> SetV2LoggingLevel<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetV2LoggingLevelOutput,
            smithy_http::result::SdkError<crate::error::SetV2LoggingLevelError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The log target.</p>
        pub fn log_target(mut self, input: crate::model::LogTarget) -> Self {
            self.inner = self.inner.log_target(input);
            self
        }
        pub fn set_log_target(
            mut self,
            input: std::option::Option<crate::model::LogTarget>,
        ) -> Self {
            self.inner = self.inner.set_log_target(input);
            self
        }
        /// <p>The log level.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.inner = self.inner.log_level(input);
            self
        }
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.inner = self.inner.set_log_level(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetV2LoggingOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_v2_logging_options_input::Builder,
    }
    impl<C> SetV2LoggingOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetV2LoggingOptionsOutput,
            smithy_http::result::SdkError<crate::error::SetV2LoggingOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the role that allows IoT to write to Cloudwatch logs.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The default logging level.</p>
        pub fn default_log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.inner = self.inner.default_log_level(input);
            self
        }
        pub fn set_default_log_level(
            mut self,
            input: std::option::Option<crate::model::LogLevel>,
        ) -> Self {
            self.inner = self.inner.set_default_log_level(input);
            self
        }
        /// <p>If true all logs are disabled. The default is false.</p>
        pub fn disable_all_logs(mut self, input: bool) -> Self {
            self.inner = self.inner.disable_all_logs(input);
            self
        }
        pub fn set_disable_all_logs(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_disable_all_logs(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartAuditMitigationActionsTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_audit_mitigation_actions_task_input::Builder,
    }
    impl<C> StartAuditMitigationActionsTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartAuditMitigationActionsTaskOutput,
            smithy_http::result::SdkError<crate::error::StartAuditMitigationActionsTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
        /// <p>Specifies the audit findings to which the mitigation actions are applied. You can apply
        /// them to a type of audit check, to all findings from an audit, or to a
        /// specific set of
        /// findings.</p>
        pub fn target(mut self, input: crate::model::AuditMitigationActionsTaskTarget) -> Self {
            self.inner = self.inner.target(input);
            self
        }
        pub fn set_target(
            mut self,
            input: std::option::Option<crate::model::AuditMitigationActionsTaskTarget>,
        ) -> Self {
            self.inner = self.inner.set_target(input);
            self
        }
        /// <p>For an audit check, specifies which mitigation actions to apply. Those actions must be defined in your AWS account.</p>
        pub fn audit_check_to_actions_mapping(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.audit_check_to_actions_mapping(k, v);
            self
        }
        pub fn set_audit_check_to_actions_mapping(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_audit_check_to_actions_mapping(input);
            self
        }
        /// <p>Each audit mitigation task must have a unique client request token. If you try to start a new task with the same token as a task that already exists, an exception occurs. If you omit this value, a unique client request token is generated automatically.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartDetectMitigationActionsTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_detect_mitigation_actions_task_input::Builder,
    }
    impl<C> StartDetectMitigationActionsTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartDetectMitigationActionsTaskOutput,
            smithy_http::result::SdkError<crate::error::StartDetectMitigationActionsTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The unique identifier of the task.
        /// </p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
        /// <p>
        /// Specifies the ML Detect findings to which the mitigation actions are applied.
        /// </p>
        pub fn target(mut self, input: crate::model::DetectMitigationActionsTaskTarget) -> Self {
            self.inner = self.inner.target(input);
            self
        }
        pub fn set_target(
            mut self,
            input: std::option::Option<crate::model::DetectMitigationActionsTaskTarget>,
        ) -> Self {
            self.inner = self.inner.set_target(input);
            self
        }
        /// <p>
        /// The actions to be performed when a device has unexpected behavior.
        /// </p>
        pub fn actions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
        /// <p>
        /// Specifies the time period of which violation events occurred between.
        /// </p>
        pub fn violation_event_occurrence_range(
            mut self,
            input: crate::model::ViolationEventOccurrenceRange,
        ) -> Self {
            self.inner = self.inner.violation_event_occurrence_range(input);
            self
        }
        pub fn set_violation_event_occurrence_range(
            mut self,
            input: std::option::Option<crate::model::ViolationEventOccurrenceRange>,
        ) -> Self {
            self.inner = self.inner.set_violation_event_occurrence_range(input);
            self
        }
        /// <p>
        /// Specifies to list only active violations.
        /// </p>
        pub fn include_only_active_violations(mut self, input: bool) -> Self {
            self.inner = self.inner.include_only_active_violations(input);
            self
        }
        pub fn set_include_only_active_violations(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_include_only_active_violations(input);
            self
        }
        /// <p>
        /// Specifies to include suppressed alerts.
        /// </p>
        pub fn include_suppressed_alerts(mut self, input: bool) -> Self {
            self.inner = self.inner.include_suppressed_alerts(input);
            self
        }
        pub fn set_include_suppressed_alerts(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_suppressed_alerts(input);
            self
        }
        /// <p>
        /// Each mitigation action task must have a unique client request token. If you try to create a new task with the same token as a task that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
        /// </p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartOnDemandAuditTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_on_demand_audit_task_input::Builder,
    }
    impl<C> StartOnDemandAuditTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartOnDemandAuditTaskOutput,
            smithy_http::result::SdkError<crate::error::StartOnDemandAuditTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Which checks are performed during the audit. The checks you specify must be enabled
        /// for your account or an exception occurs. Use <code>DescribeAccountAuditConfiguration</code>
        /// to see the list of all checks, including those that are enabled or
        /// <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.</p>
        pub fn target_check_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_check_names(inp);
            self
        }
        pub fn set_target_check_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_target_check_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartThingRegistrationTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_thing_registration_task_input::Builder,
    }
    impl<C> StartThingRegistrationTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartThingRegistrationTaskOutput,
            smithy_http::result::SdkError<crate::error::StartThingRegistrationTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The provisioning template.</p>
        pub fn template_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_body(input);
            self
        }
        pub fn set_template_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_body(input);
            self
        }
        /// <p>The S3 bucket that contains the input file.</p>
        pub fn input_file_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_file_bucket(input);
            self
        }
        pub fn set_input_file_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_input_file_bucket(input);
            self
        }
        /// <p>The name of input file within the S3 bucket. This file contains a newline delimited
        /// JSON file. Each line contains the parameter values to provision one device
        /// (thing).</p>
        pub fn input_file_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_file_key(input);
            self
        }
        pub fn set_input_file_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_input_file_key(input);
            self
        }
        /// <p>The IAM role ARN that grants permission the input file.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopThingRegistrationTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_thing_registration_task_input::Builder,
    }
    impl<C> StopThingRegistrationTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopThingRegistrationTaskOutput,
            smithy_http::result::SdkError<crate::error::StopThingRegistrationTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bulk thing provisioning task ID.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The new or modified tags for the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestAuthorization<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::test_authorization_input::Builder,
    }
    impl<C> TestAuthorization<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestAuthorizationOutput,
            smithy_http::result::SdkError<crate::error::TestAuthorizationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal(input);
            self
        }
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal(input);
            self
        }
        /// <p>The Cognito identity pool ID.</p>
        pub fn cognito_identity_pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cognito_identity_pool_id(input);
            self
        }
        pub fn set_cognito_identity_pool_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cognito_identity_pool_id(input);
            self
        }
        /// <p>A list of authorization info objects. Simulating authorization will create a response
        /// for each <code>authInfo</code> object in the list.</p>
        pub fn auth_infos(mut self, inp: impl Into<crate::model::AuthInfo>) -> Self {
            self.inner = self.inner.auth_infos(inp);
            self
        }
        pub fn set_auth_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AuthInfo>>,
        ) -> Self {
            self.inner = self.inner.set_auth_infos(input);
            self
        }
        /// <p>The MQTT client ID.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_id(input);
            self
        }
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_id(input);
            self
        }
        /// <p>When testing custom authorization, the policies specified here are treated as if they
        /// are attached to the principal being authorized.</p>
        pub fn policy_names_to_add(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_names_to_add(inp);
            self
        }
        pub fn set_policy_names_to_add(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_names_to_add(input);
            self
        }
        /// <p>When testing custom authorization, the policies specified here are treated as if they
        /// are not attached to the principal being authorized.</p>
        pub fn policy_names_to_skip(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_names_to_skip(inp);
            self
        }
        pub fn set_policy_names_to_skip(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_names_to_skip(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestInvokeAuthorizer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::test_invoke_authorizer_input::Builder,
    }
    impl<C> TestInvokeAuthorizer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestInvokeAuthorizerOutput,
            smithy_http::result::SdkError<crate::error::TestInvokeAuthorizerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The custom authorizer name.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authorizer_name(input);
            self
        }
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authorizer_name(input);
            self
        }
        /// <p>The token returned by your custom authentication service.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token(input);
            self
        }
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token(input);
            self
        }
        /// <p>The signature made with the token and your custom authentication service's private
        /// key. This value must be Base-64-encoded.</p>
        pub fn token_signature(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token_signature(input);
            self
        }
        pub fn set_token_signature(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_token_signature(input);
            self
        }
        /// <p>Specifies a test HTTP authorization request.</p>
        pub fn http_context(mut self, input: crate::model::HttpContext) -> Self {
            self.inner = self.inner.http_context(input);
            self
        }
        pub fn set_http_context(
            mut self,
            input: std::option::Option<crate::model::HttpContext>,
        ) -> Self {
            self.inner = self.inner.set_http_context(input);
            self
        }
        /// <p>Specifies a test MQTT authorization request.</p>
        pub fn mqtt_context(mut self, input: crate::model::MqttContext) -> Self {
            self.inner = self.inner.mqtt_context(input);
            self
        }
        pub fn set_mqtt_context(
            mut self,
            input: std::option::Option<crate::model::MqttContext>,
        ) -> Self {
            self.inner = self.inner.set_mqtt_context(input);
            self
        }
        /// <p>Specifies a test TLS authorization request.</p>
        pub fn tls_context(mut self, input: crate::model::TlsContext) -> Self {
            self.inner = self.inner.tls_context(input);
            self
        }
        pub fn set_tls_context(
            mut self,
            input: std::option::Option<crate::model::TlsContext>,
        ) -> Self {
            self.inner = self.inner.set_tls_context(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TransferCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::transfer_certificate_input::Builder,
    }
    impl<C> TransferCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TransferCertificateOutput,
            smithy_http::result::SdkError<crate::error::TransferCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
        /// certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(input);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
        /// <p>The AWS account.</p>
        pub fn target_aws_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_aws_account(input);
            self
        }
        pub fn set_target_aws_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_aws_account(input);
            self
        }
        /// <p>The transfer message.</p>
        pub fn transfer_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transfer_message(input);
            self
        }
        pub fn set_transfer_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transfer_message(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A list of the keys of the tags to be removed from the resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAccountAuditConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_account_audit_configuration_input::Builder,
    }
    impl<C> UpdateAccountAuditConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAccountAuditConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateAccountAuditConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon
        /// Resource Name
        /// (ARN)
        /// of the role that grants permission
        /// to
        /// AWS IoT to access information about your devices, policies,
        /// certificates,
        /// and other items as required when performing an audit.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>Information about the targets to which audit notifications are sent.</p>
        pub fn audit_notification_target_configurations(
            mut self,
            k: impl Into<crate::model::AuditNotificationType>,
            v: impl Into<crate::model::AuditNotificationTarget>,
        ) -> Self {
            self.inner = self.inner.audit_notification_target_configurations(k, v);
            self
        }
        pub fn set_audit_notification_target_configurations(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::AuditNotificationType,
                    crate::model::AuditNotificationTarget,
                >,
            >,
        ) -> Self {
            self.inner = self
                .inner
                .set_audit_notification_target_configurations(input);
            self
        }
        /// <p>Specifies which audit checks are enabled and disabled for this account. Use
        /// <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those
        /// that are currently enabled.</p>
        /// <p>Some data collection might start immediately when certain checks are enabled.
        /// When a check is disabled, any data collected so far in relation to the check is deleted.</p>
        /// <p>You
        /// cannot
        /// disable a check if
        /// it's
        /// used by any scheduled audit. You must first delete the check from the scheduled audit or
        /// delete the scheduled audit itself.</p>
        /// <p>On the first call to <code>UpdateAccountAuditConfiguration</code>,
        /// this parameter is required and must specify at least one enabled check.</p>
        pub fn audit_check_configurations(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AuditCheckConfiguration>,
        ) -> Self {
            self.inner = self.inner.audit_check_configurations(k, v);
            self
        }
        pub fn set_audit_check_configurations(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::AuditCheckConfiguration,
                >,
            >,
        ) -> Self {
            self.inner = self.inner.set_audit_check_configurations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAuditSuppression<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_audit_suppression_input::Builder,
    }
    impl<C> UpdateAuditSuppression<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAuditSuppressionOutput,
            smithy_http::result::SdkError<crate::error::UpdateAuditSuppressionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An audit check name. Checks must be enabled
        /// for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
        /// of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
        /// to select which checks are enabled.)</p>
        pub fn check_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.check_name(input);
            self
        }
        pub fn set_check_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_check_name(input);
            self
        }
        /// <p>Information that identifies the noncompliant resource.</p>
        pub fn resource_identifier(mut self, input: crate::model::ResourceIdentifier) -> Self {
            self.inner = self.inner.resource_identifier(input);
            self
        }
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<crate::model::ResourceIdentifier>,
        ) -> Self {
            self.inner = self.inner.set_resource_identifier(input);
            self
        }
        /// <p>
        /// The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to.
        /// </p>
        pub fn expiration_date(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.expiration_date(input);
            self
        }
        pub fn set_expiration_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_expiration_date(input);
            self
        }
        /// <p>
        /// Indicates whether a suppression should exist indefinitely or not.
        /// </p>
        pub fn suppress_indefinitely(mut self, input: bool) -> Self {
            self.inner = self.inner.suppress_indefinitely(input);
            self
        }
        pub fn set_suppress_indefinitely(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_suppress_indefinitely(input);
            self
        }
        /// <p>
        /// The description of the audit suppression.
        /// </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAuthorizer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_authorizer_input::Builder,
    }
    impl<C> UpdateAuthorizer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAuthorizerOutput,
            smithy_http::result::SdkError<crate::error::UpdateAuthorizerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The authorizer name.</p>
        pub fn authorizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authorizer_name(input);
            self
        }
        pub fn set_authorizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authorizer_name(input);
            self
        }
        /// <p>The ARN of the authorizer's Lambda function.</p>
        pub fn authorizer_function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authorizer_function_arn(input);
            self
        }
        pub fn set_authorizer_function_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authorizer_function_arn(input);
            self
        }
        /// <p>The key used to extract the token from the HTTP headers. </p>
        pub fn token_key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token_key_name(input);
            self
        }
        pub fn set_token_key_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_token_key_name(input);
            self
        }
        /// <p>The public keys used to verify the token signature.</p>
        pub fn token_signing_public_keys(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.token_signing_public_keys(k, v);
            self
        }
        pub fn set_token_signing_public_keys(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_token_signing_public_keys(input);
            self
        }
        /// <p>The status of the update authorizer request.</p>
        pub fn status(mut self, input: crate::model::AuthorizerStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AuthorizerStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateBillingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_billing_group_input::Builder,
    }
    impl<C> UpdateBillingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateBillingGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateBillingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the billing group.</p>
        pub fn billing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.billing_group_name(input);
            self
        }
        pub fn set_billing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_name(input);
            self
        }
        /// <p>The properties of the billing group.</p>
        pub fn billing_group_properties(
            mut self,
            input: crate::model::BillingGroupProperties,
        ) -> Self {
            self.inner = self.inner.billing_group_properties(input);
            self
        }
        pub fn set_billing_group_properties(
            mut self,
            input: std::option::Option<crate::model::BillingGroupProperties>,
        ) -> Self {
            self.inner = self.inner.set_billing_group_properties(input);
            self
        }
        /// <p>The expected version of the billing group. If the version of the billing group does
        /// not match the expected version specified in the request, the
        /// <code>UpdateBillingGroup</code> request is rejected with a
        /// <code>VersionConflictException</code>.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.inner = self.inner.expected_version(input);
            self
        }
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expected_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCACertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_ca_certificate_input::Builder,
    }
    impl<C> UpdateCACertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCaCertificateOutput,
            smithy_http::result::SdkError<crate::error::UpdateCACertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The CA certificate identifier.</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(input);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
        /// <p>The updated status of the CA certificate.</p>
        /// <p>
        /// <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and
        /// should not be used.</p>
        pub fn new_status(mut self, input: crate::model::CaCertificateStatus) -> Self {
            self.inner = self.inner.new_status(input);
            self
        }
        pub fn set_new_status(
            mut self,
            input: std::option::Option<crate::model::CaCertificateStatus>,
        ) -> Self {
            self.inner = self.inner.set_new_status(input);
            self
        }
        /// <p>The new value for the auto registration status. Valid values are: "ENABLE" or
        /// "DISABLE".</p>
        pub fn new_auto_registration_status(
            mut self,
            input: crate::model::AutoRegistrationStatus,
        ) -> Self {
            self.inner = self.inner.new_auto_registration_status(input);
            self
        }
        pub fn set_new_auto_registration_status(
            mut self,
            input: std::option::Option<crate::model::AutoRegistrationStatus>,
        ) -> Self {
            self.inner = self.inner.set_new_auto_registration_status(input);
            self
        }
        /// <p>Information about the registration configuration.</p>
        pub fn registration_config(mut self, input: crate::model::RegistrationConfig) -> Self {
            self.inner = self.inner.registration_config(input);
            self
        }
        pub fn set_registration_config(
            mut self,
            input: std::option::Option<crate::model::RegistrationConfig>,
        ) -> Self {
            self.inner = self.inner.set_registration_config(input);
            self
        }
        /// <p>If true, removes auto registration.</p>
        pub fn remove_auto_registration(mut self, input: bool) -> Self {
            self.inner = self.inner.remove_auto_registration(input);
            self
        }
        pub fn set_remove_auto_registration(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_remove_auto_registration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_certificate_input::Builder,
    }
    impl<C> UpdateCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCertificateOutput,
            smithy_http::result::SdkError<crate::error::UpdateCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the certificate. (The last part of the certificate ARN contains the
        /// certificate ID.)</p>
        pub fn certificate_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(input);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
        /// <p>The new status.</p>
        /// <p>
        /// <b>Note:</b> Setting the status to PENDING_TRANSFER  or PENDING_ACTIVATION will result
        /// in an exception being thrown. PENDING_TRANSFER and PENDING_ACTIVATION are statuses used internally by AWS IoT. They
        /// are not intended for developer use.</p>
        /// <p>
        /// <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and
        /// should not be used.</p>
        pub fn new_status(mut self, input: crate::model::CertificateStatus) -> Self {
            self.inner = self.inner.new_status(input);
            self
        }
        pub fn set_new_status(
            mut self,
            input: std::option::Option<crate::model::CertificateStatus>,
        ) -> Self {
            self.inner = self.inner.set_new_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCustomMetric<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_custom_metric_input::Builder,
    }
    impl<C> UpdateCustomMetric<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCustomMetricOutput,
            smithy_http::result::SdkError<crate::error::UpdateCustomMetricError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The name of the custom metric.
        /// Cannot be updated. </p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>
        /// Field
        /// represents a friendly name in the console for the custom metric,
        /// it
        /// doesn't have to be unique. Don't use this name as the metric identifier in
        /// the device metric report.
        /// Can
        /// be updated. </p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.display_name(input);
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_display_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDimension<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_dimension_input::Builder,
    }
    impl<C> UpdateDimension<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDimensionOutput,
            smithy_http::result::SdkError<crate::error::UpdateDimensionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
        pub fn string_values(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.string_values(inp);
            self
        }
        pub fn set_string_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_string_values(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDomainConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_domain_configuration_input::Builder,
    }
    impl<C> UpdateDomainConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDomainConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateDomainConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain configuration to be updated.</p>
        pub fn domain_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_configuration_name(input);
            self
        }
        pub fn set_domain_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_domain_configuration_name(input);
            self
        }
        /// <p>An object that specifies the authorization service for a domain.</p>
        pub fn authorizer_config(mut self, input: crate::model::AuthorizerConfig) -> Self {
            self.inner = self.inner.authorizer_config(input);
            self
        }
        pub fn set_authorizer_config(
            mut self,
            input: std::option::Option<crate::model::AuthorizerConfig>,
        ) -> Self {
            self.inner = self.inner.set_authorizer_config(input);
            self
        }
        /// <p>The status to which the domain configuration should be updated.</p>
        pub fn domain_configuration_status(
            mut self,
            input: crate::model::DomainConfigurationStatus,
        ) -> Self {
            self.inner = self.inner.domain_configuration_status(input);
            self
        }
        pub fn set_domain_configuration_status(
            mut self,
            input: std::option::Option<crate::model::DomainConfigurationStatus>,
        ) -> Self {
            self.inner = self.inner.set_domain_configuration_status(input);
            self
        }
        /// <p>Removes the authorization configuration from a domain.</p>
        pub fn remove_authorizer_config(mut self, input: bool) -> Self {
            self.inner = self.inner.remove_authorizer_config(input);
            self
        }
        pub fn set_remove_authorizer_config(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_remove_authorizer_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDynamicThingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_dynamic_thing_group_input::Builder,
    }
    impl<C> UpdateDynamicThingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDynamicThingGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateDynamicThingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the dynamic thing group to update.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_name(input);
            self
        }
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_name(input);
            self
        }
        /// <p>The dynamic thing group properties to update.</p>
        pub fn thing_group_properties(mut self, input: crate::model::ThingGroupProperties) -> Self {
            self.inner = self.inner.thing_group_properties(input);
            self
        }
        pub fn set_thing_group_properties(
            mut self,
            input: std::option::Option<crate::model::ThingGroupProperties>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_properties(input);
            self
        }
        /// <p>The expected version of the dynamic thing group to update.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.inner = self.inner.expected_version(input);
            self
        }
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expected_version(input);
            self
        }
        /// <p>The dynamic thing group index to update.</p>
        /// <note>
        /// <p>Currently one index is supported: 'AWS_Things'.</p>
        /// </note>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>The dynamic thing group search query string to update.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(input);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
        /// <p>The dynamic thing group query version to update.</p>
        /// <note>
        /// <p>Currently one query version is supported: "2017-09-30". If not specified, the
        /// query version defaults to this value.</p>
        /// </note>
        pub fn query_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_version(input);
            self
        }
        pub fn set_query_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateEventConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_event_configurations_input::Builder,
    }
    impl<C> UpdateEventConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateEventConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::UpdateEventConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The new event configuration values.</p>
        pub fn event_configurations(
            mut self,
            k: impl Into<crate::model::EventType>,
            v: impl Into<crate::model::Configuration>,
        ) -> Self {
            self.inner = self.inner.event_configurations(k, v);
            self
        }
        pub fn set_event_configurations(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::EventType, crate::model::Configuration>,
            >,
        ) -> Self {
            self.inner = self.inner.set_event_configurations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateIndexingConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_indexing_configuration_input::Builder,
    }
    impl<C> UpdateIndexingConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateIndexingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateIndexingConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Thing indexing configuration.</p>
        pub fn thing_indexing_configuration(
            mut self,
            input: crate::model::ThingIndexingConfiguration,
        ) -> Self {
            self.inner = self.inner.thing_indexing_configuration(input);
            self
        }
        pub fn set_thing_indexing_configuration(
            mut self,
            input: std::option::Option<crate::model::ThingIndexingConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_thing_indexing_configuration(input);
            self
        }
        /// <p>Thing group indexing configuration.</p>
        pub fn thing_group_indexing_configuration(
            mut self,
            input: crate::model::ThingGroupIndexingConfiguration,
        ) -> Self {
            self.inner = self.inner.thing_group_indexing_configuration(input);
            self
        }
        pub fn set_thing_group_indexing_configuration(
            mut self,
            input: std::option::Option<crate::model::ThingGroupIndexingConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_indexing_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_job_input::Builder,
    }
    impl<C> UpdateJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateJobOutput,
            smithy_http::result::SdkError<crate::error::UpdateJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the job to be updated.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>A short text description of the job.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Configuration information for pre-signed S3 URLs.</p>
        pub fn presigned_url_config(mut self, input: crate::model::PresignedUrlConfig) -> Self {
            self.inner = self.inner.presigned_url_config(input);
            self
        }
        pub fn set_presigned_url_config(
            mut self,
            input: std::option::Option<crate::model::PresignedUrlConfig>,
        ) -> Self {
            self.inner = self.inner.set_presigned_url_config(input);
            self
        }
        /// <p>Allows you to create a staged rollout of the job.</p>
        pub fn job_executions_rollout_config(
            mut self,
            input: crate::model::JobExecutionsRolloutConfig,
        ) -> Self {
            self.inner = self.inner.job_executions_rollout_config(input);
            self
        }
        pub fn set_job_executions_rollout_config(
            mut self,
            input: std::option::Option<crate::model::JobExecutionsRolloutConfig>,
        ) -> Self {
            self.inner = self.inner.set_job_executions_rollout_config(input);
            self
        }
        /// <p>Allows you to create criteria to abort a job.</p>
        pub fn abort_config(mut self, input: crate::model::AbortConfig) -> Self {
            self.inner = self.inner.abort_config(input);
            self
        }
        pub fn set_abort_config(
            mut self,
            input: std::option::Option<crate::model::AbortConfig>,
        ) -> Self {
            self.inner = self.inner.set_abort_config(input);
            self
        }
        /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>.
        /// If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>. </p>
        pub fn timeout_config(mut self, input: crate::model::TimeoutConfig) -> Self {
            self.inner = self.inner.timeout_config(input);
            self
        }
        pub fn set_timeout_config(
            mut self,
            input: std::option::Option<crate::model::TimeoutConfig>,
        ) -> Self {
            self.inner = self.inner.set_timeout_config(input);
            self
        }
        /// <p>The namespace used to indicate that a job is a customer-managed job.</p>
        /// <p>When you specify a value for this parameter, AWS IoT Core sends jobs notifications to MQTT topics that
        /// contain the value in the following format.</p>
        /// <p>
        /// <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
        /// </p>
        /// <note>
        /// <p>The <code>namespaceId</code> feature is in public preview.</p>
        /// </note>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace_id(input);
            self
        }
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateMitigationAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_mitigation_action_input::Builder,
    }
    impl<C> UpdateMitigationAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateMitigationActionOutput,
            smithy_http::result::SdkError<crate::error::UpdateMitigationActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The friendly name for the mitigation action. You cannot change the name by using
        /// <code>UpdateMitigationAction</code>. Instead, you must delete and
        /// recreate the
        /// mitigation action with the new name.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action_name(input);
            self
        }
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_action_name(input);
            self
        }
        /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>Defines the type of action and the parameters for that action.</p>
        pub fn action_params(mut self, input: crate::model::MitigationActionParams) -> Self {
            self.inner = self.inner.action_params(input);
            self
        }
        pub fn set_action_params(
            mut self,
            input: std::option::Option<crate::model::MitigationActionParams>,
        ) -> Self {
            self.inner = self.inner.set_action_params(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateProvisioningTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_provisioning_template_input::Builder,
    }
    impl<C> UpdateProvisioningTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateProvisioningTemplateOutput,
            smithy_http::result::SdkError<crate::error::UpdateProvisioningTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the fleet provisioning template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.template_name(input);
            self
        }
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_template_name(input);
            self
        }
        /// <p>The description of the fleet provisioning template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>True to enable the fleet provisioning template, otherwise false.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enabled(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(input);
            self
        }
        /// <p>The ID of the default provisioning template version.</p>
        pub fn default_version_id(mut self, input: i32) -> Self {
            self.inner = self.inner.default_version_id(input);
            self
        }
        pub fn set_default_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_default_version_id(input);
            self
        }
        /// <p>The ARN of the role associated with the provisioning template. This IoT role grants
        /// permission to provision a device.</p>
        pub fn provisioning_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.provisioning_role_arn(input);
            self
        }
        pub fn set_provisioning_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_provisioning_role_arn(input);
            self
        }
        /// <p>Updates the pre-provisioning hook template.</p>
        pub fn pre_provisioning_hook(mut self, input: crate::model::ProvisioningHook) -> Self {
            self.inner = self.inner.pre_provisioning_hook(input);
            self
        }
        pub fn set_pre_provisioning_hook(
            mut self,
            input: std::option::Option<crate::model::ProvisioningHook>,
        ) -> Self {
            self.inner = self.inner.set_pre_provisioning_hook(input);
            self
        }
        /// <p>Removes pre-provisioning hook template.</p>
        pub fn remove_pre_provisioning_hook(mut self, input: bool) -> Self {
            self.inner = self.inner.remove_pre_provisioning_hook(input);
            self
        }
        pub fn set_remove_pre_provisioning_hook(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_remove_pre_provisioning_hook(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRoleAlias<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_role_alias_input::Builder,
    }
    impl<C> UpdateRoleAlias<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRoleAliasOutput,
            smithy_http::result::SdkError<crate::error::UpdateRoleAliasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The role alias to update.</p>
        pub fn role_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_alias(input);
            self
        }
        pub fn set_role_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_alias(input);
            self
        }
        /// <p>The role ARN.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The number of seconds the credential will be valid.</p>
        pub fn credential_duration_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.credential_duration_seconds(input);
            self
        }
        pub fn set_credential_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_credential_duration_seconds(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateScheduledAudit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_scheduled_audit_input::Builder,
    }
    impl<C> UpdateScheduledAudit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateScheduledAuditOutput,
            smithy_http::result::SdkError<crate::error::UpdateScheduledAuditError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>How often the scheduled audit takes
        /// place,
        /// either <code>DAILY</code>,
        /// <code>WEEKLY</code>, <code>BIWEEKLY</code>, or <code>MONTHLY</code>. The start time of each audit is determined by the
        /// system.</p>
        pub fn frequency(mut self, input: crate::model::AuditFrequency) -> Self {
            self.inner = self.inner.frequency(input);
            self
        }
        pub fn set_frequency(
            mut self,
            input: std::option::Option<crate::model::AuditFrequency>,
        ) -> Self {
            self.inner = self.inner.set_frequency(input);
            self
        }
        /// <p>The day of the month on which the scheduled audit takes place.
        /// This
        /// can
        /// be <code>1</code> through <code>31</code> or <code>LAST</code>. This field is required if the <code>frequency</code> parameter is set to
        /// <code>MONTHLY</code>. If days 29-31 are specified, and the month does not have that many days, the audit
        /// takes place on the "LAST" day of the month.</p>
        pub fn day_of_month(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.day_of_month(input);
            self
        }
        pub fn set_day_of_month(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_day_of_month(input);
            self
        }
        /// <p>The day of the week on which the scheduled audit takes place.
        /// This
        /// can
        /// be one of <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the
        /// "frequency" parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
        pub fn day_of_week(mut self, input: crate::model::DayOfWeek) -> Self {
            self.inner = self.inner.day_of_week(input);
            self
        }
        pub fn set_day_of_week(
            mut self,
            input: std::option::Option<crate::model::DayOfWeek>,
        ) -> Self {
            self.inner = self.inner.set_day_of_week(input);
            self
        }
        /// <p>Which checks are performed during the scheduled audit. Checks must be enabled
        /// for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
        /// of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
        /// to select which checks are enabled.)</p>
        pub fn target_check_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_check_names(inp);
            self
        }
        pub fn set_target_check_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_target_check_names(input);
            self
        }
        /// <p>The name of the scheduled audit. (Max. 128 chars)</p>
        pub fn scheduled_audit_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_audit_name(input);
            self
        }
        pub fn set_scheduled_audit_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_audit_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSecurityProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_security_profile_input::Builder,
    }
    impl<C> UpdateSecurityProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSecurityProfileOutput,
            smithy_http::result::SdkError<crate::error::UpdateSecurityProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the security profile you want to update.</p>
        pub fn security_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_profile_name(input);
            self
        }
        pub fn set_security_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_name(input);
            self
        }
        /// <p>A description of the security profile.</p>
        pub fn security_profile_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.security_profile_description(input);
            self
        }
        pub fn set_security_profile_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_profile_description(input);
            self
        }
        /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
        pub fn behaviors(mut self, inp: impl Into<crate::model::Behavior>) -> Self {
            self.inner = self.inner.behaviors(inp);
            self
        }
        pub fn set_behaviors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
        ) -> Self {
            self.inner = self.inner.set_behaviors(input);
            self
        }
        /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
        pub fn alert_targets(
            mut self,
            k: impl Into<crate::model::AlertTargetType>,
            v: impl Into<crate::model::AlertTarget>,
        ) -> Self {
            self.inner = self.inner.alert_targets(k, v);
            self
        }
        pub fn set_alert_targets(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::AlertTargetType, crate::model::AlertTarget>,
            >,
        ) -> Self {
            self.inner = self.inner.set_alert_targets(input);
            self
        }
        /// <p>
        /// <i>Please use
        /// <a>UpdateSecurityProfileRequest$additionalMetricsToRetainV2</a>
        /// instead.</i>
        /// </p>
        /// <p>A list of metrics
        /// whose data is retained (stored). By default, data is retained for any metric
        /// used in the profile's <code>behaviors</code>, but
        /// it is
        /// also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn additional_metrics_to_retain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.additional_metrics_to_retain(inp);
            self
        }
        pub fn set_additional_metrics_to_retain(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_additional_metrics_to_retain(input);
            self
        }
        /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
        pub fn additional_metrics_to_retain_v2(
            mut self,
            inp: impl Into<crate::model::MetricToRetain>,
        ) -> Self {
            self.inner = self.inner.additional_metrics_to_retain_v2(inp);
            self
        }
        pub fn set_additional_metrics_to_retain_v2(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricToRetain>>,
        ) -> Self {
            self.inner = self.inner.set_additional_metrics_to_retain_v2(input);
            self
        }
        /// <p>If true, delete all <code>behaviors</code> defined for this security profile.
        /// If any <code>behaviors</code> are defined in the current invocation, an exception occurs.</p>
        pub fn delete_behaviors(mut self, input: bool) -> Self {
            self.inner = self.inner.delete_behaviors(input);
            self
        }
        pub fn set_delete_behaviors(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_delete_behaviors(input);
            self
        }
        /// <p>If true, delete all <code>alertTargets</code> defined for this security profile.
        /// If any <code>alertTargets</code> are defined in the current invocation, an exception occurs.</p>
        pub fn delete_alert_targets(mut self, input: bool) -> Self {
            self.inner = self.inner.delete_alert_targets(input);
            self
        }
        pub fn set_delete_alert_targets(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_delete_alert_targets(input);
            self
        }
        /// <p>If true, delete all <code>additionalMetricsToRetain</code> defined for this
        /// security profile. If any <code>additionalMetricsToRetain</code> are defined in the current
        /// invocation, an exception occurs.</p>
        pub fn delete_additional_metrics_to_retain(mut self, input: bool) -> Self {
            self.inner = self.inner.delete_additional_metrics_to_retain(input);
            self
        }
        pub fn set_delete_additional_metrics_to_retain(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_delete_additional_metrics_to_retain(input);
            self
        }
        /// <p>The expected version of the security profile. A new version is generated whenever
        /// the security profile is updated. If you specify a value that is different from the actual
        /// version, a <code>VersionConflictException</code> is thrown.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.inner = self.inner.expected_version(input);
            self
        }
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expected_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_stream_input::Builder,
    }
    impl<C> UpdateStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateStreamOutput,
            smithy_http::result::SdkError<crate::error::UpdateStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_id(input);
            self
        }
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_id(input);
            self
        }
        /// <p>The description of the stream.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The files associated with the stream.</p>
        pub fn files(mut self, inp: impl Into<crate::model::StreamFile>) -> Self {
            self.inner = self.inner.files(inp);
            self
        }
        pub fn set_files(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamFile>>,
        ) -> Self {
            self.inner = self.inner.set_files(input);
            self
        }
        /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateThing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_thing_input::Builder,
    }
    impl<C> UpdateThing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateThingOutput,
            smithy_http::result::SdkError<crate::error::UpdateThingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the thing to update.</p>
        /// <p>You can't change a thing's name. To change a thing's name, you must create a
        /// new thing, give it the new name, and then delete the old thing.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>The name of the thing type.</p>
        pub fn thing_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_type_name(input);
            self
        }
        pub fn set_thing_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_type_name(input);
            self
        }
        /// <p>A list of thing attributes, a JSON string containing name-value pairs. For
        /// example:</p>
        /// <p>
        /// <code>{\"attributes\":{\"name1\":\"value2\"}}</code>
        /// </p>
        /// <p>This data is used to add new attributes or update existing attributes.</p>
        pub fn attribute_payload(mut self, input: crate::model::AttributePayload) -> Self {
            self.inner = self.inner.attribute_payload(input);
            self
        }
        pub fn set_attribute_payload(
            mut self,
            input: std::option::Option<crate::model::AttributePayload>,
        ) -> Self {
            self.inner = self.inner.set_attribute_payload(input);
            self
        }
        /// <p>The expected version of the thing record in the registry. If the version of the
        /// record in the registry does not match the expected version specified in the request, the
        /// <code>UpdateThing</code> request is rejected with a
        /// <code>VersionConflictException</code>.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.inner = self.inner.expected_version(input);
            self
        }
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expected_version(input);
            self
        }
        /// <p>Remove a thing type association. If <b>true</b>, the
        /// association is removed.</p>
        pub fn remove_thing_type(mut self, input: bool) -> Self {
            self.inner = self.inner.remove_thing_type(input);
            self
        }
        pub fn set_remove_thing_type(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_remove_thing_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateThingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_thing_group_input::Builder,
    }
    impl<C> UpdateThingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateThingGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateThingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The thing group to update.</p>
        pub fn thing_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_group_name(input);
            self
        }
        pub fn set_thing_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_name(input);
            self
        }
        /// <p>The thing group properties.</p>
        pub fn thing_group_properties(mut self, input: crate::model::ThingGroupProperties) -> Self {
            self.inner = self.inner.thing_group_properties(input);
            self
        }
        pub fn set_thing_group_properties(
            mut self,
            input: std::option::Option<crate::model::ThingGroupProperties>,
        ) -> Self {
            self.inner = self.inner.set_thing_group_properties(input);
            self
        }
        /// <p>The expected version of the thing group. If this does not match the version of the
        /// thing group being updated, the update will fail.</p>
        pub fn expected_version(mut self, input: i64) -> Self {
            self.inner = self.inner.expected_version(input);
            self
        }
        pub fn set_expected_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expected_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateThingGroupsForThing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_thing_groups_for_thing_input::Builder,
    }
    impl<C> UpdateThingGroupsForThing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateThingGroupsForThingOutput,
            smithy_http::result::SdkError<crate::error::UpdateThingGroupsForThingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The thing whose group memberships will be updated.</p>
        pub fn thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_name(input);
            self
        }
        pub fn set_thing_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_thing_name(input);
            self
        }
        /// <p>The groups to which the thing will be added.</p>
        pub fn thing_groups_to_add(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_groups_to_add(inp);
            self
        }
        pub fn set_thing_groups_to_add(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_thing_groups_to_add(input);
            self
        }
        /// <p>The groups from which the thing will be removed.</p>
        pub fn thing_groups_to_remove(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.thing_groups_to_remove(inp);
            self
        }
        pub fn set_thing_groups_to_remove(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_thing_groups_to_remove(input);
            self
        }
        /// <p>Override dynamic thing groups with static thing groups when 10-group limit is
        /// reached. If a thing belongs to 10 thing groups, and one or more of those groups are
        /// dynamic thing groups, adding a thing to a static group removes the thing from the last
        /// dynamic group.</p>
        pub fn override_dynamic_groups(mut self, input: bool) -> Self {
            self.inner = self.inner.override_dynamic_groups(input);
            self
        }
        pub fn set_override_dynamic_groups(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_override_dynamic_groups(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTopicRuleDestination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_topic_rule_destination_input::Builder,
    }
    impl<C> UpdateTopicRuleDestination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTopicRuleDestinationOutput,
            smithy_http::result::SdkError<crate::error::UpdateTopicRuleDestinationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the topic rule destination.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The status of the topic rule destination. Valid values are:</p>
        /// <dl>
        /// <dt>IN_PROGRESS</dt>
        /// <dd>
        /// <p>A topic rule destination was created but has not been confirmed. You can set
        /// <code>status</code> to <code>IN_PROGRESS</code> by calling
        /// <code>UpdateTopicRuleDestination</code>. Calling
        /// <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
        /// be sent to your confirmation endpoint.</p>
        /// </dd>
        /// <dt>ENABLED</dt>
        /// <dd>
        /// <p>Confirmation was completed, and traffic to this destination is allowed. You can
        /// set <code>status</code> to <code>DISABLED</code> by calling
        /// <code>UpdateTopicRuleDestination</code>.</p>
        /// </dd>
        /// <dt>DISABLED</dt>
        /// <dd>
        /// <p>Confirmation was completed, and traffic to this destination is not allowed. You
        /// can set <code>status</code> to <code>ENABLED</code> by calling
        /// <code>UpdateTopicRuleDestination</code>.</p>
        /// </dd>
        /// <dt>ERROR</dt>
        /// <dd>
        /// <p>Confirmation could not be completed, for example if the confirmation timed out.
        /// You can call <code>GetTopicRuleDestination</code> for details about the error. You
        /// can set <code>status</code> to <code>IN_PROGRESS</code> by calling
        /// <code>UpdateTopicRuleDestination</code>. Calling
        /// <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
        /// be sent to your confirmation endpoint.</p>
        /// </dd>
        /// </dl>
        pub fn status(mut self, input: crate::model::TopicRuleDestinationStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TopicRuleDestinationStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ValidateSecurityProfileBehaviors<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::validate_security_profile_behaviors_input::Builder,
    }
    impl<C> ValidateSecurityProfileBehaviors<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ValidateSecurityProfileBehaviorsOutput,
            smithy_http::result::SdkError<crate::error::ValidateSecurityProfileBehaviorsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
        pub fn behaviors(mut self, inp: impl Into<crate::model::Behavior>) -> Self {
            self.inner = self.inner.behaviors(inp);
            self
        }
        pub fn set_behaviors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Behavior>>,
        ) -> Self {
            self.inner = self.inner.set_behaviors(input);
            self
        }
    }
}
