// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The job summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobSummary {
    /// <p>The job ARN.</p>
    #[doc(hidden)]
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The ID of the thing group.</p>
    #[doc(hidden)]
    pub thing_group_id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p> <note>
    /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
    /// </note>
    #[doc(hidden)]
    pub target_selection: std::option::Option<crate::types::TargetSelection>,
    /// <p>The job summary status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::JobStatus>,
    /// <p>The time, in seconds since the epoch, when the job was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time, in seconds since the epoch, when the job was last updated.</p>
    #[doc(hidden)]
    pub last_updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time, in seconds since the epoch, when the job completed.</p>
    #[doc(hidden)]
    pub completed_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates whether a job is concurrent. Will be true when a job is rolling out new job executions or canceling previously created executions, otherwise false.</p>
    #[doc(hidden)]
    pub is_concurrent: std::option::Option<bool>,
}
impl JobSummary {
    /// <p>The job ARN.</p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The ID of the thing group.</p>
    pub fn thing_group_id(&self) -> std::option::Option<&str> {
        self.thing_group_id.as_deref()
    }
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p> <note>
    /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
    /// </note>
    pub fn target_selection(&self) -> std::option::Option<&crate::types::TargetSelection> {
        self.target_selection.as_ref()
    }
    /// <p>The job summary status.</p>
    pub fn status(&self) -> std::option::Option<&crate::types::JobStatus> {
        self.status.as_ref()
    }
    /// <p>The time, in seconds since the epoch, when the job was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The time, in seconds since the epoch, when the job was last updated.</p>
    pub fn last_updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_at.as_ref()
    }
    /// <p>The time, in seconds since the epoch, when the job completed.</p>
    pub fn completed_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.completed_at.as_ref()
    }
    /// <p>Indicates whether a job is concurrent. Will be true when a job is rolling out new job executions or canceling previously created executions, otherwise false.</p>
    pub fn is_concurrent(&self) -> std::option::Option<bool> {
        self.is_concurrent
    }
}
impl JobSummary {
    /// Creates a new builder-style object to manufacture [`JobSummary`](crate::types::JobSummary).
    pub fn builder() -> crate::types::builders::JobSummaryBuilder {
        crate::types::builders::JobSummaryBuilder::default()
    }
}

/// A builder for [`JobSummary`](crate::types::JobSummary).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct JobSummaryBuilder {
    pub(crate) job_arn: std::option::Option<std::string::String>,
    pub(crate) job_id: std::option::Option<std::string::String>,
    pub(crate) thing_group_id: std::option::Option<std::string::String>,
    pub(crate) target_selection: std::option::Option<crate::types::TargetSelection>,
    pub(crate) status: std::option::Option<crate::types::JobStatus>,
    pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) last_updated_at: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) completed_at: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) is_concurrent: std::option::Option<bool>,
}
impl JobSummaryBuilder {
    /// <p>The job ARN.</p>
    pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.job_arn = Some(input.into());
        self
    }
    /// <p>The job ARN.</p>
    pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.job_arn = input;
        self
    }
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.job_id = Some(input.into());
        self
    }
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.job_id = input;
        self
    }
    /// <p>The ID of the thing group.</p>
    pub fn thing_group_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.thing_group_id = Some(input.into());
        self
    }
    /// <p>The ID of the thing group.</p>
    pub fn set_thing_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.thing_group_id = input;
        self
    }
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p> <note>
    /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
    /// </note>
    pub fn target_selection(mut self, input: crate::types::TargetSelection) -> Self {
        self.target_selection = Some(input);
        self
    }
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p> <note>
    /// <p>We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.</p>
    /// </note>
    pub fn set_target_selection(
        mut self,
        input: std::option::Option<crate::types::TargetSelection>,
    ) -> Self {
        self.target_selection = input;
        self
    }
    /// <p>The job summary status.</p>
    pub fn status(mut self, input: crate::types::JobStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>The job summary status.</p>
    pub fn set_status(mut self, input: std::option::Option<crate::types::JobStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The time, in seconds since the epoch, when the job was created.</p>
    pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.created_at = Some(input);
        self
    }
    /// <p>The time, in seconds since the epoch, when the job was created.</p>
    pub fn set_created_at(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The time, in seconds since the epoch, when the job was last updated.</p>
    pub fn last_updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.last_updated_at = Some(input);
        self
    }
    /// <p>The time, in seconds since the epoch, when the job was last updated.</p>
    pub fn set_last_updated_at(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.last_updated_at = input;
        self
    }
    /// <p>The time, in seconds since the epoch, when the job completed.</p>
    pub fn completed_at(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.completed_at = Some(input);
        self
    }
    /// <p>The time, in seconds since the epoch, when the job completed.</p>
    pub fn set_completed_at(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.completed_at = input;
        self
    }
    /// <p>Indicates whether a job is concurrent. Will be true when a job is rolling out new job executions or canceling previously created executions, otherwise false.</p>
    pub fn is_concurrent(mut self, input: bool) -> Self {
        self.is_concurrent = Some(input);
        self
    }
    /// <p>Indicates whether a job is concurrent. Will be true when a job is rolling out new job executions or canceling previously created executions, otherwise false.</p>
    pub fn set_is_concurrent(mut self, input: std::option::Option<bool>) -> Self {
        self.is_concurrent = input;
        self
    }
    /// Consumes the builder and constructs a [`JobSummary`](crate::types::JobSummary).
    pub fn build(self) -> crate::types::JobSummary {
        crate::types::JobSummary {
            job_arn: self.job_arn,
            job_id: self.job_id,
            thing_group_id: self.thing_group_id,
            target_selection: self.target_selection,
            status: self.status,
            created_at: self.created_at,
            last_updated_at: self.last_updated_at,
            completed_at: self.completed_at,
            is_concurrent: self.is_concurrent,
        }
    }
}
