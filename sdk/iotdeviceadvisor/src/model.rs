// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Gets the suite definition configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuiteDefinitionConfiguration {
    /// <p>Gets the suite definition name. This is a required parameter.</p>
    #[doc(hidden)]
    pub suite_definition_name: std::option::Option<std::string::String>,
    /// <p>Gets the devices configured.</p>
    #[doc(hidden)]
    pub devices: std::option::Option<std::vec::Vec<crate::model::DeviceUnderTest>>,
    /// <p>Gets the tests intended for qualification in a suite.</p>
    #[doc(hidden)]
    pub intended_for_qualification: bool,
    /// <p>Verifies if the test suite is a long duration test.</p>
    #[doc(hidden)]
    pub is_long_duration_test: bool,
    /// <p>Gets the test suite root group. This is a required parameter.</p>
    #[doc(hidden)]
    pub root_group: std::option::Option<std::string::String>,
    /// <p>Gets the device permission ARN. This is a required parameter.</p>
    #[doc(hidden)]
    pub device_permission_role_arn: std::option::Option<std::string::String>,
    /// <p>Sets the MQTT protocol that is configured in the suite definition.</p>
    #[doc(hidden)]
    pub protocol: std::option::Option<crate::model::Protocol>,
}
impl SuiteDefinitionConfiguration {
    /// <p>Gets the suite definition name. This is a required parameter.</p>
    pub fn suite_definition_name(&self) -> std::option::Option<&str> {
        self.suite_definition_name.as_deref()
    }
    /// <p>Gets the devices configured.</p>
    pub fn devices(&self) -> std::option::Option<&[crate::model::DeviceUnderTest]> {
        self.devices.as_deref()
    }
    /// <p>Gets the tests intended for qualification in a suite.</p>
    pub fn intended_for_qualification(&self) -> bool {
        self.intended_for_qualification
    }
    /// <p>Verifies if the test suite is a long duration test.</p>
    pub fn is_long_duration_test(&self) -> bool {
        self.is_long_duration_test
    }
    /// <p>Gets the test suite root group. This is a required parameter.</p>
    pub fn root_group(&self) -> std::option::Option<&str> {
        self.root_group.as_deref()
    }
    /// <p>Gets the device permission ARN. This is a required parameter.</p>
    pub fn device_permission_role_arn(&self) -> std::option::Option<&str> {
        self.device_permission_role_arn.as_deref()
    }
    /// <p>Sets the MQTT protocol that is configured in the suite definition.</p>
    pub fn protocol(&self) -> std::option::Option<&crate::model::Protocol> {
        self.protocol.as_ref()
    }
}
impl SuiteDefinitionConfiguration {
    /// Creates a new builder-style object to manufacture [`SuiteDefinitionConfiguration`](crate::model::SuiteDefinitionConfiguration).
    pub fn builder() -> crate::model::suite_definition_configuration::Builder {
        crate::model::suite_definition_configuration::Builder::default()
    }
}

/// See [`SuiteDefinitionConfiguration`](crate::model::SuiteDefinitionConfiguration).
pub mod suite_definition_configuration {

    /// A builder for [`SuiteDefinitionConfiguration`](crate::model::SuiteDefinitionConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) suite_definition_name: std::option::Option<std::string::String>,
        pub(crate) devices: std::option::Option<std::vec::Vec<crate::model::DeviceUnderTest>>,
        pub(crate) intended_for_qualification: std::option::Option<bool>,
        pub(crate) is_long_duration_test: std::option::Option<bool>,
        pub(crate) root_group: std::option::Option<std::string::String>,
        pub(crate) device_permission_role_arn: std::option::Option<std::string::String>,
        pub(crate) protocol: std::option::Option<crate::model::Protocol>,
    }
    impl Builder {
        /// <p>Gets the suite definition name. This is a required parameter.</p>
        pub fn suite_definition_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.suite_definition_name = Some(input.into());
            self
        }
        /// <p>Gets the suite definition name. This is a required parameter.</p>
        pub fn set_suite_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.suite_definition_name = input;
            self
        }
        /// Appends an item to `devices`.
        ///
        /// To override the contents of this collection use [`set_devices`](Self::set_devices).
        ///
        /// <p>Gets the devices configured.</p>
        pub fn devices(mut self, input: crate::model::DeviceUnderTest) -> Self {
            let mut v = self.devices.unwrap_or_default();
            v.push(input);
            self.devices = Some(v);
            self
        }
        /// <p>Gets the devices configured.</p>
        pub fn set_devices(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DeviceUnderTest>>,
        ) -> Self {
            self.devices = input;
            self
        }
        /// <p>Gets the tests intended for qualification in a suite.</p>
        pub fn intended_for_qualification(mut self, input: bool) -> Self {
            self.intended_for_qualification = Some(input);
            self
        }
        /// <p>Gets the tests intended for qualification in a suite.</p>
        pub fn set_intended_for_qualification(mut self, input: std::option::Option<bool>) -> Self {
            self.intended_for_qualification = input;
            self
        }
        /// <p>Verifies if the test suite is a long duration test.</p>
        pub fn is_long_duration_test(mut self, input: bool) -> Self {
            self.is_long_duration_test = Some(input);
            self
        }
        /// <p>Verifies if the test suite is a long duration test.</p>
        pub fn set_is_long_duration_test(mut self, input: std::option::Option<bool>) -> Self {
            self.is_long_duration_test = input;
            self
        }
        /// <p>Gets the test suite root group. This is a required parameter.</p>
        pub fn root_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.root_group = Some(input.into());
            self
        }
        /// <p>Gets the test suite root group. This is a required parameter.</p>
        pub fn set_root_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.root_group = input;
            self
        }
        /// <p>Gets the device permission ARN. This is a required parameter.</p>
        pub fn device_permission_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_permission_role_arn = Some(input.into());
            self
        }
        /// <p>Gets the device permission ARN. This is a required parameter.</p>
        pub fn set_device_permission_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.device_permission_role_arn = input;
            self
        }
        /// <p>Sets the MQTT protocol that is configured in the suite definition.</p>
        pub fn protocol(mut self, input: crate::model::Protocol) -> Self {
            self.protocol = Some(input);
            self
        }
        /// <p>Sets the MQTT protocol that is configured in the suite definition.</p>
        pub fn set_protocol(mut self, input: std::option::Option<crate::model::Protocol>) -> Self {
            self.protocol = input;
            self
        }
        /// Consumes the builder and constructs a [`SuiteDefinitionConfiguration`](crate::model::SuiteDefinitionConfiguration).
        pub fn build(self) -> crate::model::SuiteDefinitionConfiguration {
            crate::model::SuiteDefinitionConfiguration {
                suite_definition_name: self.suite_definition_name,
                devices: self.devices,
                intended_for_qualification: self.intended_for_qualification.unwrap_or_default(),
                is_long_duration_test: self.is_long_duration_test.unwrap_or_default(),
                root_group: self.root_group,
                device_permission_role_arn: self.device_permission_role_arn,
                protocol: self.protocol,
            }
        }
    }
}

/// When writing a match expression against `Protocol`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let protocol = unimplemented!();
/// match protocol {
///     Protocol::MqttV311 => { /* ... */ },
///     Protocol::MqttV5 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `protocol` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Protocol::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Protocol::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Protocol::NewFeature` is defined.
/// Specifically, when `protocol` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Protocol::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Protocol {
    #[allow(missing_docs)] // documentation missing in model
    MqttV311,
    #[allow(missing_docs)] // documentation missing in model
    MqttV5,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Protocol {
    fn from(s: &str) -> Self {
        match s {
            "MqttV3_1_1" => Protocol::MqttV311,
            "MqttV5" => Protocol::MqttV5,
            other => Protocol::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Protocol {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Protocol::from(s))
    }
}
impl Protocol {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Protocol::MqttV311 => "MqttV3_1_1",
            Protocol::MqttV5 => "MqttV5",
            Protocol::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MqttV3_1_1", "MqttV5"]
    }
}
impl AsRef<str> for Protocol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information of a test device. A thing ARN or a certificate ARN is required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeviceUnderTest {
    /// <p>Lists devices thing ARN.</p>
    #[doc(hidden)]
    pub thing_arn: std::option::Option<std::string::String>,
    /// <p>Lists devices certificate ARN.</p>
    #[doc(hidden)]
    pub certificate_arn: std::option::Option<std::string::String>,
}
impl DeviceUnderTest {
    /// <p>Lists devices thing ARN.</p>
    pub fn thing_arn(&self) -> std::option::Option<&str> {
        self.thing_arn.as_deref()
    }
    /// <p>Lists devices certificate ARN.</p>
    pub fn certificate_arn(&self) -> std::option::Option<&str> {
        self.certificate_arn.as_deref()
    }
}
impl DeviceUnderTest {
    /// Creates a new builder-style object to manufacture [`DeviceUnderTest`](crate::model::DeviceUnderTest).
    pub fn builder() -> crate::model::device_under_test::Builder {
        crate::model::device_under_test::Builder::default()
    }
}

/// See [`DeviceUnderTest`](crate::model::DeviceUnderTest).
pub mod device_under_test {

    /// A builder for [`DeviceUnderTest`](crate::model::DeviceUnderTest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) thing_arn: std::option::Option<std::string::String>,
        pub(crate) certificate_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Lists devices thing ARN.</p>
        pub fn thing_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_arn = Some(input.into());
            self
        }
        /// <p>Lists devices thing ARN.</p>
        pub fn set_thing_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_arn = input;
            self
        }
        /// <p>Lists devices certificate ARN.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_arn = Some(input.into());
            self
        }
        /// <p>Lists devices certificate ARN.</p>
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceUnderTest`](crate::model::DeviceUnderTest).
        pub fn build(self) -> crate::model::DeviceUnderTest {
            crate::model::DeviceUnderTest {
                thing_arn: self.thing_arn,
                certificate_arn: self.certificate_arn,
            }
        }
    }
}

/// <p>Gets suite run configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuiteRunConfiguration {
    /// <p>Sets the primary device for the test suite run. This requires a thing ARN or a certificate ARN.</p>
    #[doc(hidden)]
    pub primary_device: std::option::Option<crate::model::DeviceUnderTest>,
    /// <p>Sets test case list.</p>
    #[doc(hidden)]
    pub selected_test_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>TRUE if multiple test suites run in parallel.</p>
    #[doc(hidden)]
    pub parallel_run: bool,
}
impl SuiteRunConfiguration {
    /// <p>Sets the primary device for the test suite run. This requires a thing ARN or a certificate ARN.</p>
    pub fn primary_device(&self) -> std::option::Option<&crate::model::DeviceUnderTest> {
        self.primary_device.as_ref()
    }
    /// <p>Sets test case list.</p>
    pub fn selected_test_list(&self) -> std::option::Option<&[std::string::String]> {
        self.selected_test_list.as_deref()
    }
    /// <p>TRUE if multiple test suites run in parallel.</p>
    pub fn parallel_run(&self) -> bool {
        self.parallel_run
    }
}
impl SuiteRunConfiguration {
    /// Creates a new builder-style object to manufacture [`SuiteRunConfiguration`](crate::model::SuiteRunConfiguration).
    pub fn builder() -> crate::model::suite_run_configuration::Builder {
        crate::model::suite_run_configuration::Builder::default()
    }
}

/// See [`SuiteRunConfiguration`](crate::model::SuiteRunConfiguration).
pub mod suite_run_configuration {

    /// A builder for [`SuiteRunConfiguration`](crate::model::SuiteRunConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) primary_device: std::option::Option<crate::model::DeviceUnderTest>,
        pub(crate) selected_test_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) parallel_run: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Sets the primary device for the test suite run. This requires a thing ARN or a certificate ARN.</p>
        pub fn primary_device(mut self, input: crate::model::DeviceUnderTest) -> Self {
            self.primary_device = Some(input);
            self
        }
        /// <p>Sets the primary device for the test suite run. This requires a thing ARN or a certificate ARN.</p>
        pub fn set_primary_device(
            mut self,
            input: std::option::Option<crate::model::DeviceUnderTest>,
        ) -> Self {
            self.primary_device = input;
            self
        }
        /// Appends an item to `selected_test_list`.
        ///
        /// To override the contents of this collection use [`set_selected_test_list`](Self::set_selected_test_list).
        ///
        /// <p>Sets test case list.</p>
        pub fn selected_test_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.selected_test_list.unwrap_or_default();
            v.push(input.into());
            self.selected_test_list = Some(v);
            self
        }
        /// <p>Sets test case list.</p>
        pub fn set_selected_test_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.selected_test_list = input;
            self
        }
        /// <p>TRUE if multiple test suites run in parallel.</p>
        pub fn parallel_run(mut self, input: bool) -> Self {
            self.parallel_run = Some(input);
            self
        }
        /// <p>TRUE if multiple test suites run in parallel.</p>
        pub fn set_parallel_run(mut self, input: std::option::Option<bool>) -> Self {
            self.parallel_run = input;
            self
        }
        /// Consumes the builder and constructs a [`SuiteRunConfiguration`](crate::model::SuiteRunConfiguration).
        pub fn build(self) -> crate::model::SuiteRunConfiguration {
            crate::model::SuiteRunConfiguration {
                primary_device: self.primary_device,
                selected_test_list: self.selected_test_list,
                parallel_run: self.parallel_run.unwrap_or_default(),
            }
        }
    }
}

/// <p>Information about the suite run.</p>
/// <p>Requires permission to access the <a href="https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions">SuiteRunInformation</a> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuiteRunInformation {
    /// <p>Suite definition ID of the suite run.</p>
    #[doc(hidden)]
    pub suite_definition_id: std::option::Option<std::string::String>,
    /// <p>Suite definition version of the suite run.</p>
    #[doc(hidden)]
    pub suite_definition_version: std::option::Option<std::string::String>,
    /// <p>Suite definition name of the suite run.</p>
    #[doc(hidden)]
    pub suite_definition_name: std::option::Option<std::string::String>,
    /// <p>Suite run ID of the suite run.</p>
    #[doc(hidden)]
    pub suite_run_id: std::option::Option<std::string::String>,
    /// <p>Date (in Unix epoch time) when the suite run was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Date (in Unix epoch time) when the suite run was started.</p>
    #[doc(hidden)]
    pub started_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Date (in Unix epoch time) when the suite run ended.</p>
    #[doc(hidden)]
    pub end_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Status of the suite run.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SuiteRunStatus>,
    /// <p>Number of test cases that passed in the suite run.</p>
    #[doc(hidden)]
    pub passed: i32,
    /// <p>Number of test cases that failed in the suite run.</p>
    #[doc(hidden)]
    pub failed: i32,
}
impl SuiteRunInformation {
    /// <p>Suite definition ID of the suite run.</p>
    pub fn suite_definition_id(&self) -> std::option::Option<&str> {
        self.suite_definition_id.as_deref()
    }
    /// <p>Suite definition version of the suite run.</p>
    pub fn suite_definition_version(&self) -> std::option::Option<&str> {
        self.suite_definition_version.as_deref()
    }
    /// <p>Suite definition name of the suite run.</p>
    pub fn suite_definition_name(&self) -> std::option::Option<&str> {
        self.suite_definition_name.as_deref()
    }
    /// <p>Suite run ID of the suite run.</p>
    pub fn suite_run_id(&self) -> std::option::Option<&str> {
        self.suite_run_id.as_deref()
    }
    /// <p>Date (in Unix epoch time) when the suite run was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>Date (in Unix epoch time) when the suite run was started.</p>
    pub fn started_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_at.as_ref()
    }
    /// <p>Date (in Unix epoch time) when the suite run ended.</p>
    pub fn end_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_at.as_ref()
    }
    /// <p>Status of the suite run.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SuiteRunStatus> {
        self.status.as_ref()
    }
    /// <p>Number of test cases that passed in the suite run.</p>
    pub fn passed(&self) -> i32 {
        self.passed
    }
    /// <p>Number of test cases that failed in the suite run.</p>
    pub fn failed(&self) -> i32 {
        self.failed
    }
}
impl SuiteRunInformation {
    /// Creates a new builder-style object to manufacture [`SuiteRunInformation`](crate::model::SuiteRunInformation).
    pub fn builder() -> crate::model::suite_run_information::Builder {
        crate::model::suite_run_information::Builder::default()
    }
}

/// See [`SuiteRunInformation`](crate::model::SuiteRunInformation).
pub mod suite_run_information {

    /// A builder for [`SuiteRunInformation`](crate::model::SuiteRunInformation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) suite_definition_id: std::option::Option<std::string::String>,
        pub(crate) suite_definition_version: std::option::Option<std::string::String>,
        pub(crate) suite_definition_name: std::option::Option<std::string::String>,
        pub(crate) suite_run_id: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) started_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::SuiteRunStatus>,
        pub(crate) passed: std::option::Option<i32>,
        pub(crate) failed: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Suite definition ID of the suite run.</p>
        pub fn suite_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.suite_definition_id = Some(input.into());
            self
        }
        /// <p>Suite definition ID of the suite run.</p>
        pub fn set_suite_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.suite_definition_id = input;
            self
        }
        /// <p>Suite definition version of the suite run.</p>
        pub fn suite_definition_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.suite_definition_version = Some(input.into());
            self
        }
        /// <p>Suite definition version of the suite run.</p>
        pub fn set_suite_definition_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.suite_definition_version = input;
            self
        }
        /// <p>Suite definition name of the suite run.</p>
        pub fn suite_definition_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.suite_definition_name = Some(input.into());
            self
        }
        /// <p>Suite definition name of the suite run.</p>
        pub fn set_suite_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.suite_definition_name = input;
            self
        }
        /// <p>Suite run ID of the suite run.</p>
        pub fn suite_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.suite_run_id = Some(input.into());
            self
        }
        /// <p>Suite run ID of the suite run.</p>
        pub fn set_suite_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.suite_run_id = input;
            self
        }
        /// <p>Date (in Unix epoch time) when the suite run was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>Date (in Unix epoch time) when the suite run was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>Date (in Unix epoch time) when the suite run was started.</p>
        pub fn started_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_at = Some(input);
            self
        }
        /// <p>Date (in Unix epoch time) when the suite run was started.</p>
        pub fn set_started_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_at = input;
            self
        }
        /// <p>Date (in Unix epoch time) when the suite run ended.</p>
        pub fn end_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_at = Some(input);
            self
        }
        /// <p>Date (in Unix epoch time) when the suite run ended.</p>
        pub fn set_end_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_at = input;
            self
        }
        /// <p>Status of the suite run.</p>
        pub fn status(mut self, input: crate::model::SuiteRunStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status of the suite run.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SuiteRunStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Number of test cases that passed in the suite run.</p>
        pub fn passed(mut self, input: i32) -> Self {
            self.passed = Some(input);
            self
        }
        /// <p>Number of test cases that passed in the suite run.</p>
        pub fn set_passed(mut self, input: std::option::Option<i32>) -> Self {
            self.passed = input;
            self
        }
        /// <p>Number of test cases that failed in the suite run.</p>
        pub fn failed(mut self, input: i32) -> Self {
            self.failed = Some(input);
            self
        }
        /// <p>Number of test cases that failed in the suite run.</p>
        pub fn set_failed(mut self, input: std::option::Option<i32>) -> Self {
            self.failed = input;
            self
        }
        /// Consumes the builder and constructs a [`SuiteRunInformation`](crate::model::SuiteRunInformation).
        pub fn build(self) -> crate::model::SuiteRunInformation {
            crate::model::SuiteRunInformation {
                suite_definition_id: self.suite_definition_id,
                suite_definition_version: self.suite_definition_version,
                suite_definition_name: self.suite_definition_name,
                suite_run_id: self.suite_run_id,
                created_at: self.created_at,
                started_at: self.started_at,
                end_at: self.end_at,
                status: self.status,
                passed: self.passed.unwrap_or_default(),
                failed: self.failed.unwrap_or_default(),
            }
        }
    }
}

/// When writing a match expression against `SuiteRunStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let suiterunstatus = unimplemented!();
/// match suiterunstatus {
///     SuiteRunStatus::Canceled => { /* ... */ },
///     SuiteRunStatus::Error => { /* ... */ },
///     SuiteRunStatus::Fail => { /* ... */ },
///     SuiteRunStatus::Pass => { /* ... */ },
///     SuiteRunStatus::PassWithWarnings => { /* ... */ },
///     SuiteRunStatus::Pending => { /* ... */ },
///     SuiteRunStatus::Running => { /* ... */ },
///     SuiteRunStatus::Stopped => { /* ... */ },
///     SuiteRunStatus::Stopping => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `suiterunstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SuiteRunStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SuiteRunStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SuiteRunStatus::NewFeature` is defined.
/// Specifically, when `suiterunstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SuiteRunStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SuiteRunStatus {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Fail,
    #[allow(missing_docs)] // documentation missing in model
    Pass,
    #[allow(missing_docs)] // documentation missing in model
    PassWithWarnings,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SuiteRunStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELED" => SuiteRunStatus::Canceled,
            "ERROR" => SuiteRunStatus::Error,
            "FAIL" => SuiteRunStatus::Fail,
            "PASS" => SuiteRunStatus::Pass,
            "PASS_WITH_WARNINGS" => SuiteRunStatus::PassWithWarnings,
            "PENDING" => SuiteRunStatus::Pending,
            "RUNNING" => SuiteRunStatus::Running,
            "STOPPED" => SuiteRunStatus::Stopped,
            "STOPPING" => SuiteRunStatus::Stopping,
            other => SuiteRunStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SuiteRunStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SuiteRunStatus::from(s))
    }
}
impl SuiteRunStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SuiteRunStatus::Canceled => "CANCELED",
            SuiteRunStatus::Error => "ERROR",
            SuiteRunStatus::Fail => "FAIL",
            SuiteRunStatus::Pass => "PASS",
            SuiteRunStatus::PassWithWarnings => "PASS_WITH_WARNINGS",
            SuiteRunStatus::Pending => "PENDING",
            SuiteRunStatus::Running => "RUNNING",
            SuiteRunStatus::Stopped => "STOPPED",
            SuiteRunStatus::Stopping => "STOPPING",
            SuiteRunStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELED",
            "ERROR",
            "FAIL",
            "PASS",
            "PASS_WITH_WARNINGS",
            "PENDING",
            "RUNNING",
            "STOPPED",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for SuiteRunStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the suite definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuiteDefinitionInformation {
    /// <p>Suite definition ID of the test suite.</p>
    #[doc(hidden)]
    pub suite_definition_id: std::option::Option<std::string::String>,
    /// <p>Suite name of the test suite.</p>
    #[doc(hidden)]
    pub suite_definition_name: std::option::Option<std::string::String>,
    /// <p>Specifies the devices that are under test for the test suite.</p>
    #[doc(hidden)]
    pub default_devices: std::option::Option<std::vec::Vec<crate::model::DeviceUnderTest>>,
    /// <p>Specifies if the test suite is intended for qualification.</p>
    #[doc(hidden)]
    pub intended_for_qualification: bool,
    /// <p>Verifies if the test suite is a long duration test.</p>
    #[doc(hidden)]
    pub is_long_duration_test: bool,
    /// <p>Gets the MQTT protocol that is configured in the suite definition.</p>
    #[doc(hidden)]
    pub protocol: std::option::Option<crate::model::Protocol>,
    /// <p>Date (in Unix epoch time) when the test suite was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl SuiteDefinitionInformation {
    /// <p>Suite definition ID of the test suite.</p>
    pub fn suite_definition_id(&self) -> std::option::Option<&str> {
        self.suite_definition_id.as_deref()
    }
    /// <p>Suite name of the test suite.</p>
    pub fn suite_definition_name(&self) -> std::option::Option<&str> {
        self.suite_definition_name.as_deref()
    }
    /// <p>Specifies the devices that are under test for the test suite.</p>
    pub fn default_devices(&self) -> std::option::Option<&[crate::model::DeviceUnderTest]> {
        self.default_devices.as_deref()
    }
    /// <p>Specifies if the test suite is intended for qualification.</p>
    pub fn intended_for_qualification(&self) -> bool {
        self.intended_for_qualification
    }
    /// <p>Verifies if the test suite is a long duration test.</p>
    pub fn is_long_duration_test(&self) -> bool {
        self.is_long_duration_test
    }
    /// <p>Gets the MQTT protocol that is configured in the suite definition.</p>
    pub fn protocol(&self) -> std::option::Option<&crate::model::Protocol> {
        self.protocol.as_ref()
    }
    /// <p>Date (in Unix epoch time) when the test suite was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
}
impl SuiteDefinitionInformation {
    /// Creates a new builder-style object to manufacture [`SuiteDefinitionInformation`](crate::model::SuiteDefinitionInformation).
    pub fn builder() -> crate::model::suite_definition_information::Builder {
        crate::model::suite_definition_information::Builder::default()
    }
}

/// See [`SuiteDefinitionInformation`](crate::model::SuiteDefinitionInformation).
pub mod suite_definition_information {

    /// A builder for [`SuiteDefinitionInformation`](crate::model::SuiteDefinitionInformation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) suite_definition_id: std::option::Option<std::string::String>,
        pub(crate) suite_definition_name: std::option::Option<std::string::String>,
        pub(crate) default_devices:
            std::option::Option<std::vec::Vec<crate::model::DeviceUnderTest>>,
        pub(crate) intended_for_qualification: std::option::Option<bool>,
        pub(crate) is_long_duration_test: std::option::Option<bool>,
        pub(crate) protocol: std::option::Option<crate::model::Protocol>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Suite definition ID of the test suite.</p>
        pub fn suite_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.suite_definition_id = Some(input.into());
            self
        }
        /// <p>Suite definition ID of the test suite.</p>
        pub fn set_suite_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.suite_definition_id = input;
            self
        }
        /// <p>Suite name of the test suite.</p>
        pub fn suite_definition_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.suite_definition_name = Some(input.into());
            self
        }
        /// <p>Suite name of the test suite.</p>
        pub fn set_suite_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.suite_definition_name = input;
            self
        }
        /// Appends an item to `default_devices`.
        ///
        /// To override the contents of this collection use [`set_default_devices`](Self::set_default_devices).
        ///
        /// <p>Specifies the devices that are under test for the test suite.</p>
        pub fn default_devices(mut self, input: crate::model::DeviceUnderTest) -> Self {
            let mut v = self.default_devices.unwrap_or_default();
            v.push(input);
            self.default_devices = Some(v);
            self
        }
        /// <p>Specifies the devices that are under test for the test suite.</p>
        pub fn set_default_devices(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DeviceUnderTest>>,
        ) -> Self {
            self.default_devices = input;
            self
        }
        /// <p>Specifies if the test suite is intended for qualification.</p>
        pub fn intended_for_qualification(mut self, input: bool) -> Self {
            self.intended_for_qualification = Some(input);
            self
        }
        /// <p>Specifies if the test suite is intended for qualification.</p>
        pub fn set_intended_for_qualification(mut self, input: std::option::Option<bool>) -> Self {
            self.intended_for_qualification = input;
            self
        }
        /// <p>Verifies if the test suite is a long duration test.</p>
        pub fn is_long_duration_test(mut self, input: bool) -> Self {
            self.is_long_duration_test = Some(input);
            self
        }
        /// <p>Verifies if the test suite is a long duration test.</p>
        pub fn set_is_long_duration_test(mut self, input: std::option::Option<bool>) -> Self {
            self.is_long_duration_test = input;
            self
        }
        /// <p>Gets the MQTT protocol that is configured in the suite definition.</p>
        pub fn protocol(mut self, input: crate::model::Protocol) -> Self {
            self.protocol = Some(input);
            self
        }
        /// <p>Gets the MQTT protocol that is configured in the suite definition.</p>
        pub fn set_protocol(mut self, input: std::option::Option<crate::model::Protocol>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>Date (in Unix epoch time) when the test suite was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>Date (in Unix epoch time) when the test suite was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Consumes the builder and constructs a [`SuiteDefinitionInformation`](crate::model::SuiteDefinitionInformation).
        pub fn build(self) -> crate::model::SuiteDefinitionInformation {
            crate::model::SuiteDefinitionInformation {
                suite_definition_id: self.suite_definition_id,
                suite_definition_name: self.suite_definition_name,
                default_devices: self.default_devices,
                intended_for_qualification: self.intended_for_qualification.unwrap_or_default(),
                is_long_duration_test: self.is_long_duration_test.unwrap_or_default(),
                protocol: self.protocol,
                created_at: self.created_at,
            }
        }
    }
}

/// <p>Show each group result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TestResult {
    /// <p>Show each group of test results.</p>
    #[doc(hidden)]
    pub groups: std::option::Option<std::vec::Vec<crate::model::GroupResult>>,
}
impl TestResult {
    /// <p>Show each group of test results.</p>
    pub fn groups(&self) -> std::option::Option<&[crate::model::GroupResult]> {
        self.groups.as_deref()
    }
}
impl TestResult {
    /// Creates a new builder-style object to manufacture [`TestResult`](crate::model::TestResult).
    pub fn builder() -> crate::model::test_result::Builder {
        crate::model::test_result::Builder::default()
    }
}

/// See [`TestResult`](crate::model::TestResult).
pub mod test_result {

    /// A builder for [`TestResult`](crate::model::TestResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) groups: std::option::Option<std::vec::Vec<crate::model::GroupResult>>,
    }
    impl Builder {
        /// Appends an item to `groups`.
        ///
        /// To override the contents of this collection use [`set_groups`](Self::set_groups).
        ///
        /// <p>Show each group of test results.</p>
        pub fn groups(mut self, input: crate::model::GroupResult) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input);
            self.groups = Some(v);
            self
        }
        /// <p>Show each group of test results.</p>
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupResult>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// Consumes the builder and constructs a [`TestResult`](crate::model::TestResult).
        pub fn build(self) -> crate::model::TestResult {
            crate::model::TestResult {
                groups: self.groups,
            }
        }
    }
}

/// <p>Show Group Result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupResult {
    /// <p>Group result ID.</p>
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// <p>Group Result Name.</p>
    #[doc(hidden)]
    pub group_name: std::option::Option<std::string::String>,
    /// <p>Tests under Group Result.</p>
    #[doc(hidden)]
    pub tests: std::option::Option<std::vec::Vec<crate::model::TestCaseRun>>,
}
impl GroupResult {
    /// <p>Group result ID.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>Group Result Name.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>Tests under Group Result.</p>
    pub fn tests(&self) -> std::option::Option<&[crate::model::TestCaseRun]> {
        self.tests.as_deref()
    }
}
impl GroupResult {
    /// Creates a new builder-style object to manufacture [`GroupResult`](crate::model::GroupResult).
    pub fn builder() -> crate::model::group_result::Builder {
        crate::model::group_result::Builder::default()
    }
}

/// See [`GroupResult`](crate::model::GroupResult).
pub mod group_result {

    /// A builder for [`GroupResult`](crate::model::GroupResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) tests: std::option::Option<std::vec::Vec<crate::model::TestCaseRun>>,
    }
    impl Builder {
        /// <p>Group result ID.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>Group result ID.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>Group Result Name.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>Group Result Name.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// Appends an item to `tests`.
        ///
        /// To override the contents of this collection use [`set_tests`](Self::set_tests).
        ///
        /// <p>Tests under Group Result.</p>
        pub fn tests(mut self, input: crate::model::TestCaseRun) -> Self {
            let mut v = self.tests.unwrap_or_default();
            v.push(input);
            self.tests = Some(v);
            self
        }
        /// <p>Tests under Group Result.</p>
        pub fn set_tests(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TestCaseRun>>,
        ) -> Self {
            self.tests = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupResult`](crate::model::GroupResult).
        pub fn build(self) -> crate::model::GroupResult {
            crate::model::GroupResult {
                group_id: self.group_id,
                group_name: self.group_name,
                tests: self.tests,
            }
        }
    }
}

/// <p>Provides the test case run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TestCaseRun {
    /// <p>Provides the test case run ID.</p>
    #[doc(hidden)]
    pub test_case_run_id: std::option::Option<std::string::String>,
    /// <p>Provides the test case run definition ID.</p>
    #[doc(hidden)]
    pub test_case_definition_id: std::option::Option<std::string::String>,
    /// <p>Provides the test case run definition name.</p>
    #[doc(hidden)]
    pub test_case_definition_name: std::option::Option<std::string::String>,
    /// <p>Provides the test case run status. Status is one of the following:</p>
    /// <ul>
    /// <li> <p> <code>PASS</code>: Test passed.</p> </li>
    /// <li> <p> <code>FAIL</code>: Test failed.</p> </li>
    /// <li> <p> <code>PENDING</code>: Test has not started running but is scheduled.</p> </li>
    /// <li> <p> <code>RUNNING</code>: Test is running.</p> </li>
    /// <li> <p> <code>STOPPING</code>: Test is performing cleanup steps. You will see this status only if you stop a suite run.</p> </li>
    /// <li> <p> <code>STOPPED</code> Test is stopped. You will see this status only if you stop a suite run.</p> </li>
    /// <li> <p> <code>PASS_WITH_WARNINGS</code>: Test passed with warnings.</p> </li>
    /// <li> <p> <code>ERORR</code>: Test faced an error when running due to an internal issue.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
    /// <p>Provides test case run start time.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Provides test case run end time.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Provides test case run log URL.</p>
    #[doc(hidden)]
    pub log_url: std::option::Option<std::string::String>,
    /// <p>Provides test case run warnings.</p>
    #[doc(hidden)]
    pub warnings: std::option::Option<std::string::String>,
    /// <p>Provides test case run failure result.</p>
    #[doc(hidden)]
    pub failure: std::option::Option<std::string::String>,
    /// <p> Provides the test scenarios for the test case run. </p>
    #[doc(hidden)]
    pub test_scenarios: std::option::Option<std::vec::Vec<crate::model::TestCaseScenario>>,
}
impl TestCaseRun {
    /// <p>Provides the test case run ID.</p>
    pub fn test_case_run_id(&self) -> std::option::Option<&str> {
        self.test_case_run_id.as_deref()
    }
    /// <p>Provides the test case run definition ID.</p>
    pub fn test_case_definition_id(&self) -> std::option::Option<&str> {
        self.test_case_definition_id.as_deref()
    }
    /// <p>Provides the test case run definition name.</p>
    pub fn test_case_definition_name(&self) -> std::option::Option<&str> {
        self.test_case_definition_name.as_deref()
    }
    /// <p>Provides the test case run status. Status is one of the following:</p>
    /// <ul>
    /// <li> <p> <code>PASS</code>: Test passed.</p> </li>
    /// <li> <p> <code>FAIL</code>: Test failed.</p> </li>
    /// <li> <p> <code>PENDING</code>: Test has not started running but is scheduled.</p> </li>
    /// <li> <p> <code>RUNNING</code>: Test is running.</p> </li>
    /// <li> <p> <code>STOPPING</code>: Test is performing cleanup steps. You will see this status only if you stop a suite run.</p> </li>
    /// <li> <p> <code>STOPPED</code> Test is stopped. You will see this status only if you stop a suite run.</p> </li>
    /// <li> <p> <code>PASS_WITH_WARNINGS</code>: Test passed with warnings.</p> </li>
    /// <li> <p> <code>ERORR</code>: Test faced an error when running due to an internal issue.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::Status> {
        self.status.as_ref()
    }
    /// <p>Provides test case run start time.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>Provides test case run end time.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>Provides test case run log URL.</p>
    pub fn log_url(&self) -> std::option::Option<&str> {
        self.log_url.as_deref()
    }
    /// <p>Provides test case run warnings.</p>
    pub fn warnings(&self) -> std::option::Option<&str> {
        self.warnings.as_deref()
    }
    /// <p>Provides test case run failure result.</p>
    pub fn failure(&self) -> std::option::Option<&str> {
        self.failure.as_deref()
    }
    /// <p> Provides the test scenarios for the test case run. </p>
    pub fn test_scenarios(&self) -> std::option::Option<&[crate::model::TestCaseScenario]> {
        self.test_scenarios.as_deref()
    }
}
impl TestCaseRun {
    /// Creates a new builder-style object to manufacture [`TestCaseRun`](crate::model::TestCaseRun).
    pub fn builder() -> crate::model::test_case_run::Builder {
        crate::model::test_case_run::Builder::default()
    }
}

/// See [`TestCaseRun`](crate::model::TestCaseRun).
pub mod test_case_run {

    /// A builder for [`TestCaseRun`](crate::model::TestCaseRun).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) test_case_run_id: std::option::Option<std::string::String>,
        pub(crate) test_case_definition_id: std::option::Option<std::string::String>,
        pub(crate) test_case_definition_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) log_url: std::option::Option<std::string::String>,
        pub(crate) warnings: std::option::Option<std::string::String>,
        pub(crate) failure: std::option::Option<std::string::String>,
        pub(crate) test_scenarios:
            std::option::Option<std::vec::Vec<crate::model::TestCaseScenario>>,
    }
    impl Builder {
        /// <p>Provides the test case run ID.</p>
        pub fn test_case_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.test_case_run_id = Some(input.into());
            self
        }
        /// <p>Provides the test case run ID.</p>
        pub fn set_test_case_run_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.test_case_run_id = input;
            self
        }
        /// <p>Provides the test case run definition ID.</p>
        pub fn test_case_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.test_case_definition_id = Some(input.into());
            self
        }
        /// <p>Provides the test case run definition ID.</p>
        pub fn set_test_case_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.test_case_definition_id = input;
            self
        }
        /// <p>Provides the test case run definition name.</p>
        pub fn test_case_definition_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.test_case_definition_name = Some(input.into());
            self
        }
        /// <p>Provides the test case run definition name.</p>
        pub fn set_test_case_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.test_case_definition_name = input;
            self
        }
        /// <p>Provides the test case run status. Status is one of the following:</p>
        /// <ul>
        /// <li> <p> <code>PASS</code>: Test passed.</p> </li>
        /// <li> <p> <code>FAIL</code>: Test failed.</p> </li>
        /// <li> <p> <code>PENDING</code>: Test has not started running but is scheduled.</p> </li>
        /// <li> <p> <code>RUNNING</code>: Test is running.</p> </li>
        /// <li> <p> <code>STOPPING</code>: Test is performing cleanup steps. You will see this status only if you stop a suite run.</p> </li>
        /// <li> <p> <code>STOPPED</code> Test is stopped. You will see this status only if you stop a suite run.</p> </li>
        /// <li> <p> <code>PASS_WITH_WARNINGS</code>: Test passed with warnings.</p> </li>
        /// <li> <p> <code>ERORR</code>: Test faced an error when running due to an internal issue.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Provides the test case run status. Status is one of the following:</p>
        /// <ul>
        /// <li> <p> <code>PASS</code>: Test passed.</p> </li>
        /// <li> <p> <code>FAIL</code>: Test failed.</p> </li>
        /// <li> <p> <code>PENDING</code>: Test has not started running but is scheduled.</p> </li>
        /// <li> <p> <code>RUNNING</code>: Test is running.</p> </li>
        /// <li> <p> <code>STOPPING</code>: Test is performing cleanup steps. You will see this status only if you stop a suite run.</p> </li>
        /// <li> <p> <code>STOPPED</code> Test is stopped. You will see this status only if you stop a suite run.</p> </li>
        /// <li> <p> <code>PASS_WITH_WARNINGS</code>: Test passed with warnings.</p> </li>
        /// <li> <p> <code>ERORR</code>: Test faced an error when running due to an internal issue.</p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input;
            self
        }
        /// <p>Provides test case run start time.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>Provides test case run start time.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>Provides test case run end time.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>Provides test case run end time.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>Provides test case run log URL.</p>
        pub fn log_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_url = Some(input.into());
            self
        }
        /// <p>Provides test case run log URL.</p>
        pub fn set_log_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_url = input;
            self
        }
        /// <p>Provides test case run warnings.</p>
        pub fn warnings(mut self, input: impl Into<std::string::String>) -> Self {
            self.warnings = Some(input.into());
            self
        }
        /// <p>Provides test case run warnings.</p>
        pub fn set_warnings(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.warnings = input;
            self
        }
        /// <p>Provides test case run failure result.</p>
        pub fn failure(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure = Some(input.into());
            self
        }
        /// <p>Provides test case run failure result.</p>
        pub fn set_failure(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.failure = input;
            self
        }
        /// Appends an item to `test_scenarios`.
        ///
        /// To override the contents of this collection use [`set_test_scenarios`](Self::set_test_scenarios).
        ///
        /// <p> Provides the test scenarios for the test case run. </p>
        pub fn test_scenarios(mut self, input: crate::model::TestCaseScenario) -> Self {
            let mut v = self.test_scenarios.unwrap_or_default();
            v.push(input);
            self.test_scenarios = Some(v);
            self
        }
        /// <p> Provides the test scenarios for the test case run. </p>
        pub fn set_test_scenarios(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TestCaseScenario>>,
        ) -> Self {
            self.test_scenarios = input;
            self
        }
        /// Consumes the builder and constructs a [`TestCaseRun`](crate::model::TestCaseRun).
        pub fn build(self) -> crate::model::TestCaseRun {
            crate::model::TestCaseRun {
                test_case_run_id: self.test_case_run_id,
                test_case_definition_id: self.test_case_definition_id,
                test_case_definition_name: self.test_case_definition_name,
                status: self.status,
                start_time: self.start_time,
                end_time: self.end_time,
                log_url: self.log_url,
                warnings: self.warnings,
                failure: self.failure,
                test_scenarios: self.test_scenarios,
            }
        }
    }
}

/// <p>Provides test case scenario.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TestCaseScenario {
    /// <p>Provides test case scenario ID.</p>
    #[doc(hidden)]
    pub test_case_scenario_id: std::option::Option<std::string::String>,
    /// <p>Provides test case scenario type. Type is one of the following:</p>
    /// <ul>
    /// <li> <p>Advanced</p> </li>
    /// <li> <p>Basic</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub test_case_scenario_type: std::option::Option<crate::model::TestCaseScenarioType>,
    /// <p>Provides the test case scenario status. Status is one of the following:</p>
    /// <ul>
    /// <li> <p> <code>PASS</code>: Test passed.</p> </li>
    /// <li> <p> <code>FAIL</code>: Test failed.</p> </li>
    /// <li> <p> <code>PENDING</code>: Test has not started running but is scheduled.</p> </li>
    /// <li> <p> <code>RUNNING</code>: Test is running.</p> </li>
    /// <li> <p> <code>STOPPING</code>: Test is performing cleanup steps. You will see this status only if you stop a suite run.</p> </li>
    /// <li> <p> <code>STOPPED</code> Test is stopped. You will see this status only if you stop a suite run.</p> </li>
    /// <li> <p> <code>PASS_WITH_WARNINGS</code>: Test passed with warnings.</p> </li>
    /// <li> <p> <code>ERORR</code>: Test faced an error when running due to an internal issue.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TestCaseScenarioStatus>,
    /// <p>Provides test case scenario failure result.</p>
    #[doc(hidden)]
    pub failure: std::option::Option<std::string::String>,
    /// <p> </p>
    #[doc(hidden)]
    pub system_message: std::option::Option<std::string::String>,
}
impl TestCaseScenario {
    /// <p>Provides test case scenario ID.</p>
    pub fn test_case_scenario_id(&self) -> std::option::Option<&str> {
        self.test_case_scenario_id.as_deref()
    }
    /// <p>Provides test case scenario type. Type is one of the following:</p>
    /// <ul>
    /// <li> <p>Advanced</p> </li>
    /// <li> <p>Basic</p> </li>
    /// </ul>
    pub fn test_case_scenario_type(
        &self,
    ) -> std::option::Option<&crate::model::TestCaseScenarioType> {
        self.test_case_scenario_type.as_ref()
    }
    /// <p>Provides the test case scenario status. Status is one of the following:</p>
    /// <ul>
    /// <li> <p> <code>PASS</code>: Test passed.</p> </li>
    /// <li> <p> <code>FAIL</code>: Test failed.</p> </li>
    /// <li> <p> <code>PENDING</code>: Test has not started running but is scheduled.</p> </li>
    /// <li> <p> <code>RUNNING</code>: Test is running.</p> </li>
    /// <li> <p> <code>STOPPING</code>: Test is performing cleanup steps. You will see this status only if you stop a suite run.</p> </li>
    /// <li> <p> <code>STOPPED</code> Test is stopped. You will see this status only if you stop a suite run.</p> </li>
    /// <li> <p> <code>PASS_WITH_WARNINGS</code>: Test passed with warnings.</p> </li>
    /// <li> <p> <code>ERORR</code>: Test faced an error when running due to an internal issue.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::TestCaseScenarioStatus> {
        self.status.as_ref()
    }
    /// <p>Provides test case scenario failure result.</p>
    pub fn failure(&self) -> std::option::Option<&str> {
        self.failure.as_deref()
    }
    /// <p> </p>
    pub fn system_message(&self) -> std::option::Option<&str> {
        self.system_message.as_deref()
    }
}
impl TestCaseScenario {
    /// Creates a new builder-style object to manufacture [`TestCaseScenario`](crate::model::TestCaseScenario).
    pub fn builder() -> crate::model::test_case_scenario::Builder {
        crate::model::test_case_scenario::Builder::default()
    }
}

/// See [`TestCaseScenario`](crate::model::TestCaseScenario).
pub mod test_case_scenario {

    /// A builder for [`TestCaseScenario`](crate::model::TestCaseScenario).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) test_case_scenario_id: std::option::Option<std::string::String>,
        pub(crate) test_case_scenario_type: std::option::Option<crate::model::TestCaseScenarioType>,
        pub(crate) status: std::option::Option<crate::model::TestCaseScenarioStatus>,
        pub(crate) failure: std::option::Option<std::string::String>,
        pub(crate) system_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Provides test case scenario ID.</p>
        pub fn test_case_scenario_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.test_case_scenario_id = Some(input.into());
            self
        }
        /// <p>Provides test case scenario ID.</p>
        pub fn set_test_case_scenario_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.test_case_scenario_id = input;
            self
        }
        /// <p>Provides test case scenario type. Type is one of the following:</p>
        /// <ul>
        /// <li> <p>Advanced</p> </li>
        /// <li> <p>Basic</p> </li>
        /// </ul>
        pub fn test_case_scenario_type(
            mut self,
            input: crate::model::TestCaseScenarioType,
        ) -> Self {
            self.test_case_scenario_type = Some(input);
            self
        }
        /// <p>Provides test case scenario type. Type is one of the following:</p>
        /// <ul>
        /// <li> <p>Advanced</p> </li>
        /// <li> <p>Basic</p> </li>
        /// </ul>
        pub fn set_test_case_scenario_type(
            mut self,
            input: std::option::Option<crate::model::TestCaseScenarioType>,
        ) -> Self {
            self.test_case_scenario_type = input;
            self
        }
        /// <p>Provides the test case scenario status. Status is one of the following:</p>
        /// <ul>
        /// <li> <p> <code>PASS</code>: Test passed.</p> </li>
        /// <li> <p> <code>FAIL</code>: Test failed.</p> </li>
        /// <li> <p> <code>PENDING</code>: Test has not started running but is scheduled.</p> </li>
        /// <li> <p> <code>RUNNING</code>: Test is running.</p> </li>
        /// <li> <p> <code>STOPPING</code>: Test is performing cleanup steps. You will see this status only if you stop a suite run.</p> </li>
        /// <li> <p> <code>STOPPED</code> Test is stopped. You will see this status only if you stop a suite run.</p> </li>
        /// <li> <p> <code>PASS_WITH_WARNINGS</code>: Test passed with warnings.</p> </li>
        /// <li> <p> <code>ERORR</code>: Test faced an error when running due to an internal issue.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::TestCaseScenarioStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Provides the test case scenario status. Status is one of the following:</p>
        /// <ul>
        /// <li> <p> <code>PASS</code>: Test passed.</p> </li>
        /// <li> <p> <code>FAIL</code>: Test failed.</p> </li>
        /// <li> <p> <code>PENDING</code>: Test has not started running but is scheduled.</p> </li>
        /// <li> <p> <code>RUNNING</code>: Test is running.</p> </li>
        /// <li> <p> <code>STOPPING</code>: Test is performing cleanup steps. You will see this status only if you stop a suite run.</p> </li>
        /// <li> <p> <code>STOPPED</code> Test is stopped. You will see this status only if you stop a suite run.</p> </li>
        /// <li> <p> <code>PASS_WITH_WARNINGS</code>: Test passed with warnings.</p> </li>
        /// <li> <p> <code>ERORR</code>: Test faced an error when running due to an internal issue.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TestCaseScenarioStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Provides test case scenario failure result.</p>
        pub fn failure(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure = Some(input.into());
            self
        }
        /// <p>Provides test case scenario failure result.</p>
        pub fn set_failure(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.failure = input;
            self
        }
        /// <p> </p>
        pub fn system_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.system_message = Some(input.into());
            self
        }
        /// <p> </p>
        pub fn set_system_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.system_message = input;
            self
        }
        /// Consumes the builder and constructs a [`TestCaseScenario`](crate::model::TestCaseScenario).
        pub fn build(self) -> crate::model::TestCaseScenario {
            crate::model::TestCaseScenario {
                test_case_scenario_id: self.test_case_scenario_id,
                test_case_scenario_type: self.test_case_scenario_type,
                status: self.status,
                failure: self.failure,
                system_message: self.system_message,
            }
        }
    }
}

/// When writing a match expression against `TestCaseScenarioStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let testcasescenariostatus = unimplemented!();
/// match testcasescenariostatus {
///     TestCaseScenarioStatus::Canceled => { /* ... */ },
///     TestCaseScenarioStatus::Error => { /* ... */ },
///     TestCaseScenarioStatus::Fail => { /* ... */ },
///     TestCaseScenarioStatus::Pass => { /* ... */ },
///     TestCaseScenarioStatus::PassWithWarnings => { /* ... */ },
///     TestCaseScenarioStatus::Pending => { /* ... */ },
///     TestCaseScenarioStatus::Running => { /* ... */ },
///     TestCaseScenarioStatus::Stopped => { /* ... */ },
///     TestCaseScenarioStatus::Stopping => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `testcasescenariostatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TestCaseScenarioStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TestCaseScenarioStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TestCaseScenarioStatus::NewFeature` is defined.
/// Specifically, when `testcasescenariostatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TestCaseScenarioStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TestCaseScenarioStatus {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Fail,
    #[allow(missing_docs)] // documentation missing in model
    Pass,
    #[allow(missing_docs)] // documentation missing in model
    PassWithWarnings,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TestCaseScenarioStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELED" => TestCaseScenarioStatus::Canceled,
            "ERROR" => TestCaseScenarioStatus::Error,
            "FAIL" => TestCaseScenarioStatus::Fail,
            "PASS" => TestCaseScenarioStatus::Pass,
            "PASS_WITH_WARNINGS" => TestCaseScenarioStatus::PassWithWarnings,
            "PENDING" => TestCaseScenarioStatus::Pending,
            "RUNNING" => TestCaseScenarioStatus::Running,
            "STOPPED" => TestCaseScenarioStatus::Stopped,
            "STOPPING" => TestCaseScenarioStatus::Stopping,
            other => {
                TestCaseScenarioStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TestCaseScenarioStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TestCaseScenarioStatus::from(s))
    }
}
impl TestCaseScenarioStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TestCaseScenarioStatus::Canceled => "CANCELED",
            TestCaseScenarioStatus::Error => "ERROR",
            TestCaseScenarioStatus::Fail => "FAIL",
            TestCaseScenarioStatus::Pass => "PASS",
            TestCaseScenarioStatus::PassWithWarnings => "PASS_WITH_WARNINGS",
            TestCaseScenarioStatus::Pending => "PENDING",
            TestCaseScenarioStatus::Running => "RUNNING",
            TestCaseScenarioStatus::Stopped => "STOPPED",
            TestCaseScenarioStatus::Stopping => "STOPPING",
            TestCaseScenarioStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELED",
            "ERROR",
            "FAIL",
            "PASS",
            "PASS_WITH_WARNINGS",
            "PENDING",
            "RUNNING",
            "STOPPED",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for TestCaseScenarioStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TestCaseScenarioType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let testcasescenariotype = unimplemented!();
/// match testcasescenariotype {
///     TestCaseScenarioType::Advanced => { /* ... */ },
///     TestCaseScenarioType::Basic => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `testcasescenariotype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TestCaseScenarioType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TestCaseScenarioType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TestCaseScenarioType::NewFeature` is defined.
/// Specifically, when `testcasescenariotype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TestCaseScenarioType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TestCaseScenarioType {
    #[allow(missing_docs)] // documentation missing in model
    Advanced,
    #[allow(missing_docs)] // documentation missing in model
    Basic,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TestCaseScenarioType {
    fn from(s: &str) -> Self {
        match s {
            "Advanced" => TestCaseScenarioType::Advanced,
            "Basic" => TestCaseScenarioType::Basic,
            other => {
                TestCaseScenarioType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TestCaseScenarioType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TestCaseScenarioType::from(s))
    }
}
impl TestCaseScenarioType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TestCaseScenarioType::Advanced => "Advanced",
            TestCaseScenarioType::Basic => "Basic",
            TestCaseScenarioType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Advanced", "Basic"]
    }
}
impl AsRef<str> for TestCaseScenarioType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Status`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let status = unimplemented!();
/// match status {
///     Status::Canceled => { /* ... */ },
///     Status::Error => { /* ... */ },
///     Status::Fail => { /* ... */ },
///     Status::Pass => { /* ... */ },
///     Status::PassWithWarnings => { /* ... */ },
///     Status::Pending => { /* ... */ },
///     Status::Running => { /* ... */ },
///     Status::Stopped => { /* ... */ },
///     Status::Stopping => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `status` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Status::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Status::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Status::NewFeature` is defined.
/// Specifically, when `status` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Status::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Status {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Fail,
    #[allow(missing_docs)] // documentation missing in model
    Pass,
    #[allow(missing_docs)] // documentation missing in model
    PassWithWarnings,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Status {
    fn from(s: &str) -> Self {
        match s {
            "CANCELED" => Status::Canceled,
            "ERROR" => Status::Error,
            "FAIL" => Status::Fail,
            "PASS" => Status::Pass,
            "PASS_WITH_WARNINGS" => Status::PassWithWarnings,
            "PENDING" => Status::Pending,
            "RUNNING" => Status::Running,
            "STOPPED" => Status::Stopped,
            "STOPPING" => Status::Stopping,
            other => Status::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Status {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Status::from(s))
    }
}
impl Status {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Status::Canceled => "CANCELED",
            Status::Error => "ERROR",
            Status::Fail => "FAIL",
            Status::Pass => "PASS",
            Status::PassWithWarnings => "PASS_WITH_WARNINGS",
            Status::Pending => "PENDING",
            Status::Running => "RUNNING",
            Status::Stopped => "STOPPED",
            Status::Stopping => "STOPPING",
            Status::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELED",
            "ERROR",
            "FAIL",
            "PASS",
            "PASS_WITH_WARNINGS",
            "PENDING",
            "RUNNING",
            "STOPPED",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for Status {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
