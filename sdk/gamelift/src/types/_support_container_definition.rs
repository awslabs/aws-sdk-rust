// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes a support container in a container group. A support container might be in a game server container group or a per-instance container group. Support containers don't run game server processes.</p>
/// <p>You can update a support container definition and deploy the updates to an existing fleet. When creating or updating a game server container group definition, use the property <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_GameServerContainerDefinitionInput.html">GameServerContainerDefinitionInput</a>.</p>
/// <p><b>Part of:</b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a></p>
/// <p><b>Returned by:</b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeContainerGroupDefinition.html">DescribeContainerGroupDefinition</a>, <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ListContainerGroupDefinitions.html">ListContainerGroupDefinitions</a>, <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_UpdateContainerGroupDefinition.html">UpdateContainerGroupDefinition</a></p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct SupportContainerDefinition {
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub container_name: ::std::option::Option<::std::string::String>,
    /// <p>Indicates that the container relies on the status of other containers in the same container group during its startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub mount_points: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>,
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub environment_override: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    /// <p>Indicates whether the container is vital to the container group. If an essential container fails, the entire container group restarts.</p>
    pub essential: ::std::option::Option<bool>,
    /// <p>A configuration for a non-terminal health check. A support container automatically restarts if it stops functioning or if it fails this health check.</p>
    pub health_check: ::std::option::Option<crate::types::ContainerHealthCheck>,
    /// <p>The URI to the image that Amazon GameLift Servers deploys to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub image_uri: ::std::option::Option<::std::string::String>,
    /// <p>The amount of memory that Amazon GameLift Servers makes available to the container. If memory limits aren't set for an individual container, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition TotalMemoryLimitMebibytes</a></p>
    pub memory_hard_limit_mebibytes: ::std::option::Option<i32>,
    /// <p>A set of ports that allow access to the container from external users. Processes running in the container can bind to a one of these ports. Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    /// <p>A unique and immutable identifier for the container image. The digest is a SHA 256 hash of the container image manifest.</p>
    pub resolved_image_digest: ::std::option::Option<::std::string::String>,
    /// <p>The number of vCPU units that are reserved for the container. If no resources are reserved, the container shares the total vCPU limit for the container group.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition TotalVcpuLimit</a></p>
    pub vcpu: ::std::option::Option<f64>,
}
impl SupportContainerDefinition {
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub fn container_name(&self) -> ::std::option::Option<&str> {
        self.container_name.as_deref()
    }
    /// <p>Indicates that the container relies on the status of other containers in the same container group during its startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.depends_on.is_none()`.
    pub fn depends_on(&self) -> &[crate::types::ContainerDependency] {
        self.depends_on.as_deref().unwrap_or_default()
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.mount_points.is_none()`.
    pub fn mount_points(&self) -> &[crate::types::ContainerMountPoint] {
        self.mount_points.as_deref().unwrap_or_default()
    }
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.environment_override.is_none()`.
    pub fn environment_override(&self) -> &[crate::types::ContainerEnvironment] {
        self.environment_override.as_deref().unwrap_or_default()
    }
    /// <p>Indicates whether the container is vital to the container group. If an essential container fails, the entire container group restarts.</p>
    pub fn essential(&self) -> ::std::option::Option<bool> {
        self.essential
    }
    /// <p>A configuration for a non-terminal health check. A support container automatically restarts if it stops functioning or if it fails this health check.</p>
    pub fn health_check(&self) -> ::std::option::Option<&crate::types::ContainerHealthCheck> {
        self.health_check.as_ref()
    }
    /// <p>The URI to the image that Amazon GameLift Servers deploys to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub fn image_uri(&self) -> ::std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>The amount of memory that Amazon GameLift Servers makes available to the container. If memory limits aren't set for an individual container, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition TotalMemoryLimitMebibytes</a></p>
    pub fn memory_hard_limit_mebibytes(&self) -> ::std::option::Option<i32> {
        self.memory_hard_limit_mebibytes
    }
    /// <p>A set of ports that allow access to the container from external users. Processes running in the container can bind to a one of these ports. Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn port_configuration(&self) -> ::std::option::Option<&crate::types::ContainerPortConfiguration> {
        self.port_configuration.as_ref()
    }
    /// <p>A unique and immutable identifier for the container image. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn resolved_image_digest(&self) -> ::std::option::Option<&str> {
        self.resolved_image_digest.as_deref()
    }
    /// <p>The number of vCPU units that are reserved for the container. If no resources are reserved, the container shares the total vCPU limit for the container group.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition TotalVcpuLimit</a></p>
    pub fn vcpu(&self) -> ::std::option::Option<f64> {
        self.vcpu
    }
}
impl SupportContainerDefinition {
    /// Creates a new builder-style object to manufacture [`SupportContainerDefinition`](crate::types::SupportContainerDefinition).
    pub fn builder() -> crate::types::builders::SupportContainerDefinitionBuilder {
        crate::types::builders::SupportContainerDefinitionBuilder::default()
    }
}

/// A builder for [`SupportContainerDefinition`](crate::types::SupportContainerDefinition).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct SupportContainerDefinitionBuilder {
    pub(crate) container_name: ::std::option::Option<::std::string::String>,
    pub(crate) depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
    pub(crate) mount_points: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>,
    pub(crate) environment_override: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    pub(crate) essential: ::std::option::Option<bool>,
    pub(crate) health_check: ::std::option::Option<crate::types::ContainerHealthCheck>,
    pub(crate) image_uri: ::std::option::Option<::std::string::String>,
    pub(crate) memory_hard_limit_mebibytes: ::std::option::Option<i32>,
    pub(crate) port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    pub(crate) resolved_image_digest: ::std::option::Option<::std::string::String>,
    pub(crate) vcpu: ::std::option::Option<f64>,
}
impl SupportContainerDefinitionBuilder {
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub fn container_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.container_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub fn set_container_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.container_name = input;
        self
    }
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub fn get_container_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.container_name
    }
    /// Appends an item to `depends_on`.
    ///
    /// To override the contents of this collection use [`set_depends_on`](Self::set_depends_on).
    ///
    /// <p>Indicates that the container relies on the status of other containers in the same container group during its startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub fn depends_on(mut self, input: crate::types::ContainerDependency) -> Self {
        let mut v = self.depends_on.unwrap_or_default();
        v.push(input);
        self.depends_on = ::std::option::Option::Some(v);
        self
    }
    /// <p>Indicates that the container relies on the status of other containers in the same container group during its startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub fn set_depends_on(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>) -> Self {
        self.depends_on = input;
        self
    }
    /// <p>Indicates that the container relies on the status of other containers in the same container group during its startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub fn get_depends_on(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>> {
        &self.depends_on
    }
    /// Appends an item to `mount_points`.
    ///
    /// To override the contents of this collection use [`set_mount_points`](Self::set_mount_points).
    ///
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn mount_points(mut self, input: crate::types::ContainerMountPoint) -> Self {
        let mut v = self.mount_points.unwrap_or_default();
        v.push(input);
        self.mount_points = ::std::option::Option::Some(v);
        self
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn set_mount_points(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>) -> Self {
        self.mount_points = input;
        self
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn get_mount_points(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>> {
        &self.mount_points
    }
    /// Appends an item to `environment_override`.
    ///
    /// To override the contents of this collection use [`set_environment_override`](Self::set_environment_override).
    ///
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn environment_override(mut self, input: crate::types::ContainerEnvironment) -> Self {
        let mut v = self.environment_override.unwrap_or_default();
        v.push(input);
        self.environment_override = ::std::option::Option::Some(v);
        self
    }
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn set_environment_override(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>) -> Self {
        self.environment_override = input;
        self
    }
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn get_environment_override(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>> {
        &self.environment_override
    }
    /// <p>Indicates whether the container is vital to the container group. If an essential container fails, the entire container group restarts.</p>
    pub fn essential(mut self, input: bool) -> Self {
        self.essential = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the container is vital to the container group. If an essential container fails, the entire container group restarts.</p>
    pub fn set_essential(mut self, input: ::std::option::Option<bool>) -> Self {
        self.essential = input;
        self
    }
    /// <p>Indicates whether the container is vital to the container group. If an essential container fails, the entire container group restarts.</p>
    pub fn get_essential(&self) -> &::std::option::Option<bool> {
        &self.essential
    }
    /// <p>A configuration for a non-terminal health check. A support container automatically restarts if it stops functioning or if it fails this health check.</p>
    pub fn health_check(mut self, input: crate::types::ContainerHealthCheck) -> Self {
        self.health_check = ::std::option::Option::Some(input);
        self
    }
    /// <p>A configuration for a non-terminal health check. A support container automatically restarts if it stops functioning or if it fails this health check.</p>
    pub fn set_health_check(mut self, input: ::std::option::Option<crate::types::ContainerHealthCheck>) -> Self {
        self.health_check = input;
        self
    }
    /// <p>A configuration for a non-terminal health check. A support container automatically restarts if it stops functioning or if it fails this health check.</p>
    pub fn get_health_check(&self) -> &::std::option::Option<crate::types::ContainerHealthCheck> {
        &self.health_check
    }
    /// <p>The URI to the image that Amazon GameLift Servers deploys to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub fn image_uri(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.image_uri = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The URI to the image that Amazon GameLift Servers deploys to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub fn set_image_uri(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.image_uri = input;
        self
    }
    /// <p>The URI to the image that Amazon GameLift Servers deploys to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub fn get_image_uri(&self) -> &::std::option::Option<::std::string::String> {
        &self.image_uri
    }
    /// <p>The amount of memory that Amazon GameLift Servers makes available to the container. If memory limits aren't set for an individual container, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition TotalMemoryLimitMebibytes</a></p>
    pub fn memory_hard_limit_mebibytes(mut self, input: i32) -> Self {
        self.memory_hard_limit_mebibytes = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of memory that Amazon GameLift Servers makes available to the container. If memory limits aren't set for an individual container, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition TotalMemoryLimitMebibytes</a></p>
    pub fn set_memory_hard_limit_mebibytes(mut self, input: ::std::option::Option<i32>) -> Self {
        self.memory_hard_limit_mebibytes = input;
        self
    }
    /// <p>The amount of memory that Amazon GameLift Servers makes available to the container. If memory limits aren't set for an individual container, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition TotalMemoryLimitMebibytes</a></p>
    pub fn get_memory_hard_limit_mebibytes(&self) -> &::std::option::Option<i32> {
        &self.memory_hard_limit_mebibytes
    }
    /// <p>A set of ports that allow access to the container from external users. Processes running in the container can bind to a one of these ports. Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn port_configuration(mut self, input: crate::types::ContainerPortConfiguration) -> Self {
        self.port_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>A set of ports that allow access to the container from external users. Processes running in the container can bind to a one of these ports. Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn set_port_configuration(mut self, input: ::std::option::Option<crate::types::ContainerPortConfiguration>) -> Self {
        self.port_configuration = input;
        self
    }
    /// <p>A set of ports that allow access to the container from external users. Processes running in the container can bind to a one of these ports. Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn get_port_configuration(&self) -> &::std::option::Option<crate::types::ContainerPortConfiguration> {
        &self.port_configuration
    }
    /// <p>A unique and immutable identifier for the container image. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn resolved_image_digest(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.resolved_image_digest = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique and immutable identifier for the container image. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn set_resolved_image_digest(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.resolved_image_digest = input;
        self
    }
    /// <p>A unique and immutable identifier for the container image. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn get_resolved_image_digest(&self) -> &::std::option::Option<::std::string::String> {
        &self.resolved_image_digest
    }
    /// <p>The number of vCPU units that are reserved for the container. If no resources are reserved, the container shares the total vCPU limit for the container group.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition TotalVcpuLimit</a></p>
    pub fn vcpu(mut self, input: f64) -> Self {
        self.vcpu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of vCPU units that are reserved for the container. If no resources are reserved, the container shares the total vCPU limit for the container group.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition TotalVcpuLimit</a></p>
    pub fn set_vcpu(mut self, input: ::std::option::Option<f64>) -> Self {
        self.vcpu = input;
        self
    }
    /// <p>The number of vCPU units that are reserved for the container. If no resources are reserved, the container shares the total vCPU limit for the container group.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition TotalVcpuLimit</a></p>
    pub fn get_vcpu(&self) -> &::std::option::Option<f64> {
        &self.vcpu
    }
    /// Consumes the builder and constructs a [`SupportContainerDefinition`](crate::types::SupportContainerDefinition).
    pub fn build(self) -> crate::types::SupportContainerDefinition {
        crate::types::SupportContainerDefinition {
            container_name: self.container_name,
            depends_on: self.depends_on,
            mount_points: self.mount_points,
            environment_override: self.environment_override,
            essential: self.essential,
            health_check: self.health_check,
            image_uri: self.image_uri,
            memory_hard_limit_mebibytes: self.memory_hard_limit_mebibytes,
            port_configuration: self.port_configuration,
            resolved_image_digest: self.resolved_image_digest,
            vcpu: self.vcpu,
        }
    }
}
