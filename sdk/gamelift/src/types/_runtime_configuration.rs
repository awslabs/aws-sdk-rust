// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A collection of server process configurations that describe the set of processes to run on each instance in a fleet. Server processes run either an executable in a custom game build or a Realtime Servers script. GameLift launches the configured processes, manages their life cycle, and replaces them as needed. Each instance checks regularly for an updated runtime configuration. </p>
/// <p>A GameLift instance is limited to 50 processes running concurrently. To calculate the total number of processes in a runtime configuration, add the values of the <code>ConcurrentExecutions</code> parameter for each server process. Learn more about <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/fleets-multiprocess.html"> Running Multiple Processes on a Fleet</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RuntimeConfiguration {
    /// <p>A collection of server process configurations that identify what server processes to run on each instance in a fleet.</p>
    #[doc(hidden)]
    pub server_processes: std::option::Option<std::vec::Vec<crate::types::ServerProcess>>,
    /// <p>The number of game sessions in status <code>ACTIVATING</code> to allow on an instance. This setting limits the instance resources that can be used for new game activations at any one time.</p>
    #[doc(hidden)]
    pub max_concurrent_game_session_activations: std::option::Option<i32>,
    /// <p>The maximum amount of time (in seconds) allowed to launch a new game session and have it report ready to host players. During this time, the game session is in status <code>ACTIVATING</code>. If the game session does not become active before the timeout, it is ended and the game session status is changed to <code>TERMINATED</code>.</p>
    #[doc(hidden)]
    pub game_session_activation_timeout_seconds: std::option::Option<i32>,
}
impl RuntimeConfiguration {
    /// <p>A collection of server process configurations that identify what server processes to run on each instance in a fleet.</p>
    pub fn server_processes(&self) -> std::option::Option<&[crate::types::ServerProcess]> {
        self.server_processes.as_deref()
    }
    /// <p>The number of game sessions in status <code>ACTIVATING</code> to allow on an instance. This setting limits the instance resources that can be used for new game activations at any one time.</p>
    pub fn max_concurrent_game_session_activations(&self) -> std::option::Option<i32> {
        self.max_concurrent_game_session_activations
    }
    /// <p>The maximum amount of time (in seconds) allowed to launch a new game session and have it report ready to host players. During this time, the game session is in status <code>ACTIVATING</code>. If the game session does not become active before the timeout, it is ended and the game session status is changed to <code>TERMINATED</code>.</p>
    pub fn game_session_activation_timeout_seconds(&self) -> std::option::Option<i32> {
        self.game_session_activation_timeout_seconds
    }
}
impl RuntimeConfiguration {
    /// Creates a new builder-style object to manufacture [`RuntimeConfiguration`](crate::types::RuntimeConfiguration).
    pub fn builder() -> crate::types::builders::RuntimeConfigurationBuilder {
        crate::types::builders::RuntimeConfigurationBuilder::default()
    }
}

/// A builder for [`RuntimeConfiguration`](crate::types::RuntimeConfiguration).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct RuntimeConfigurationBuilder {
    pub(crate) server_processes: std::option::Option<std::vec::Vec<crate::types::ServerProcess>>,
    pub(crate) max_concurrent_game_session_activations: std::option::Option<i32>,
    pub(crate) game_session_activation_timeout_seconds: std::option::Option<i32>,
}
impl RuntimeConfigurationBuilder {
    /// Appends an item to `server_processes`.
    ///
    /// To override the contents of this collection use [`set_server_processes`](Self::set_server_processes).
    ///
    /// <p>A collection of server process configurations that identify what server processes to run on each instance in a fleet.</p>
    pub fn server_processes(mut self, input: crate::types::ServerProcess) -> Self {
        let mut v = self.server_processes.unwrap_or_default();
        v.push(input);
        self.server_processes = Some(v);
        self
    }
    /// <p>A collection of server process configurations that identify what server processes to run on each instance in a fleet.</p>
    pub fn set_server_processes(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::ServerProcess>>,
    ) -> Self {
        self.server_processes = input;
        self
    }
    /// <p>The number of game sessions in status <code>ACTIVATING</code> to allow on an instance. This setting limits the instance resources that can be used for new game activations at any one time.</p>
    pub fn max_concurrent_game_session_activations(mut self, input: i32) -> Self {
        self.max_concurrent_game_session_activations = Some(input);
        self
    }
    /// <p>The number of game sessions in status <code>ACTIVATING</code> to allow on an instance. This setting limits the instance resources that can be used for new game activations at any one time.</p>
    pub fn set_max_concurrent_game_session_activations(
        mut self,
        input: std::option::Option<i32>,
    ) -> Self {
        self.max_concurrent_game_session_activations = input;
        self
    }
    /// <p>The maximum amount of time (in seconds) allowed to launch a new game session and have it report ready to host players. During this time, the game session is in status <code>ACTIVATING</code>. If the game session does not become active before the timeout, it is ended and the game session status is changed to <code>TERMINATED</code>.</p>
    pub fn game_session_activation_timeout_seconds(mut self, input: i32) -> Self {
        self.game_session_activation_timeout_seconds = Some(input);
        self
    }
    /// <p>The maximum amount of time (in seconds) allowed to launch a new game session and have it report ready to host players. During this time, the game session is in status <code>ACTIVATING</code>. If the game session does not become active before the timeout, it is ended and the game session status is changed to <code>TERMINATED</code>.</p>
    pub fn set_game_session_activation_timeout_seconds(
        mut self,
        input: std::option::Option<i32>,
    ) -> Self {
        self.game_session_activation_timeout_seconds = input;
        self
    }
    /// Consumes the builder and constructs a [`RuntimeConfiguration`](crate::types::RuntimeConfiguration).
    pub fn build(self) -> crate::types::RuntimeConfiguration {
        crate::types::RuntimeConfiguration {
            server_processes: self.server_processes,
            max_concurrent_game_session_activations: self.max_concurrent_game_session_activations,
            game_session_activation_timeout_seconds: self.game_session_activation_timeout_seconds,
        }
    }
}
