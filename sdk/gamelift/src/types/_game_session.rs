// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Properties describing a game session.</p>
/// <p>A game session in ACTIVE status can host players. When a game session ends, its status is set to <code>TERMINATED</code>. </p>
/// <p>Amazon GameLift retains a game session resource for 30 days after the game session ends. You can reuse idempotency token values after this time. Game session logs are retained for 14 days.</p>
/// <p> <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-awssdk.html#reference-awssdk-resources-fleets">All APIs by task</a> </p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GameSession {
    /// <p>A unique identifier for the game session. A game session ARN has the following format: <code>arn:aws:gamelift:
    /// <region>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </region></code>.</p>
    pub game_session_id: ::std::option::Option<::std::string::String>,
    /// <p>A descriptive label that is associated with a game session. Session names do not need to be unique.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>A unique identifier for the fleet that the game session is running on.</p>
    pub fleet_id: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) associated with the GameLift fleet that this game session is running on. </p>
    pub fleet_arn: ::std::option::Option<::std::string::String>,
    /// <p>A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub creation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>A time stamp indicating when this data object was terminated. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub termination_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>Number of players currently in the game session.</p>
    pub current_player_session_count: ::std::option::Option<i32>,
    /// <p>The maximum number of players that can be connected simultaneously to the game session.</p>
    pub maximum_player_session_count: ::std::option::Option<i32>,
    /// <p>Current status of the game session. A game session must have an <code>ACTIVE</code> status to have player sessions.</p>
    pub status: ::std::option::Option<crate::types::GameSessionStatus>,
    /// <p>Provides additional information about game session status. <code>INTERRUPTED</code> indicates that the game session was hosted on a spot instance that was reclaimed, causing the active game session to be terminated.</p>
    pub status_reason: ::std::option::Option<crate::types::GameSessionStatusReason>,
    /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
    pub game_properties: ::std::option::Option<::std::vec::Vec<crate::types::GameProperty>>,
    /// <p>The IP address of the game session. To connect to a Amazon GameLift game server, an app needs both the IP address and port number.</p>
    pub ip_address: ::std::option::Option<::std::string::String>,
    /// <p>The DNS identifier assigned to the instance that is running the game session. Values have the following format:</p>
    /// <ul>
    /// <li> <p>TLS-enabled fleets: <code>
    /// <unique identifier>
    /// .
    /// <region identifier>
    /// .amazongamelift.com
    /// </region>
    /// </unique></code>.</p> </li>
    /// <li> <p>Non-TLS-enabled fleets: <code>ec2-
    /// <unique identifier>
    /// .compute.amazonaws.com
    /// </unique></code>. (See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses">Amazon EC2 Instance IP Addressing</a>.)</p> </li>
    /// </ul>
    /// <p>When connecting to a game session that is running on a TLS-enabled fleet, you must use the DNS name, not the IP address.</p>
    pub dns_name: ::std::option::Option<::std::string::String>,
    /// <p>The port number for the game session. To connect to a Amazon GameLift game server, an app needs both the IP address and port number.</p>
    pub port: ::std::option::Option<i32>,
    /// <p>Indicates whether or not the game session is accepting new players.</p>
    pub player_session_creation_policy: ::std::option::Option<crate::types::PlayerSessionCreationPolicy>,
    /// <p>A unique identifier for a player. This ID is used to enforce a resource protection policy (if one exists), that limits the number of game sessions a player can create.</p>
    pub creator_id: ::std::option::Option<::std::string::String>,
    /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
    pub game_session_data: ::std::option::Option<::std::string::String>,
    /// <p>Information about the matchmaking process that resulted in the game session, if matchmaking was used. Data is in JSON syntax, formatted as a string. Information includes the matchmaker ID as well as player attributes and team assignments. For more details on matchmaker data, see <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-server.html#match-server-data">Match Data</a>. Matchmaker data is updated whenever new players are added during a successful backfill (see <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_StartMatchBackfill.html">StartMatchBackfill</a>). </p>
    pub matchmaker_data: ::std::option::Option<::std::string::String>,
    /// <p>The fleet location where the game session is running. This value might specify the fleet's home Region or a remote location. Location is expressed as an Amazon Web Services Region code such as <code>us-west-2</code>. </p>
    pub location: ::std::option::Option<::std::string::String>,
}
impl GameSession {
    /// <p>A unique identifier for the game session. A game session ARN has the following format: <code>arn:aws:gamelift:
    /// <region>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </region></code>.</p>
    pub fn game_session_id(&self) -> ::std::option::Option<&str> {
        self.game_session_id.as_deref()
    }
    /// <p>A descriptive label that is associated with a game session. Session names do not need to be unique.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the fleet that the game session is running on.</p>
    pub fn fleet_id(&self) -> ::std::option::Option<&str> {
        self.fleet_id.as_deref()
    }
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) associated with the GameLift fleet that this game session is running on. </p>
    pub fn fleet_arn(&self) -> ::std::option::Option<&str> {
        self.fleet_arn.as_deref()
    }
    /// <p>A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn creation_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>A time stamp indicating when this data object was terminated. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn termination_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.termination_time.as_ref()
    }
    /// <p>Number of players currently in the game session.</p>
    pub fn current_player_session_count(&self) -> ::std::option::Option<i32> {
        self.current_player_session_count
    }
    /// <p>The maximum number of players that can be connected simultaneously to the game session.</p>
    pub fn maximum_player_session_count(&self) -> ::std::option::Option<i32> {
        self.maximum_player_session_count
    }
    /// <p>Current status of the game session. A game session must have an <code>ACTIVE</code> status to have player sessions.</p>
    pub fn status(&self) -> ::std::option::Option<&crate::types::GameSessionStatus> {
        self.status.as_ref()
    }
    /// <p>Provides additional information about game session status. <code>INTERRUPTED</code> indicates that the game session was hosted on a spot instance that was reclaimed, causing the active game session to be terminated.</p>
    pub fn status_reason(&self) -> ::std::option::Option<&crate::types::GameSessionStatusReason> {
        self.status_reason.as_ref()
    }
    /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.game_properties.is_none()`.
    pub fn game_properties(&self) -> &[crate::types::GameProperty] {
        self.game_properties.as_deref().unwrap_or_default()
    }
    /// <p>The IP address of the game session. To connect to a Amazon GameLift game server, an app needs both the IP address and port number.</p>
    pub fn ip_address(&self) -> ::std::option::Option<&str> {
        self.ip_address.as_deref()
    }
    /// <p>The DNS identifier assigned to the instance that is running the game session. Values have the following format:</p>
    /// <ul>
    /// <li> <p>TLS-enabled fleets: <code>
    /// <unique identifier>
    /// .
    /// <region identifier>
    /// .amazongamelift.com
    /// </region>
    /// </unique></code>.</p> </li>
    /// <li> <p>Non-TLS-enabled fleets: <code>ec2-
    /// <unique identifier>
    /// .compute.amazonaws.com
    /// </unique></code>. (See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses">Amazon EC2 Instance IP Addressing</a>.)</p> </li>
    /// </ul>
    /// <p>When connecting to a game session that is running on a TLS-enabled fleet, you must use the DNS name, not the IP address.</p>
    pub fn dns_name(&self) -> ::std::option::Option<&str> {
        self.dns_name.as_deref()
    }
    /// <p>The port number for the game session. To connect to a Amazon GameLift game server, an app needs both the IP address and port number.</p>
    pub fn port(&self) -> ::std::option::Option<i32> {
        self.port
    }
    /// <p>Indicates whether or not the game session is accepting new players.</p>
    pub fn player_session_creation_policy(&self) -> ::std::option::Option<&crate::types::PlayerSessionCreationPolicy> {
        self.player_session_creation_policy.as_ref()
    }
    /// <p>A unique identifier for a player. This ID is used to enforce a resource protection policy (if one exists), that limits the number of game sessions a player can create.</p>
    pub fn creator_id(&self) -> ::std::option::Option<&str> {
        self.creator_id.as_deref()
    }
    /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
    pub fn game_session_data(&self) -> ::std::option::Option<&str> {
        self.game_session_data.as_deref()
    }
    /// <p>Information about the matchmaking process that resulted in the game session, if matchmaking was used. Data is in JSON syntax, formatted as a string. Information includes the matchmaker ID as well as player attributes and team assignments. For more details on matchmaker data, see <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-server.html#match-server-data">Match Data</a>. Matchmaker data is updated whenever new players are added during a successful backfill (see <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_StartMatchBackfill.html">StartMatchBackfill</a>). </p>
    pub fn matchmaker_data(&self) -> ::std::option::Option<&str> {
        self.matchmaker_data.as_deref()
    }
    /// <p>The fleet location where the game session is running. This value might specify the fleet's home Region or a remote location. Location is expressed as an Amazon Web Services Region code such as <code>us-west-2</code>. </p>
    pub fn location(&self) -> ::std::option::Option<&str> {
        self.location.as_deref()
    }
}
impl GameSession {
    /// Creates a new builder-style object to manufacture [`GameSession`](crate::types::GameSession).
    pub fn builder() -> crate::types::builders::GameSessionBuilder {
        crate::types::builders::GameSessionBuilder::default()
    }
}

/// A builder for [`GameSession`](crate::types::GameSession).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct GameSessionBuilder {
    pub(crate) game_session_id: ::std::option::Option<::std::string::String>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) fleet_id: ::std::option::Option<::std::string::String>,
    pub(crate) fleet_arn: ::std::option::Option<::std::string::String>,
    pub(crate) creation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) termination_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) current_player_session_count: ::std::option::Option<i32>,
    pub(crate) maximum_player_session_count: ::std::option::Option<i32>,
    pub(crate) status: ::std::option::Option<crate::types::GameSessionStatus>,
    pub(crate) status_reason: ::std::option::Option<crate::types::GameSessionStatusReason>,
    pub(crate) game_properties: ::std::option::Option<::std::vec::Vec<crate::types::GameProperty>>,
    pub(crate) ip_address: ::std::option::Option<::std::string::String>,
    pub(crate) dns_name: ::std::option::Option<::std::string::String>,
    pub(crate) port: ::std::option::Option<i32>,
    pub(crate) player_session_creation_policy: ::std::option::Option<crate::types::PlayerSessionCreationPolicy>,
    pub(crate) creator_id: ::std::option::Option<::std::string::String>,
    pub(crate) game_session_data: ::std::option::Option<::std::string::String>,
    pub(crate) matchmaker_data: ::std::option::Option<::std::string::String>,
    pub(crate) location: ::std::option::Option<::std::string::String>,
}
impl GameSessionBuilder {
    /// <p>A unique identifier for the game session. A game session ARN has the following format: <code>arn:aws:gamelift:
    /// <region>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </region></code>.</p>
    pub fn game_session_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.game_session_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier for the game session. A game session ARN has the following format: <code>arn:aws:gamelift:
    /// <region>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </region></code>.</p>
    pub fn set_game_session_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.game_session_id = input;
        self
    }
    /// <p>A unique identifier for the game session. A game session ARN has the following format: <code>arn:aws:gamelift:
    /// <region>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </region></code>.</p>
    pub fn get_game_session_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.game_session_id
    }
    /// <p>A descriptive label that is associated with a game session. Session names do not need to be unique.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A descriptive label that is associated with a game session. Session names do not need to be unique.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>A descriptive label that is associated with a game session. Session names do not need to be unique.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>A unique identifier for the fleet that the game session is running on.</p>
    pub fn fleet_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.fleet_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier for the fleet that the game session is running on.</p>
    pub fn set_fleet_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.fleet_id = input;
        self
    }
    /// <p>A unique identifier for the fleet that the game session is running on.</p>
    pub fn get_fleet_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.fleet_id
    }
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) associated with the GameLift fleet that this game session is running on. </p>
    pub fn fleet_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.fleet_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) associated with the GameLift fleet that this game session is running on. </p>
    pub fn set_fleet_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.fleet_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) associated with the GameLift fleet that this game session is running on. </p>
    pub fn get_fleet_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.fleet_arn
    }
    /// <p>A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn creation_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.creation_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn set_creation_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.creation_time = input;
        self
    }
    /// <p>A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn get_creation_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.creation_time
    }
    /// <p>A time stamp indicating when this data object was terminated. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn termination_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.termination_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>A time stamp indicating when this data object was terminated. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn set_termination_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.termination_time = input;
        self
    }
    /// <p>A time stamp indicating when this data object was terminated. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn get_termination_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.termination_time
    }
    /// <p>Number of players currently in the game session.</p>
    pub fn current_player_session_count(mut self, input: i32) -> Self {
        self.current_player_session_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>Number of players currently in the game session.</p>
    pub fn set_current_player_session_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.current_player_session_count = input;
        self
    }
    /// <p>Number of players currently in the game session.</p>
    pub fn get_current_player_session_count(&self) -> &::std::option::Option<i32> {
        &self.current_player_session_count
    }
    /// <p>The maximum number of players that can be connected simultaneously to the game session.</p>
    pub fn maximum_player_session_count(mut self, input: i32) -> Self {
        self.maximum_player_session_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of players that can be connected simultaneously to the game session.</p>
    pub fn set_maximum_player_session_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.maximum_player_session_count = input;
        self
    }
    /// <p>The maximum number of players that can be connected simultaneously to the game session.</p>
    pub fn get_maximum_player_session_count(&self) -> &::std::option::Option<i32> {
        &self.maximum_player_session_count
    }
    /// <p>Current status of the game session. A game session must have an <code>ACTIVE</code> status to have player sessions.</p>
    pub fn status(mut self, input: crate::types::GameSessionStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>Current status of the game session. A game session must have an <code>ACTIVE</code> status to have player sessions.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::GameSessionStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>Current status of the game session. A game session must have an <code>ACTIVE</code> status to have player sessions.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::GameSessionStatus> {
        &self.status
    }
    /// <p>Provides additional information about game session status. <code>INTERRUPTED</code> indicates that the game session was hosted on a spot instance that was reclaimed, causing the active game session to be terminated.</p>
    pub fn status_reason(mut self, input: crate::types::GameSessionStatusReason) -> Self {
        self.status_reason = ::std::option::Option::Some(input);
        self
    }
    /// <p>Provides additional information about game session status. <code>INTERRUPTED</code> indicates that the game session was hosted on a spot instance that was reclaimed, causing the active game session to be terminated.</p>
    pub fn set_status_reason(mut self, input: ::std::option::Option<crate::types::GameSessionStatusReason>) -> Self {
        self.status_reason = input;
        self
    }
    /// <p>Provides additional information about game session status. <code>INTERRUPTED</code> indicates that the game session was hosted on a spot instance that was reclaimed, causing the active game session to be terminated.</p>
    pub fn get_status_reason(&self) -> &::std::option::Option<crate::types::GameSessionStatusReason> {
        &self.status_reason
    }
    /// Appends an item to `game_properties`.
    ///
    /// To override the contents of this collection use [`set_game_properties`](Self::set_game_properties).
    ///
    /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
    pub fn game_properties(mut self, input: crate::types::GameProperty) -> Self {
        let mut v = self.game_properties.unwrap_or_default();
        v.push(input);
        self.game_properties = ::std::option::Option::Some(v);
        self
    }
    /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
    pub fn set_game_properties(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::GameProperty>>) -> Self {
        self.game_properties = input;
        self
    }
    /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
    pub fn get_game_properties(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::GameProperty>> {
        &self.game_properties
    }
    /// <p>The IP address of the game session. To connect to a Amazon GameLift game server, an app needs both the IP address and port number.</p>
    pub fn ip_address(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ip_address = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IP address of the game session. To connect to a Amazon GameLift game server, an app needs both the IP address and port number.</p>
    pub fn set_ip_address(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ip_address = input;
        self
    }
    /// <p>The IP address of the game session. To connect to a Amazon GameLift game server, an app needs both the IP address and port number.</p>
    pub fn get_ip_address(&self) -> &::std::option::Option<::std::string::String> {
        &self.ip_address
    }
    /// <p>The DNS identifier assigned to the instance that is running the game session. Values have the following format:</p>
    /// <ul>
    /// <li> <p>TLS-enabled fleets: <code>
    /// <unique identifier>
    /// .
    /// <region identifier>
    /// .amazongamelift.com
    /// </region>
    /// </unique></code>.</p> </li>
    /// <li> <p>Non-TLS-enabled fleets: <code>ec2-
    /// <unique identifier>
    /// .compute.amazonaws.com
    /// </unique></code>. (See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses">Amazon EC2 Instance IP Addressing</a>.)</p> </li>
    /// </ul>
    /// <p>When connecting to a game session that is running on a TLS-enabled fleet, you must use the DNS name, not the IP address.</p>
    pub fn dns_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.dns_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The DNS identifier assigned to the instance that is running the game session. Values have the following format:</p>
    /// <ul>
    /// <li> <p>TLS-enabled fleets: <code>
    /// <unique identifier>
    /// .
    /// <region identifier>
    /// .amazongamelift.com
    /// </region>
    /// </unique></code>.</p> </li>
    /// <li> <p>Non-TLS-enabled fleets: <code>ec2-
    /// <unique identifier>
    /// .compute.amazonaws.com
    /// </unique></code>. (See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses">Amazon EC2 Instance IP Addressing</a>.)</p> </li>
    /// </ul>
    /// <p>When connecting to a game session that is running on a TLS-enabled fleet, you must use the DNS name, not the IP address.</p>
    pub fn set_dns_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.dns_name = input;
        self
    }
    /// <p>The DNS identifier assigned to the instance that is running the game session. Values have the following format:</p>
    /// <ul>
    /// <li> <p>TLS-enabled fleets: <code>
    /// <unique identifier>
    /// .
    /// <region identifier>
    /// .amazongamelift.com
    /// </region>
    /// </unique></code>.</p> </li>
    /// <li> <p>Non-TLS-enabled fleets: <code>ec2-
    /// <unique identifier>
    /// .compute.amazonaws.com
    /// </unique></code>. (See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses">Amazon EC2 Instance IP Addressing</a>.)</p> </li>
    /// </ul>
    /// <p>When connecting to a game session that is running on a TLS-enabled fleet, you must use the DNS name, not the IP address.</p>
    pub fn get_dns_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.dns_name
    }
    /// <p>The port number for the game session. To connect to a Amazon GameLift game server, an app needs both the IP address and port number.</p>
    pub fn port(mut self, input: i32) -> Self {
        self.port = ::std::option::Option::Some(input);
        self
    }
    /// <p>The port number for the game session. To connect to a Amazon GameLift game server, an app needs both the IP address and port number.</p>
    pub fn set_port(mut self, input: ::std::option::Option<i32>) -> Self {
        self.port = input;
        self
    }
    /// <p>The port number for the game session. To connect to a Amazon GameLift game server, an app needs both the IP address and port number.</p>
    pub fn get_port(&self) -> &::std::option::Option<i32> {
        &self.port
    }
    /// <p>Indicates whether or not the game session is accepting new players.</p>
    pub fn player_session_creation_policy(mut self, input: crate::types::PlayerSessionCreationPolicy) -> Self {
        self.player_session_creation_policy = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether or not the game session is accepting new players.</p>
    pub fn set_player_session_creation_policy(mut self, input: ::std::option::Option<crate::types::PlayerSessionCreationPolicy>) -> Self {
        self.player_session_creation_policy = input;
        self
    }
    /// <p>Indicates whether or not the game session is accepting new players.</p>
    pub fn get_player_session_creation_policy(&self) -> &::std::option::Option<crate::types::PlayerSessionCreationPolicy> {
        &self.player_session_creation_policy
    }
    /// <p>A unique identifier for a player. This ID is used to enforce a resource protection policy (if one exists), that limits the number of game sessions a player can create.</p>
    pub fn creator_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.creator_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier for a player. This ID is used to enforce a resource protection policy (if one exists), that limits the number of game sessions a player can create.</p>
    pub fn set_creator_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.creator_id = input;
        self
    }
    /// <p>A unique identifier for a player. This ID is used to enforce a resource protection policy (if one exists), that limits the number of game sessions a player can create.</p>
    pub fn get_creator_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.creator_id
    }
    /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
    pub fn game_session_data(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.game_session_data = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
    pub fn set_game_session_data(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.game_session_data = input;
        self
    }
    /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
    pub fn get_game_session_data(&self) -> &::std::option::Option<::std::string::String> {
        &self.game_session_data
    }
    /// <p>Information about the matchmaking process that resulted in the game session, if matchmaking was used. Data is in JSON syntax, formatted as a string. Information includes the matchmaker ID as well as player attributes and team assignments. For more details on matchmaker data, see <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-server.html#match-server-data">Match Data</a>. Matchmaker data is updated whenever new players are added during a successful backfill (see <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_StartMatchBackfill.html">StartMatchBackfill</a>). </p>
    pub fn matchmaker_data(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.matchmaker_data = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Information about the matchmaking process that resulted in the game session, if matchmaking was used. Data is in JSON syntax, formatted as a string. Information includes the matchmaker ID as well as player attributes and team assignments. For more details on matchmaker data, see <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-server.html#match-server-data">Match Data</a>. Matchmaker data is updated whenever new players are added during a successful backfill (see <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_StartMatchBackfill.html">StartMatchBackfill</a>). </p>
    pub fn set_matchmaker_data(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.matchmaker_data = input;
        self
    }
    /// <p>Information about the matchmaking process that resulted in the game session, if matchmaking was used. Data is in JSON syntax, formatted as a string. Information includes the matchmaker ID as well as player attributes and team assignments. For more details on matchmaker data, see <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-server.html#match-server-data">Match Data</a>. Matchmaker data is updated whenever new players are added during a successful backfill (see <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_StartMatchBackfill.html">StartMatchBackfill</a>). </p>
    pub fn get_matchmaker_data(&self) -> &::std::option::Option<::std::string::String> {
        &self.matchmaker_data
    }
    /// <p>The fleet location where the game session is running. This value might specify the fleet's home Region or a remote location. Location is expressed as an Amazon Web Services Region code such as <code>us-west-2</code>. </p>
    pub fn location(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.location = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The fleet location where the game session is running. This value might specify the fleet's home Region or a remote location. Location is expressed as an Amazon Web Services Region code such as <code>us-west-2</code>. </p>
    pub fn set_location(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.location = input;
        self
    }
    /// <p>The fleet location where the game session is running. This value might specify the fleet's home Region or a remote location. Location is expressed as an Amazon Web Services Region code such as <code>us-west-2</code>. </p>
    pub fn get_location(&self) -> &::std::option::Option<::std::string::String> {
        &self.location
    }
    /// Consumes the builder and constructs a [`GameSession`](crate::types::GameSession).
    pub fn build(self) -> crate::types::GameSession {
        crate::types::GameSession {
            game_session_id: self.game_session_id,
            name: self.name,
            fleet_id: self.fleet_id,
            fleet_arn: self.fleet_arn,
            creation_time: self.creation_time,
            termination_time: self.termination_time,
            current_player_session_count: self.current_player_session_count,
            maximum_player_session_count: self.maximum_player_session_count,
            status: self.status,
            status_reason: self.status_reason,
            game_properties: self.game_properties,
            ip_address: self.ip_address,
            dns_name: self.dns_name,
            port: self.port,
            player_session_creation_policy: self.player_session_creation_policy,
            creator_id: self.creator_id,
            game_session_data: self.game_session_data,
            matchmaker_data: self.matchmaker_data,
            location: self.location,
        }
    }
}
