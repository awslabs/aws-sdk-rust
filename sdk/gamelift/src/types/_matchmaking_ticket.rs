// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Ticket generated to track the progress of a matchmaking request. Each ticket is uniquely identified by a ticket ID, supplied by the requester, when creating a matchmaking request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MatchmakingTicket  {
    /// <p>A unique identifier for a matchmaking ticket.</p>
    #[doc(hidden)]
    pub ticket_id: std::option::Option<std::string::String>,
    /// <p>Name of the matchmaking configuration that is used with this ticket. Matchmaking configurations determine how players are grouped into a match and how a new game session is created for the match.</p>
    #[doc(hidden)]
    pub configuration_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) associated with the GameLift matchmaking configuration resource that is used with this ticket.</p>
    #[doc(hidden)]
    pub configuration_arn: std::option::Option<std::string::String>,
    /// <p>Current status of the matchmaking request.</p> 
    /// <ul> 
    /// <li> <p> <b>QUEUED</b> -- The matchmaking request has been received and is currently waiting to be processed.</p> </li> 
    /// <li> <p> <b>SEARCHING</b> -- The matchmaking request is currently being processed. </p> </li> 
    /// <li> <p> <b>REQUIRES_ACCEPTANCE</b> -- A match has been proposed and the players must accept the match. This status is used only with requests that use a matchmaking configuration with a player acceptance requirement.</p> </li> 
    /// <li> <p> <b>PLACING</b> -- The FlexMatch engine has matched players and is in the process of placing a new game session for the match.</p> </li> 
    /// <li> <p> <b>COMPLETED</b> -- Players have been matched and a game session is ready to host the players. A ticket in this state contains the necessary connection information for players.</p> </li> 
    /// <li> <p> <b>FAILED</b> -- The matchmaking request was not completed.</p> </li> 
    /// <li> <p> <b>CANCELLED</b> -- The matchmaking request was canceled. This may be the result of a <code>StopMatchmaking</code> operation or a proposed match that one or more players failed to accept.</p> </li> 
    /// <li> <p> <b>TIMED_OUT</b> -- The matchmaking request was not successful within the duration specified in the matchmaking configuration. </p> </li> 
    /// </ul> <note> 
    /// <p>Matchmaking requests that fail to successfully complete (statuses FAILED, CANCELLED, TIMED_OUT) can be resubmitted as new requests with new ticket IDs.</p> 
    /// </note>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::MatchmakingConfigurationStatus>,
    /// <p>Code to explain the current status. For example, a status reason may indicate when a ticket has returned to <code>SEARCHING</code> status after a proposed match fails to receive player acceptances.</p>
    #[doc(hidden)]
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>Additional information about the current status.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>Time stamp indicating when this matchmaking request was received. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Time stamp indicating when the matchmaking request stopped being processed due to successful completion, timeout, or cancellation. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A set of <code>Player</code> objects, each representing a player to find matches for. Players are identified by a unique player ID and may include latency data for use during matchmaking. If the ticket is in status <code>COMPLETED</code>, the <code>Player</code> objects include the team the players were assigned to in the resulting match.</p>
    #[doc(hidden)]
    pub players: std::option::Option<std::vec::Vec<crate::types::Player>>,
    /// <p>Connection information for a new game session. Once a match is made, the FlexMatch engine creates a new game session for it. This information is added to the matchmaking ticket, which you can be retrieve by calling <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeMatchmaking.html">DescribeMatchmaking</a> .</p>
    #[doc(hidden)]
    pub game_session_connection_info: std::option::Option<crate::types::GameSessionConnectionInfo>,
    /// <p>Average amount of time (in seconds) that players are currently waiting for a match. If there is not enough recent data, this property may be empty.</p>
    #[doc(hidden)]
    pub estimated_wait_time: std::option::Option<i32>,
}
impl MatchmakingTicket {
    /// <p>A unique identifier for a matchmaking ticket.</p>
    pub fn ticket_id(&self) -> std::option::Option<& str> {
        self.ticket_id.as_deref()
    }
    /// <p>Name of the matchmaking configuration that is used with this ticket. Matchmaking configurations determine how players are grouped into a match and how a new game session is created for the match.</p>
    pub fn configuration_name(&self) -> std::option::Option<& str> {
        self.configuration_name.as_deref()
    }
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) associated with the GameLift matchmaking configuration resource that is used with this ticket.</p>
    pub fn configuration_arn(&self) -> std::option::Option<& str> {
        self.configuration_arn.as_deref()
    }
    /// <p>Current status of the matchmaking request.</p> 
    /// <ul> 
    /// <li> <p> <b>QUEUED</b> -- The matchmaking request has been received and is currently waiting to be processed.</p> </li> 
    /// <li> <p> <b>SEARCHING</b> -- The matchmaking request is currently being processed. </p> </li> 
    /// <li> <p> <b>REQUIRES_ACCEPTANCE</b> -- A match has been proposed and the players must accept the match. This status is used only with requests that use a matchmaking configuration with a player acceptance requirement.</p> </li> 
    /// <li> <p> <b>PLACING</b> -- The FlexMatch engine has matched players and is in the process of placing a new game session for the match.</p> </li> 
    /// <li> <p> <b>COMPLETED</b> -- Players have been matched and a game session is ready to host the players. A ticket in this state contains the necessary connection information for players.</p> </li> 
    /// <li> <p> <b>FAILED</b> -- The matchmaking request was not completed.</p> </li> 
    /// <li> <p> <b>CANCELLED</b> -- The matchmaking request was canceled. This may be the result of a <code>StopMatchmaking</code> operation or a proposed match that one or more players failed to accept.</p> </li> 
    /// <li> <p> <b>TIMED_OUT</b> -- The matchmaking request was not successful within the duration specified in the matchmaking configuration. </p> </li> 
    /// </ul> <note> 
    /// <p>Matchmaking requests that fail to successfully complete (statuses FAILED, CANCELLED, TIMED_OUT) can be resubmitted as new requests with new ticket IDs.</p> 
    /// </note>
    pub fn status(&self) -> std::option::Option<& crate::types::MatchmakingConfigurationStatus> {
        self.status.as_ref()
    }
    /// <p>Code to explain the current status. For example, a status reason may indicate when a ticket has returned to <code>SEARCHING</code> status after a proposed match fails to receive player acceptances.</p>
    pub fn status_reason(&self) -> std::option::Option<& str> {
        self.status_reason.as_deref()
    }
    /// <p>Additional information about the current status.</p>
    pub fn status_message(&self) -> std::option::Option<& str> {
        self.status_message.as_deref()
    }
    /// <p>Time stamp indicating when this matchmaking request was received. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn start_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>Time stamp indicating when the matchmaking request stopped being processed due to successful completion, timeout, or cancellation. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn end_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>A set of <code>Player</code> objects, each representing a player to find matches for. Players are identified by a unique player ID and may include latency data for use during matchmaking. If the ticket is in status <code>COMPLETED</code>, the <code>Player</code> objects include the team the players were assigned to in the resulting match.</p>
    pub fn players(&self) -> std::option::Option<& [crate::types::Player]> {
        self.players.as_deref()
    }
    /// <p>Connection information for a new game session. Once a match is made, the FlexMatch engine creates a new game session for it. This information is added to the matchmaking ticket, which you can be retrieve by calling <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeMatchmaking.html">DescribeMatchmaking</a> .</p>
    pub fn game_session_connection_info(&self) -> std::option::Option<& crate::types::GameSessionConnectionInfo> {
        self.game_session_connection_info.as_ref()
    }
    /// <p>Average amount of time (in seconds) that players are currently waiting for a match. If there is not enough recent data, this property may be empty.</p>
    pub fn estimated_wait_time(&self) -> std::option::Option<i32> {
        self.estimated_wait_time
    }
}
impl MatchmakingTicket {
    /// Creates a new builder-style object to manufacture [`MatchmakingTicket`](crate::types::MatchmakingTicket).
    pub fn builder() -> crate::types::builders::MatchmakingTicketBuilder {
        crate::types::builders::MatchmakingTicketBuilder::default()
    }
}

/// A builder for [`MatchmakingTicket`](crate::types::MatchmakingTicket).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct MatchmakingTicketBuilder {
    pub(crate) ticket_id: std::option::Option<std::string::String>,
    pub(crate) configuration_name: std::option::Option<std::string::String>,
    pub(crate) configuration_arn: std::option::Option<std::string::String>,
    pub(crate) status: std::option::Option<crate::types::MatchmakingConfigurationStatus>,
    pub(crate) status_reason: std::option::Option<std::string::String>,
    pub(crate) status_message: std::option::Option<std::string::String>,
    pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) players: std::option::Option<std::vec::Vec<crate::types::Player>>,
    pub(crate) game_session_connection_info: std::option::Option<crate::types::GameSessionConnectionInfo>,
    pub(crate) estimated_wait_time: std::option::Option<i32>,
}
impl MatchmakingTicketBuilder {
    /// <p>A unique identifier for a matchmaking ticket.</p>
    pub fn ticket_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.ticket_id = Some(input.into());
        self
    }
    /// <p>A unique identifier for a matchmaking ticket.</p>
    pub fn set_ticket_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.ticket_id = input; self
    }
    /// <p>Name of the matchmaking configuration that is used with this ticket. Matchmaking configurations determine how players are grouped into a match and how a new game session is created for the match.</p>
    pub fn configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.configuration_name = Some(input.into());
        self
    }
    /// <p>Name of the matchmaking configuration that is used with this ticket. Matchmaking configurations determine how players are grouped into a match and how a new game session is created for the match.</p>
    pub fn set_configuration_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.configuration_name = input; self
    }
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) associated with the GameLift matchmaking configuration resource that is used with this ticket.</p>
    pub fn configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.configuration_arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) associated with the GameLift matchmaking configuration resource that is used with this ticket.</p>
    pub fn set_configuration_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.configuration_arn = input; self
    }
    /// <p>Current status of the matchmaking request.</p> 
    /// <ul> 
    /// <li> <p> <b>QUEUED</b> -- The matchmaking request has been received and is currently waiting to be processed.</p> </li> 
    /// <li> <p> <b>SEARCHING</b> -- The matchmaking request is currently being processed. </p> </li> 
    /// <li> <p> <b>REQUIRES_ACCEPTANCE</b> -- A match has been proposed and the players must accept the match. This status is used only with requests that use a matchmaking configuration with a player acceptance requirement.</p> </li> 
    /// <li> <p> <b>PLACING</b> -- The FlexMatch engine has matched players and is in the process of placing a new game session for the match.</p> </li> 
    /// <li> <p> <b>COMPLETED</b> -- Players have been matched and a game session is ready to host the players. A ticket in this state contains the necessary connection information for players.</p> </li> 
    /// <li> <p> <b>FAILED</b> -- The matchmaking request was not completed.</p> </li> 
    /// <li> <p> <b>CANCELLED</b> -- The matchmaking request was canceled. This may be the result of a <code>StopMatchmaking</code> operation or a proposed match that one or more players failed to accept.</p> </li> 
    /// <li> <p> <b>TIMED_OUT</b> -- The matchmaking request was not successful within the duration specified in the matchmaking configuration. </p> </li> 
    /// </ul> <note> 
    /// <p>Matchmaking requests that fail to successfully complete (statuses FAILED, CANCELLED, TIMED_OUT) can be resubmitted as new requests with new ticket IDs.</p> 
    /// </note>
    pub fn status(mut self, input: crate::types::MatchmakingConfigurationStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>Current status of the matchmaking request.</p> 
    /// <ul> 
    /// <li> <p> <b>QUEUED</b> -- The matchmaking request has been received and is currently waiting to be processed.</p> </li> 
    /// <li> <p> <b>SEARCHING</b> -- The matchmaking request is currently being processed. </p> </li> 
    /// <li> <p> <b>REQUIRES_ACCEPTANCE</b> -- A match has been proposed and the players must accept the match. This status is used only with requests that use a matchmaking configuration with a player acceptance requirement.</p> </li> 
    /// <li> <p> <b>PLACING</b> -- The FlexMatch engine has matched players and is in the process of placing a new game session for the match.</p> </li> 
    /// <li> <p> <b>COMPLETED</b> -- Players have been matched and a game session is ready to host the players. A ticket in this state contains the necessary connection information for players.</p> </li> 
    /// <li> <p> <b>FAILED</b> -- The matchmaking request was not completed.</p> </li> 
    /// <li> <p> <b>CANCELLED</b> -- The matchmaking request was canceled. This may be the result of a <code>StopMatchmaking</code> operation or a proposed match that one or more players failed to accept.</p> </li> 
    /// <li> <p> <b>TIMED_OUT</b> -- The matchmaking request was not successful within the duration specified in the matchmaking configuration. </p> </li> 
    /// </ul> <note> 
    /// <p>Matchmaking requests that fail to successfully complete (statuses FAILED, CANCELLED, TIMED_OUT) can be resubmitted as new requests with new ticket IDs.</p> 
    /// </note>
    pub fn set_status(mut self, input: std::option::Option<crate::types::MatchmakingConfigurationStatus>) -> Self {
        self.status = input; self
    }
    /// <p>Code to explain the current status. For example, a status reason may indicate when a ticket has returned to <code>SEARCHING</code> status after a proposed match fails to receive player acceptances.</p>
    pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
        self.status_reason = Some(input.into());
        self
    }
    /// <p>Code to explain the current status. For example, a status reason may indicate when a ticket has returned to <code>SEARCHING</code> status after a proposed match fails to receive player acceptances.</p>
    pub fn set_status_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.status_reason = input; self
    }
    /// <p>Additional information about the current status.</p>
    pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
        self.status_message = Some(input.into());
        self
    }
    /// <p>Additional information about the current status.</p>
    pub fn set_status_message(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.status_message = input; self
    }
    /// <p>Time stamp indicating when this matchmaking request was received. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.start_time = Some(input);
        self
    }
    /// <p>Time stamp indicating when this matchmaking request was received. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn set_start_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.start_time = input; self
    }
    /// <p>Time stamp indicating when the matchmaking request stopped being processed due to successful completion, timeout, or cancellation. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.end_time = Some(input);
        self
    }
    /// <p>Time stamp indicating when the matchmaking request stopped being processed due to successful completion, timeout, or cancellation. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn set_end_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.end_time = input; self
    }
    /// Appends an item to `players`.
    ///
    /// To override the contents of this collection use [`set_players`](Self::set_players).
    ///
    /// <p>A set of <code>Player</code> objects, each representing a player to find matches for. Players are identified by a unique player ID and may include latency data for use during matchmaking. If the ticket is in status <code>COMPLETED</code>, the <code>Player</code> objects include the team the players were assigned to in the resulting match.</p>
    pub fn players(mut self, input: crate::types::Player) -> Self {
        let mut v = self.players.unwrap_or_default();
                        v.push(input);
                        self.players = Some(v);
                        self
    }
    /// <p>A set of <code>Player</code> objects, each representing a player to find matches for. Players are identified by a unique player ID and may include latency data for use during matchmaking. If the ticket is in status <code>COMPLETED</code>, the <code>Player</code> objects include the team the players were assigned to in the resulting match.</p>
    pub fn set_players(mut self, input: std::option::Option<std::vec::Vec<crate::types::Player>>) -> Self {
        self.players = input; self
    }
    /// <p>Connection information for a new game session. Once a match is made, the FlexMatch engine creates a new game session for it. This information is added to the matchmaking ticket, which you can be retrieve by calling <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeMatchmaking.html">DescribeMatchmaking</a> .</p>
    pub fn game_session_connection_info(mut self, input: crate::types::GameSessionConnectionInfo) -> Self {
        self.game_session_connection_info = Some(input);
        self
    }
    /// <p>Connection information for a new game session. Once a match is made, the FlexMatch engine creates a new game session for it. This information is added to the matchmaking ticket, which you can be retrieve by calling <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeMatchmaking.html">DescribeMatchmaking</a> .</p>
    pub fn set_game_session_connection_info(mut self, input: std::option::Option<crate::types::GameSessionConnectionInfo>) -> Self {
        self.game_session_connection_info = input; self
    }
    /// <p>Average amount of time (in seconds) that players are currently waiting for a match. If there is not enough recent data, this property may be empty.</p>
    pub fn estimated_wait_time(mut self, input: i32) -> Self {
        self.estimated_wait_time = Some(input);
        self
    }
    /// <p>Average amount of time (in seconds) that players are currently waiting for a match. If there is not enough recent data, this property may be empty.</p>
    pub fn set_estimated_wait_time(mut self, input: std::option::Option<i32>) -> Self {
        self.estimated_wait_time = input; self
    }
    /// Consumes the builder and constructs a [`MatchmakingTicket`](crate::types::MatchmakingTicket).
    pub fn build(self) -> crate::types::MatchmakingTicket {
        crate::types::MatchmakingTicket {
            ticket_id: self.ticket_id
            ,
            configuration_name: self.configuration_name
            ,
            configuration_arn: self.configuration_arn
            ,
            status: self.status
            ,
            status_reason: self.status_reason
            ,
            status_message: self.status_message
            ,
            start_time: self.start_time
            ,
            end_time: self.end_time
            ,
            players: self.players
            ,
            game_session_connection_info: self.game_session_connection_info
            ,
            estimated_wait_time: self.estimated_wait_time
            ,
        }
    }
}

