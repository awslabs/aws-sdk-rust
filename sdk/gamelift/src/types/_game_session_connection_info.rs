// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Connection information for a new game session that is created in response to a start matchmaking request. Once a match is made, the FlexMatch engine creates a new game session for it. This information, including the game session endpoint and player sessions for each player in the original matchmaking request, is added to the matchmaking ticket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GameSessionConnectionInfo  {
    /// <p>A unique identifier for the game session. Use the game session ID.</p>
    #[doc(hidden)]
    pub game_session_arn: std::option::Option<std::string::String>,
    /// <p>The IP address of the game session. To connect to a GameLift game server, an app needs both the IP address and port number.</p>
    #[doc(hidden)]
    pub ip_address: std::option::Option<std::string::String>,
    /// <p>The DNS identifier assigned to the instance that is running the game session. Values have the following format:</p> 
    /// <ul> 
    /// <li> <p>TLS-enabled fleets: <code>
    /// <unique identifier>
    /// .
    /// <region identifier>
    /// .amazongamelift.com
    /// </region>
    /// </unique></code>.</p> </li> 
    /// <li> <p>Non-TLS-enabled fleets: <code>ec2-
    /// <unique identifier>
    /// .compute.amazonaws.com
    /// </unique></code>. (See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses">Amazon EC2 Instance IP Addressing</a>.)</p> </li> 
    /// </ul> 
    /// <p>When connecting to a game session that is running on a TLS-enabled fleet, you must use the DNS name, not the IP address.</p>
    #[doc(hidden)]
    pub dns_name: std::option::Option<std::string::String>,
    /// <p>The port number for the game session. To connect to a GameLift game server, an app needs both the IP address and port number.</p>
    #[doc(hidden)]
    pub port: std::option::Option<i32>,
    /// <p>A collection of player session IDs, one for each player ID that was included in the original matchmaking request. </p>
    #[doc(hidden)]
    pub matched_player_sessions: std::option::Option<std::vec::Vec<crate::types::MatchedPlayerSession>>,
}
impl GameSessionConnectionInfo {
    /// <p>A unique identifier for the game session. Use the game session ID.</p>
    pub fn game_session_arn(&self) -> std::option::Option<& str> {
        self.game_session_arn.as_deref()
    }
    /// <p>The IP address of the game session. To connect to a GameLift game server, an app needs both the IP address and port number.</p>
    pub fn ip_address(&self) -> std::option::Option<& str> {
        self.ip_address.as_deref()
    }
    /// <p>The DNS identifier assigned to the instance that is running the game session. Values have the following format:</p> 
    /// <ul> 
    /// <li> <p>TLS-enabled fleets: <code>
    /// <unique identifier>
    /// .
    /// <region identifier>
    /// .amazongamelift.com
    /// </region>
    /// </unique></code>.</p> </li> 
    /// <li> <p>Non-TLS-enabled fleets: <code>ec2-
    /// <unique identifier>
    /// .compute.amazonaws.com
    /// </unique></code>. (See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses">Amazon EC2 Instance IP Addressing</a>.)</p> </li> 
    /// </ul> 
    /// <p>When connecting to a game session that is running on a TLS-enabled fleet, you must use the DNS name, not the IP address.</p>
    pub fn dns_name(&self) -> std::option::Option<& str> {
        self.dns_name.as_deref()
    }
    /// <p>The port number for the game session. To connect to a GameLift game server, an app needs both the IP address and port number.</p>
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
    /// <p>A collection of player session IDs, one for each player ID that was included in the original matchmaking request. </p>
    pub fn matched_player_sessions(&self) -> std::option::Option<& [crate::types::MatchedPlayerSession]> {
        self.matched_player_sessions.as_deref()
    }
}
impl GameSessionConnectionInfo {
    /// Creates a new builder-style object to manufacture [`GameSessionConnectionInfo`](crate::types::GameSessionConnectionInfo).
    pub fn builder() -> crate::types::builders::GameSessionConnectionInfoBuilder {
        crate::types::builders::GameSessionConnectionInfoBuilder::default()
    }
}

/// A builder for [`GameSessionConnectionInfo`](crate::types::GameSessionConnectionInfo).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct GameSessionConnectionInfoBuilder {
    pub(crate) game_session_arn: std::option::Option<std::string::String>,
    pub(crate) ip_address: std::option::Option<std::string::String>,
    pub(crate) dns_name: std::option::Option<std::string::String>,
    pub(crate) port: std::option::Option<i32>,
    pub(crate) matched_player_sessions: std::option::Option<std::vec::Vec<crate::types::MatchedPlayerSession>>,
}
impl GameSessionConnectionInfoBuilder {
    /// <p>A unique identifier for the game session. Use the game session ID.</p>
    pub fn game_session_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.game_session_arn = Some(input.into());
        self
    }
    /// <p>A unique identifier for the game session. Use the game session ID.</p>
    pub fn set_game_session_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.game_session_arn = input; self
    }
    /// <p>The IP address of the game session. To connect to a GameLift game server, an app needs both the IP address and port number.</p>
    pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
        self.ip_address = Some(input.into());
        self
    }
    /// <p>The IP address of the game session. To connect to a GameLift game server, an app needs both the IP address and port number.</p>
    pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.ip_address = input; self
    }
    /// <p>The DNS identifier assigned to the instance that is running the game session. Values have the following format:</p> 
    /// <ul> 
    /// <li> <p>TLS-enabled fleets: <code>
    /// <unique identifier>
    /// .
    /// <region identifier>
    /// .amazongamelift.com
    /// </region>
    /// </unique></code>.</p> </li> 
    /// <li> <p>Non-TLS-enabled fleets: <code>ec2-
    /// <unique identifier>
    /// .compute.amazonaws.com
    /// </unique></code>. (See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses">Amazon EC2 Instance IP Addressing</a>.)</p> </li> 
    /// </ul> 
    /// <p>When connecting to a game session that is running on a TLS-enabled fleet, you must use the DNS name, not the IP address.</p>
    pub fn dns_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.dns_name = Some(input.into());
        self
    }
    /// <p>The DNS identifier assigned to the instance that is running the game session. Values have the following format:</p> 
    /// <ul> 
    /// <li> <p>TLS-enabled fleets: <code>
    /// <unique identifier>
    /// .
    /// <region identifier>
    /// .amazongamelift.com
    /// </region>
    /// </unique></code>.</p> </li> 
    /// <li> <p>Non-TLS-enabled fleets: <code>ec2-
    /// <unique identifier>
    /// .compute.amazonaws.com
    /// </unique></code>. (See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses">Amazon EC2 Instance IP Addressing</a>.)</p> </li> 
    /// </ul> 
    /// <p>When connecting to a game session that is running on a TLS-enabled fleet, you must use the DNS name, not the IP address.</p>
    pub fn set_dns_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.dns_name = input; self
    }
    /// <p>The port number for the game session. To connect to a GameLift game server, an app needs both the IP address and port number.</p>
    pub fn port(mut self, input: i32) -> Self {
        self.port = Some(input);
        self
    }
    /// <p>The port number for the game session. To connect to a GameLift game server, an app needs both the IP address and port number.</p>
    pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
        self.port = input; self
    }
    /// Appends an item to `matched_player_sessions`.
    ///
    /// To override the contents of this collection use [`set_matched_player_sessions`](Self::set_matched_player_sessions).
    ///
    /// <p>A collection of player session IDs, one for each player ID that was included in the original matchmaking request. </p>
    pub fn matched_player_sessions(mut self, input: crate::types::MatchedPlayerSession) -> Self {
        let mut v = self.matched_player_sessions.unwrap_or_default();
                        v.push(input);
                        self.matched_player_sessions = Some(v);
                        self
    }
    /// <p>A collection of player session IDs, one for each player ID that was included in the original matchmaking request. </p>
    pub fn set_matched_player_sessions(mut self, input: std::option::Option<std::vec::Vec<crate::types::MatchedPlayerSession>>) -> Self {
        self.matched_player_sessions = input; self
    }
    /// Consumes the builder and constructs a [`GameSessionConnectionInfo`](crate::types::GameSessionConnectionInfo).
    pub fn build(self) -> crate::types::GameSessionConnectionInfo {
        crate::types::GameSessionConnectionInfo {
            game_session_arn: self.game_session_arn
            ,
            ip_address: self.ip_address
            ,
            dns_name: self.dns_name
            ,
            port: self.port
            ,
            matched_player_sessions: self.matched_player_sessions
            ,
        }
    }
}

