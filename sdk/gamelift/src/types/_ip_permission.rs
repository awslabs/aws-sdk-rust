// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an instance in a fleet. New game sessions are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. Fleets with custom game builds must have permissions explicitly set. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct IpPermission {
    /// <p>A starting value for a range of allowed port numbers.</p>
    /// <p>For fleets using Linux builds, only ports <code>22</code> and <code>1026-60000</code> are valid.</p>
    /// <p>For fleets using Windows builds, only ports <code>1026-60000</code> are valid.</p>
    pub from_port: ::std::option::Option<i32>,
    /// <p>An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than <code>FromPort</code>.</p>
    /// <p>For fleets using Linux builds, only ports <code>22</code> and <code>1026-60000</code> are valid.</p>
    /// <p>For fleets using Windows builds, only ports <code>1026-60000</code> are valid.</p>
    pub to_port: ::std::option::Option<i32>,
    /// <p>A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "<code>000.000.000.000/[subnet mask]</code>" or optionally the shortened version "<code>0.0.0.0/[subnet mask]</code>".</p>
    pub ip_range: ::std::option::Option<::std::string::String>,
    /// <p>The network communication protocol used by the fleet.</p>
    pub protocol: ::std::option::Option<crate::types::IpProtocol>,
}
impl IpPermission {
    /// <p>A starting value for a range of allowed port numbers.</p>
    /// <p>For fleets using Linux builds, only ports <code>22</code> and <code>1026-60000</code> are valid.</p>
    /// <p>For fleets using Windows builds, only ports <code>1026-60000</code> are valid.</p>
    pub fn from_port(&self) -> ::std::option::Option<i32> {
        self.from_port
    }
    /// <p>An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than <code>FromPort</code>.</p>
    /// <p>For fleets using Linux builds, only ports <code>22</code> and <code>1026-60000</code> are valid.</p>
    /// <p>For fleets using Windows builds, only ports <code>1026-60000</code> are valid.</p>
    pub fn to_port(&self) -> ::std::option::Option<i32> {
        self.to_port
    }
    /// <p>A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "<code>000.000.000.000/[subnet mask]</code>" or optionally the shortened version "<code>0.0.0.0/[subnet mask]</code>".</p>
    pub fn ip_range(&self) -> ::std::option::Option<&str> {
        self.ip_range.as_deref()
    }
    /// <p>The network communication protocol used by the fleet.</p>
    pub fn protocol(&self) -> ::std::option::Option<&crate::types::IpProtocol> {
        self.protocol.as_ref()
    }
}
impl IpPermission {
    /// Creates a new builder-style object to manufacture [`IpPermission`](crate::types::IpPermission).
    pub fn builder() -> crate::types::builders::IpPermissionBuilder {
        crate::types::builders::IpPermissionBuilder::default()
    }
}

/// A builder for [`IpPermission`](crate::types::IpPermission).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct IpPermissionBuilder {
    pub(crate) from_port: ::std::option::Option<i32>,
    pub(crate) to_port: ::std::option::Option<i32>,
    pub(crate) ip_range: ::std::option::Option<::std::string::String>,
    pub(crate) protocol: ::std::option::Option<crate::types::IpProtocol>,
}
impl IpPermissionBuilder {
    /// <p>A starting value for a range of allowed port numbers.</p>
    /// <p>For fleets using Linux builds, only ports <code>22</code> and <code>1026-60000</code> are valid.</p>
    /// <p>For fleets using Windows builds, only ports <code>1026-60000</code> are valid.</p>
    /// This field is required.
    pub fn from_port(mut self, input: i32) -> Self {
        self.from_port = ::std::option::Option::Some(input);
        self
    }
    /// <p>A starting value for a range of allowed port numbers.</p>
    /// <p>For fleets using Linux builds, only ports <code>22</code> and <code>1026-60000</code> are valid.</p>
    /// <p>For fleets using Windows builds, only ports <code>1026-60000</code> are valid.</p>
    pub fn set_from_port(mut self, input: ::std::option::Option<i32>) -> Self {
        self.from_port = input;
        self
    }
    /// <p>A starting value for a range of allowed port numbers.</p>
    /// <p>For fleets using Linux builds, only ports <code>22</code> and <code>1026-60000</code> are valid.</p>
    /// <p>For fleets using Windows builds, only ports <code>1026-60000</code> are valid.</p>
    pub fn get_from_port(&self) -> &::std::option::Option<i32> {
        &self.from_port
    }
    /// <p>An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than <code>FromPort</code>.</p>
    /// <p>For fleets using Linux builds, only ports <code>22</code> and <code>1026-60000</code> are valid.</p>
    /// <p>For fleets using Windows builds, only ports <code>1026-60000</code> are valid.</p>
    /// This field is required.
    pub fn to_port(mut self, input: i32) -> Self {
        self.to_port = ::std::option::Option::Some(input);
        self
    }
    /// <p>An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than <code>FromPort</code>.</p>
    /// <p>For fleets using Linux builds, only ports <code>22</code> and <code>1026-60000</code> are valid.</p>
    /// <p>For fleets using Windows builds, only ports <code>1026-60000</code> are valid.</p>
    pub fn set_to_port(mut self, input: ::std::option::Option<i32>) -> Self {
        self.to_port = input;
        self
    }
    /// <p>An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than <code>FromPort</code>.</p>
    /// <p>For fleets using Linux builds, only ports <code>22</code> and <code>1026-60000</code> are valid.</p>
    /// <p>For fleets using Windows builds, only ports <code>1026-60000</code> are valid.</p>
    pub fn get_to_port(&self) -> &::std::option::Option<i32> {
        &self.to_port
    }
    /// <p>A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "<code>000.000.000.000/[subnet mask]</code>" or optionally the shortened version "<code>0.0.0.0/[subnet mask]</code>".</p>
    /// This field is required.
    pub fn ip_range(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ip_range = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "<code>000.000.000.000/[subnet mask]</code>" or optionally the shortened version "<code>0.0.0.0/[subnet mask]</code>".</p>
    pub fn set_ip_range(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ip_range = input;
        self
    }
    /// <p>A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "<code>000.000.000.000/[subnet mask]</code>" or optionally the shortened version "<code>0.0.0.0/[subnet mask]</code>".</p>
    pub fn get_ip_range(&self) -> &::std::option::Option<::std::string::String> {
        &self.ip_range
    }
    /// <p>The network communication protocol used by the fleet.</p>
    /// This field is required.
    pub fn protocol(mut self, input: crate::types::IpProtocol) -> Self {
        self.protocol = ::std::option::Option::Some(input);
        self
    }
    /// <p>The network communication protocol used by the fleet.</p>
    pub fn set_protocol(mut self, input: ::std::option::Option<crate::types::IpProtocol>) -> Self {
        self.protocol = input;
        self
    }
    /// <p>The network communication protocol used by the fleet.</p>
    pub fn get_protocol(&self) -> &::std::option::Option<crate::types::IpProtocol> {
        &self.protocol
    }
    /// Consumes the builder and constructs a [`IpPermission`](crate::types::IpPermission).
    pub fn build(self) -> crate::types::IpPermission {
        crate::types::IpPermission {
            from_port: self.from_port,
            to_port: self.to_port,
            ip_range: self.ip_range,
            protocol: self.protocol,
        }
    }
}
