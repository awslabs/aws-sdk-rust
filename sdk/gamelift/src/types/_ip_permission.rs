// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an instance in a fleet. New game sessions are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. Fleets with custom game builds must have permissions explicitly set. For Realtime Servers fleets, GameLift automatically opens two port ranges, one for TCP messaging and one for UDP.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IpPermission {
    /// <p>A starting value for a range of allowed port numbers.</p>
    /// <p>For fleets using Windows and Linux builds, only ports 1026-60000 are valid.</p>
    #[doc(hidden)]
    pub from_port: std::option::Option<i32>,
    /// <p>An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than <code>FromPort</code>.</p>
    /// <p>For fleets using Windows and Linux builds, only ports 1026-60000 are valid.</p>
    #[doc(hidden)]
    pub to_port: std::option::Option<i32>,
    /// <p>A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "<code>000.000.000.000/[subnet mask]</code>" or optionally the shortened version "<code>0.0.0.0/[subnet mask]</code>".</p>
    #[doc(hidden)]
    pub ip_range: std::option::Option<std::string::String>,
    /// <p>The network communication protocol used by the fleet.</p>
    #[doc(hidden)]
    pub protocol: std::option::Option<crate::types::IpProtocol>,
}
impl IpPermission {
    /// <p>A starting value for a range of allowed port numbers.</p>
    /// <p>For fleets using Windows and Linux builds, only ports 1026-60000 are valid.</p>
    pub fn from_port(&self) -> std::option::Option<i32> {
        self.from_port
    }
    /// <p>An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than <code>FromPort</code>.</p>
    /// <p>For fleets using Windows and Linux builds, only ports 1026-60000 are valid.</p>
    pub fn to_port(&self) -> std::option::Option<i32> {
        self.to_port
    }
    /// <p>A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "<code>000.000.000.000/[subnet mask]</code>" or optionally the shortened version "<code>0.0.0.0/[subnet mask]</code>".</p>
    pub fn ip_range(&self) -> std::option::Option<&str> {
        self.ip_range.as_deref()
    }
    /// <p>The network communication protocol used by the fleet.</p>
    pub fn protocol(&self) -> std::option::Option<&crate::types::IpProtocol> {
        self.protocol.as_ref()
    }
}
impl IpPermission {
    /// Creates a new builder-style object to manufacture [`IpPermission`](crate::types::IpPermission).
    pub fn builder() -> crate::types::builders::IpPermissionBuilder {
        crate::types::builders::IpPermissionBuilder::default()
    }
}

/// A builder for [`IpPermission`](crate::types::IpPermission).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct IpPermissionBuilder {
    pub(crate) from_port: std::option::Option<i32>,
    pub(crate) to_port: std::option::Option<i32>,
    pub(crate) ip_range: std::option::Option<std::string::String>,
    pub(crate) protocol: std::option::Option<crate::types::IpProtocol>,
}
impl IpPermissionBuilder {
    /// <p>A starting value for a range of allowed port numbers.</p>
    /// <p>For fleets using Windows and Linux builds, only ports 1026-60000 are valid.</p>
    pub fn from_port(mut self, input: i32) -> Self {
        self.from_port = Some(input);
        self
    }
    /// <p>A starting value for a range of allowed port numbers.</p>
    /// <p>For fleets using Windows and Linux builds, only ports 1026-60000 are valid.</p>
    pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
        self.from_port = input;
        self
    }
    /// <p>An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than <code>FromPort</code>.</p>
    /// <p>For fleets using Windows and Linux builds, only ports 1026-60000 are valid.</p>
    pub fn to_port(mut self, input: i32) -> Self {
        self.to_port = Some(input);
        self
    }
    /// <p>An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than <code>FromPort</code>.</p>
    /// <p>For fleets using Windows and Linux builds, only ports 1026-60000 are valid.</p>
    pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
        self.to_port = input;
        self
    }
    /// <p>A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "<code>000.000.000.000/[subnet mask]</code>" or optionally the shortened version "<code>0.0.0.0/[subnet mask]</code>".</p>
    pub fn ip_range(mut self, input: impl Into<std::string::String>) -> Self {
        self.ip_range = Some(input.into());
        self
    }
    /// <p>A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "<code>000.000.000.000/[subnet mask]</code>" or optionally the shortened version "<code>0.0.0.0/[subnet mask]</code>".</p>
    pub fn set_ip_range(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.ip_range = input;
        self
    }
    /// <p>The network communication protocol used by the fleet.</p>
    pub fn protocol(mut self, input: crate::types::IpProtocol) -> Self {
        self.protocol = Some(input);
        self
    }
    /// <p>The network communication protocol used by the fleet.</p>
    pub fn set_protocol(mut self, input: std::option::Option<crate::types::IpProtocol>) -> Self {
        self.protocol = input;
        self
    }
    /// Consumes the builder and constructs a [`IpPermission`](crate::types::IpPermission).
    pub fn build(self) -> crate::types::IpPermission {
        crate::types::IpPermission {
            from_port: self.from_port,
            to_port: self.to_port,
            ip_range: self.ip_range,
            protocol: self.protocol,
        }
    }
}
