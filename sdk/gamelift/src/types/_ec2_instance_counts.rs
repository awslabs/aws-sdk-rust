// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Resource capacity settings. Fleet capacity is measured in Amazon EC2 instances. Pending and terminating counts are non-zero when the fleet capacity is adjusting to a scaling event or if access to resources is temporarily affected.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Ec2InstanceCounts {
    /// <p>Ideal number of active instances. GameLift will always try to maintain the desired number of instances. Capacity is scaled up or down by changing the desired instances. </p>
    #[doc(hidden)]
    pub desired: std::option::Option<i32>,
    /// <p>The minimum instance count value allowed.</p>
    #[doc(hidden)]
    pub minimum: std::option::Option<i32>,
    /// <p>The maximum instance count value allowed.</p>
    #[doc(hidden)]
    pub maximum: std::option::Option<i32>,
    /// <p>Number of instances that are starting but not yet active.</p>
    #[doc(hidden)]
    pub pending: std::option::Option<i32>,
    /// <p>Actual number of instances that are ready to host game sessions.</p>
    #[doc(hidden)]
    pub active: std::option::Option<i32>,
    /// <p>Number of active instances that are not currently hosting a game session.</p>
    #[doc(hidden)]
    pub idle: std::option::Option<i32>,
    /// <p>Number of instances that are no longer active but haven't yet been terminated.</p>
    #[doc(hidden)]
    pub terminating: std::option::Option<i32>,
}
impl Ec2InstanceCounts {
    /// <p>Ideal number of active instances. GameLift will always try to maintain the desired number of instances. Capacity is scaled up or down by changing the desired instances. </p>
    pub fn desired(&self) -> std::option::Option<i32> {
        self.desired
    }
    /// <p>The minimum instance count value allowed.</p>
    pub fn minimum(&self) -> std::option::Option<i32> {
        self.minimum
    }
    /// <p>The maximum instance count value allowed.</p>
    pub fn maximum(&self) -> std::option::Option<i32> {
        self.maximum
    }
    /// <p>Number of instances that are starting but not yet active.</p>
    pub fn pending(&self) -> std::option::Option<i32> {
        self.pending
    }
    /// <p>Actual number of instances that are ready to host game sessions.</p>
    pub fn active(&self) -> std::option::Option<i32> {
        self.active
    }
    /// <p>Number of active instances that are not currently hosting a game session.</p>
    pub fn idle(&self) -> std::option::Option<i32> {
        self.idle
    }
    /// <p>Number of instances that are no longer active but haven't yet been terminated.</p>
    pub fn terminating(&self) -> std::option::Option<i32> {
        self.terminating
    }
}
impl Ec2InstanceCounts {
    /// Creates a new builder-style object to manufacture [`Ec2InstanceCounts`](crate::types::Ec2InstanceCounts).
    pub fn builder() -> crate::types::builders::Ec2InstanceCountsBuilder {
        crate::types::builders::Ec2InstanceCountsBuilder::default()
    }
}

/// A builder for [`Ec2InstanceCounts`](crate::types::Ec2InstanceCounts).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct Ec2InstanceCountsBuilder {
    pub(crate) desired: std::option::Option<i32>,
    pub(crate) minimum: std::option::Option<i32>,
    pub(crate) maximum: std::option::Option<i32>,
    pub(crate) pending: std::option::Option<i32>,
    pub(crate) active: std::option::Option<i32>,
    pub(crate) idle: std::option::Option<i32>,
    pub(crate) terminating: std::option::Option<i32>,
}
impl Ec2InstanceCountsBuilder {
    /// <p>Ideal number of active instances. GameLift will always try to maintain the desired number of instances. Capacity is scaled up or down by changing the desired instances. </p>
    pub fn desired(mut self, input: i32) -> Self {
        self.desired = Some(input);
        self
    }
    /// <p>Ideal number of active instances. GameLift will always try to maintain the desired number of instances. Capacity is scaled up or down by changing the desired instances. </p>
    pub fn set_desired(mut self, input: std::option::Option<i32>) -> Self {
        self.desired = input;
        self
    }
    /// <p>The minimum instance count value allowed.</p>
    pub fn minimum(mut self, input: i32) -> Self {
        self.minimum = Some(input);
        self
    }
    /// <p>The minimum instance count value allowed.</p>
    pub fn set_minimum(mut self, input: std::option::Option<i32>) -> Self {
        self.minimum = input;
        self
    }
    /// <p>The maximum instance count value allowed.</p>
    pub fn maximum(mut self, input: i32) -> Self {
        self.maximum = Some(input);
        self
    }
    /// <p>The maximum instance count value allowed.</p>
    pub fn set_maximum(mut self, input: std::option::Option<i32>) -> Self {
        self.maximum = input;
        self
    }
    /// <p>Number of instances that are starting but not yet active.</p>
    pub fn pending(mut self, input: i32) -> Self {
        self.pending = Some(input);
        self
    }
    /// <p>Number of instances that are starting but not yet active.</p>
    pub fn set_pending(mut self, input: std::option::Option<i32>) -> Self {
        self.pending = input;
        self
    }
    /// <p>Actual number of instances that are ready to host game sessions.</p>
    pub fn active(mut self, input: i32) -> Self {
        self.active = Some(input);
        self
    }
    /// <p>Actual number of instances that are ready to host game sessions.</p>
    pub fn set_active(mut self, input: std::option::Option<i32>) -> Self {
        self.active = input;
        self
    }
    /// <p>Number of active instances that are not currently hosting a game session.</p>
    pub fn idle(mut self, input: i32) -> Self {
        self.idle = Some(input);
        self
    }
    /// <p>Number of active instances that are not currently hosting a game session.</p>
    pub fn set_idle(mut self, input: std::option::Option<i32>) -> Self {
        self.idle = input;
        self
    }
    /// <p>Number of instances that are no longer active but haven't yet been terminated.</p>
    pub fn terminating(mut self, input: i32) -> Self {
        self.terminating = Some(input);
        self
    }
    /// <p>Number of instances that are no longer active but haven't yet been terminated.</p>
    pub fn set_terminating(mut self, input: std::option::Option<i32>) -> Self {
        self.terminating = input;
        self
    }
    /// Consumes the builder and constructs a [`Ec2InstanceCounts`](crate::types::Ec2InstanceCounts).
    pub fn build(self) -> crate::types::Ec2InstanceCounts {
        crate::types::Ec2InstanceCounts {
            desired: self.desired,
            minimum: self.minimum,
            maximum: self.maximum,
            pending: self.pending,
            active: self.active,
            idle: self.idle,
            terminating: self.terminating,
        }
    }
}
