// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes a support container in a container group. You can define a support container in either a game server container group or a per-instance container group. Support containers don't run game server processes.</p>
/// <p>This definition includes container configuration, resources, and start instructions. Use this data type when creating or updating a container group definition. For properties of a deployed support container, see <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_SupportContainerDefinition.html">SupportContainerDefinition</a>.</p>
/// <p><b>Use with: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_CreateContainerGroupDefinition.html">CreateContainerGroupDefinition</a>, <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_UpdateContainerGroupDefinition.html">UpdateContainerGroupDefinition</a></p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct SupportContainerDefinitionInput {
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub container_name: ::std::option::Option<::std::string::String>,
    /// <p>Establishes dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. For example, you might specify that <i>ContainerB</i> has a <code>START</code> dependency on <i>ContainerA</i>. This dependency means that <i>ContainerB</i> can't start until after <i>ContainerA</i> has started. This dependency is reversed on shutdown, which means that <i>ContainerB</i> must shut down before <i>ContainerA</i> can shut down.</p>
    pub depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub mount_points: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>,
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub environment_override: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    /// <p>Flags the container as vital for the container group to function properly. If an essential container fails, the entire container group restarts. At least one support container in a per-instance container group must be essential. When flagging a container as essential, also configure a health check so that the container can signal that it's healthy.</p>
    pub essential: ::std::option::Option<bool>,
    /// <p>Configuration for a non-terminal health check. A container automatically restarts if it stops functioning. With a health check, you can define additional reasons to flag a container as unhealthy and restart it. If an essential container fails a health check, the entire container group restarts.</p>
    pub health_check: ::std::option::Option<crate::types::ContainerHealthCheck>,
    /// <p>The location of the container image to deploy to a container fleet. Provide an image in an Amazon Elastic Container Registry public or private repository. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]@\[digest\]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]:\[tag\]</code></p></li>
    /// </ul>
    pub image_uri: ::std::option::Option<::std::string::String>,
    /// <p>A specified amount of memory (in MiB) to reserve for this container. If you don't specify a container-specific memory limit, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a>TotalMemoryLimitMebibytes<code></code></p>
    pub memory_hard_limit_mebibytes: ::std::option::Option<i32>,
    /// <p>A set of ports that Amazon GameLift can assign to processes in the container. Any processes that accept inbound traffic connections must be assigned a port from this set. The container port range must be large enough to assign one to each process in the container that needs one.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    /// <p>The number of vCPU units to reserve for this container. The container can use more resources when needed, if available. If you don't reserve CPU units for this container, it shares the container group's total vCPU limit.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a> TotalCpuLimit</p>
    pub vcpu: ::std::option::Option<f64>,
}
impl SupportContainerDefinitionInput {
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub fn container_name(&self) -> ::std::option::Option<&str> {
        self.container_name.as_deref()
    }
    /// <p>Establishes dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. For example, you might specify that <i>ContainerB</i> has a <code>START</code> dependency on <i>ContainerA</i>. This dependency means that <i>ContainerB</i> can't start until after <i>ContainerA</i> has started. This dependency is reversed on shutdown, which means that <i>ContainerB</i> must shut down before <i>ContainerA</i> can shut down.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.depends_on.is_none()`.
    pub fn depends_on(&self) -> &[crate::types::ContainerDependency] {
        self.depends_on.as_deref().unwrap_or_default()
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.mount_points.is_none()`.
    pub fn mount_points(&self) -> &[crate::types::ContainerMountPoint] {
        self.mount_points.as_deref().unwrap_or_default()
    }
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.environment_override.is_none()`.
    pub fn environment_override(&self) -> &[crate::types::ContainerEnvironment] {
        self.environment_override.as_deref().unwrap_or_default()
    }
    /// <p>Flags the container as vital for the container group to function properly. If an essential container fails, the entire container group restarts. At least one support container in a per-instance container group must be essential. When flagging a container as essential, also configure a health check so that the container can signal that it's healthy.</p>
    pub fn essential(&self) -> ::std::option::Option<bool> {
        self.essential
    }
    /// <p>Configuration for a non-terminal health check. A container automatically restarts if it stops functioning. With a health check, you can define additional reasons to flag a container as unhealthy and restart it. If an essential container fails a health check, the entire container group restarts.</p>
    pub fn health_check(&self) -> ::std::option::Option<&crate::types::ContainerHealthCheck> {
        self.health_check.as_ref()
    }
    /// <p>The location of the container image to deploy to a container fleet. Provide an image in an Amazon Elastic Container Registry public or private repository. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]@\[digest\]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]:\[tag\]</code></p></li>
    /// </ul>
    pub fn image_uri(&self) -> ::std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>A specified amount of memory (in MiB) to reserve for this container. If you don't specify a container-specific memory limit, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a>TotalMemoryLimitMebibytes<code></code></p>
    pub fn memory_hard_limit_mebibytes(&self) -> ::std::option::Option<i32> {
        self.memory_hard_limit_mebibytes
    }
    /// <p>A set of ports that Amazon GameLift can assign to processes in the container. Any processes that accept inbound traffic connections must be assigned a port from this set. The container port range must be large enough to assign one to each process in the container that needs one.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn port_configuration(&self) -> ::std::option::Option<&crate::types::ContainerPortConfiguration> {
        self.port_configuration.as_ref()
    }
    /// <p>The number of vCPU units to reserve for this container. The container can use more resources when needed, if available. If you don't reserve CPU units for this container, it shares the container group's total vCPU limit.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a> TotalCpuLimit</p>
    pub fn vcpu(&self) -> ::std::option::Option<f64> {
        self.vcpu
    }
}
impl SupportContainerDefinitionInput {
    /// Creates a new builder-style object to manufacture [`SupportContainerDefinitionInput`](crate::types::SupportContainerDefinitionInput).
    pub fn builder() -> crate::types::builders::SupportContainerDefinitionInputBuilder {
        crate::types::builders::SupportContainerDefinitionInputBuilder::default()
    }
}

/// A builder for [`SupportContainerDefinitionInput`](crate::types::SupportContainerDefinitionInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct SupportContainerDefinitionInputBuilder {
    pub(crate) container_name: ::std::option::Option<::std::string::String>,
    pub(crate) depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
    pub(crate) mount_points: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>,
    pub(crate) environment_override: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    pub(crate) essential: ::std::option::Option<bool>,
    pub(crate) health_check: ::std::option::Option<crate::types::ContainerHealthCheck>,
    pub(crate) image_uri: ::std::option::Option<::std::string::String>,
    pub(crate) memory_hard_limit_mebibytes: ::std::option::Option<i32>,
    pub(crate) port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    pub(crate) vcpu: ::std::option::Option<f64>,
}
impl SupportContainerDefinitionInputBuilder {
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    /// This field is required.
    pub fn container_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.container_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub fn set_container_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.container_name = input;
        self
    }
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub fn get_container_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.container_name
    }
    /// Appends an item to `depends_on`.
    ///
    /// To override the contents of this collection use [`set_depends_on`](Self::set_depends_on).
    ///
    /// <p>Establishes dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. For example, you might specify that <i>ContainerB</i> has a <code>START</code> dependency on <i>ContainerA</i>. This dependency means that <i>ContainerB</i> can't start until after <i>ContainerA</i> has started. This dependency is reversed on shutdown, which means that <i>ContainerB</i> must shut down before <i>ContainerA</i> can shut down.</p>
    pub fn depends_on(mut self, input: crate::types::ContainerDependency) -> Self {
        let mut v = self.depends_on.unwrap_or_default();
        v.push(input);
        self.depends_on = ::std::option::Option::Some(v);
        self
    }
    /// <p>Establishes dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. For example, you might specify that <i>ContainerB</i> has a <code>START</code> dependency on <i>ContainerA</i>. This dependency means that <i>ContainerB</i> can't start until after <i>ContainerA</i> has started. This dependency is reversed on shutdown, which means that <i>ContainerB</i> must shut down before <i>ContainerA</i> can shut down.</p>
    pub fn set_depends_on(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>) -> Self {
        self.depends_on = input;
        self
    }
    /// <p>Establishes dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. For example, you might specify that <i>ContainerB</i> has a <code>START</code> dependency on <i>ContainerA</i>. This dependency means that <i>ContainerB</i> can't start until after <i>ContainerA</i> has started. This dependency is reversed on shutdown, which means that <i>ContainerB</i> must shut down before <i>ContainerA</i> can shut down.</p>
    pub fn get_depends_on(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>> {
        &self.depends_on
    }
    /// Appends an item to `mount_points`.
    ///
    /// To override the contents of this collection use [`set_mount_points`](Self::set_mount_points).
    ///
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn mount_points(mut self, input: crate::types::ContainerMountPoint) -> Self {
        let mut v = self.mount_points.unwrap_or_default();
        v.push(input);
        self.mount_points = ::std::option::Option::Some(v);
        self
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn set_mount_points(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>) -> Self {
        self.mount_points = input;
        self
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn get_mount_points(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>> {
        &self.mount_points
    }
    /// Appends an item to `environment_override`.
    ///
    /// To override the contents of this collection use [`set_environment_override`](Self::set_environment_override).
    ///
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn environment_override(mut self, input: crate::types::ContainerEnvironment) -> Self {
        let mut v = self.environment_override.unwrap_or_default();
        v.push(input);
        self.environment_override = ::std::option::Option::Some(v);
        self
    }
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn set_environment_override(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>) -> Self {
        self.environment_override = input;
        self
    }
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn get_environment_override(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>> {
        &self.environment_override
    }
    /// <p>Flags the container as vital for the container group to function properly. If an essential container fails, the entire container group restarts. At least one support container in a per-instance container group must be essential. When flagging a container as essential, also configure a health check so that the container can signal that it's healthy.</p>
    pub fn essential(mut self, input: bool) -> Self {
        self.essential = ::std::option::Option::Some(input);
        self
    }
    /// <p>Flags the container as vital for the container group to function properly. If an essential container fails, the entire container group restarts. At least one support container in a per-instance container group must be essential. When flagging a container as essential, also configure a health check so that the container can signal that it's healthy.</p>
    pub fn set_essential(mut self, input: ::std::option::Option<bool>) -> Self {
        self.essential = input;
        self
    }
    /// <p>Flags the container as vital for the container group to function properly. If an essential container fails, the entire container group restarts. At least one support container in a per-instance container group must be essential. When flagging a container as essential, also configure a health check so that the container can signal that it's healthy.</p>
    pub fn get_essential(&self) -> &::std::option::Option<bool> {
        &self.essential
    }
    /// <p>Configuration for a non-terminal health check. A container automatically restarts if it stops functioning. With a health check, you can define additional reasons to flag a container as unhealthy and restart it. If an essential container fails a health check, the entire container group restarts.</p>
    pub fn health_check(mut self, input: crate::types::ContainerHealthCheck) -> Self {
        self.health_check = ::std::option::Option::Some(input);
        self
    }
    /// <p>Configuration for a non-terminal health check. A container automatically restarts if it stops functioning. With a health check, you can define additional reasons to flag a container as unhealthy and restart it. If an essential container fails a health check, the entire container group restarts.</p>
    pub fn set_health_check(mut self, input: ::std::option::Option<crate::types::ContainerHealthCheck>) -> Self {
        self.health_check = input;
        self
    }
    /// <p>Configuration for a non-terminal health check. A container automatically restarts if it stops functioning. With a health check, you can define additional reasons to flag a container as unhealthy and restart it. If an essential container fails a health check, the entire container group restarts.</p>
    pub fn get_health_check(&self) -> &::std::option::Option<crate::types::ContainerHealthCheck> {
        &self.health_check
    }
    /// <p>The location of the container image to deploy to a container fleet. Provide an image in an Amazon Elastic Container Registry public or private repository. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]@\[digest\]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]:\[tag\]</code></p></li>
    /// </ul>
    /// This field is required.
    pub fn image_uri(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.image_uri = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The location of the container image to deploy to a container fleet. Provide an image in an Amazon Elastic Container Registry public or private repository. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]@\[digest\]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]:\[tag\]</code></p></li>
    /// </ul>
    pub fn set_image_uri(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.image_uri = input;
        self
    }
    /// <p>The location of the container image to deploy to a container fleet. Provide an image in an Amazon Elastic Container Registry public or private repository. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]@\[digest\]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]:\[tag\]</code></p></li>
    /// </ul>
    pub fn get_image_uri(&self) -> &::std::option::Option<::std::string::String> {
        &self.image_uri
    }
    /// <p>A specified amount of memory (in MiB) to reserve for this container. If you don't specify a container-specific memory limit, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a>TotalMemoryLimitMebibytes<code></code></p>
    pub fn memory_hard_limit_mebibytes(mut self, input: i32) -> Self {
        self.memory_hard_limit_mebibytes = ::std::option::Option::Some(input);
        self
    }
    /// <p>A specified amount of memory (in MiB) to reserve for this container. If you don't specify a container-specific memory limit, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a>TotalMemoryLimitMebibytes<code></code></p>
    pub fn set_memory_hard_limit_mebibytes(mut self, input: ::std::option::Option<i32>) -> Self {
        self.memory_hard_limit_mebibytes = input;
        self
    }
    /// <p>A specified amount of memory (in MiB) to reserve for this container. If you don't specify a container-specific memory limit, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a>TotalMemoryLimitMebibytes<code></code></p>
    pub fn get_memory_hard_limit_mebibytes(&self) -> &::std::option::Option<i32> {
        &self.memory_hard_limit_mebibytes
    }
    /// <p>A set of ports that Amazon GameLift can assign to processes in the container. Any processes that accept inbound traffic connections must be assigned a port from this set. The container port range must be large enough to assign one to each process in the container that needs one.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn port_configuration(mut self, input: crate::types::ContainerPortConfiguration) -> Self {
        self.port_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>A set of ports that Amazon GameLift can assign to processes in the container. Any processes that accept inbound traffic connections must be assigned a port from this set. The container port range must be large enough to assign one to each process in the container that needs one.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn set_port_configuration(mut self, input: ::std::option::Option<crate::types::ContainerPortConfiguration>) -> Self {
        self.port_configuration = input;
        self
    }
    /// <p>A set of ports that Amazon GameLift can assign to processes in the container. Any processes that accept inbound traffic connections must be assigned a port from this set. The container port range must be large enough to assign one to each process in the container that needs one.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn get_port_configuration(&self) -> &::std::option::Option<crate::types::ContainerPortConfiguration> {
        &self.port_configuration
    }
    /// <p>The number of vCPU units to reserve for this container. The container can use more resources when needed, if available. If you don't reserve CPU units for this container, it shares the container group's total vCPU limit.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a> TotalCpuLimit</p>
    pub fn vcpu(mut self, input: f64) -> Self {
        self.vcpu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of vCPU units to reserve for this container. The container can use more resources when needed, if available. If you don't reserve CPU units for this container, it shares the container group's total vCPU limit.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a> TotalCpuLimit</p>
    pub fn set_vcpu(mut self, input: ::std::option::Option<f64>) -> Self {
        self.vcpu = input;
        self
    }
    /// <p>The number of vCPU units to reserve for this container. The container can use more resources when needed, if available. If you don't reserve CPU units for this container, it shares the container group's total vCPU limit.</p>
    /// <p><b>Related data type: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a> TotalCpuLimit</p>
    pub fn get_vcpu(&self) -> &::std::option::Option<f64> {
        &self.vcpu
    }
    /// Consumes the builder and constructs a [`SupportContainerDefinitionInput`](crate::types::SupportContainerDefinitionInput).
    pub fn build(self) -> crate::types::SupportContainerDefinitionInput {
        crate::types::SupportContainerDefinitionInput {
            container_name: self.container_name,
            depends_on: self.depends_on,
            mount_points: self.mount_points,
            environment_override: self.environment_override,
            essential: self.essential,
            health_check: self.health_check,
            image_uri: self.image_uri,
            memory_hard_limit_mebibytes: self.memory_hard_limit_mebibytes,
            port_configuration: self.port_configuration,
            vcpu: self.vcpu,
        }
    }
}
