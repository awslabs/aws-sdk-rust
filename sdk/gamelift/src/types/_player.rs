// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents a player in matchmaking. When starting a matchmaking request, a player has a player ID, attributes, and may have latency data. Team information is added after a match has been successfully completed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Player {
    /// <p>A unique identifier for a player</p>
    #[doc(hidden)]
    pub player_id: std::option::Option<std::string::String>,
    /// <p>A collection of key:value pairs containing player information for use in matchmaking. Player attribute keys must match the <i>playerAttributes</i> used in a matchmaking rule set. Example: <code>"PlayerAttributes": {"skill": {"N": "23"}, "gameMode": {"S": "deathmatch"}}</code>.</p>
    /// <p>You can provide up to 10 <code>PlayerAttributes</code>.</p>
    #[doc(hidden)]
    pub player_attributes: std::option::Option<
        std::collections::HashMap<std::string::String, crate::types::AttributeValue>,
    >,
    /// <p>Name of the team that the player is assigned to in a match. Team names are defined in a matchmaking rule set.</p>
    #[doc(hidden)]
    pub team: std::option::Option<std::string::String>,
    /// <p>A set of values, expressed in milliseconds, that indicates the amount of latency that a player experiences when connected to @aws; Regions. If this property is present, FlexMatch considers placing the match only in Regions for which latency is reported. </p>
    /// <p>If a matchmaker has a rule that evaluates player latency, players must report latency in order to be matched. If no latency is reported in this scenario, FlexMatch assumes that no Regions are available to the player and the ticket is not matchable. </p>
    #[doc(hidden)]
    pub latency_in_ms: std::option::Option<std::collections::HashMap<std::string::String, i32>>,
}
impl Player {
    /// <p>A unique identifier for a player</p>
    pub fn player_id(&self) -> std::option::Option<&str> {
        self.player_id.as_deref()
    }
    /// <p>A collection of key:value pairs containing player information for use in matchmaking. Player attribute keys must match the <i>playerAttributes</i> used in a matchmaking rule set. Example: <code>"PlayerAttributes": {"skill": {"N": "23"}, "gameMode": {"S": "deathmatch"}}</code>.</p>
    /// <p>You can provide up to 10 <code>PlayerAttributes</code>.</p>
    pub fn player_attributes(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::types::AttributeValue>,
    > {
        self.player_attributes.as_ref()
    }
    /// <p>Name of the team that the player is assigned to in a match. Team names are defined in a matchmaking rule set.</p>
    pub fn team(&self) -> std::option::Option<&str> {
        self.team.as_deref()
    }
    /// <p>A set of values, expressed in milliseconds, that indicates the amount of latency that a player experiences when connected to @aws; Regions. If this property is present, FlexMatch considers placing the match only in Regions for which latency is reported. </p>
    /// <p>If a matchmaker has a rule that evaluates player latency, players must report latency in order to be matched. If no latency is reported in this scenario, FlexMatch assumes that no Regions are available to the player and the ticket is not matchable. </p>
    pub fn latency_in_ms(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, i32>> {
        self.latency_in_ms.as_ref()
    }
}
impl Player {
    /// Creates a new builder-style object to manufacture [`Player`](crate::types::Player).
    pub fn builder() -> crate::types::builders::PlayerBuilder {
        crate::types::builders::PlayerBuilder::default()
    }
}

/// A builder for [`Player`](crate::types::Player).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct PlayerBuilder {
    pub(crate) player_id: std::option::Option<std::string::String>,
    pub(crate) player_attributes: std::option::Option<
        std::collections::HashMap<std::string::String, crate::types::AttributeValue>,
    >,
    pub(crate) team: std::option::Option<std::string::String>,
    pub(crate) latency_in_ms:
        std::option::Option<std::collections::HashMap<std::string::String, i32>>,
}
impl PlayerBuilder {
    /// <p>A unique identifier for a player</p>
    pub fn player_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.player_id = Some(input.into());
        self
    }
    /// <p>A unique identifier for a player</p>
    pub fn set_player_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.player_id = input;
        self
    }
    /// Adds a key-value pair to `player_attributes`.
    ///
    /// To override the contents of this collection use [`set_player_attributes`](Self::set_player_attributes).
    ///
    /// <p>A collection of key:value pairs containing player information for use in matchmaking. Player attribute keys must match the <i>playerAttributes</i> used in a matchmaking rule set. Example: <code>"PlayerAttributes": {"skill": {"N": "23"}, "gameMode": {"S": "deathmatch"}}</code>.</p>
    /// <p>You can provide up to 10 <code>PlayerAttributes</code>.</p>
    pub fn player_attributes(
        mut self,
        k: impl Into<std::string::String>,
        v: crate::types::AttributeValue,
    ) -> Self {
        let mut hash_map = self.player_attributes.unwrap_or_default();
        hash_map.insert(k.into(), v);
        self.player_attributes = Some(hash_map);
        self
    }
    /// <p>A collection of key:value pairs containing player information for use in matchmaking. Player attribute keys must match the <i>playerAttributes</i> used in a matchmaking rule set. Example: <code>"PlayerAttributes": {"skill": {"N": "23"}, "gameMode": {"S": "deathmatch"}}</code>.</p>
    /// <p>You can provide up to 10 <code>PlayerAttributes</code>.</p>
    pub fn set_player_attributes(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, crate::types::AttributeValue>,
        >,
    ) -> Self {
        self.player_attributes = input;
        self
    }
    /// <p>Name of the team that the player is assigned to in a match. Team names are defined in a matchmaking rule set.</p>
    pub fn team(mut self, input: impl Into<std::string::String>) -> Self {
        self.team = Some(input.into());
        self
    }
    /// <p>Name of the team that the player is assigned to in a match. Team names are defined in a matchmaking rule set.</p>
    pub fn set_team(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.team = input;
        self
    }
    /// Adds a key-value pair to `latency_in_ms`.
    ///
    /// To override the contents of this collection use [`set_latency_in_ms`](Self::set_latency_in_ms).
    ///
    /// <p>A set of values, expressed in milliseconds, that indicates the amount of latency that a player experiences when connected to @aws; Regions. If this property is present, FlexMatch considers placing the match only in Regions for which latency is reported. </p>
    /// <p>If a matchmaker has a rule that evaluates player latency, players must report latency in order to be matched. If no latency is reported in this scenario, FlexMatch assumes that no Regions are available to the player and the ticket is not matchable. </p>
    pub fn latency_in_ms(mut self, k: impl Into<std::string::String>, v: i32) -> Self {
        let mut hash_map = self.latency_in_ms.unwrap_or_default();
        hash_map.insert(k.into(), v);
        self.latency_in_ms = Some(hash_map);
        self
    }
    /// <p>A set of values, expressed in milliseconds, that indicates the amount of latency that a player experiences when connected to @aws; Regions. If this property is present, FlexMatch considers placing the match only in Regions for which latency is reported. </p>
    /// <p>If a matchmaker has a rule that evaluates player latency, players must report latency in order to be matched. If no latency is reported in this scenario, FlexMatch assumes that no Regions are available to the player and the ticket is not matchable. </p>
    pub fn set_latency_in_ms(
        mut self,
        input: std::option::Option<std::collections::HashMap<std::string::String, i32>>,
    ) -> Self {
        self.latency_in_ms = input;
        self
    }
    /// Consumes the builder and constructs a [`Player`](crate::types::Player).
    pub fn build(self) -> crate::types::Player {
        crate::types::Player {
            player_id: self.player_id,
            player_attributes: self.player_attributes,
            team: self.team,
            latency_in_ms: self.latency_in_ms,
        }
    }
}
