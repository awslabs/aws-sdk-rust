// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An Amazon GameLift Servers compute resource for hosting your game servers. Computes in an Amazon GameLift Servers fleet differs depending on the fleet's compute type property as follows:</p>
/// <ul>
/// <li>
/// <p>For managed EC2 fleets, a compute is an EC2 instance.</p></li>
/// <li>
/// <p>For Anywhere fleets, a compute is a computing resource that you provide and is registered to the fleet.</p></li>
/// </ul>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct Compute {
    /// <p>A unique identifier for the fleet that the compute belongs to.</p>
    pub fleet_id: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the fleet that the compute belongs to.</p>
    pub fleet_arn: ::std::option::Option<::std::string::String>,
    /// <p>A descriptive label for the compute resource. For instances in a managed EC2 fleet, the compute name is the same value as the <code>InstanceId</code> ID.</p>
    pub compute_name: ::std::option::Option<::std::string::String>,
    /// <p>The ARN that is assigned to a compute resource and uniquely identifies it. ARNs are unique across locations. Instances in managed EC2 fleets are not assigned a Compute ARN.</p>
    pub compute_arn: ::std::option::Option<::std::string::String>,
    /// <p>The IP address of a compute resource. Amazon GameLift Servers requires a DNS name or IP address for a compute.</p>
    pub ip_address: ::std::option::Option<::std::string::String>,
    /// <p>The DNS name of a compute resource. Amazon GameLift Servers requires a DNS name or IP address for a compute.</p>
    pub dns_name: ::std::option::Option<::std::string::String>,
    /// <p>Current status of the compute. A compute must have an <code>ACTIVE</code> status to host game sessions. Valid values include <code>PENDING</code>, <code>ACTIVE</code>, <code>TERMINATING</code>, and <code>IMPAIRED</code>.</p><note>
    /// <p>While the ComputeStatus enum type is valid for Container based servers, the result may also include other non-enumerated string values such as "Active" for fleets which are not Container-based.</p>
    /// </note>
    pub compute_status: ::std::option::Option<crate::types::ComputeStatus>,
    /// <p>The name of the custom location you added to the fleet that this compute resource resides in.</p>
    pub location: ::std::option::Option<::std::string::String>,
    /// <p>A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub creation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The type of operating system on the compute resource.</p><note>
    /// <p>Amazon Linux 2 (AL2) will reach end of support on 6/30/2026. See more details in the <a href="http://aws.amazon.com/aws.amazon.com/amazon-linux-2/faqs/">Amazon Linux 2 FAQs</a>. For game servers that are hosted on AL2 and use server SDK version 4.x for Amazon GameLift Servers, first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html"> Migrate to server SDK version 5.</a></p>
    /// </note>
    pub operating_system: ::std::option::Option<crate::types::OperatingSystem>,
    /// <p>The Amazon EC2 instance type that the fleet uses. For registered computes in an Amazon GameLift Servers Anywhere fleet, this property is empty.</p>
    pub r#type: ::std::option::Option<crate::types::Ec2InstanceType>,
    /// <p>The Amazon GameLift Servers SDK endpoint connection for a registered compute resource in an Anywhere fleet. The game servers on the compute use this endpoint to connect to the Amazon GameLift Servers service.</p>
    pub game_lift_service_sdk_endpoint: ::std::option::Option<::std::string::String>,
    /// <p>The endpoint of the Amazon GameLift Servers Agent.</p>
    pub game_lift_agent_endpoint: ::std::option::Option<::std::string::String>,
    /// <p>The <code>InstanceID</code> of the EC2 instance that is hosting the compute.</p>
    pub instance_id: ::std::option::Option<::std::string::String>,
    /// <p>A set of attributes for each container in the compute.</p>
    pub container_attributes: ::std::option::Option<::std::vec::Vec<crate::types::ContainerAttribute>>,
    /// <p>The game server container group definition for the compute.</p>
    pub game_server_container_group_definition_arn: ::std::option::Option<::std::string::String>,
}
impl Compute {
    /// <p>A unique identifier for the fleet that the compute belongs to.</p>
    pub fn fleet_id(&self) -> ::std::option::Option<&str> {
        self.fleet_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the fleet that the compute belongs to.</p>
    pub fn fleet_arn(&self) -> ::std::option::Option<&str> {
        self.fleet_arn.as_deref()
    }
    /// <p>A descriptive label for the compute resource. For instances in a managed EC2 fleet, the compute name is the same value as the <code>InstanceId</code> ID.</p>
    pub fn compute_name(&self) -> ::std::option::Option<&str> {
        self.compute_name.as_deref()
    }
    /// <p>The ARN that is assigned to a compute resource and uniquely identifies it. ARNs are unique across locations. Instances in managed EC2 fleets are not assigned a Compute ARN.</p>
    pub fn compute_arn(&self) -> ::std::option::Option<&str> {
        self.compute_arn.as_deref()
    }
    /// <p>The IP address of a compute resource. Amazon GameLift Servers requires a DNS name or IP address for a compute.</p>
    pub fn ip_address(&self) -> ::std::option::Option<&str> {
        self.ip_address.as_deref()
    }
    /// <p>The DNS name of a compute resource. Amazon GameLift Servers requires a DNS name or IP address for a compute.</p>
    pub fn dns_name(&self) -> ::std::option::Option<&str> {
        self.dns_name.as_deref()
    }
    /// <p>Current status of the compute. A compute must have an <code>ACTIVE</code> status to host game sessions. Valid values include <code>PENDING</code>, <code>ACTIVE</code>, <code>TERMINATING</code>, and <code>IMPAIRED</code>.</p><note>
    /// <p>While the ComputeStatus enum type is valid for Container based servers, the result may also include other non-enumerated string values such as "Active" for fleets which are not Container-based.</p>
    /// </note>
    pub fn compute_status(&self) -> ::std::option::Option<&crate::types::ComputeStatus> {
        self.compute_status.as_ref()
    }
    /// <p>The name of the custom location you added to the fleet that this compute resource resides in.</p>
    pub fn location(&self) -> ::std::option::Option<&str> {
        self.location.as_deref()
    }
    /// <p>A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn creation_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The type of operating system on the compute resource.</p><note>
    /// <p>Amazon Linux 2 (AL2) will reach end of support on 6/30/2026. See more details in the <a href="http://aws.amazon.com/aws.amazon.com/amazon-linux-2/faqs/">Amazon Linux 2 FAQs</a>. For game servers that are hosted on AL2 and use server SDK version 4.x for Amazon GameLift Servers, first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html"> Migrate to server SDK version 5.</a></p>
    /// </note>
    pub fn operating_system(&self) -> ::std::option::Option<&crate::types::OperatingSystem> {
        self.operating_system.as_ref()
    }
    /// <p>The Amazon EC2 instance type that the fleet uses. For registered computes in an Amazon GameLift Servers Anywhere fleet, this property is empty.</p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::Ec2InstanceType> {
        self.r#type.as_ref()
    }
    /// <p>The Amazon GameLift Servers SDK endpoint connection for a registered compute resource in an Anywhere fleet. The game servers on the compute use this endpoint to connect to the Amazon GameLift Servers service.</p>
    pub fn game_lift_service_sdk_endpoint(&self) -> ::std::option::Option<&str> {
        self.game_lift_service_sdk_endpoint.as_deref()
    }
    /// <p>The endpoint of the Amazon GameLift Servers Agent.</p>
    pub fn game_lift_agent_endpoint(&self) -> ::std::option::Option<&str> {
        self.game_lift_agent_endpoint.as_deref()
    }
    /// <p>The <code>InstanceID</code> of the EC2 instance that is hosting the compute.</p>
    pub fn instance_id(&self) -> ::std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>A set of attributes for each container in the compute.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.container_attributes.is_none()`.
    pub fn container_attributes(&self) -> &[crate::types::ContainerAttribute] {
        self.container_attributes.as_deref().unwrap_or_default()
    }
    /// <p>The game server container group definition for the compute.</p>
    pub fn game_server_container_group_definition_arn(&self) -> ::std::option::Option<&str> {
        self.game_server_container_group_definition_arn.as_deref()
    }
}
impl ::std::fmt::Debug for Compute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("Compute");
        formatter.field("fleet_id", &self.fleet_id);
        formatter.field("fleet_arn", &self.fleet_arn);
        formatter.field("compute_name", &self.compute_name);
        formatter.field("compute_arn", &self.compute_arn);
        formatter.field("ip_address", &"*** Sensitive Data Redacted ***");
        formatter.field("dns_name", &self.dns_name);
        formatter.field("compute_status", &self.compute_status);
        formatter.field("location", &self.location);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("operating_system", &self.operating_system);
        formatter.field("r#type", &self.r#type);
        formatter.field("game_lift_service_sdk_endpoint", &self.game_lift_service_sdk_endpoint);
        formatter.field("game_lift_agent_endpoint", &self.game_lift_agent_endpoint);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("container_attributes", &self.container_attributes);
        formatter.field(
            "game_server_container_group_definition_arn",
            &self.game_server_container_group_definition_arn,
        );
        formatter.finish()
    }
}
impl Compute {
    /// Creates a new builder-style object to manufacture [`Compute`](crate::types::Compute).
    pub fn builder() -> crate::types::builders::ComputeBuilder {
        crate::types::builders::ComputeBuilder::default()
    }
}

/// A builder for [`Compute`](crate::types::Compute).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct ComputeBuilder {
    pub(crate) fleet_id: ::std::option::Option<::std::string::String>,
    pub(crate) fleet_arn: ::std::option::Option<::std::string::String>,
    pub(crate) compute_name: ::std::option::Option<::std::string::String>,
    pub(crate) compute_arn: ::std::option::Option<::std::string::String>,
    pub(crate) ip_address: ::std::option::Option<::std::string::String>,
    pub(crate) dns_name: ::std::option::Option<::std::string::String>,
    pub(crate) compute_status: ::std::option::Option<crate::types::ComputeStatus>,
    pub(crate) location: ::std::option::Option<::std::string::String>,
    pub(crate) creation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) operating_system: ::std::option::Option<crate::types::OperatingSystem>,
    pub(crate) r#type: ::std::option::Option<crate::types::Ec2InstanceType>,
    pub(crate) game_lift_service_sdk_endpoint: ::std::option::Option<::std::string::String>,
    pub(crate) game_lift_agent_endpoint: ::std::option::Option<::std::string::String>,
    pub(crate) instance_id: ::std::option::Option<::std::string::String>,
    pub(crate) container_attributes: ::std::option::Option<::std::vec::Vec<crate::types::ContainerAttribute>>,
    pub(crate) game_server_container_group_definition_arn: ::std::option::Option<::std::string::String>,
}
impl ComputeBuilder {
    /// <p>A unique identifier for the fleet that the compute belongs to.</p>
    pub fn fleet_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.fleet_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier for the fleet that the compute belongs to.</p>
    pub fn set_fleet_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.fleet_id = input;
        self
    }
    /// <p>A unique identifier for the fleet that the compute belongs to.</p>
    pub fn get_fleet_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.fleet_id
    }
    /// <p>The Amazon Resource Name (ARN) of the fleet that the compute belongs to.</p>
    pub fn fleet_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.fleet_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the fleet that the compute belongs to.</p>
    pub fn set_fleet_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.fleet_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the fleet that the compute belongs to.</p>
    pub fn get_fleet_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.fleet_arn
    }
    /// <p>A descriptive label for the compute resource. For instances in a managed EC2 fleet, the compute name is the same value as the <code>InstanceId</code> ID.</p>
    pub fn compute_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.compute_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A descriptive label for the compute resource. For instances in a managed EC2 fleet, the compute name is the same value as the <code>InstanceId</code> ID.</p>
    pub fn set_compute_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.compute_name = input;
        self
    }
    /// <p>A descriptive label for the compute resource. For instances in a managed EC2 fleet, the compute name is the same value as the <code>InstanceId</code> ID.</p>
    pub fn get_compute_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.compute_name
    }
    /// <p>The ARN that is assigned to a compute resource and uniquely identifies it. ARNs are unique across locations. Instances in managed EC2 fleets are not assigned a Compute ARN.</p>
    pub fn compute_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.compute_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN that is assigned to a compute resource and uniquely identifies it. ARNs are unique across locations. Instances in managed EC2 fleets are not assigned a Compute ARN.</p>
    pub fn set_compute_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.compute_arn = input;
        self
    }
    /// <p>The ARN that is assigned to a compute resource and uniquely identifies it. ARNs are unique across locations. Instances in managed EC2 fleets are not assigned a Compute ARN.</p>
    pub fn get_compute_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.compute_arn
    }
    /// <p>The IP address of a compute resource. Amazon GameLift Servers requires a DNS name or IP address for a compute.</p>
    pub fn ip_address(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ip_address = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IP address of a compute resource. Amazon GameLift Servers requires a DNS name or IP address for a compute.</p>
    pub fn set_ip_address(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ip_address = input;
        self
    }
    /// <p>The IP address of a compute resource. Amazon GameLift Servers requires a DNS name or IP address for a compute.</p>
    pub fn get_ip_address(&self) -> &::std::option::Option<::std::string::String> {
        &self.ip_address
    }
    /// <p>The DNS name of a compute resource. Amazon GameLift Servers requires a DNS name or IP address for a compute.</p>
    pub fn dns_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.dns_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The DNS name of a compute resource. Amazon GameLift Servers requires a DNS name or IP address for a compute.</p>
    pub fn set_dns_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.dns_name = input;
        self
    }
    /// <p>The DNS name of a compute resource. Amazon GameLift Servers requires a DNS name or IP address for a compute.</p>
    pub fn get_dns_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.dns_name
    }
    /// <p>Current status of the compute. A compute must have an <code>ACTIVE</code> status to host game sessions. Valid values include <code>PENDING</code>, <code>ACTIVE</code>, <code>TERMINATING</code>, and <code>IMPAIRED</code>.</p><note>
    /// <p>While the ComputeStatus enum type is valid for Container based servers, the result may also include other non-enumerated string values such as "Active" for fleets which are not Container-based.</p>
    /// </note>
    pub fn compute_status(mut self, input: crate::types::ComputeStatus) -> Self {
        self.compute_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>Current status of the compute. A compute must have an <code>ACTIVE</code> status to host game sessions. Valid values include <code>PENDING</code>, <code>ACTIVE</code>, <code>TERMINATING</code>, and <code>IMPAIRED</code>.</p><note>
    /// <p>While the ComputeStatus enum type is valid for Container based servers, the result may also include other non-enumerated string values such as "Active" for fleets which are not Container-based.</p>
    /// </note>
    pub fn set_compute_status(mut self, input: ::std::option::Option<crate::types::ComputeStatus>) -> Self {
        self.compute_status = input;
        self
    }
    /// <p>Current status of the compute. A compute must have an <code>ACTIVE</code> status to host game sessions. Valid values include <code>PENDING</code>, <code>ACTIVE</code>, <code>TERMINATING</code>, and <code>IMPAIRED</code>.</p><note>
    /// <p>While the ComputeStatus enum type is valid for Container based servers, the result may also include other non-enumerated string values such as "Active" for fleets which are not Container-based.</p>
    /// </note>
    pub fn get_compute_status(&self) -> &::std::option::Option<crate::types::ComputeStatus> {
        &self.compute_status
    }
    /// <p>The name of the custom location you added to the fleet that this compute resource resides in.</p>
    pub fn location(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.location = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the custom location you added to the fleet that this compute resource resides in.</p>
    pub fn set_location(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.location = input;
        self
    }
    /// <p>The name of the custom location you added to the fleet that this compute resource resides in.</p>
    pub fn get_location(&self) -> &::std::option::Option<::std::string::String> {
        &self.location
    }
    /// <p>A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn creation_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.creation_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn set_creation_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.creation_time = input;
        self
    }
    /// <p>A time stamp indicating when this data object was created. Format is a number expressed in Unix time as milliseconds (for example <code>"1469498468.057"</code>).</p>
    pub fn get_creation_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.creation_time
    }
    /// <p>The type of operating system on the compute resource.</p><note>
    /// <p>Amazon Linux 2 (AL2) will reach end of support on 6/30/2026. See more details in the <a href="http://aws.amazon.com/aws.amazon.com/amazon-linux-2/faqs/">Amazon Linux 2 FAQs</a>. For game servers that are hosted on AL2 and use server SDK version 4.x for Amazon GameLift Servers, first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html"> Migrate to server SDK version 5.</a></p>
    /// </note>
    pub fn operating_system(mut self, input: crate::types::OperatingSystem) -> Self {
        self.operating_system = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of operating system on the compute resource.</p><note>
    /// <p>Amazon Linux 2 (AL2) will reach end of support on 6/30/2026. See more details in the <a href="http://aws.amazon.com/aws.amazon.com/amazon-linux-2/faqs/">Amazon Linux 2 FAQs</a>. For game servers that are hosted on AL2 and use server SDK version 4.x for Amazon GameLift Servers, first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html"> Migrate to server SDK version 5.</a></p>
    /// </note>
    pub fn set_operating_system(mut self, input: ::std::option::Option<crate::types::OperatingSystem>) -> Self {
        self.operating_system = input;
        self
    }
    /// <p>The type of operating system on the compute resource.</p><note>
    /// <p>Amazon Linux 2 (AL2) will reach end of support on 6/30/2026. See more details in the <a href="http://aws.amazon.com/aws.amazon.com/amazon-linux-2/faqs/">Amazon Linux 2 FAQs</a>. For game servers that are hosted on AL2 and use server SDK version 4.x for Amazon GameLift Servers, first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html"> Migrate to server SDK version 5.</a></p>
    /// </note>
    pub fn get_operating_system(&self) -> &::std::option::Option<crate::types::OperatingSystem> {
        &self.operating_system
    }
    /// <p>The Amazon EC2 instance type that the fleet uses. For registered computes in an Amazon GameLift Servers Anywhere fleet, this property is empty.</p>
    pub fn r#type(mut self, input: crate::types::Ec2InstanceType) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Amazon EC2 instance type that the fleet uses. For registered computes in an Amazon GameLift Servers Anywhere fleet, this property is empty.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::Ec2InstanceType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>The Amazon EC2 instance type that the fleet uses. For registered computes in an Amazon GameLift Servers Anywhere fleet, this property is empty.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::Ec2InstanceType> {
        &self.r#type
    }
    /// <p>The Amazon GameLift Servers SDK endpoint connection for a registered compute resource in an Anywhere fleet. The game servers on the compute use this endpoint to connect to the Amazon GameLift Servers service.</p>
    pub fn game_lift_service_sdk_endpoint(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.game_lift_service_sdk_endpoint = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon GameLift Servers SDK endpoint connection for a registered compute resource in an Anywhere fleet. The game servers on the compute use this endpoint to connect to the Amazon GameLift Servers service.</p>
    pub fn set_game_lift_service_sdk_endpoint(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.game_lift_service_sdk_endpoint = input;
        self
    }
    /// <p>The Amazon GameLift Servers SDK endpoint connection for a registered compute resource in an Anywhere fleet. The game servers on the compute use this endpoint to connect to the Amazon GameLift Servers service.</p>
    pub fn get_game_lift_service_sdk_endpoint(&self) -> &::std::option::Option<::std::string::String> {
        &self.game_lift_service_sdk_endpoint
    }
    /// <p>The endpoint of the Amazon GameLift Servers Agent.</p>
    pub fn game_lift_agent_endpoint(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.game_lift_agent_endpoint = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The endpoint of the Amazon GameLift Servers Agent.</p>
    pub fn set_game_lift_agent_endpoint(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.game_lift_agent_endpoint = input;
        self
    }
    /// <p>The endpoint of the Amazon GameLift Servers Agent.</p>
    pub fn get_game_lift_agent_endpoint(&self) -> &::std::option::Option<::std::string::String> {
        &self.game_lift_agent_endpoint
    }
    /// <p>The <code>InstanceID</code> of the EC2 instance that is hosting the compute.</p>
    pub fn instance_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.instance_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The <code>InstanceID</code> of the EC2 instance that is hosting the compute.</p>
    pub fn set_instance_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.instance_id = input;
        self
    }
    /// <p>The <code>InstanceID</code> of the EC2 instance that is hosting the compute.</p>
    pub fn get_instance_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.instance_id
    }
    /// Appends an item to `container_attributes`.
    ///
    /// To override the contents of this collection use [`set_container_attributes`](Self::set_container_attributes).
    ///
    /// <p>A set of attributes for each container in the compute.</p>
    pub fn container_attributes(mut self, input: crate::types::ContainerAttribute) -> Self {
        let mut v = self.container_attributes.unwrap_or_default();
        v.push(input);
        self.container_attributes = ::std::option::Option::Some(v);
        self
    }
    /// <p>A set of attributes for each container in the compute.</p>
    pub fn set_container_attributes(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerAttribute>>) -> Self {
        self.container_attributes = input;
        self
    }
    /// <p>A set of attributes for each container in the compute.</p>
    pub fn get_container_attributes(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerAttribute>> {
        &self.container_attributes
    }
    /// <p>The game server container group definition for the compute.</p>
    pub fn game_server_container_group_definition_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.game_server_container_group_definition_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The game server container group definition for the compute.</p>
    pub fn set_game_server_container_group_definition_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.game_server_container_group_definition_arn = input;
        self
    }
    /// <p>The game server container group definition for the compute.</p>
    pub fn get_game_server_container_group_definition_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.game_server_container_group_definition_arn
    }
    /// Consumes the builder and constructs a [`Compute`](crate::types::Compute).
    pub fn build(self) -> crate::types::Compute {
        crate::types::Compute {
            fleet_id: self.fleet_id,
            fleet_arn: self.fleet_arn,
            compute_name: self.compute_name,
            compute_arn: self.compute_arn,
            ip_address: self.ip_address,
            dns_name: self.dns_name,
            compute_status: self.compute_status,
            location: self.location,
            creation_time: self.creation_time,
            operating_system: self.operating_system,
            r#type: self.r#type,
            game_lift_service_sdk_endpoint: self.game_lift_service_sdk_endpoint,
            game_lift_agent_endpoint: self.game_lift_agent_endpoint,
            instance_id: self.instance_id,
            container_attributes: self.container_attributes,
            game_server_container_group_definition_arn: self.game_server_container_group_definition_arn,
        }
    }
}
impl ::std::fmt::Debug for ComputeBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ComputeBuilder");
        formatter.field("fleet_id", &self.fleet_id);
        formatter.field("fleet_arn", &self.fleet_arn);
        formatter.field("compute_name", &self.compute_name);
        formatter.field("compute_arn", &self.compute_arn);
        formatter.field("ip_address", &"*** Sensitive Data Redacted ***");
        formatter.field("dns_name", &self.dns_name);
        formatter.field("compute_status", &self.compute_status);
        formatter.field("location", &self.location);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("operating_system", &self.operating_system);
        formatter.field("r#type", &self.r#type);
        formatter.field("game_lift_service_sdk_endpoint", &self.game_lift_service_sdk_endpoint);
        formatter.field("game_lift_agent_endpoint", &self.game_lift_agent_endpoint);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("container_attributes", &self.container_attributes);
        formatter.field(
            "game_server_container_group_definition_arn",
            &self.game_server_container_group_definition_arn,
        );
        formatter.finish()
    }
}
