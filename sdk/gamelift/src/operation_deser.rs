// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_match_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptMatchOutput, crate::error::AcceptMatchError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::AcceptMatchError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AcceptMatchError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::AcceptMatchError { meta: generic, kind: crate::error::AcceptMatchErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AcceptMatchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::AcceptMatchError { meta: generic, kind: crate::error::AcceptMatchErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AcceptMatchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::AcceptMatchError { meta: generic, kind: crate::error::AcceptMatchErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AcceptMatchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::AcceptMatchError { meta: generic, kind: crate::error::AcceptMatchErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AcceptMatchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AcceptMatchError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_match_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptMatchOutput, crate::error::AcceptMatchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_match_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_claim_game_server_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ClaimGameServerOutput, crate::error::ClaimGameServerError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ClaimGameServerError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ClaimGameServerError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::ClaimGameServerError { meta: generic, kind: crate::error::ClaimGameServerErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ClaimGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::ClaimGameServerError { meta: generic, kind: crate::error::ClaimGameServerErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ClaimGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ClaimGameServerError { meta: generic, kind: crate::error::ClaimGameServerErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ClaimGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::ClaimGameServerError { meta: generic, kind: crate::error::ClaimGameServerErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ClaimGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OutOfCapacityException" => crate::error::ClaimGameServerError { meta: generic, kind: crate::error::ClaimGameServerErrorKind::OutOfCapacityException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::out_of_capacity_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_out_of_capacity_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ClaimGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::ClaimGameServerError { meta: generic, kind: crate::error::ClaimGameServerErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ClaimGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ClaimGameServerError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_claim_game_server_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ClaimGameServerOutput, crate::error::ClaimGameServerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::claim_game_server_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_claim_game_server(response.body().as_ref(), output).map_err(crate::error::ClaimGameServerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_alias_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateAliasOutput, crate::error::CreateAliasError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateAliasError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateAliasError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::CreateAliasError { meta: generic, kind: crate::error::CreateAliasErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::CreateAliasError { meta: generic, kind: crate::error::CreateAliasErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateAliasError { meta: generic, kind: crate::error::CreateAliasErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::CreateAliasError { meta: generic, kind: crate::error::CreateAliasErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::CreateAliasError { meta: generic, kind: crate::error::CreateAliasErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreateAliasError { meta: generic, kind: crate::error::CreateAliasErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateAliasError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_alias_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateAliasOutput, crate::error::CreateAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_alias_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_alias(response.body().as_ref(), output).map_err(crate::error::CreateAliasError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_build_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateBuildOutput, crate::error::CreateBuildError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateBuildError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateBuildError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::CreateBuildError { meta: generic, kind: crate::error::CreateBuildErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::CreateBuildError { meta: generic, kind: crate::error::CreateBuildErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateBuildError { meta: generic, kind: crate::error::CreateBuildErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::CreateBuildError { meta: generic, kind: crate::error::CreateBuildErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreateBuildError { meta: generic, kind: crate::error::CreateBuildErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateBuildError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_build_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateBuildOutput, crate::error::CreateBuildError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_build_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_build(response.body().as_ref(), output).map_err(crate::error::CreateBuildError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fleet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateFleetOutput, crate::error::CreateFleetError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateFleetError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateFleetError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::CreateFleetError { meta: generic, kind: crate::error::CreateFleetErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::CreateFleetError { meta: generic, kind: crate::error::CreateFleetErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateFleetError { meta: generic, kind: crate::error::CreateFleetErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::CreateFleetError { meta: generic, kind: crate::error::CreateFleetErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::CreateFleetError { meta: generic, kind: crate::error::CreateFleetErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::CreateFleetError { meta: generic, kind: crate::error::CreateFleetErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreateFleetError { meta: generic, kind: crate::error::CreateFleetErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::CreateFleetError { meta: generic, kind: crate::error::CreateFleetErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateFleetError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fleet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateFleetOutput, crate::error::CreateFleetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_fleet_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_fleet(response.body().as_ref(), output).map_err(crate::error::CreateFleetError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fleet_locations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateFleetLocationsOutput, crate::error::CreateFleetLocationsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateFleetLocationsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateFleetLocationsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::CreateFleetLocationsError { meta: generic, kind: crate::error::CreateFleetLocationsErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::CreateFleetLocationsError { meta: generic, kind: crate::error::CreateFleetLocationsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFleetStatusException" => crate::error::CreateFleetLocationsError { meta: generic, kind: crate::error::CreateFleetLocationsErrorKind::InvalidFleetStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_fleet_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_fleet_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateFleetLocationsError { meta: generic, kind: crate::error::CreateFleetLocationsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::CreateFleetLocationsError { meta: generic, kind: crate::error::CreateFleetLocationsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreateFleetLocationsError { meta: generic, kind: crate::error::CreateFleetLocationsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::CreateFleetLocationsError { meta: generic, kind: crate::error::CreateFleetLocationsErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateFleetLocationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fleet_locations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateFleetLocationsOutput, crate::error::CreateFleetLocationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_fleet_locations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_fleet_locations(response.body().as_ref(), output).map_err(crate::error::CreateFleetLocationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_server_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateGameServerGroupOutput, crate::error::CreateGameServerGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateGameServerGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateGameServerGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::CreateGameServerGroupError { meta: generic, kind: crate::error::CreateGameServerGroupErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::CreateGameServerGroupError { meta: generic, kind: crate::error::CreateGameServerGroupErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateGameServerGroupError { meta: generic, kind: crate::error::CreateGameServerGroupErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::CreateGameServerGroupError { meta: generic, kind: crate::error::CreateGameServerGroupErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreateGameServerGroupError { meta: generic, kind: crate::error::CreateGameServerGroupErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateGameServerGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_server_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateGameServerGroupOutput, crate::error::CreateGameServerGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_game_server_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_game_server_group(response.body().as_ref(), output).map_err(crate::error::CreateGameServerGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_session_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateGameSessionOutput, crate::error::CreateGameSessionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateGameSessionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateGameSessionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::CreateGameSessionError { meta: generic, kind: crate::error::CreateGameSessionErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FleetCapacityExceededException" => crate::error::CreateGameSessionError { meta: generic, kind: crate::error::CreateGameSessionErrorKind::FleetCapacityExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::fleet_capacity_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_fleet_capacity_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "IdempotentParameterMismatchException" => crate::error::CreateGameSessionError { meta: generic, kind: crate::error::CreateGameSessionErrorKind::IdempotentParameterMismatchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotent_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::CreateGameSessionError { meta: generic, kind: crate::error::CreateGameSessionErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFleetStatusException" => crate::error::CreateGameSessionError { meta: generic, kind: crate::error::CreateGameSessionErrorKind::InvalidFleetStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_fleet_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_fleet_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateGameSessionError { meta: generic, kind: crate::error::CreateGameSessionErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::CreateGameSessionError { meta: generic, kind: crate::error::CreateGameSessionErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::CreateGameSessionError { meta: generic, kind: crate::error::CreateGameSessionErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TerminalRoutingStrategyException" => crate::error::CreateGameSessionError { meta: generic, kind: crate::error::CreateGameSessionErrorKind::TerminalRoutingStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::terminal_routing_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_terminal_routing_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreateGameSessionError { meta: generic, kind: crate::error::CreateGameSessionErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::CreateGameSessionError { meta: generic, kind: crate::error::CreateGameSessionErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateGameSessionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_session_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateGameSessionOutput, crate::error::CreateGameSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_game_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_game_session(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_session_queue_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateGameSessionQueueOutput, crate::error::CreateGameSessionQueueError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateGameSessionQueueError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateGameSessionQueueError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::CreateGameSessionQueueError { meta: generic, kind: crate::error::CreateGameSessionQueueErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateGameSessionQueueError { meta: generic, kind: crate::error::CreateGameSessionQueueErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::CreateGameSessionQueueError { meta: generic, kind: crate::error::CreateGameSessionQueueErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::CreateGameSessionQueueError { meta: generic, kind: crate::error::CreateGameSessionQueueErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::CreateGameSessionQueueError { meta: generic, kind: crate::error::CreateGameSessionQueueErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreateGameSessionQueueError { meta: generic, kind: crate::error::CreateGameSessionQueueErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateGameSessionQueueError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_session_queue_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateGameSessionQueueOutput, crate::error::CreateGameSessionQueueError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_game_session_queue_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_game_session_queue(response.body().as_ref(), output).map_err(crate::error::CreateGameSessionQueueError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_location_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLocationOutput, crate::error::CreateLocationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateLocationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateLocationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::CreateLocationError { meta: generic, kind: crate::error::CreateLocationErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLocationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::CreateLocationError { meta: generic, kind: crate::error::CreateLocationErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLocationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateLocationError { meta: generic, kind: crate::error::CreateLocationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLocationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::CreateLocationError { meta: generic, kind: crate::error::CreateLocationErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLocationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::CreateLocationError { meta: generic, kind: crate::error::CreateLocationErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLocationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreateLocationError { meta: generic, kind: crate::error::CreateLocationErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLocationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateLocationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_location_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLocationOutput, crate::error::CreateLocationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_location_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_location(response.body().as_ref(), output).map_err(crate::error::CreateLocationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_matchmaking_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateMatchmakingConfigurationOutput, crate::error::CreateMatchmakingConfigurationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateMatchmakingConfigurationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateMatchmakingConfigurationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::CreateMatchmakingConfigurationError { meta: generic, kind: crate::error::CreateMatchmakingConfigurationErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateMatchmakingConfigurationError { meta: generic, kind: crate::error::CreateMatchmakingConfigurationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::CreateMatchmakingConfigurationError { meta: generic, kind: crate::error::CreateMatchmakingConfigurationErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::CreateMatchmakingConfigurationError { meta: generic, kind: crate::error::CreateMatchmakingConfigurationErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::CreateMatchmakingConfigurationError { meta: generic, kind: crate::error::CreateMatchmakingConfigurationErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::CreateMatchmakingConfigurationError { meta: generic, kind: crate::error::CreateMatchmakingConfigurationErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateMatchmakingConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_matchmaking_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateMatchmakingConfigurationOutput, crate::error::CreateMatchmakingConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_matchmaking_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_matchmaking_configuration(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_matchmaking_rule_set_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateMatchmakingRuleSetOutput, crate::error::CreateMatchmakingRuleSetError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateMatchmakingRuleSetError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateMatchmakingRuleSetError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::CreateMatchmakingRuleSetError { meta: generic, kind: crate::error::CreateMatchmakingRuleSetErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateMatchmakingRuleSetError { meta: generic, kind: crate::error::CreateMatchmakingRuleSetErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::CreateMatchmakingRuleSetError { meta: generic, kind: crate::error::CreateMatchmakingRuleSetErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::CreateMatchmakingRuleSetError { meta: generic, kind: crate::error::CreateMatchmakingRuleSetErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::CreateMatchmakingRuleSetError { meta: generic, kind: crate::error::CreateMatchmakingRuleSetErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateMatchmakingRuleSetError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_matchmaking_rule_set_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateMatchmakingRuleSetOutput, crate::error::CreateMatchmakingRuleSetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_matchmaking_rule_set_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_matchmaking_rule_set(response.body().as_ref(), output).map_err(crate::error::CreateMatchmakingRuleSetError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_player_session_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePlayerSessionOutput, crate::error::CreatePlayerSessionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreatePlayerSessionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreatePlayerSessionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "GameSessionFullException" => crate::error::CreatePlayerSessionError { meta: generic, kind: crate::error::CreatePlayerSessionErrorKind::GameSessionFullException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::game_session_full_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_game_session_full_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::CreatePlayerSessionError { meta: generic, kind: crate::error::CreatePlayerSessionErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidGameSessionStatusException" => crate::error::CreatePlayerSessionError { meta: generic, kind: crate::error::CreatePlayerSessionErrorKind::InvalidGameSessionStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_game_session_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_game_session_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreatePlayerSessionError { meta: generic, kind: crate::error::CreatePlayerSessionErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::CreatePlayerSessionError { meta: generic, kind: crate::error::CreatePlayerSessionErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TerminalRoutingStrategyException" => crate::error::CreatePlayerSessionError { meta: generic, kind: crate::error::CreatePlayerSessionErrorKind::TerminalRoutingStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::terminal_routing_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_terminal_routing_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreatePlayerSessionError { meta: generic, kind: crate::error::CreatePlayerSessionErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreatePlayerSessionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_player_session_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePlayerSessionOutput, crate::error::CreatePlayerSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_player_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_player_session(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_player_sessions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePlayerSessionsOutput, crate::error::CreatePlayerSessionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreatePlayerSessionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreatePlayerSessionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "GameSessionFullException" => crate::error::CreatePlayerSessionsError { meta: generic, kind: crate::error::CreatePlayerSessionsErrorKind::GameSessionFullException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::game_session_full_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_game_session_full_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::CreatePlayerSessionsError { meta: generic, kind: crate::error::CreatePlayerSessionsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidGameSessionStatusException" => crate::error::CreatePlayerSessionsError { meta: generic, kind: crate::error::CreatePlayerSessionsErrorKind::InvalidGameSessionStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_game_session_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_game_session_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreatePlayerSessionsError { meta: generic, kind: crate::error::CreatePlayerSessionsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::CreatePlayerSessionsError { meta: generic, kind: crate::error::CreatePlayerSessionsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TerminalRoutingStrategyException" => crate::error::CreatePlayerSessionsError { meta: generic, kind: crate::error::CreatePlayerSessionsErrorKind::TerminalRoutingStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::terminal_routing_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_terminal_routing_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreatePlayerSessionsError { meta: generic, kind: crate::error::CreatePlayerSessionsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreatePlayerSessionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_player_sessions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePlayerSessionsOutput, crate::error::CreatePlayerSessionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_player_sessions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_player_sessions(response.body().as_ref(), output).map_err(crate::error::CreatePlayerSessionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_script_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateScriptOutput, crate::error::CreateScriptError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateScriptError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateScriptError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::CreateScriptError { meta: generic, kind: crate::error::CreateScriptErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::CreateScriptError { meta: generic, kind: crate::error::CreateScriptErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateScriptError { meta: generic, kind: crate::error::CreateScriptErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::CreateScriptError { meta: generic, kind: crate::error::CreateScriptErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreateScriptError { meta: generic, kind: crate::error::CreateScriptErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateScriptError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_script_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateScriptOutput, crate::error::CreateScriptError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_script_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_script(response.body().as_ref(), output).map_err(crate::error::CreateScriptError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_peering_authorization_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcPeeringAuthorizationOutput, crate::error::CreateVpcPeeringAuthorizationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateVpcPeeringAuthorizationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateVpcPeeringAuthorizationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::CreateVpcPeeringAuthorizationError { meta: generic, kind: crate::error::CreateVpcPeeringAuthorizationErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateVpcPeeringAuthorizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateVpcPeeringAuthorizationError { meta: generic, kind: crate::error::CreateVpcPeeringAuthorizationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateVpcPeeringAuthorizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::CreateVpcPeeringAuthorizationError { meta: generic, kind: crate::error::CreateVpcPeeringAuthorizationErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateVpcPeeringAuthorizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreateVpcPeeringAuthorizationError { meta: generic, kind: crate::error::CreateVpcPeeringAuthorizationErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateVpcPeeringAuthorizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateVpcPeeringAuthorizationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_peering_authorization_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcPeeringAuthorizationOutput, crate::error::CreateVpcPeeringAuthorizationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpc_peering_authorization_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_vpc_peering_authorization(response.body().as_ref(), output).map_err(crate::error::CreateVpcPeeringAuthorizationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_peering_connection_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcPeeringConnectionOutput, crate::error::CreateVpcPeeringConnectionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateVpcPeeringConnectionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateVpcPeeringConnectionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::CreateVpcPeeringConnectionError { meta: generic, kind: crate::error::CreateVpcPeeringConnectionErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateVpcPeeringConnectionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateVpcPeeringConnectionError { meta: generic, kind: crate::error::CreateVpcPeeringConnectionErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateVpcPeeringConnectionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::CreateVpcPeeringConnectionError { meta: generic, kind: crate::error::CreateVpcPeeringConnectionErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateVpcPeeringConnectionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::CreateVpcPeeringConnectionError { meta: generic, kind: crate::error::CreateVpcPeeringConnectionErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateVpcPeeringConnectionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateVpcPeeringConnectionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_peering_connection_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcPeeringConnectionOutput, crate::error::CreateVpcPeeringConnectionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpc_peering_connection_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_alias_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteAliasOutput, crate::error::DeleteAliasError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteAliasError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteAliasError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteAliasError { meta: generic, kind: crate::error::DeleteAliasErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteAliasError { meta: generic, kind: crate::error::DeleteAliasErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteAliasError { meta: generic, kind: crate::error::DeleteAliasErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::DeleteAliasError { meta: generic, kind: crate::error::DeleteAliasErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeleteAliasError { meta: generic, kind: crate::error::DeleteAliasErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteAliasError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_alias_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteAliasOutput, crate::error::DeleteAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_alias_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_build_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteBuildOutput, crate::error::DeleteBuildError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteBuildError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteBuildError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteBuildError { meta: generic, kind: crate::error::DeleteBuildErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteBuildError { meta: generic, kind: crate::error::DeleteBuildErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteBuildError { meta: generic, kind: crate::error::DeleteBuildErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::DeleteBuildError { meta: generic, kind: crate::error::DeleteBuildErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeleteBuildError { meta: generic, kind: crate::error::DeleteBuildErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteBuildError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_build_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteBuildOutput, crate::error::DeleteBuildError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_build_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fleet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFleetOutput, crate::error::DeleteFleetError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteFleetError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteFleetError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteFleetError { meta: generic, kind: crate::error::DeleteFleetErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFleetStatusException" => crate::error::DeleteFleetError { meta: generic, kind: crate::error::DeleteFleetErrorKind::InvalidFleetStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_fleet_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_fleet_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteFleetError { meta: generic, kind: crate::error::DeleteFleetErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteFleetError { meta: generic, kind: crate::error::DeleteFleetErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::DeleteFleetError { meta: generic, kind: crate::error::DeleteFleetErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeleteFleetError { meta: generic, kind: crate::error::DeleteFleetErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteFleetError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fleet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFleetOutput, crate::error::DeleteFleetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_fleet_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fleet_locations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFleetLocationsOutput, crate::error::DeleteFleetLocationsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteFleetLocationsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteFleetLocationsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteFleetLocationsError { meta: generic, kind: crate::error::DeleteFleetLocationsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteFleetLocationsError { meta: generic, kind: crate::error::DeleteFleetLocationsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteFleetLocationsError { meta: generic, kind: crate::error::DeleteFleetLocationsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeleteFleetLocationsError { meta: generic, kind: crate::error::DeleteFleetLocationsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DeleteFleetLocationsError { meta: generic, kind: crate::error::DeleteFleetLocationsErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFleetLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteFleetLocationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fleet_locations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFleetLocationsOutput, crate::error::DeleteFleetLocationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_fleet_locations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_fleet_locations(response.body().as_ref(), output).map_err(crate::error::DeleteFleetLocationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_game_server_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteGameServerGroupOutput, crate::error::DeleteGameServerGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteGameServerGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteGameServerGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteGameServerGroupError { meta: generic, kind: crate::error::DeleteGameServerGroupErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteGameServerGroupError { meta: generic, kind: crate::error::DeleteGameServerGroupErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteGameServerGroupError { meta: generic, kind: crate::error::DeleteGameServerGroupErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeleteGameServerGroupError { meta: generic, kind: crate::error::DeleteGameServerGroupErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteGameServerGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_game_server_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteGameServerGroupOutput, crate::error::DeleteGameServerGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_game_server_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_game_server_group(response.body().as_ref(), output).map_err(crate::error::DeleteGameServerGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_game_session_queue_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteGameSessionQueueOutput, crate::error::DeleteGameSessionQueueError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteGameSessionQueueError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteGameSessionQueueError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteGameSessionQueueError { meta: generic, kind: crate::error::DeleteGameSessionQueueErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteGameSessionQueueError { meta: generic, kind: crate::error::DeleteGameSessionQueueErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteGameSessionQueueError { meta: generic, kind: crate::error::DeleteGameSessionQueueErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::DeleteGameSessionQueueError { meta: generic, kind: crate::error::DeleteGameSessionQueueErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeleteGameSessionQueueError { meta: generic, kind: crate::error::DeleteGameSessionQueueErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteGameSessionQueueError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_game_session_queue_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteGameSessionQueueOutput, crate::error::DeleteGameSessionQueueError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_game_session_queue_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_location_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLocationOutput, crate::error::DeleteLocationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteLocationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteLocationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteLocationError { meta: generic, kind: crate::error::DeleteLocationErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteLocationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteLocationError { meta: generic, kind: crate::error::DeleteLocationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteLocationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteLocationError { meta: generic, kind: crate::error::DeleteLocationErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteLocationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeleteLocationError { meta: generic, kind: crate::error::DeleteLocationErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteLocationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteLocationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_location_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLocationOutput, crate::error::DeleteLocationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_location_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_matchmaking_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteMatchmakingConfigurationOutput, crate::error::DeleteMatchmakingConfigurationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteMatchmakingConfigurationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteMatchmakingConfigurationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteMatchmakingConfigurationError { meta: generic, kind: crate::error::DeleteMatchmakingConfigurationErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteMatchmakingConfigurationError { meta: generic, kind: crate::error::DeleteMatchmakingConfigurationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteMatchmakingConfigurationError { meta: generic, kind: crate::error::DeleteMatchmakingConfigurationErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::DeleteMatchmakingConfigurationError { meta: generic, kind: crate::error::DeleteMatchmakingConfigurationErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DeleteMatchmakingConfigurationError { meta: generic, kind: crate::error::DeleteMatchmakingConfigurationErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteMatchmakingConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_matchmaking_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteMatchmakingConfigurationOutput, crate::error::DeleteMatchmakingConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_matchmaking_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_matchmaking_rule_set_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteMatchmakingRuleSetOutput, crate::error::DeleteMatchmakingRuleSetError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteMatchmakingRuleSetError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteMatchmakingRuleSetError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteMatchmakingRuleSetError { meta: generic, kind: crate::error::DeleteMatchmakingRuleSetErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteMatchmakingRuleSetError { meta: generic, kind: crate::error::DeleteMatchmakingRuleSetErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteMatchmakingRuleSetError { meta: generic, kind: crate::error::DeleteMatchmakingRuleSetErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::DeleteMatchmakingRuleSetError { meta: generic, kind: crate::error::DeleteMatchmakingRuleSetErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DeleteMatchmakingRuleSetError { meta: generic, kind: crate::error::DeleteMatchmakingRuleSetErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteMatchmakingRuleSetError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_matchmaking_rule_set_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteMatchmakingRuleSetOutput, crate::error::DeleteMatchmakingRuleSetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_matchmaking_rule_set_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_scaling_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteScalingPolicyOutput, crate::error::DeleteScalingPolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteScalingPolicyError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteScalingPolicyError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteScalingPolicyError { meta: generic, kind: crate::error::DeleteScalingPolicyErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteScalingPolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteScalingPolicyError { meta: generic, kind: crate::error::DeleteScalingPolicyErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteScalingPolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteScalingPolicyError { meta: generic, kind: crate::error::DeleteScalingPolicyErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteScalingPolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeleteScalingPolicyError { meta: generic, kind: crate::error::DeleteScalingPolicyErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteScalingPolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteScalingPolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_scaling_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteScalingPolicyOutput, crate::error::DeleteScalingPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_scaling_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_script_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteScriptOutput, crate::error::DeleteScriptError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteScriptError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteScriptError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteScriptError { meta: generic, kind: crate::error::DeleteScriptErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteScriptError { meta: generic, kind: crate::error::DeleteScriptErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteScriptError { meta: generic, kind: crate::error::DeleteScriptErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::DeleteScriptError { meta: generic, kind: crate::error::DeleteScriptErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeleteScriptError { meta: generic, kind: crate::error::DeleteScriptErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteScriptError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_script_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteScriptOutput, crate::error::DeleteScriptError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_script_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_peering_authorization_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcPeeringAuthorizationOutput, crate::error::DeleteVpcPeeringAuthorizationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteVpcPeeringAuthorizationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteVpcPeeringAuthorizationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteVpcPeeringAuthorizationError { meta: generic, kind: crate::error::DeleteVpcPeeringAuthorizationErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVpcPeeringAuthorizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteVpcPeeringAuthorizationError { meta: generic, kind: crate::error::DeleteVpcPeeringAuthorizationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVpcPeeringAuthorizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteVpcPeeringAuthorizationError { meta: generic, kind: crate::error::DeleteVpcPeeringAuthorizationErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVpcPeeringAuthorizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeleteVpcPeeringAuthorizationError { meta: generic, kind: crate::error::DeleteVpcPeeringAuthorizationErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVpcPeeringAuthorizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteVpcPeeringAuthorizationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_peering_authorization_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcPeeringAuthorizationOutput, crate::error::DeleteVpcPeeringAuthorizationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpc_peering_authorization_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_peering_connection_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcPeeringConnectionOutput, crate::error::DeleteVpcPeeringConnectionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteVpcPeeringConnectionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteVpcPeeringConnectionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeleteVpcPeeringConnectionError { meta: generic, kind: crate::error::DeleteVpcPeeringConnectionErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVpcPeeringConnectionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteVpcPeeringConnectionError { meta: generic, kind: crate::error::DeleteVpcPeeringConnectionErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVpcPeeringConnectionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeleteVpcPeeringConnectionError { meta: generic, kind: crate::error::DeleteVpcPeeringConnectionErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVpcPeeringConnectionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeleteVpcPeeringConnectionError { meta: generic, kind: crate::error::DeleteVpcPeeringConnectionErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVpcPeeringConnectionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteVpcPeeringConnectionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_peering_connection_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcPeeringConnectionOutput, crate::error::DeleteVpcPeeringConnectionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpc_peering_connection_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_compute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterComputeOutput, crate::error::DeregisterComputeError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeregisterComputeError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeregisterComputeError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeregisterComputeError { meta: generic, kind: crate::error::DeregisterComputeErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeregisterComputeError { meta: generic, kind: crate::error::DeregisterComputeErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeregisterComputeError { meta: generic, kind: crate::error::DeregisterComputeErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeregisterComputeError { meta: generic, kind: crate::error::DeregisterComputeErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeregisterComputeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_compute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterComputeOutput, crate::error::DeregisterComputeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_compute_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_game_server_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterGameServerOutput, crate::error::DeregisterGameServerError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeregisterGameServerError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeregisterGameServerError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DeregisterGameServerError { meta: generic, kind: crate::error::DeregisterGameServerErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeregisterGameServerError { meta: generic, kind: crate::error::DeregisterGameServerErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DeregisterGameServerError { meta: generic, kind: crate::error::DeregisterGameServerErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DeregisterGameServerError { meta: generic, kind: crate::error::DeregisterGameServerErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeregisterGameServerError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_game_server_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterGameServerOutput, crate::error::DeregisterGameServerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_game_server_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_alias_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAliasOutput, crate::error::DescribeAliasError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeAliasError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeAliasError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeAliasError { meta: generic, kind: crate::error::DescribeAliasErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeAliasError { meta: generic, kind: crate::error::DescribeAliasErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeAliasError { meta: generic, kind: crate::error::DescribeAliasErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeAliasError { meta: generic, kind: crate::error::DescribeAliasErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeAliasError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_alias_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAliasOutput, crate::error::DescribeAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_alias_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_alias(response.body().as_ref(), output).map_err(crate::error::DescribeAliasError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_build_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeBuildOutput, crate::error::DescribeBuildError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeBuildError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeBuildError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeBuildError { meta: generic, kind: crate::error::DescribeBuildErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeBuildError { meta: generic, kind: crate::error::DescribeBuildErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeBuildError { meta: generic, kind: crate::error::DescribeBuildErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeBuildError { meta: generic, kind: crate::error::DescribeBuildErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeBuildError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_build_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeBuildOutput, crate::error::DescribeBuildError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_build_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_build(response.body().as_ref(), output).map_err(crate::error::DescribeBuildError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_compute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeComputeOutput, crate::error::DescribeComputeError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeComputeError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeComputeError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeComputeError { meta: generic, kind: crate::error::DescribeComputeErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeComputeError { meta: generic, kind: crate::error::DescribeComputeErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeComputeError { meta: generic, kind: crate::error::DescribeComputeErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeComputeError { meta: generic, kind: crate::error::DescribeComputeErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeComputeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_compute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeComputeOutput, crate::error::DescribeComputeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_compute_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_compute(response.body().as_ref(), output).map_err(crate::error::DescribeComputeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ec2_instance_limits_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeEc2InstanceLimitsOutput, crate::error::DescribeEC2InstanceLimitsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeEC2InstanceLimitsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeEC2InstanceLimitsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeEC2InstanceLimitsError { meta: generic, kind: crate::error::DescribeEC2InstanceLimitsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEC2InstanceLimitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeEC2InstanceLimitsError { meta: generic, kind: crate::error::DescribeEC2InstanceLimitsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEC2InstanceLimitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeEC2InstanceLimitsError { meta: generic, kind: crate::error::DescribeEC2InstanceLimitsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEC2InstanceLimitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeEC2InstanceLimitsError { meta: generic, kind: crate::error::DescribeEC2InstanceLimitsErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEC2InstanceLimitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeEC2InstanceLimitsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ec2_instance_limits_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeEc2InstanceLimitsOutput, crate::error::DescribeEC2InstanceLimitsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ec2_instance_limits_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_ec2_instance_limits(response.body().as_ref(), output).map_err(crate::error::DescribeEC2InstanceLimitsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_attributes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetAttributesOutput, crate::error::DescribeFleetAttributesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeFleetAttributesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeFleetAttributesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeFleetAttributesError { meta: generic, kind: crate::error::DescribeFleetAttributesErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeFleetAttributesError { meta: generic, kind: crate::error::DescribeFleetAttributesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeFleetAttributesError { meta: generic, kind: crate::error::DescribeFleetAttributesErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeFleetAttributesError { meta: generic, kind: crate::error::DescribeFleetAttributesErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeFleetAttributesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_attributes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetAttributesOutput, crate::error::DescribeFleetAttributesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_attributes_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_fleet_attributes(response.body().as_ref(), output).map_err(crate::error::DescribeFleetAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_capacity_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetCapacityOutput, crate::error::DescribeFleetCapacityError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeFleetCapacityError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeFleetCapacityError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeFleetCapacityError { meta: generic, kind: crate::error::DescribeFleetCapacityErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeFleetCapacityError { meta: generic, kind: crate::error::DescribeFleetCapacityErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeFleetCapacityError { meta: generic, kind: crate::error::DescribeFleetCapacityErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeFleetCapacityError { meta: generic, kind: crate::error::DescribeFleetCapacityErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeFleetCapacityError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_capacity_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetCapacityOutput, crate::error::DescribeFleetCapacityError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_capacity_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_fleet_capacity(response.body().as_ref(), output).map_err(crate::error::DescribeFleetCapacityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_events_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetEventsOutput, crate::error::DescribeFleetEventsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeFleetEventsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeFleetEventsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeFleetEventsError { meta: generic, kind: crate::error::DescribeFleetEventsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeFleetEventsError { meta: generic, kind: crate::error::DescribeFleetEventsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeFleetEventsError { meta: generic, kind: crate::error::DescribeFleetEventsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeFleetEventsError { meta: generic, kind: crate::error::DescribeFleetEventsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeFleetEventsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_events_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetEventsOutput, crate::error::DescribeFleetEventsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_events_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_fleet_events(response.body().as_ref(), output).map_err(crate::error::DescribeFleetEventsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_location_attributes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetLocationAttributesOutput, crate::error::DescribeFleetLocationAttributesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeFleetLocationAttributesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeFleetLocationAttributesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeFleetLocationAttributesError { meta: generic, kind: crate::error::DescribeFleetLocationAttributesErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeFleetLocationAttributesError { meta: generic, kind: crate::error::DescribeFleetLocationAttributesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeFleetLocationAttributesError { meta: generic, kind: crate::error::DescribeFleetLocationAttributesErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeFleetLocationAttributesError { meta: generic, kind: crate::error::DescribeFleetLocationAttributesErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeFleetLocationAttributesError { meta: generic, kind: crate::error::DescribeFleetLocationAttributesErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeFleetLocationAttributesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_location_attributes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetLocationAttributesOutput, crate::error::DescribeFleetLocationAttributesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_location_attributes_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_fleet_location_attributes(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_location_capacity_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetLocationCapacityOutput, crate::error::DescribeFleetLocationCapacityError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeFleetLocationCapacityError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeFleetLocationCapacityError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeFleetLocationCapacityError { meta: generic, kind: crate::error::DescribeFleetLocationCapacityErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeFleetLocationCapacityError { meta: generic, kind: crate::error::DescribeFleetLocationCapacityErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeFleetLocationCapacityError { meta: generic, kind: crate::error::DescribeFleetLocationCapacityErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeFleetLocationCapacityError { meta: generic, kind: crate::error::DescribeFleetLocationCapacityErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeFleetLocationCapacityError { meta: generic, kind: crate::error::DescribeFleetLocationCapacityErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeFleetLocationCapacityError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_location_capacity_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetLocationCapacityOutput, crate::error::DescribeFleetLocationCapacityError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_location_capacity_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_fleet_location_capacity(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationCapacityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_location_utilization_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetLocationUtilizationOutput, crate::error::DescribeFleetLocationUtilizationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeFleetLocationUtilizationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeFleetLocationUtilizationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeFleetLocationUtilizationError { meta: generic, kind: crate::error::DescribeFleetLocationUtilizationErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationUtilizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeFleetLocationUtilizationError { meta: generic, kind: crate::error::DescribeFleetLocationUtilizationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationUtilizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeFleetLocationUtilizationError { meta: generic, kind: crate::error::DescribeFleetLocationUtilizationErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationUtilizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeFleetLocationUtilizationError { meta: generic, kind: crate::error::DescribeFleetLocationUtilizationErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationUtilizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeFleetLocationUtilizationError { meta: generic, kind: crate::error::DescribeFleetLocationUtilizationErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationUtilizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeFleetLocationUtilizationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_location_utilization_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetLocationUtilizationOutput, crate::error::DescribeFleetLocationUtilizationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_location_utilization_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_fleet_location_utilization(response.body().as_ref(), output).map_err(crate::error::DescribeFleetLocationUtilizationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_port_settings_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetPortSettingsOutput, crate::error::DescribeFleetPortSettingsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeFleetPortSettingsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeFleetPortSettingsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeFleetPortSettingsError { meta: generic, kind: crate::error::DescribeFleetPortSettingsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeFleetPortSettingsError { meta: generic, kind: crate::error::DescribeFleetPortSettingsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeFleetPortSettingsError { meta: generic, kind: crate::error::DescribeFleetPortSettingsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeFleetPortSettingsError { meta: generic, kind: crate::error::DescribeFleetPortSettingsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeFleetPortSettingsError { meta: generic, kind: crate::error::DescribeFleetPortSettingsErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeFleetPortSettingsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_port_settings_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetPortSettingsOutput, crate::error::DescribeFleetPortSettingsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_port_settings_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_fleet_port_settings(response.body().as_ref(), output).map_err(crate::error::DescribeFleetPortSettingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_utilization_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetUtilizationOutput, crate::error::DescribeFleetUtilizationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeFleetUtilizationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeFleetUtilizationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeFleetUtilizationError { meta: generic, kind: crate::error::DescribeFleetUtilizationErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetUtilizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeFleetUtilizationError { meta: generic, kind: crate::error::DescribeFleetUtilizationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetUtilizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeFleetUtilizationError { meta: generic, kind: crate::error::DescribeFleetUtilizationErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetUtilizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeFleetUtilizationError { meta: generic, kind: crate::error::DescribeFleetUtilizationErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeFleetUtilizationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeFleetUtilizationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_utilization_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetUtilizationOutput, crate::error::DescribeFleetUtilizationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_utilization_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_fleet_utilization(response.body().as_ref(), output).map_err(crate::error::DescribeFleetUtilizationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_server_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameServerOutput, crate::error::DescribeGameServerError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeGameServerError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeGameServerError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeGameServerError { meta: generic, kind: crate::error::DescribeGameServerErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeGameServerError { meta: generic, kind: crate::error::DescribeGameServerErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeGameServerError { meta: generic, kind: crate::error::DescribeGameServerErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeGameServerError { meta: generic, kind: crate::error::DescribeGameServerErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeGameServerError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_server_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameServerOutput, crate::error::DescribeGameServerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_game_server_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_game_server(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_server_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameServerGroupOutput, crate::error::DescribeGameServerGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeGameServerGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeGameServerGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeGameServerGroupError { meta: generic, kind: crate::error::DescribeGameServerGroupErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeGameServerGroupError { meta: generic, kind: crate::error::DescribeGameServerGroupErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeGameServerGroupError { meta: generic, kind: crate::error::DescribeGameServerGroupErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeGameServerGroupError { meta: generic, kind: crate::error::DescribeGameServerGroupErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeGameServerGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_server_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameServerGroupOutput, crate::error::DescribeGameServerGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_game_server_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_game_server_group(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_server_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameServerInstancesOutput, crate::error::DescribeGameServerInstancesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeGameServerInstancesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeGameServerInstancesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeGameServerInstancesError { meta: generic, kind: crate::error::DescribeGameServerInstancesErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeGameServerInstancesError { meta: generic, kind: crate::error::DescribeGameServerInstancesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeGameServerInstancesError { meta: generic, kind: crate::error::DescribeGameServerInstancesErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeGameServerInstancesError { meta: generic, kind: crate::error::DescribeGameServerInstancesErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeGameServerInstancesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_server_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameServerInstancesOutput, crate::error::DescribeGameServerInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_game_server_instances_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_game_server_instances(response.body().as_ref(), output).map_err(crate::error::DescribeGameServerInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_session_details_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameSessionDetailsOutput, crate::error::DescribeGameSessionDetailsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeGameSessionDetailsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeGameSessionDetailsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeGameSessionDetailsError { meta: generic, kind: crate::error::DescribeGameSessionDetailsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionDetailsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeGameSessionDetailsError { meta: generic, kind: crate::error::DescribeGameSessionDetailsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionDetailsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeGameSessionDetailsError { meta: generic, kind: crate::error::DescribeGameSessionDetailsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionDetailsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TerminalRoutingStrategyException" => crate::error::DescribeGameSessionDetailsError { meta: generic, kind: crate::error::DescribeGameSessionDetailsErrorKind::TerminalRoutingStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::terminal_routing_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_terminal_routing_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionDetailsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeGameSessionDetailsError { meta: generic, kind: crate::error::DescribeGameSessionDetailsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionDetailsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeGameSessionDetailsError { meta: generic, kind: crate::error::DescribeGameSessionDetailsErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionDetailsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeGameSessionDetailsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_session_details_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameSessionDetailsOutput, crate::error::DescribeGameSessionDetailsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_game_session_details_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_game_session_details(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionDetailsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_session_placement_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameSessionPlacementOutput, crate::error::DescribeGameSessionPlacementError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeGameSessionPlacementError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeGameSessionPlacementError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeGameSessionPlacementError { meta: generic, kind: crate::error::DescribeGameSessionPlacementErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeGameSessionPlacementError { meta: generic, kind: crate::error::DescribeGameSessionPlacementErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeGameSessionPlacementError { meta: generic, kind: crate::error::DescribeGameSessionPlacementErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeGameSessionPlacementError { meta: generic, kind: crate::error::DescribeGameSessionPlacementErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeGameSessionPlacementError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_session_placement_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameSessionPlacementOutput, crate::error::DescribeGameSessionPlacementError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_game_session_placement_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_game_session_placement(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionPlacementError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_session_queues_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameSessionQueuesOutput, crate::error::DescribeGameSessionQueuesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeGameSessionQueuesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeGameSessionQueuesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeGameSessionQueuesError { meta: generic, kind: crate::error::DescribeGameSessionQueuesErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionQueuesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeGameSessionQueuesError { meta: generic, kind: crate::error::DescribeGameSessionQueuesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionQueuesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeGameSessionQueuesError { meta: generic, kind: crate::error::DescribeGameSessionQueuesErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionQueuesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeGameSessionQueuesError { meta: generic, kind: crate::error::DescribeGameSessionQueuesErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionQueuesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeGameSessionQueuesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_session_queues_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameSessionQueuesOutput, crate::error::DescribeGameSessionQueuesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_game_session_queues_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_game_session_queues(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionQueuesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_sessions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameSessionsOutput, crate::error::DescribeGameSessionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeGameSessionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeGameSessionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeGameSessionsError { meta: generic, kind: crate::error::DescribeGameSessionsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeGameSessionsError { meta: generic, kind: crate::error::DescribeGameSessionsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeGameSessionsError { meta: generic, kind: crate::error::DescribeGameSessionsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TerminalRoutingStrategyException" => crate::error::DescribeGameSessionsError { meta: generic, kind: crate::error::DescribeGameSessionsErrorKind::TerminalRoutingStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::terminal_routing_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_terminal_routing_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeGameSessionsError { meta: generic, kind: crate::error::DescribeGameSessionsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeGameSessionsError { meta: generic, kind: crate::error::DescribeGameSessionsErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeGameSessionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_game_sessions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeGameSessionsOutput, crate::error::DescribeGameSessionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_game_sessions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_game_sessions(response.body().as_ref(), output).map_err(crate::error::DescribeGameSessionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancesOutput, crate::error::DescribeInstancesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeInstancesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeInstancesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeInstancesError { meta: generic, kind: crate::error::DescribeInstancesErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeInstancesError { meta: generic, kind: crate::error::DescribeInstancesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeInstancesError { meta: generic, kind: crate::error::DescribeInstancesErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeInstancesError { meta: generic, kind: crate::error::DescribeInstancesErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeInstancesError { meta: generic, kind: crate::error::DescribeInstancesErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeInstancesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancesOutput, crate::error::DescribeInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instances_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instances(response.body().as_ref(), output).map_err(crate::error::DescribeInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_matchmaking_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMatchmakingOutput, crate::error::DescribeMatchmakingError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeMatchmakingError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMatchmakingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeMatchmakingError { meta: generic, kind: crate::error::DescribeMatchmakingErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeMatchmakingError { meta: generic, kind: crate::error::DescribeMatchmakingErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeMatchmakingError { meta: generic, kind: crate::error::DescribeMatchmakingErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeMatchmakingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_matchmaking_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMatchmakingOutput, crate::error::DescribeMatchmakingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_matchmaking_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_matchmaking(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_matchmaking_configurations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMatchmakingConfigurationsOutput, crate::error::DescribeMatchmakingConfigurationsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeMatchmakingConfigurationsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMatchmakingConfigurationsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeMatchmakingConfigurationsError { meta: generic, kind: crate::error::DescribeMatchmakingConfigurationsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingConfigurationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeMatchmakingConfigurationsError { meta: generic, kind: crate::error::DescribeMatchmakingConfigurationsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingConfigurationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeMatchmakingConfigurationsError { meta: generic, kind: crate::error::DescribeMatchmakingConfigurationsErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingConfigurationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeMatchmakingConfigurationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_matchmaking_configurations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMatchmakingConfigurationsOutput, crate::error::DescribeMatchmakingConfigurationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_matchmaking_configurations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_matchmaking_configurations(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_matchmaking_rule_sets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMatchmakingRuleSetsOutput, crate::error::DescribeMatchmakingRuleSetsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeMatchmakingRuleSetsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMatchmakingRuleSetsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeMatchmakingRuleSetsError { meta: generic, kind: crate::error::DescribeMatchmakingRuleSetsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingRuleSetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeMatchmakingRuleSetsError { meta: generic, kind: crate::error::DescribeMatchmakingRuleSetsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingRuleSetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeMatchmakingRuleSetsError { meta: generic, kind: crate::error::DescribeMatchmakingRuleSetsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingRuleSetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeMatchmakingRuleSetsError { meta: generic, kind: crate::error::DescribeMatchmakingRuleSetsErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingRuleSetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeMatchmakingRuleSetsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_matchmaking_rule_sets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMatchmakingRuleSetsOutput, crate::error::DescribeMatchmakingRuleSetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_matchmaking_rule_sets_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_matchmaking_rule_sets(response.body().as_ref(), output).map_err(crate::error::DescribeMatchmakingRuleSetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_player_sessions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePlayerSessionsOutput, crate::error::DescribePlayerSessionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribePlayerSessionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribePlayerSessionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribePlayerSessionsError { meta: generic, kind: crate::error::DescribePlayerSessionsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePlayerSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribePlayerSessionsError { meta: generic, kind: crate::error::DescribePlayerSessionsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePlayerSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribePlayerSessionsError { meta: generic, kind: crate::error::DescribePlayerSessionsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePlayerSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribePlayerSessionsError { meta: generic, kind: crate::error::DescribePlayerSessionsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePlayerSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribePlayerSessionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_player_sessions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePlayerSessionsOutput, crate::error::DescribePlayerSessionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_player_sessions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_player_sessions(response.body().as_ref(), output).map_err(crate::error::DescribePlayerSessionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_runtime_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeRuntimeConfigurationOutput, crate::error::DescribeRuntimeConfigurationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeRuntimeConfigurationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeRuntimeConfigurationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeRuntimeConfigurationError { meta: generic, kind: crate::error::DescribeRuntimeConfigurationErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRuntimeConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeRuntimeConfigurationError { meta: generic, kind: crate::error::DescribeRuntimeConfigurationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRuntimeConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeRuntimeConfigurationError { meta: generic, kind: crate::error::DescribeRuntimeConfigurationErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRuntimeConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeRuntimeConfigurationError { meta: generic, kind: crate::error::DescribeRuntimeConfigurationErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRuntimeConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeRuntimeConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_runtime_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeRuntimeConfigurationOutput, crate::error::DescribeRuntimeConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_runtime_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_runtime_configuration(response.body().as_ref(), output).map_err(crate::error::DescribeRuntimeConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scaling_policies_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeScalingPoliciesOutput, crate::error::DescribeScalingPoliciesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeScalingPoliciesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeScalingPoliciesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeScalingPoliciesError { meta: generic, kind: crate::error::DescribeScalingPoliciesErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeScalingPoliciesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeScalingPoliciesError { meta: generic, kind: crate::error::DescribeScalingPoliciesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeScalingPoliciesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeScalingPoliciesError { meta: generic, kind: crate::error::DescribeScalingPoliciesErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeScalingPoliciesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeScalingPoliciesError { meta: generic, kind: crate::error::DescribeScalingPoliciesErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeScalingPoliciesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::DescribeScalingPoliciesError { meta: generic, kind: crate::error::DescribeScalingPoliciesErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeScalingPoliciesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeScalingPoliciesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scaling_policies_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeScalingPoliciesOutput, crate::error::DescribeScalingPoliciesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_scaling_policies_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_scaling_policies(response.body().as_ref(), output).map_err(crate::error::DescribeScalingPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_script_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeScriptOutput, crate::error::DescribeScriptError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeScriptError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeScriptError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeScriptError { meta: generic, kind: crate::error::DescribeScriptErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeScriptError { meta: generic, kind: crate::error::DescribeScriptErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeScriptError { meta: generic, kind: crate::error::DescribeScriptErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeScriptError { meta: generic, kind: crate::error::DescribeScriptErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeScriptError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_script_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeScriptOutput, crate::error::DescribeScriptError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_script_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_script(response.body().as_ref(), output).map_err(crate::error::DescribeScriptError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_peering_authorizations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcPeeringAuthorizationsOutput, crate::error::DescribeVpcPeeringAuthorizationsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeVpcPeeringAuthorizationsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeVpcPeeringAuthorizationsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeVpcPeeringAuthorizationsError { meta: generic, kind: crate::error::DescribeVpcPeeringAuthorizationsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVpcPeeringAuthorizationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeVpcPeeringAuthorizationsError { meta: generic, kind: crate::error::DescribeVpcPeeringAuthorizationsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVpcPeeringAuthorizationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeVpcPeeringAuthorizationsError { meta: generic, kind: crate::error::DescribeVpcPeeringAuthorizationsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVpcPeeringAuthorizationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeVpcPeeringAuthorizationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_peering_authorizations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcPeeringAuthorizationsOutput, crate::error::DescribeVpcPeeringAuthorizationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_peering_authorizations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_vpc_peering_authorizations(response.body().as_ref(), output).map_err(crate::error::DescribeVpcPeeringAuthorizationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_peering_connections_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcPeeringConnectionsOutput, crate::error::DescribeVpcPeeringConnectionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeVpcPeeringConnectionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeVpcPeeringConnectionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::DescribeVpcPeeringConnectionsError { meta: generic, kind: crate::error::DescribeVpcPeeringConnectionsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVpcPeeringConnectionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeVpcPeeringConnectionsError { meta: generic, kind: crate::error::DescribeVpcPeeringConnectionsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVpcPeeringConnectionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::DescribeVpcPeeringConnectionsError { meta: generic, kind: crate::error::DescribeVpcPeeringConnectionsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVpcPeeringConnectionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::DescribeVpcPeeringConnectionsError { meta: generic, kind: crate::error::DescribeVpcPeeringConnectionsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVpcPeeringConnectionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeVpcPeeringConnectionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_peering_connections_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcPeeringConnectionsOutput, crate::error::DescribeVpcPeeringConnectionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_peering_connections_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_vpc_peering_connections(response.body().as_ref(), output).map_err(crate::error::DescribeVpcPeeringConnectionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compute_access_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetComputeAccessOutput, crate::error::GetComputeAccessError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetComputeAccessError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetComputeAccessError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::GetComputeAccessError { meta: generic, kind: crate::error::GetComputeAccessErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComputeAccessError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::GetComputeAccessError { meta: generic, kind: crate::error::GetComputeAccessErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComputeAccessError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::GetComputeAccessError { meta: generic, kind: crate::error::GetComputeAccessErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComputeAccessError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::GetComputeAccessError { meta: generic, kind: crate::error::GetComputeAccessErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComputeAccessError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetComputeAccessError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compute_access_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetComputeAccessOutput, crate::error::GetComputeAccessError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_compute_access_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_compute_access(response.body().as_ref(), output).map_err(crate::error::GetComputeAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compute_auth_token_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetComputeAuthTokenOutput, crate::error::GetComputeAuthTokenError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetComputeAuthTokenError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetComputeAuthTokenError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::GetComputeAuthTokenError { meta: generic, kind: crate::error::GetComputeAuthTokenErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComputeAuthTokenError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::GetComputeAuthTokenError { meta: generic, kind: crate::error::GetComputeAuthTokenErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComputeAuthTokenError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::GetComputeAuthTokenError { meta: generic, kind: crate::error::GetComputeAuthTokenErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComputeAuthTokenError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::GetComputeAuthTokenError { meta: generic, kind: crate::error::GetComputeAuthTokenErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetComputeAuthTokenError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetComputeAuthTokenError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_compute_auth_token_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetComputeAuthTokenOutput, crate::error::GetComputeAuthTokenError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_compute_auth_token_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_compute_auth_token(response.body().as_ref(), output).map_err(crate::error::GetComputeAuthTokenError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_session_log_url_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetGameSessionLogUrlOutput, crate::error::GetGameSessionLogUrlError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetGameSessionLogUrlError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetGameSessionLogUrlError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::GetGameSessionLogUrlError { meta: generic, kind: crate::error::GetGameSessionLogUrlErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameSessionLogUrlError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::GetGameSessionLogUrlError { meta: generic, kind: crate::error::GetGameSessionLogUrlErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameSessionLogUrlError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::GetGameSessionLogUrlError { meta: generic, kind: crate::error::GetGameSessionLogUrlErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameSessionLogUrlError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::GetGameSessionLogUrlError { meta: generic, kind: crate::error::GetGameSessionLogUrlErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameSessionLogUrlError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetGameSessionLogUrlError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_session_log_url_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetGameSessionLogUrlOutput, crate::error::GetGameSessionLogUrlError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_game_session_log_url_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_game_session_log_url(response.body().as_ref(), output).map_err(crate::error::GetGameSessionLogUrlError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_access_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInstanceAccessOutput, crate::error::GetInstanceAccessError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetInstanceAccessError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetInstanceAccessError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::GetInstanceAccessError { meta: generic, kind: crate::error::GetInstanceAccessErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInstanceAccessError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::GetInstanceAccessError { meta: generic, kind: crate::error::GetInstanceAccessErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInstanceAccessError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::GetInstanceAccessError { meta: generic, kind: crate::error::GetInstanceAccessErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInstanceAccessError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::GetInstanceAccessError { meta: generic, kind: crate::error::GetInstanceAccessErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInstanceAccessError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetInstanceAccessError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_access_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInstanceAccessOutput, crate::error::GetInstanceAccessError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_instance_access_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_instance_access(response.body().as_ref(), output).map_err(crate::error::GetInstanceAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_aliases_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListAliasesOutput, crate::error::ListAliasesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListAliasesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListAliasesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ListAliasesError { meta: generic, kind: crate::error::ListAliasesErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAliasesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListAliasesError { meta: generic, kind: crate::error::ListAliasesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAliasesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::ListAliasesError { meta: generic, kind: crate::error::ListAliasesErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAliasesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListAliasesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_aliases_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListAliasesOutput, crate::error::ListAliasesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_aliases_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_aliases(response.body().as_ref(), output).map_err(crate::error::ListAliasesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_builds_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBuildsOutput, crate::error::ListBuildsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListBuildsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListBuildsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ListBuildsError { meta: generic, kind: crate::error::ListBuildsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBuildsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListBuildsError { meta: generic, kind: crate::error::ListBuildsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBuildsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::ListBuildsError { meta: generic, kind: crate::error::ListBuildsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBuildsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListBuildsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_builds_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBuildsOutput, crate::error::ListBuildsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_builds_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_builds(response.body().as_ref(), output).map_err(crate::error::ListBuildsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListComputeOutput, crate::error::ListComputeError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListComputeError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListComputeError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ListComputeError { meta: generic, kind: crate::error::ListComputeErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListComputeError { meta: generic, kind: crate::error::ListComputeErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::ListComputeError { meta: generic, kind: crate::error::ListComputeErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListComputeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListComputeOutput, crate::error::ListComputeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_compute_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_compute(response.body().as_ref(), output).map_err(crate::error::ListComputeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_fleets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListFleetsOutput, crate::error::ListFleetsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListFleetsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListFleetsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ListFleetsError { meta: generic, kind: crate::error::ListFleetsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListFleetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListFleetsError { meta: generic, kind: crate::error::ListFleetsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListFleetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::ListFleetsError { meta: generic, kind: crate::error::ListFleetsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListFleetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::ListFleetsError { meta: generic, kind: crate::error::ListFleetsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListFleetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListFleetsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_fleets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListFleetsOutput, crate::error::ListFleetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_fleets_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_fleets(response.body().as_ref(), output).map_err(crate::error::ListFleetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_server_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListGameServerGroupsOutput, crate::error::ListGameServerGroupsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListGameServerGroupsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListGameServerGroupsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ListGameServerGroupsError { meta: generic, kind: crate::error::ListGameServerGroupsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameServerGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListGameServerGroupsError { meta: generic, kind: crate::error::ListGameServerGroupsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameServerGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::ListGameServerGroupsError { meta: generic, kind: crate::error::ListGameServerGroupsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameServerGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListGameServerGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_server_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListGameServerGroupsOutput, crate::error::ListGameServerGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_game_server_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_game_server_groups(response.body().as_ref(), output).map_err(crate::error::ListGameServerGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_servers_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListGameServersOutput, crate::error::ListGameServersError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListGameServersError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListGameServersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ListGameServersError { meta: generic, kind: crate::error::ListGameServersErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameServersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListGameServersError { meta: generic, kind: crate::error::ListGameServersErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameServersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::ListGameServersError { meta: generic, kind: crate::error::ListGameServersErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameServersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListGameServersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_servers_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListGameServersOutput, crate::error::ListGameServersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_game_servers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_game_servers(response.body().as_ref(), output).map_err(crate::error::ListGameServersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_locations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListLocationsOutput, crate::error::ListLocationsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListLocationsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListLocationsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ListLocationsError { meta: generic, kind: crate::error::ListLocationsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListLocationsError { meta: generic, kind: crate::error::ListLocationsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::ListLocationsError { meta: generic, kind: crate::error::ListLocationsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListLocationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListLocationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_locations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListLocationsOutput, crate::error::ListLocationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_locations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_locations(response.body().as_ref(), output).map_err(crate::error::ListLocationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_scripts_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListScriptsOutput, crate::error::ListScriptsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListScriptsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListScriptsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ListScriptsError { meta: generic, kind: crate::error::ListScriptsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListScriptsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListScriptsError { meta: generic, kind: crate::error::ListScriptsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListScriptsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::ListScriptsError { meta: generic, kind: crate::error::ListScriptsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListScriptsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListScriptsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_scripts_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListScriptsOutput, crate::error::ListScriptsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_scripts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_scripts(response.body().as_ref(), output).map_err(crate::error::ListScriptsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListTagsForResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ListTagsForResourceError { meta: generic, kind: crate::error::ListTagsForResourceErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListTagsForResourceError { meta: generic, kind: crate::error::ListTagsForResourceErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::ListTagsForResourceError { meta: generic, kind: crate::error::ListTagsForResourceErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::ListTagsForResourceError { meta: generic, kind: crate::error::ListTagsForResourceErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListTagsForResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tags_for_resource(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_scaling_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutScalingPolicyOutput, crate::error::PutScalingPolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutScalingPolicyError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutScalingPolicyError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::PutScalingPolicyError { meta: generic, kind: crate::error::PutScalingPolicyErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutScalingPolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::PutScalingPolicyError { meta: generic, kind: crate::error::PutScalingPolicyErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutScalingPolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::PutScalingPolicyError { meta: generic, kind: crate::error::PutScalingPolicyErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutScalingPolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::PutScalingPolicyError { meta: generic, kind: crate::error::PutScalingPolicyErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutScalingPolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutScalingPolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_scaling_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutScalingPolicyOutput, crate::error::PutScalingPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_scaling_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_scaling_policy(response.body().as_ref(), output).map_err(crate::error::PutScalingPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_compute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterComputeOutput, crate::error::RegisterComputeError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RegisterComputeError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RegisterComputeError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::RegisterComputeError { meta: generic, kind: crate::error::RegisterComputeErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::RegisterComputeError { meta: generic, kind: crate::error::RegisterComputeErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::RegisterComputeError { meta: generic, kind: crate::error::RegisterComputeErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::RegisterComputeError { meta: generic, kind: crate::error::RegisterComputeErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterComputeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RegisterComputeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_compute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterComputeOutput, crate::error::RegisterComputeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_compute_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_compute(response.body().as_ref(), output).map_err(crate::error::RegisterComputeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_game_server_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterGameServerOutput, crate::error::RegisterGameServerError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RegisterGameServerError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RegisterGameServerError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::RegisterGameServerError { meta: generic, kind: crate::error::RegisterGameServerErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::RegisterGameServerError { meta: generic, kind: crate::error::RegisterGameServerErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::RegisterGameServerError { meta: generic, kind: crate::error::RegisterGameServerErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::RegisterGameServerError { meta: generic, kind: crate::error::RegisterGameServerErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::RegisterGameServerError { meta: generic, kind: crate::error::RegisterGameServerErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RegisterGameServerError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_game_server_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterGameServerOutput, crate::error::RegisterGameServerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_game_server_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_game_server(response.body().as_ref(), output).map_err(crate::error::RegisterGameServerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_request_upload_credentials_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RequestUploadCredentialsOutput, crate::error::RequestUploadCredentialsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RequestUploadCredentialsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RequestUploadCredentialsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::RequestUploadCredentialsError { meta: generic, kind: crate::error::RequestUploadCredentialsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RequestUploadCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::RequestUploadCredentialsError { meta: generic, kind: crate::error::RequestUploadCredentialsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RequestUploadCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::RequestUploadCredentialsError { meta: generic, kind: crate::error::RequestUploadCredentialsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RequestUploadCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::RequestUploadCredentialsError { meta: generic, kind: crate::error::RequestUploadCredentialsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RequestUploadCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RequestUploadCredentialsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_request_upload_credentials_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RequestUploadCredentialsOutput, crate::error::RequestUploadCredentialsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::request_upload_credentials_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_request_upload_credentials(response.body().as_ref(), output).map_err(crate::error::RequestUploadCredentialsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resolve_alias_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResolveAliasOutput, crate::error::ResolveAliasError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ResolveAliasError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ResolveAliasError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ResolveAliasError { meta: generic, kind: crate::error::ResolveAliasErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResolveAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ResolveAliasError { meta: generic, kind: crate::error::ResolveAliasErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResolveAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::ResolveAliasError { meta: generic, kind: crate::error::ResolveAliasErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResolveAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TerminalRoutingStrategyException" => crate::error::ResolveAliasError { meta: generic, kind: crate::error::ResolveAliasErrorKind::TerminalRoutingStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::terminal_routing_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_terminal_routing_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResolveAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::ResolveAliasError { meta: generic, kind: crate::error::ResolveAliasErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResolveAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ResolveAliasError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resolve_alias_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResolveAliasOutput, crate::error::ResolveAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::resolve_alias_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_resolve_alias(response.body().as_ref(), output).map_err(crate::error::ResolveAliasError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resume_game_server_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResumeGameServerGroupOutput, crate::error::ResumeGameServerGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ResumeGameServerGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ResumeGameServerGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ResumeGameServerGroupError { meta: generic, kind: crate::error::ResumeGameServerGroupErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResumeGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ResumeGameServerGroupError { meta: generic, kind: crate::error::ResumeGameServerGroupErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResumeGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::ResumeGameServerGroupError { meta: generic, kind: crate::error::ResumeGameServerGroupErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResumeGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::ResumeGameServerGroupError { meta: generic, kind: crate::error::ResumeGameServerGroupErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ResumeGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ResumeGameServerGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resume_game_server_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResumeGameServerGroupOutput, crate::error::ResumeGameServerGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::resume_game_server_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_resume_game_server_group(response.body().as_ref(), output).map_err(crate::error::ResumeGameServerGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_game_sessions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SearchGameSessionsOutput, crate::error::SearchGameSessionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::SearchGameSessionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::SearchGameSessionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::SearchGameSessionsError { meta: generic, kind: crate::error::SearchGameSessionsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SearchGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::SearchGameSessionsError { meta: generic, kind: crate::error::SearchGameSessionsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SearchGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::SearchGameSessionsError { meta: generic, kind: crate::error::SearchGameSessionsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SearchGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TerminalRoutingStrategyException" => crate::error::SearchGameSessionsError { meta: generic, kind: crate::error::SearchGameSessionsErrorKind::TerminalRoutingStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::terminal_routing_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_terminal_routing_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SearchGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::SearchGameSessionsError { meta: generic, kind: crate::error::SearchGameSessionsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SearchGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::SearchGameSessionsError { meta: generic, kind: crate::error::SearchGameSessionsErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SearchGameSessionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::SearchGameSessionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_game_sessions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SearchGameSessionsOutput, crate::error::SearchGameSessionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::search_game_sessions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_search_game_sessions(response.body().as_ref(), output).map_err(crate::error::SearchGameSessionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_fleet_actions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartFleetActionsOutput, crate::error::StartFleetActionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StartFleetActionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartFleetActionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::StartFleetActionsError { meta: generic, kind: crate::error::StartFleetActionsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartFleetActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::StartFleetActionsError { meta: generic, kind: crate::error::StartFleetActionsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartFleetActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::StartFleetActionsError { meta: generic, kind: crate::error::StartFleetActionsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartFleetActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::StartFleetActionsError { meta: generic, kind: crate::error::StartFleetActionsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartFleetActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::StartFleetActionsError { meta: generic, kind: crate::error::StartFleetActionsErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartFleetActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartFleetActionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_fleet_actions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartFleetActionsOutput, crate::error::StartFleetActionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_fleet_actions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_fleet_actions(response.body().as_ref(), output).map_err(crate::error::StartFleetActionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_game_session_placement_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartGameSessionPlacementOutput, crate::error::StartGameSessionPlacementError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StartGameSessionPlacementError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartGameSessionPlacementError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::StartGameSessionPlacementError { meta: generic, kind: crate::error::StartGameSessionPlacementErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::StartGameSessionPlacementError { meta: generic, kind: crate::error::StartGameSessionPlacementErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::StartGameSessionPlacementError { meta: generic, kind: crate::error::StartGameSessionPlacementErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::StartGameSessionPlacementError { meta: generic, kind: crate::error::StartGameSessionPlacementErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartGameSessionPlacementError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_game_session_placement_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartGameSessionPlacementOutput, crate::error::StartGameSessionPlacementError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_game_session_placement_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_game_session_placement(response.body().as_ref(), output).map_err(crate::error::StartGameSessionPlacementError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_match_backfill_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartMatchBackfillOutput, crate::error::StartMatchBackfillError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StartMatchBackfillError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartMatchBackfillError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::StartMatchBackfillError { meta: generic, kind: crate::error::StartMatchBackfillErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartMatchBackfillError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::StartMatchBackfillError { meta: generic, kind: crate::error::StartMatchBackfillErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartMatchBackfillError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::StartMatchBackfillError { meta: generic, kind: crate::error::StartMatchBackfillErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartMatchBackfillError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::StartMatchBackfillError { meta: generic, kind: crate::error::StartMatchBackfillErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartMatchBackfillError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartMatchBackfillError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_match_backfill_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartMatchBackfillOutput, crate::error::StartMatchBackfillError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_match_backfill_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_match_backfill(response.body().as_ref(), output).map_err(crate::error::StartMatchBackfillError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_matchmaking_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartMatchmakingOutput, crate::error::StartMatchmakingError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StartMatchmakingError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartMatchmakingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::StartMatchmakingError { meta: generic, kind: crate::error::StartMatchmakingErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartMatchmakingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::StartMatchmakingError { meta: generic, kind: crate::error::StartMatchmakingErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartMatchmakingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::StartMatchmakingError { meta: generic, kind: crate::error::StartMatchmakingErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartMatchmakingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::StartMatchmakingError { meta: generic, kind: crate::error::StartMatchmakingErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartMatchmakingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartMatchmakingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_matchmaking_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartMatchmakingOutput, crate::error::StartMatchmakingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_matchmaking_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_matchmaking(response.body().as_ref(), output).map_err(crate::error::StartMatchmakingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_fleet_actions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopFleetActionsOutput, crate::error::StopFleetActionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StopFleetActionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StopFleetActionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::StopFleetActionsError { meta: generic, kind: crate::error::StopFleetActionsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopFleetActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::StopFleetActionsError { meta: generic, kind: crate::error::StopFleetActionsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopFleetActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::StopFleetActionsError { meta: generic, kind: crate::error::StopFleetActionsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopFleetActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::StopFleetActionsError { meta: generic, kind: crate::error::StopFleetActionsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopFleetActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::StopFleetActionsError { meta: generic, kind: crate::error::StopFleetActionsErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopFleetActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StopFleetActionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_fleet_actions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopFleetActionsOutput, crate::error::StopFleetActionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_fleet_actions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_stop_fleet_actions(response.body().as_ref(), output).map_err(crate::error::StopFleetActionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_game_session_placement_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopGameSessionPlacementOutput, crate::error::StopGameSessionPlacementError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StopGameSessionPlacementError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StopGameSessionPlacementError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::StopGameSessionPlacementError { meta: generic, kind: crate::error::StopGameSessionPlacementErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::StopGameSessionPlacementError { meta: generic, kind: crate::error::StopGameSessionPlacementErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::StopGameSessionPlacementError { meta: generic, kind: crate::error::StopGameSessionPlacementErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::StopGameSessionPlacementError { meta: generic, kind: crate::error::StopGameSessionPlacementErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopGameSessionPlacementError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StopGameSessionPlacementError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_game_session_placement_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopGameSessionPlacementOutput, crate::error::StopGameSessionPlacementError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_game_session_placement_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_stop_game_session_placement(response.body().as_ref(), output).map_err(crate::error::StopGameSessionPlacementError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_matchmaking_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopMatchmakingOutput, crate::error::StopMatchmakingError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StopMatchmakingError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StopMatchmakingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::StopMatchmakingError { meta: generic, kind: crate::error::StopMatchmakingErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopMatchmakingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::StopMatchmakingError { meta: generic, kind: crate::error::StopMatchmakingErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopMatchmakingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::StopMatchmakingError { meta: generic, kind: crate::error::StopMatchmakingErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopMatchmakingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::StopMatchmakingError { meta: generic, kind: crate::error::StopMatchmakingErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopMatchmakingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StopMatchmakingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_matchmaking_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopMatchmakingOutput, crate::error::StopMatchmakingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_matchmaking_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_suspend_game_server_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SuspendGameServerGroupOutput, crate::error::SuspendGameServerGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::SuspendGameServerGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::SuspendGameServerGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::SuspendGameServerGroupError { meta: generic, kind: crate::error::SuspendGameServerGroupErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SuspendGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::SuspendGameServerGroupError { meta: generic, kind: crate::error::SuspendGameServerGroupErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SuspendGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::SuspendGameServerGroupError { meta: generic, kind: crate::error::SuspendGameServerGroupErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SuspendGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::SuspendGameServerGroupError { meta: generic, kind: crate::error::SuspendGameServerGroupErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SuspendGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::SuspendGameServerGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_suspend_game_server_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SuspendGameServerGroupOutput, crate::error::SuspendGameServerGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::suspend_game_server_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_suspend_game_server_group(response.body().as_ref(), output).map_err(crate::error::SuspendGameServerGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::TagResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::TagResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UntagResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TaggingFailedException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::TaggingFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tagging_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tagging_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UntagResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_alias_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateAliasOutput, crate::error::UpdateAliasError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateAliasError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateAliasError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::UpdateAliasError { meta: generic, kind: crate::error::UpdateAliasErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateAliasError { meta: generic, kind: crate::error::UpdateAliasErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateAliasError { meta: generic, kind: crate::error::UpdateAliasErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::UpdateAliasError { meta: generic, kind: crate::error::UpdateAliasErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAliasError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateAliasError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_alias_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateAliasOutput, crate::error::UpdateAliasError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_alias_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_alias(response.body().as_ref(), output).map_err(crate::error::UpdateAliasError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_build_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateBuildOutput, crate::error::UpdateBuildError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateBuildError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateBuildError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::UpdateBuildError { meta: generic, kind: crate::error::UpdateBuildErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateBuildError { meta: generic, kind: crate::error::UpdateBuildErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateBuildError { meta: generic, kind: crate::error::UpdateBuildErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::UpdateBuildError { meta: generic, kind: crate::error::UpdateBuildErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateBuildError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_build_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateBuildOutput, crate::error::UpdateBuildError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_build_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_build(response.body().as_ref(), output).map_err(crate::error::UpdateBuildError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_fleet_attributes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateFleetAttributesOutput, crate::error::UpdateFleetAttributesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateFleetAttributesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateFleetAttributesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateFleetAttributesError { meta: generic, kind: crate::error::UpdateFleetAttributesErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::UpdateFleetAttributesError { meta: generic, kind: crate::error::UpdateFleetAttributesErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFleetStatusException" => crate::error::UpdateFleetAttributesError { meta: generic, kind: crate::error::UpdateFleetAttributesErrorKind::InvalidFleetStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_fleet_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_fleet_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateFleetAttributesError { meta: generic, kind: crate::error::UpdateFleetAttributesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::UpdateFleetAttributesError { meta: generic, kind: crate::error::UpdateFleetAttributesErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateFleetAttributesError { meta: generic, kind: crate::error::UpdateFleetAttributesErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::UpdateFleetAttributesError { meta: generic, kind: crate::error::UpdateFleetAttributesErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateFleetAttributesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_fleet_attributes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateFleetAttributesOutput, crate::error::UpdateFleetAttributesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_fleet_attributes_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_fleet_attributes(response.body().as_ref(), output).map_err(crate::error::UpdateFleetAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_fleet_capacity_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateFleetCapacityOutput, crate::error::UpdateFleetCapacityError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateFleetCapacityError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateFleetCapacityError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateFleetCapacityError { meta: generic, kind: crate::error::UpdateFleetCapacityErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::UpdateFleetCapacityError { meta: generic, kind: crate::error::UpdateFleetCapacityErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFleetStatusException" => crate::error::UpdateFleetCapacityError { meta: generic, kind: crate::error::UpdateFleetCapacityErrorKind::InvalidFleetStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_fleet_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_fleet_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateFleetCapacityError { meta: generic, kind: crate::error::UpdateFleetCapacityErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::UpdateFleetCapacityError { meta: generic, kind: crate::error::UpdateFleetCapacityErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateFleetCapacityError { meta: generic, kind: crate::error::UpdateFleetCapacityErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::UpdateFleetCapacityError { meta: generic, kind: crate::error::UpdateFleetCapacityErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::UpdateFleetCapacityError { meta: generic, kind: crate::error::UpdateFleetCapacityErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetCapacityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateFleetCapacityError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_fleet_capacity_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateFleetCapacityOutput, crate::error::UpdateFleetCapacityError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_fleet_capacity_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_fleet_capacity(response.body().as_ref(), output).map_err(crate::error::UpdateFleetCapacityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_fleet_port_settings_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateFleetPortSettingsOutput, crate::error::UpdateFleetPortSettingsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateFleetPortSettingsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateFleetPortSettingsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateFleetPortSettingsError { meta: generic, kind: crate::error::UpdateFleetPortSettingsErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::UpdateFleetPortSettingsError { meta: generic, kind: crate::error::UpdateFleetPortSettingsErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFleetStatusException" => crate::error::UpdateFleetPortSettingsError { meta: generic, kind: crate::error::UpdateFleetPortSettingsErrorKind::InvalidFleetStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_fleet_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_fleet_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateFleetPortSettingsError { meta: generic, kind: crate::error::UpdateFleetPortSettingsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededException" => crate::error::UpdateFleetPortSettingsError { meta: generic, kind: crate::error::UpdateFleetPortSettingsErrorKind::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateFleetPortSettingsError { meta: generic, kind: crate::error::UpdateFleetPortSettingsErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::UpdateFleetPortSettingsError { meta: generic, kind: crate::error::UpdateFleetPortSettingsErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateFleetPortSettingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateFleetPortSettingsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_fleet_port_settings_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateFleetPortSettingsOutput, crate::error::UpdateFleetPortSettingsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_fleet_port_settings_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_fleet_port_settings(response.body().as_ref(), output).map_err(crate::error::UpdateFleetPortSettingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_server_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateGameServerOutput, crate::error::UpdateGameServerError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateGameServerError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateGameServerError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::UpdateGameServerError { meta: generic, kind: crate::error::UpdateGameServerErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateGameServerError { meta: generic, kind: crate::error::UpdateGameServerErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateGameServerError { meta: generic, kind: crate::error::UpdateGameServerErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::UpdateGameServerError { meta: generic, kind: crate::error::UpdateGameServerErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameServerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateGameServerError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_server_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateGameServerOutput, crate::error::UpdateGameServerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_game_server_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_game_server(response.body().as_ref(), output).map_err(crate::error::UpdateGameServerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_server_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateGameServerGroupOutput, crate::error::UpdateGameServerGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateGameServerGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateGameServerGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::UpdateGameServerGroupError { meta: generic, kind: crate::error::UpdateGameServerGroupErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateGameServerGroupError { meta: generic, kind: crate::error::UpdateGameServerGroupErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateGameServerGroupError { meta: generic, kind: crate::error::UpdateGameServerGroupErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::UpdateGameServerGroupError { meta: generic, kind: crate::error::UpdateGameServerGroupErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameServerGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateGameServerGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_server_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateGameServerGroupOutput, crate::error::UpdateGameServerGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_game_server_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_game_server_group(response.body().as_ref(), output).map_err(crate::error::UpdateGameServerGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_session_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateGameSessionOutput, crate::error::UpdateGameSessionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateGameSessionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateGameSessionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateGameSessionError { meta: generic, kind: crate::error::UpdateGameSessionErrorKind::ConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InternalServiceException" => crate::error::UpdateGameSessionError { meta: generic, kind: crate::error::UpdateGameSessionErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidGameSessionStatusException" => crate::error::UpdateGameSessionError { meta: generic, kind: crate::error::UpdateGameSessionErrorKind::InvalidGameSessionStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_game_session_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_game_session_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateGameSessionError { meta: generic, kind: crate::error::UpdateGameSessionErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateGameSessionError { meta: generic, kind: crate::error::UpdateGameSessionErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::UpdateGameSessionError { meta: generic, kind: crate::error::UpdateGameSessionErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateGameSessionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_session_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateGameSessionOutput, crate::error::UpdateGameSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_game_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_game_session(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_session_queue_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateGameSessionQueueOutput, crate::error::UpdateGameSessionQueueError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateGameSessionQueueError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateGameSessionQueueError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::UpdateGameSessionQueueError { meta: generic, kind: crate::error::UpdateGameSessionQueueErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateGameSessionQueueError { meta: generic, kind: crate::error::UpdateGameSessionQueueErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateGameSessionQueueError { meta: generic, kind: crate::error::UpdateGameSessionQueueErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::UpdateGameSessionQueueError { meta: generic, kind: crate::error::UpdateGameSessionQueueErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionQueueError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateGameSessionQueueError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_session_queue_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateGameSessionQueueOutput, crate::error::UpdateGameSessionQueueError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_game_session_queue_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_game_session_queue(response.body().as_ref(), output).map_err(crate::error::UpdateGameSessionQueueError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_matchmaking_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateMatchmakingConfigurationOutput, crate::error::UpdateMatchmakingConfigurationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateMatchmakingConfigurationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateMatchmakingConfigurationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::UpdateMatchmakingConfigurationError { meta: generic, kind: crate::error::UpdateMatchmakingConfigurationErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateMatchmakingConfigurationError { meta: generic, kind: crate::error::UpdateMatchmakingConfigurationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateMatchmakingConfigurationError { meta: generic, kind: crate::error::UpdateMatchmakingConfigurationErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::UpdateMatchmakingConfigurationError { meta: generic, kind: crate::error::UpdateMatchmakingConfigurationErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMatchmakingConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateMatchmakingConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_matchmaking_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateMatchmakingConfigurationOutput, crate::error::UpdateMatchmakingConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_matchmaking_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_matchmaking_configuration(response.body().as_ref(), output).map_err(crate::error::UpdateMatchmakingConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_runtime_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateRuntimeConfigurationOutput, crate::error::UpdateRuntimeConfigurationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateRuntimeConfigurationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateRuntimeConfigurationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::UpdateRuntimeConfigurationError { meta: generic, kind: crate::error::UpdateRuntimeConfigurationErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRuntimeConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFleetStatusException" => crate::error::UpdateRuntimeConfigurationError { meta: generic, kind: crate::error::UpdateRuntimeConfigurationErrorKind::InvalidFleetStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_fleet_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_fleet_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRuntimeConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateRuntimeConfigurationError { meta: generic, kind: crate::error::UpdateRuntimeConfigurationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRuntimeConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateRuntimeConfigurationError { meta: generic, kind: crate::error::UpdateRuntimeConfigurationErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRuntimeConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::UpdateRuntimeConfigurationError { meta: generic, kind: crate::error::UpdateRuntimeConfigurationErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRuntimeConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateRuntimeConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_runtime_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateRuntimeConfigurationOutput, crate::error::UpdateRuntimeConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_runtime_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_runtime_configuration(response.body().as_ref(), output).map_err(crate::error::UpdateRuntimeConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_script_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateScriptOutput, crate::error::UpdateScriptError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateScriptError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateScriptError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::UpdateScriptError { meta: generic, kind: crate::error::UpdateScriptErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateScriptError { meta: generic, kind: crate::error::UpdateScriptErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NotFoundException" => crate::error::UpdateScriptError { meta: generic, kind: crate::error::UpdateScriptErrorKind::NotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedException" => crate::error::UpdateScriptError { meta: generic, kind: crate::error::UpdateScriptErrorKind::UnauthorizedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unauthorized_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateScriptError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateScriptError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_script_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateScriptOutput, crate::error::UpdateScriptError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_script_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_script(response.body().as_ref(), output).map_err(crate::error::UpdateScriptError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_matchmaking_rule_set_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ValidateMatchmakingRuleSetOutput, crate::error::ValidateMatchmakingRuleSetError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ValidateMatchmakingRuleSetError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ValidateMatchmakingRuleSetError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServiceException" => crate::error::ValidateMatchmakingRuleSetError { meta: generic, kind: crate::error::ValidateMatchmakingRuleSetErrorKind::InternalServiceException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ValidateMatchmakingRuleSetError { meta: generic, kind: crate::error::ValidateMatchmakingRuleSetErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedRegionException" => crate::error::ValidateMatchmakingRuleSetError { meta: generic, kind: crate::error::ValidateMatchmakingRuleSetErrorKind::UnsupportedRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_unsupported_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateMatchmakingRuleSetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ValidateMatchmakingRuleSetError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_matchmaking_rule_set_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ValidateMatchmakingRuleSetOutput, crate::error::ValidateMatchmakingRuleSetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::validate_matchmaking_rule_set_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_validate_matchmaking_rule_set(response.body().as_ref(), output).map_err(crate::error::ValidateMatchmakingRuleSetError::unhandled)?;
        output.build()
    })
}

