// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::claim_game_server::_claim_game_server_output::ClaimGameServerOutputBuilder;

pub use crate::operation::claim_game_server::_claim_game_server_input::ClaimGameServerInputBuilder;

impl ClaimGameServerInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::claim_game_server::ClaimGameServerOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::claim_game_server::ClaimGameServerError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.claim_game_server();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `ClaimGameServer`.
///
/// <p><b>This operation is used with the Amazon GameLift FleetIQ solution and game server groups.</b></p>
/// <p>Locates an available game server and temporarily reserves it to host gameplay and players. This operation is called from a game client or client service (such as a matchmaker) to request hosting resources for a new game session. In response, Amazon GameLift FleetIQ locates an available game server, places it in <code>CLAIMED</code> status for 60 seconds, and returns connection information that players can use to connect to the game server.</p>
/// <p>To claim a game server, identify a game server group. You can also specify a game server ID, although this approach bypasses Amazon GameLift FleetIQ placement optimization. Optionally, include game data to pass to the game server at the start of a game session, such as a game map or player information. Add filter options to further restrict how a game server is chosen, such as only allowing game servers on <code>ACTIVE</code> instances to be claimed.</p>
/// <p>When a game server is successfully claimed, connection information is returned. A claimed game server's utilization status remains <code>AVAILABLE</code> while the claim status is set to <code>CLAIMED</code> for up to 60 seconds. This time period gives the game server time to update its status to <code>UTILIZED</code> after players join. If the game server's status is not updated within 60 seconds, the game server reverts to unclaimed status and is available to be claimed by another request. The claim time period is a fixed value and is not configurable.</p>
/// <p>If you try to claim a specific game server, this request will fail in the following cases:</p>
/// <ul>
/// <li>
/// <p>If the game server utilization status is <code>UTILIZED</code>.</p></li>
/// <li>
/// <p>If the game server claim status is <code>CLAIMED</code>.</p></li>
/// <li>
/// <p>If the game server is running on an instance in <code>DRAINING</code> status and the provided filter option does not allow placing on <code>DRAINING</code> instances.</p></li>
/// </ul>
/// <p><b>Learn more</b></p>
/// <p><a href="https://docs.aws.amazon.com/gamelift/latest/fleetiqguide/gsg-intro.html">Amazon GameLift FleetIQ Guide</a></p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct ClaimGameServerFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::claim_game_server::builders::ClaimGameServerInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::claim_game_server::ClaimGameServerOutput,
        crate::operation::claim_game_server::ClaimGameServerError,
    > for ClaimGameServerFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::claim_game_server::ClaimGameServerOutput,
            crate::operation::claim_game_server::ClaimGameServerError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl ClaimGameServerFluentBuilder {
    /// Creates a new `ClaimGameServer`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the ClaimGameServer as a reference.
    pub fn as_input(&self) -> &crate::operation::claim_game_server::builders::ClaimGameServerInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::claim_game_server::ClaimGameServerOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::claim_game_server::ClaimGameServerError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::claim_game_server::ClaimGameServer::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::claim_game_server::ClaimGameServer::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::claim_game_server::ClaimGameServerOutput,
        crate::operation::claim_game_server::ClaimGameServerError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A unique identifier for the game server group where the game server is running. If you are not specifying a game server to claim, this value identifies where you want Amazon GameLift FleetIQ to look for an available game server to claim.</p>
    pub fn game_server_group_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.game_server_group_name(input.into());
        self
    }
    /// <p>A unique identifier for the game server group where the game server is running. If you are not specifying a game server to claim, this value identifies where you want Amazon GameLift FleetIQ to look for an available game server to claim.</p>
    pub fn set_game_server_group_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_game_server_group_name(input);
        self
    }
    /// <p>A unique identifier for the game server group where the game server is running. If you are not specifying a game server to claim, this value identifies where you want Amazon GameLift FleetIQ to look for an available game server to claim.</p>
    pub fn get_game_server_group_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_game_server_group_name()
    }
    /// <p>A custom string that uniquely identifies the game server to claim. If this parameter is left empty, Amazon GameLift FleetIQ searches for an available game server in the specified game server group.</p>
    pub fn game_server_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.game_server_id(input.into());
        self
    }
    /// <p>A custom string that uniquely identifies the game server to claim. If this parameter is left empty, Amazon GameLift FleetIQ searches for an available game server in the specified game server group.</p>
    pub fn set_game_server_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_game_server_id(input);
        self
    }
    /// <p>A custom string that uniquely identifies the game server to claim. If this parameter is left empty, Amazon GameLift FleetIQ searches for an available game server in the specified game server group.</p>
    pub fn get_game_server_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_game_server_id()
    }
    /// <p>A set of custom game server properties, formatted as a single string value. This data is passed to a game client or service when it requests information on game servers.</p>
    pub fn game_server_data(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.game_server_data(input.into());
        self
    }
    /// <p>A set of custom game server properties, formatted as a single string value. This data is passed to a game client or service when it requests information on game servers.</p>
    pub fn set_game_server_data(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_game_server_data(input);
        self
    }
    /// <p>A set of custom game server properties, formatted as a single string value. This data is passed to a game client or service when it requests information on game servers.</p>
    pub fn get_game_server_data(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_game_server_data()
    }
    /// <p>Object that restricts how a claimed game server is chosen.</p>
    pub fn filter_option(mut self, input: crate::types::ClaimFilterOption) -> Self {
        self.inner = self.inner.filter_option(input);
        self
    }
    /// <p>Object that restricts how a claimed game server is chosen.</p>
    pub fn set_filter_option(mut self, input: ::std::option::Option<crate::types::ClaimFilterOption>) -> Self {
        self.inner = self.inner.set_filter_option(input);
        self
    }
    /// <p>Object that restricts how a claimed game server is chosen.</p>
    pub fn get_filter_option(&self) -> &::std::option::Option<crate::types::ClaimFilterOption> {
        self.inner.get_filter_option()
    }
}
