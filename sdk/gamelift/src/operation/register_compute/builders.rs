// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::register_compute::_register_compute_output::RegisterComputeOutputBuilder;

pub use crate::operation::register_compute::_register_compute_input::RegisterComputeInputBuilder;

impl RegisterComputeInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::register_compute::RegisterComputeOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::register_compute::RegisterComputeError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.register_compute();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `RegisterCompute`.
///
/// <p>Registers a compute resource to an Amazon GameLift Anywhere fleet. With Anywhere fleets you can incorporate your own computing hardware into an Amazon GameLift game hosting solution.</p>
/// <p>To register a compute to a fleet, give the compute a name (must be unique within the fleet) and specify the compute resource's DNS name or IP address. Provide the Anywhere fleet ID and a fleet location to associate with the compute being registered. You can optionally include the path to a TLS certificate on the compute resource.</p>
/// <p>If successful, this operation returns the compute details, including an Amazon GameLift SDK endpoint. Game server processes that run on the compute use this endpoint to communicate with the Amazon GameLift service. Each server process includes the SDK endpoint in its call to the Amazon GameLift server SDK action <code>InitSDK()</code>.</p>
/// <p><b>Learn more</b></p>
/// <ul>
/// <li>
/// <p><a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/fleets-creating-anywhere.html">Create an Anywhere fleet</a></p></li>
/// <li>
/// <p><a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/integration-testing.html">Test your integration</a></p></li>
/// <li>
/// <p><a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk.html">Server SDK reference guides</a> (for version 5.x)</p></li>
/// </ul>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct RegisterComputeFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::register_compute::builders::RegisterComputeInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::register_compute::RegisterComputeOutput,
        crate::operation::register_compute::RegisterComputeError,
    > for RegisterComputeFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::register_compute::RegisterComputeOutput,
            crate::operation::register_compute::RegisterComputeError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl RegisterComputeFluentBuilder {
    /// Creates a new `RegisterCompute`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the RegisterCompute as a reference.
    pub fn as_input(&self) -> &crate::operation::register_compute::builders::RegisterComputeInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::register_compute::RegisterComputeOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::register_compute::RegisterComputeError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::register_compute::RegisterCompute::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::register_compute::RegisterCompute::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::register_compute::RegisterComputeOutput,
        crate::operation::register_compute::RegisterComputeError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A unique identifier for the fleet to register the compute to. You can use either the fleet ID or ARN value.</p>
    pub fn fleet_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.fleet_id(input.into());
        self
    }
    /// <p>A unique identifier for the fleet to register the compute to. You can use either the fleet ID or ARN value.</p>
    pub fn set_fleet_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_fleet_id(input);
        self
    }
    /// <p>A unique identifier for the fleet to register the compute to. You can use either the fleet ID or ARN value.</p>
    pub fn get_fleet_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_fleet_id()
    }
    /// <p>A descriptive label for the compute resource.</p>
    pub fn compute_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.compute_name(input.into());
        self
    }
    /// <p>A descriptive label for the compute resource.</p>
    pub fn set_compute_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_compute_name(input);
        self
    }
    /// <p>A descriptive label for the compute resource.</p>
    pub fn get_compute_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_compute_name()
    }
    /// <p>The path to a TLS certificate on your compute resource. Amazon GameLift doesn't validate the path and certificate.</p>
    pub fn certificate_path(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.certificate_path(input.into());
        self
    }
    /// <p>The path to a TLS certificate on your compute resource. Amazon GameLift doesn't validate the path and certificate.</p>
    pub fn set_certificate_path(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_certificate_path(input);
        self
    }
    /// <p>The path to a TLS certificate on your compute resource. Amazon GameLift doesn't validate the path and certificate.</p>
    pub fn get_certificate_path(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_certificate_path()
    }
    /// <p>The DNS name of the compute resource. Amazon GameLift requires either a DNS name or IP address.</p>
    pub fn dns_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.dns_name(input.into());
        self
    }
    /// <p>The DNS name of the compute resource. Amazon GameLift requires either a DNS name or IP address.</p>
    pub fn set_dns_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_dns_name(input);
        self
    }
    /// <p>The DNS name of the compute resource. Amazon GameLift requires either a DNS name or IP address.</p>
    pub fn get_dns_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_dns_name()
    }
    /// <p>The IP address of the compute resource. Amazon GameLift requires either a DNS name or IP address.</p>
    pub fn ip_address(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.ip_address(input.into());
        self
    }
    /// <p>The IP address of the compute resource. Amazon GameLift requires either a DNS name or IP address.</p>
    pub fn set_ip_address(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_ip_address(input);
        self
    }
    /// <p>The IP address of the compute resource. Amazon GameLift requires either a DNS name or IP address.</p>
    pub fn get_ip_address(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_ip_address()
    }
    /// <p>The name of a custom location to associate with the compute resource being registered.</p>
    pub fn location(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.location(input.into());
        self
    }
    /// <p>The name of a custom location to associate with the compute resource being registered.</p>
    pub fn set_location(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_location(input);
        self
    }
    /// <p>The name of a custom location to associate with the compute resource being registered.</p>
    pub fn get_location(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_location()
    }
}
