// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::terminate_game_session::_terminate_game_session_input::TerminateGameSessionInputBuilder;

pub use crate::operation::terminate_game_session::_terminate_game_session_output::TerminateGameSessionOutputBuilder;

impl crate::operation::terminate_game_session::builders::TerminateGameSessionInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::terminate_game_session::TerminateGameSessionOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::terminate_game_session::TerminateGameSessionError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.terminate_game_session();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `TerminateGameSession`.
///
/// <p><b>This API works with the following fleet types:</b> EC2, Anywhere, Container</p>
/// <p>Ends a game session that's currently in progress. Use this action to terminate any game session that isn't in <code>ERROR</code> status. Terminating a game session is the most efficient way to free up a server process when it's hosting a game session that's in a bad state or not ending properly. You can use this action to terminate a game session that's being hosted on any type of Amazon GameLift Servers fleet compute, including computes for managed EC2, managed container, and Anywhere fleets. The game server must be integrated with Amazon GameLift Servers server SDK 5.x or greater.</p>
/// <p><b>Request options</b></p>
/// <p>Request termination for a single game session. Provide the game session ID and the termination mode. There are two potential methods for terminating a game session:</p>
/// <ul>
/// <li>
/// <p>Initiate a graceful termination using the normal game session shutdown sequence. With this mode, the Amazon GameLift Servers service prompts the server process that's hosting the game session by calling the server SDK callback method <code>OnProcessTerminate()</code>. The callback implementation is part of the custom game server code. It might involve a variety of actions to gracefully end a game session, such as notifying players, before stopping the server process.</p></li>
/// <li>
/// <p>Force an immediate game session termination. With this mode, the Amazon GameLift Servers service takes action to stop the server process, which ends the game session without the normal game session shutdown sequence.</p></li>
/// </ul>
/// <p><b>Results</b></p>
/// <p>If successful, game session termination is initiated. During this activity, the game session status is changed to <code>TERMINATING</code>. When completed, the server process that was hosting the game session has been stopped and replaced with a new server process that's ready to host a new game session. The old game session's status is changed to <code>TERMINATED</code> with a status reason that indicates the termination method used.</p>
/// <p><b>Learn more</b></p>
/// <p><a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html">Add Amazon GameLift Servers to your game server</a></p>
/// <p>Amazon GameLift Servers server SDK 5 reference guide for <code>OnProcessTerminate()</code> (<a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/integration-server-sdk5-cpp-initsdk.html">C++</a>) (<a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/integration-server-sdk5-csharp-initsdk.html">C#</a>) (<a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/integration-server-sdk5-unreal-initsdk.html">Unreal</a>) (<a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/integration-server-sdk-go-initsdk.html">Go</a>)</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct TerminateGameSessionFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::terminate_game_session::builders::TerminateGameSessionInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::terminate_game_session::TerminateGameSessionOutput,
        crate::operation::terminate_game_session::TerminateGameSessionError,
    > for TerminateGameSessionFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::terminate_game_session::TerminateGameSessionOutput,
            crate::operation::terminate_game_session::TerminateGameSessionError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl TerminateGameSessionFluentBuilder {
    /// Creates a new `TerminateGameSessionFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the TerminateGameSession as a reference.
    pub fn as_input(&self) -> &crate::operation::terminate_game_session::builders::TerminateGameSessionInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::terminate_game_session::TerminateGameSessionOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::terminate_game_session::TerminateGameSessionError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::terminate_game_session::TerminateGameSession::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::terminate_game_session::TerminateGameSession::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::terminate_game_session::TerminateGameSessionOutput,
        crate::operation::terminate_game_session::TerminateGameSessionError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A unique identifier for the game session to be terminated. A game session ARN has the following format: <code>arn:aws:gamelift:<location>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </location></code>.</p>
    pub fn game_session_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.game_session_id(input.into());
        self
    }
    /// <p>A unique identifier for the game session to be terminated. A game session ARN has the following format: <code>arn:aws:gamelift:<location>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </location></code>.</p>
    pub fn set_game_session_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_game_session_id(input);
        self
    }
    /// <p>A unique identifier for the game session to be terminated. A game session ARN has the following format: <code>arn:aws:gamelift:<location>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </location></code>.</p>
    pub fn get_game_session_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_game_session_id()
    }
    /// <p>The method to use to terminate the game session. Available methods include:</p>
    /// <ul>
    /// <li>
    /// <p><code>TRIGGER_ON_PROCESS_TERMINATE</code> – Prompts the Amazon GameLift Servers service to send an <code>OnProcessTerminate()</code> callback to the server process and initiate the normal game session shutdown sequence. The <code>OnProcessTerminate</code> method, which is implemented in the game server code, must include a call to the server SDK action <code>ProcessEnding()</code>, which is how the server process signals to Amazon GameLift Servers that a game session is ending. If the server process doesn't call <code>ProcessEnding()</code>, the game session termination won't conclude successfully.</p></li>
    /// <li>
    /// <p><code>FORCE_TERMINATE</code> – Prompts the Amazon GameLift Servers service to stop the server process immediately. Amazon GameLift Servers takes action (depending on the type of fleet) to shut down the server process without the normal game session shutdown sequence.</p><note>
    /// <p>This method is not available for game sessions that are running on Anywhere fleets unless the fleet is deployed with the Amazon GameLift Servers Agent. In this scenario, a force terminate request results in an invalid or bad request exception.</p>
    /// </note></li>
    /// </ul>
    pub fn termination_mode(mut self, input: crate::types::TerminationMode) -> Self {
        self.inner = self.inner.termination_mode(input);
        self
    }
    /// <p>The method to use to terminate the game session. Available methods include:</p>
    /// <ul>
    /// <li>
    /// <p><code>TRIGGER_ON_PROCESS_TERMINATE</code> – Prompts the Amazon GameLift Servers service to send an <code>OnProcessTerminate()</code> callback to the server process and initiate the normal game session shutdown sequence. The <code>OnProcessTerminate</code> method, which is implemented in the game server code, must include a call to the server SDK action <code>ProcessEnding()</code>, which is how the server process signals to Amazon GameLift Servers that a game session is ending. If the server process doesn't call <code>ProcessEnding()</code>, the game session termination won't conclude successfully.</p></li>
    /// <li>
    /// <p><code>FORCE_TERMINATE</code> – Prompts the Amazon GameLift Servers service to stop the server process immediately. Amazon GameLift Servers takes action (depending on the type of fleet) to shut down the server process without the normal game session shutdown sequence.</p><note>
    /// <p>This method is not available for game sessions that are running on Anywhere fleets unless the fleet is deployed with the Amazon GameLift Servers Agent. In this scenario, a force terminate request results in an invalid or bad request exception.</p>
    /// </note></li>
    /// </ul>
    pub fn set_termination_mode(mut self, input: ::std::option::Option<crate::types::TerminationMode>) -> Self {
        self.inner = self.inner.set_termination_mode(input);
        self
    }
    /// <p>The method to use to terminate the game session. Available methods include:</p>
    /// <ul>
    /// <li>
    /// <p><code>TRIGGER_ON_PROCESS_TERMINATE</code> – Prompts the Amazon GameLift Servers service to send an <code>OnProcessTerminate()</code> callback to the server process and initiate the normal game session shutdown sequence. The <code>OnProcessTerminate</code> method, which is implemented in the game server code, must include a call to the server SDK action <code>ProcessEnding()</code>, which is how the server process signals to Amazon GameLift Servers that a game session is ending. If the server process doesn't call <code>ProcessEnding()</code>, the game session termination won't conclude successfully.</p></li>
    /// <li>
    /// <p><code>FORCE_TERMINATE</code> – Prompts the Amazon GameLift Servers service to stop the server process immediately. Amazon GameLift Servers takes action (depending on the type of fleet) to shut down the server process without the normal game session shutdown sequence.</p><note>
    /// <p>This method is not available for game sessions that are running on Anywhere fleets unless the fleet is deployed with the Amazon GameLift Servers Agent. In this scenario, a force terminate request results in an invalid or bad request exception.</p>
    /// </note></li>
    /// </ul>
    pub fn get_termination_mode(&self) -> &::std::option::Option<crate::types::TerminationMode> {
        self.inner.get_termination_mode()
    }
}
