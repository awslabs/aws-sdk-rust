// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateMatchmakingConfigurationInput  {
    /// <p>A unique identifier for the matchmaking configuration. This name is used to identify the configuration associated with a matchmaking request or ticket.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A human-readable description of the matchmaking configuration. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) that is assigned to a GameLift game session queue resource and uniquely identifies it. ARNs are unique across all Regions. Format is <code>arn:aws:gamelift:
    /// <region>
    /// ::gamesessionqueue/
    /// <queue name></queue>
    /// </region></code>. Queues can be located in any Region. Queues are used to start new GameLift-hosted game sessions for matches that are created with this matchmaking configuration. If <code>FlexMatchMode</code> is set to <code>STANDALONE</code>, do not set this parameter. </p>
    #[doc(hidden)]
    pub game_session_queue_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out. Requests that fail due to timing out can be resubmitted as needed.</p>
    #[doc(hidden)]
    pub request_timeout_seconds: std::option::Option<i32>,
    /// <p>The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required. </p>
    #[doc(hidden)]
    pub acceptance_timeout_seconds: std::option::Option<i32>,
    /// <p>A flag that determines whether a match that was created with this configuration must be accepted by the matched players. To require acceptance, set to <code>TRUE</code>. With this option enabled, matchmaking tickets use the status <code>REQUIRES_ACCEPTANCE</code> to indicate when a completed potential match is waiting for player acceptance. </p>
    #[doc(hidden)]
    pub acceptance_required: std::option::Option<bool>,
    /// <p>A unique identifier for the matchmaking rule set to use with this configuration. You can use either the rule set name or ARN value. A matchmaking configuration can only use rule sets that are defined in the same Region.</p>
    #[doc(hidden)]
    pub rule_set_name: std::option::Option<std::string::String>,
    /// <p>An SNS topic ARN that is set up to receive matchmaking notifications. See <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-notification.html"> Setting up notifications for matchmaking</a> for more information.</p>
    #[doc(hidden)]
    pub notification_target: std::option::Option<std::string::String>,
    /// <p>The number of player slots in a match to keep open for future players. For example, if the configuration's rule set specifies a match for a single 12-person team, and the additional player count is set to 2, only 10 players are selected for the match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    #[doc(hidden)]
    pub additional_player_count: std::option::Option<i32>,
    /// <p>Information to be added to all events related to this matchmaking configuration. </p>
    #[doc(hidden)]
    pub custom_event_data: std::option::Option<std::string::String>,
    /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <code>GameSession</code> object that is created for a successful match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    #[doc(hidden)]
    pub game_properties: std::option::Option<std::vec::Vec<crate::types::GameProperty>>,
    /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <code>GameSession</code> object that is created for a successful match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    #[doc(hidden)]
    pub game_session_data: std::option::Option<std::string::String>,
    /// <p>The method used to backfill game sessions that are created with this matchmaking configuration. Specify <code>MANUAL</code> when your game manages backfill requests manually or does not use the match backfill feature. Specify <code>AUTOMATIC</code> to have GameLift create a backfill request whenever a game session has one or more open slots. Learn more about manual and automatic backfill in <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-backfill.html"> Backfill Existing Games with FlexMatch</a>. Automatic backfill is not available when <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    #[doc(hidden)]
    pub backfill_mode: std::option::Option<crate::types::BackfillMode>,
    /// <p>Indicates whether this matchmaking configuration is being used with GameLift hosting or as a standalone matchmaking solution. </p> 
    /// <ul> 
    /// <li> <p> <b>STANDALONE</b> - FlexMatch forms matches and returns match information, including players and team assignments, in a <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-events.html#match-events-matchmakingsucceeded"> MatchmakingSucceeded</a> event.</p> </li> 
    /// <li> <p> <b>WITH_QUEUE</b> - FlexMatch forms matches and uses the specified GameLift queue to start a game session for the match. </p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub flex_match_mode: std::option::Option<crate::types::FlexMatchMode>,
    /// <p>A list of labels to assign to the new matchmaking configuration resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
}
impl CreateMatchmakingConfigurationInput {
    /// <p>A unique identifier for the matchmaking configuration. This name is used to identify the configuration associated with a matchmaking request or ticket.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A human-readable description of the matchmaking configuration. </p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) that is assigned to a GameLift game session queue resource and uniquely identifies it. ARNs are unique across all Regions. Format is <code>arn:aws:gamelift:
    /// <region>
    /// ::gamesessionqueue/
    /// <queue name></queue>
    /// </region></code>. Queues can be located in any Region. Queues are used to start new GameLift-hosted game sessions for matches that are created with this matchmaking configuration. If <code>FlexMatchMode</code> is set to <code>STANDALONE</code>, do not set this parameter. </p>
    pub fn game_session_queue_arns(&self) -> std::option::Option<& [std::string::String]> {
        self.game_session_queue_arns.as_deref()
    }
    /// <p>The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out. Requests that fail due to timing out can be resubmitted as needed.</p>
    pub fn request_timeout_seconds(&self) -> std::option::Option<i32> {
        self.request_timeout_seconds
    }
    /// <p>The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required. </p>
    pub fn acceptance_timeout_seconds(&self) -> std::option::Option<i32> {
        self.acceptance_timeout_seconds
    }
    /// <p>A flag that determines whether a match that was created with this configuration must be accepted by the matched players. To require acceptance, set to <code>TRUE</code>. With this option enabled, matchmaking tickets use the status <code>REQUIRES_ACCEPTANCE</code> to indicate when a completed potential match is waiting for player acceptance. </p>
    pub fn acceptance_required(&self) -> std::option::Option<bool> {
        self.acceptance_required
    }
    /// <p>A unique identifier for the matchmaking rule set to use with this configuration. You can use either the rule set name or ARN value. A matchmaking configuration can only use rule sets that are defined in the same Region.</p>
    pub fn rule_set_name(&self) -> std::option::Option<& str> {
        self.rule_set_name.as_deref()
    }
    /// <p>An SNS topic ARN that is set up to receive matchmaking notifications. See <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-notification.html"> Setting up notifications for matchmaking</a> for more information.</p>
    pub fn notification_target(&self) -> std::option::Option<& str> {
        self.notification_target.as_deref()
    }
    /// <p>The number of player slots in a match to keep open for future players. For example, if the configuration's rule set specifies a match for a single 12-person team, and the additional player count is set to 2, only 10 players are selected for the match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn additional_player_count(&self) -> std::option::Option<i32> {
        self.additional_player_count
    }
    /// <p>Information to be added to all events related to this matchmaking configuration. </p>
    pub fn custom_event_data(&self) -> std::option::Option<& str> {
        self.custom_event_data.as_deref()
    }
    /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <code>GameSession</code> object that is created for a successful match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn game_properties(&self) -> std::option::Option<& [crate::types::GameProperty]> {
        self.game_properties.as_deref()
    }
    /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <code>GameSession</code> object that is created for a successful match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn game_session_data(&self) -> std::option::Option<& str> {
        self.game_session_data.as_deref()
    }
    /// <p>The method used to backfill game sessions that are created with this matchmaking configuration. Specify <code>MANUAL</code> when your game manages backfill requests manually or does not use the match backfill feature. Specify <code>AUTOMATIC</code> to have GameLift create a backfill request whenever a game session has one or more open slots. Learn more about manual and automatic backfill in <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-backfill.html"> Backfill Existing Games with FlexMatch</a>. Automatic backfill is not available when <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn backfill_mode(&self) -> std::option::Option<& crate::types::BackfillMode> {
        self.backfill_mode.as_ref()
    }
    /// <p>Indicates whether this matchmaking configuration is being used with GameLift hosting or as a standalone matchmaking solution. </p> 
    /// <ul> 
    /// <li> <p> <b>STANDALONE</b> - FlexMatch forms matches and returns match information, including players and team assignments, in a <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-events.html#match-events-matchmakingsucceeded"> MatchmakingSucceeded</a> event.</p> </li> 
    /// <li> <p> <b>WITH_QUEUE</b> - FlexMatch forms matches and uses the specified GameLift queue to start a game session for the match. </p> </li> 
    /// </ul>
    pub fn flex_match_mode(&self) -> std::option::Option<& crate::types::FlexMatchMode> {
        self.flex_match_mode.as_ref()
    }
    /// <p>A list of labels to assign to the new matchmaking configuration resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::types::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateMatchmakingConfigurationInput {
    /// Creates a new builder-style object to manufacture [`CreateMatchmakingConfigurationInput`](crate::operation::create_matchmaking_configuration::CreateMatchmakingConfigurationInput).
    pub fn builder() -> crate::operation::create_matchmaking_configuration::builders::CreateMatchmakingConfigurationInputBuilder {
        crate::operation::create_matchmaking_configuration::builders::CreateMatchmakingConfigurationInputBuilder::default()
    }
}

/// A builder for [`CreateMatchmakingConfigurationInput`](crate::operation::create_matchmaking_configuration::CreateMatchmakingConfigurationInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct CreateMatchmakingConfigurationInputBuilder {
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) description: std::option::Option<std::string::String>,
    pub(crate) game_session_queue_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) request_timeout_seconds: std::option::Option<i32>,
    pub(crate) acceptance_timeout_seconds: std::option::Option<i32>,
    pub(crate) acceptance_required: std::option::Option<bool>,
    pub(crate) rule_set_name: std::option::Option<std::string::String>,
    pub(crate) notification_target: std::option::Option<std::string::String>,
    pub(crate) additional_player_count: std::option::Option<i32>,
    pub(crate) custom_event_data: std::option::Option<std::string::String>,
    pub(crate) game_properties: std::option::Option<std::vec::Vec<crate::types::GameProperty>>,
    pub(crate) game_session_data: std::option::Option<std::string::String>,
    pub(crate) backfill_mode: std::option::Option<crate::types::BackfillMode>,
    pub(crate) flex_match_mode: std::option::Option<crate::types::FlexMatchMode>,
    pub(crate) tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
}
impl CreateMatchmakingConfigurationInputBuilder {
    /// <p>A unique identifier for the matchmaking configuration. This name is used to identify the configuration associated with a matchmaking request or ticket.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>A unique identifier for the matchmaking configuration. This name is used to identify the configuration associated with a matchmaking request or ticket.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input; self
    }
    /// <p>A human-readable description of the matchmaking configuration. </p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>A human-readable description of the matchmaking configuration. </p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input; self
    }
    /// Appends an item to `game_session_queue_arns`.
    ///
    /// To override the contents of this collection use [`set_game_session_queue_arns`](Self::set_game_session_queue_arns).
    ///
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) that is assigned to a GameLift game session queue resource and uniquely identifies it. ARNs are unique across all Regions. Format is <code>arn:aws:gamelift:
    /// <region>
    /// ::gamesessionqueue/
    /// <queue name></queue>
    /// </region></code>. Queues can be located in any Region. Queues are used to start new GameLift-hosted game sessions for matches that are created with this matchmaking configuration. If <code>FlexMatchMode</code> is set to <code>STANDALONE</code>, do not set this parameter. </p>
    pub fn game_session_queue_arns(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.game_session_queue_arns.unwrap_or_default();
                        v.push(input.into());
                        self.game_session_queue_arns = Some(v);
                        self
    }
    /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) that is assigned to a GameLift game session queue resource and uniquely identifies it. ARNs are unique across all Regions. Format is <code>arn:aws:gamelift:
    /// <region>
    /// ::gamesessionqueue/
    /// <queue name></queue>
    /// </region></code>. Queues can be located in any Region. Queues are used to start new GameLift-hosted game sessions for matches that are created with this matchmaking configuration. If <code>FlexMatchMode</code> is set to <code>STANDALONE</code>, do not set this parameter. </p>
    pub fn set_game_session_queue_arns(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
        self.game_session_queue_arns = input; self
    }
    /// <p>The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out. Requests that fail due to timing out can be resubmitted as needed.</p>
    pub fn request_timeout_seconds(mut self, input: i32) -> Self {
        self.request_timeout_seconds = Some(input);
        self
    }
    /// <p>The maximum duration, in seconds, that a matchmaking ticket can remain in process before timing out. Requests that fail due to timing out can be resubmitted as needed.</p>
    pub fn set_request_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
        self.request_timeout_seconds = input; self
    }
    /// <p>The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required. </p>
    pub fn acceptance_timeout_seconds(mut self, input: i32) -> Self {
        self.acceptance_timeout_seconds = Some(input);
        self
    }
    /// <p>The length of time (in seconds) to wait for players to accept a proposed match, if acceptance is required. </p>
    pub fn set_acceptance_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
        self.acceptance_timeout_seconds = input; self
    }
    /// <p>A flag that determines whether a match that was created with this configuration must be accepted by the matched players. To require acceptance, set to <code>TRUE</code>. With this option enabled, matchmaking tickets use the status <code>REQUIRES_ACCEPTANCE</code> to indicate when a completed potential match is waiting for player acceptance. </p>
    pub fn acceptance_required(mut self, input: bool) -> Self {
        self.acceptance_required = Some(input);
        self
    }
    /// <p>A flag that determines whether a match that was created with this configuration must be accepted by the matched players. To require acceptance, set to <code>TRUE</code>. With this option enabled, matchmaking tickets use the status <code>REQUIRES_ACCEPTANCE</code> to indicate when a completed potential match is waiting for player acceptance. </p>
    pub fn set_acceptance_required(mut self, input: std::option::Option<bool>) -> Self {
        self.acceptance_required = input; self
    }
    /// <p>A unique identifier for the matchmaking rule set to use with this configuration. You can use either the rule set name or ARN value. A matchmaking configuration can only use rule sets that are defined in the same Region.</p>
    pub fn rule_set_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.rule_set_name = Some(input.into());
        self
    }
    /// <p>A unique identifier for the matchmaking rule set to use with this configuration. You can use either the rule set name or ARN value. A matchmaking configuration can only use rule sets that are defined in the same Region.</p>
    pub fn set_rule_set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.rule_set_name = input; self
    }
    /// <p>An SNS topic ARN that is set up to receive matchmaking notifications. See <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-notification.html"> Setting up notifications for matchmaking</a> for more information.</p>
    pub fn notification_target(mut self, input: impl Into<std::string::String>) -> Self {
        self.notification_target = Some(input.into());
        self
    }
    /// <p>An SNS topic ARN that is set up to receive matchmaking notifications. See <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-notification.html"> Setting up notifications for matchmaking</a> for more information.</p>
    pub fn set_notification_target(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.notification_target = input; self
    }
    /// <p>The number of player slots in a match to keep open for future players. For example, if the configuration's rule set specifies a match for a single 12-person team, and the additional player count is set to 2, only 10 players are selected for the match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn additional_player_count(mut self, input: i32) -> Self {
        self.additional_player_count = Some(input);
        self
    }
    /// <p>The number of player slots in a match to keep open for future players. For example, if the configuration's rule set specifies a match for a single 12-person team, and the additional player count is set to 2, only 10 players are selected for the match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn set_additional_player_count(mut self, input: std::option::Option<i32>) -> Self {
        self.additional_player_count = input; self
    }
    /// <p>Information to be added to all events related to this matchmaking configuration. </p>
    pub fn custom_event_data(mut self, input: impl Into<std::string::String>) -> Self {
        self.custom_event_data = Some(input.into());
        self
    }
    /// <p>Information to be added to all events related to this matchmaking configuration. </p>
    pub fn set_custom_event_data(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.custom_event_data = input; self
    }
    /// Appends an item to `game_properties`.
    ///
    /// To override the contents of this collection use [`set_game_properties`](Self::set_game_properties).
    ///
    /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <code>GameSession</code> object that is created for a successful match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn game_properties(mut self, input: crate::types::GameProperty) -> Self {
        let mut v = self.game_properties.unwrap_or_default();
                        v.push(input);
                        self.game_properties = Some(v);
                        self
    }
    /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <code>GameSession</code> object that is created for a successful match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn set_game_properties(mut self, input: std::option::Option<std::vec::Vec<crate::types::GameProperty>>) -> Self {
        self.game_properties = input; self
    }
    /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <code>GameSession</code> object that is created for a successful match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn game_session_data(mut self, input: impl Into<std::string::String>) -> Self {
        self.game_session_data = Some(input.into());
        self
    }
    /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <code>GameSession</code> object that is created for a successful match. This parameter is not used if <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn set_game_session_data(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.game_session_data = input; self
    }
    /// <p>The method used to backfill game sessions that are created with this matchmaking configuration. Specify <code>MANUAL</code> when your game manages backfill requests manually or does not use the match backfill feature. Specify <code>AUTOMATIC</code> to have GameLift create a backfill request whenever a game session has one or more open slots. Learn more about manual and automatic backfill in <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-backfill.html"> Backfill Existing Games with FlexMatch</a>. Automatic backfill is not available when <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn backfill_mode(mut self, input: crate::types::BackfillMode) -> Self {
        self.backfill_mode = Some(input);
        self
    }
    /// <p>The method used to backfill game sessions that are created with this matchmaking configuration. Specify <code>MANUAL</code> when your game manages backfill requests manually or does not use the match backfill feature. Specify <code>AUTOMATIC</code> to have GameLift create a backfill request whenever a game session has one or more open slots. Learn more about manual and automatic backfill in <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-backfill.html"> Backfill Existing Games with FlexMatch</a>. Automatic backfill is not available when <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
    pub fn set_backfill_mode(mut self, input: std::option::Option<crate::types::BackfillMode>) -> Self {
        self.backfill_mode = input; self
    }
    /// <p>Indicates whether this matchmaking configuration is being used with GameLift hosting or as a standalone matchmaking solution. </p> 
    /// <ul> 
    /// <li> <p> <b>STANDALONE</b> - FlexMatch forms matches and returns match information, including players and team assignments, in a <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-events.html#match-events-matchmakingsucceeded"> MatchmakingSucceeded</a> event.</p> </li> 
    /// <li> <p> <b>WITH_QUEUE</b> - FlexMatch forms matches and uses the specified GameLift queue to start a game session for the match. </p> </li> 
    /// </ul>
    pub fn flex_match_mode(mut self, input: crate::types::FlexMatchMode) -> Self {
        self.flex_match_mode = Some(input);
        self
    }
    /// <p>Indicates whether this matchmaking configuration is being used with GameLift hosting or as a standalone matchmaking solution. </p> 
    /// <ul> 
    /// <li> <p> <b>STANDALONE</b> - FlexMatch forms matches and returns match information, including players and team assignments, in a <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-events.html#match-events-matchmakingsucceeded"> MatchmakingSucceeded</a> event.</p> </li> 
    /// <li> <p> <b>WITH_QUEUE</b> - FlexMatch forms matches and uses the specified GameLift queue to start a game session for the match. </p> </li> 
    /// </ul>
    pub fn set_flex_match_mode(mut self, input: std::option::Option<crate::types::FlexMatchMode>) -> Self {
        self.flex_match_mode = input; self
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of labels to assign to the new matchmaking configuration resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
                        v.push(input);
                        self.tags = Some(v);
                        self
    }
    /// <p>A list of labels to assign to the new matchmaking configuration resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input; self
    }
    /// Consumes the builder and constructs a [`CreateMatchmakingConfigurationInput`](crate::operation::create_matchmaking_configuration::CreateMatchmakingConfigurationInput).
    pub fn build(self) -> Result<crate::operation::create_matchmaking_configuration::CreateMatchmakingConfigurationInput, aws_smithy_http::operation::error::BuildError> {
        Ok(
            crate::operation::create_matchmaking_configuration::CreateMatchmakingConfigurationInput {
                name: self.name
                ,
                description: self.description
                ,
                game_session_queue_arns: self.game_session_queue_arns
                ,
                request_timeout_seconds: self.request_timeout_seconds
                ,
                acceptance_timeout_seconds: self.acceptance_timeout_seconds
                ,
                acceptance_required: self.acceptance_required
                ,
                rule_set_name: self.rule_set_name
                ,
                notification_target: self.notification_target
                ,
                additional_player_count: self.additional_player_count
                ,
                custom_event_data: self.custom_event_data
                ,
                game_properties: self.game_properties
                ,
                game_session_data: self.game_session_data
                ,
                backfill_mode: self.backfill_mode
                ,
                flex_match_mode: self.flex_match_mode
                ,
                tags: self.tags
                ,
            }
        )
    }
}

