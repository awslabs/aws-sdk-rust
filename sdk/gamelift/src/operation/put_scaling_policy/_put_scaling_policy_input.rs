// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutScalingPolicyInput {
    /// <p>A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique. A fleet can have only one scaling policy with the same name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the fleet to apply this policy to. You can use either the fleet ID or ARN value. The fleet cannot be in any of the following statuses: ERROR or DELETING.</p>
    #[doc(hidden)]
    pub fleet_id: std::option::Option<std::string::String>,
    /// <p>Amount of adjustment to make, based on the scaling adjustment type.</p>
    #[doc(hidden)]
    pub scaling_adjustment: i32,
    /// <p>The type of adjustment to make to a fleet's instance count:</p>
    /// <ul>
    /// <li> <p> <b>ChangeInCapacity</b> -- add (or subtract) the scaling adjustment value from the current instance count. Positive values scale up while negative values scale down.</p> </li>
    /// <li> <p> <b>ExactCapacity</b> -- set the instance count to the scaling adjustment value.</p> </li>
    /// <li> <p> <b>PercentChangeInCapacity</b> -- increase or reduce the current instance count by the scaling adjustment, read as a percentage. Positive values scale up while negative values scale down; for example, a value of "-10" scales the fleet down by 10%.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub scaling_adjustment_type: std::option::Option<crate::types::ScalingAdjustmentType>,
    /// <p>Metric value used to trigger a scaling event.</p>
    #[doc(hidden)]
    pub threshold: f64,
    /// <p>Comparison operator to use when measuring the metric against the threshold value.</p>
    #[doc(hidden)]
    pub comparison_operator: std::option::Option<crate::types::ComparisonOperatorType>,
    /// <p>Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.</p>
    #[doc(hidden)]
    pub evaluation_periods: std::option::Option<i32>,
    /// <p>Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment. For detailed descriptions of fleet metrics, see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/monitoring-cloudwatch.html">Monitor Amazon GameLift with Amazon CloudWatch</a>. </p>
    /// <ul>
    /// <li> <p> <b>ActivatingGameSessions</b> -- Game sessions in the process of being created.</p> </li>
    /// <li> <p> <b>ActiveGameSessions</b> -- Game sessions that are currently running.</p> </li>
    /// <li> <p> <b>ActiveInstances</b> -- Fleet instances that are currently running at least one game session.</p> </li>
    /// <li> <p> <b>AvailableGameSessions</b> -- Additional game sessions that fleet could host simultaneously, given current capacity.</p> </li>
    /// <li> <p> <b>AvailablePlayerSessions</b> -- Empty player slots in currently active game sessions. This includes game sessions that are not currently accepting players. Reserved player slots are not included.</p> </li>
    /// <li> <p> <b>CurrentPlayerSessions</b> -- Player slots in active game sessions that are being used by a player or are reserved for a player. </p> </li>
    /// <li> <p> <b>IdleInstances</b> -- Active instances that are currently hosting zero game sessions. </p> </li>
    /// <li> <p> <b>PercentAvailableGameSessions</b> -- Unused percentage of the total number of game sessions that a fleet could host simultaneously, given current capacity. Use this metric for a target-based scaling policy.</p> </li>
    /// <li> <p> <b>PercentIdleInstances</b> -- Percentage of the total number of active instances that are hosting zero game sessions.</p> </li>
    /// <li> <p> <b>QueueDepth</b> -- Pending game session placement requests, in any queue, where the current fleet is the top-priority destination.</p> </li>
    /// <li> <p> <b>WaitTime</b> -- Current wait time for pending game session placement requests, in any queue, where the current fleet is the top-priority destination. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub metric_name: std::option::Option<crate::types::MetricName>,
    /// <p>The type of scaling policy to create. For a target-based policy, set the parameter <i>MetricName</i> to 'PercentAvailableGameSessions' and specify a <i>TargetConfiguration</i>. For a rule-based policy set the following parameters: <i>MetricName</i>, <i>ComparisonOperator</i>, <i>Threshold</i>, <i>EvaluationPeriods</i>, <i>ScalingAdjustmentType</i>, and <i>ScalingAdjustment</i>.</p>
    #[doc(hidden)]
    pub policy_type: std::option::Option<crate::types::PolicyType>,
    /// <p>An object that contains settings for a target-based scaling policy.</p>
    #[doc(hidden)]
    pub target_configuration: std::option::Option<crate::types::TargetConfiguration>,
}
impl PutScalingPolicyInput {
    /// <p>A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique. A fleet can have only one scaling policy with the same name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A unique identifier for the fleet to apply this policy to. You can use either the fleet ID or ARN value. The fleet cannot be in any of the following statuses: ERROR or DELETING.</p>
    pub fn fleet_id(&self) -> std::option::Option<&str> {
        self.fleet_id.as_deref()
    }
    /// <p>Amount of adjustment to make, based on the scaling adjustment type.</p>
    pub fn scaling_adjustment(&self) -> i32 {
        self.scaling_adjustment
    }
    /// <p>The type of adjustment to make to a fleet's instance count:</p>
    /// <ul>
    /// <li> <p> <b>ChangeInCapacity</b> -- add (or subtract) the scaling adjustment value from the current instance count. Positive values scale up while negative values scale down.</p> </li>
    /// <li> <p> <b>ExactCapacity</b> -- set the instance count to the scaling adjustment value.</p> </li>
    /// <li> <p> <b>PercentChangeInCapacity</b> -- increase or reduce the current instance count by the scaling adjustment, read as a percentage. Positive values scale up while negative values scale down; for example, a value of "-10" scales the fleet down by 10%.</p> </li>
    /// </ul>
    pub fn scaling_adjustment_type(
        &self,
    ) -> std::option::Option<&crate::types::ScalingAdjustmentType> {
        self.scaling_adjustment_type.as_ref()
    }
    /// <p>Metric value used to trigger a scaling event.</p>
    pub fn threshold(&self) -> f64 {
        self.threshold
    }
    /// <p>Comparison operator to use when measuring the metric against the threshold value.</p>
    pub fn comparison_operator(
        &self,
    ) -> std::option::Option<&crate::types::ComparisonOperatorType> {
        self.comparison_operator.as_ref()
    }
    /// <p>Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.</p>
    pub fn evaluation_periods(&self) -> std::option::Option<i32> {
        self.evaluation_periods
    }
    /// <p>Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment. For detailed descriptions of fleet metrics, see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/monitoring-cloudwatch.html">Monitor Amazon GameLift with Amazon CloudWatch</a>. </p>
    /// <ul>
    /// <li> <p> <b>ActivatingGameSessions</b> -- Game sessions in the process of being created.</p> </li>
    /// <li> <p> <b>ActiveGameSessions</b> -- Game sessions that are currently running.</p> </li>
    /// <li> <p> <b>ActiveInstances</b> -- Fleet instances that are currently running at least one game session.</p> </li>
    /// <li> <p> <b>AvailableGameSessions</b> -- Additional game sessions that fleet could host simultaneously, given current capacity.</p> </li>
    /// <li> <p> <b>AvailablePlayerSessions</b> -- Empty player slots in currently active game sessions. This includes game sessions that are not currently accepting players. Reserved player slots are not included.</p> </li>
    /// <li> <p> <b>CurrentPlayerSessions</b> -- Player slots in active game sessions that are being used by a player or are reserved for a player. </p> </li>
    /// <li> <p> <b>IdleInstances</b> -- Active instances that are currently hosting zero game sessions. </p> </li>
    /// <li> <p> <b>PercentAvailableGameSessions</b> -- Unused percentage of the total number of game sessions that a fleet could host simultaneously, given current capacity. Use this metric for a target-based scaling policy.</p> </li>
    /// <li> <p> <b>PercentIdleInstances</b> -- Percentage of the total number of active instances that are hosting zero game sessions.</p> </li>
    /// <li> <p> <b>QueueDepth</b> -- Pending game session placement requests, in any queue, where the current fleet is the top-priority destination.</p> </li>
    /// <li> <p> <b>WaitTime</b> -- Current wait time for pending game session placement requests, in any queue, where the current fleet is the top-priority destination. </p> </li>
    /// </ul>
    pub fn metric_name(&self) -> std::option::Option<&crate::types::MetricName> {
        self.metric_name.as_ref()
    }
    /// <p>The type of scaling policy to create. For a target-based policy, set the parameter <i>MetricName</i> to 'PercentAvailableGameSessions' and specify a <i>TargetConfiguration</i>. For a rule-based policy set the following parameters: <i>MetricName</i>, <i>ComparisonOperator</i>, <i>Threshold</i>, <i>EvaluationPeriods</i>, <i>ScalingAdjustmentType</i>, and <i>ScalingAdjustment</i>.</p>
    pub fn policy_type(&self) -> std::option::Option<&crate::types::PolicyType> {
        self.policy_type.as_ref()
    }
    /// <p>An object that contains settings for a target-based scaling policy.</p>
    pub fn target_configuration(&self) -> std::option::Option<&crate::types::TargetConfiguration> {
        self.target_configuration.as_ref()
    }
}
impl PutScalingPolicyInput {
    /// Creates a new builder-style object to manufacture [`PutScalingPolicyInput`](crate::operation::put_scaling_policy::PutScalingPolicyInput).
    pub fn builder() -> crate::operation::put_scaling_policy::builders::PutScalingPolicyInputBuilder
    {
        crate::operation::put_scaling_policy::builders::PutScalingPolicyInputBuilder::default()
    }
}

/// A builder for [`PutScalingPolicyInput`](crate::operation::put_scaling_policy::PutScalingPolicyInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct PutScalingPolicyInputBuilder {
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) fleet_id: std::option::Option<std::string::String>,
    pub(crate) scaling_adjustment: std::option::Option<i32>,
    pub(crate) scaling_adjustment_type: std::option::Option<crate::types::ScalingAdjustmentType>,
    pub(crate) threshold: std::option::Option<f64>,
    pub(crate) comparison_operator: std::option::Option<crate::types::ComparisonOperatorType>,
    pub(crate) evaluation_periods: std::option::Option<i32>,
    pub(crate) metric_name: std::option::Option<crate::types::MetricName>,
    pub(crate) policy_type: std::option::Option<crate::types::PolicyType>,
    pub(crate) target_configuration: std::option::Option<crate::types::TargetConfiguration>,
}
impl PutScalingPolicyInputBuilder {
    /// <p>A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique. A fleet can have only one scaling policy with the same name.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique. A fleet can have only one scaling policy with the same name.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>A unique identifier for the fleet to apply this policy to. You can use either the fleet ID or ARN value. The fleet cannot be in any of the following statuses: ERROR or DELETING.</p>
    pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.fleet_id = Some(input.into());
        self
    }
    /// <p>A unique identifier for the fleet to apply this policy to. You can use either the fleet ID or ARN value. The fleet cannot be in any of the following statuses: ERROR or DELETING.</p>
    pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.fleet_id = input;
        self
    }
    /// <p>Amount of adjustment to make, based on the scaling adjustment type.</p>
    pub fn scaling_adjustment(mut self, input: i32) -> Self {
        self.scaling_adjustment = Some(input);
        self
    }
    /// <p>Amount of adjustment to make, based on the scaling adjustment type.</p>
    pub fn set_scaling_adjustment(mut self, input: std::option::Option<i32>) -> Self {
        self.scaling_adjustment = input;
        self
    }
    /// <p>The type of adjustment to make to a fleet's instance count:</p>
    /// <ul>
    /// <li> <p> <b>ChangeInCapacity</b> -- add (or subtract) the scaling adjustment value from the current instance count. Positive values scale up while negative values scale down.</p> </li>
    /// <li> <p> <b>ExactCapacity</b> -- set the instance count to the scaling adjustment value.</p> </li>
    /// <li> <p> <b>PercentChangeInCapacity</b> -- increase or reduce the current instance count by the scaling adjustment, read as a percentage. Positive values scale up while negative values scale down; for example, a value of "-10" scales the fleet down by 10%.</p> </li>
    /// </ul>
    pub fn scaling_adjustment_type(mut self, input: crate::types::ScalingAdjustmentType) -> Self {
        self.scaling_adjustment_type = Some(input);
        self
    }
    /// <p>The type of adjustment to make to a fleet's instance count:</p>
    /// <ul>
    /// <li> <p> <b>ChangeInCapacity</b> -- add (or subtract) the scaling adjustment value from the current instance count. Positive values scale up while negative values scale down.</p> </li>
    /// <li> <p> <b>ExactCapacity</b> -- set the instance count to the scaling adjustment value.</p> </li>
    /// <li> <p> <b>PercentChangeInCapacity</b> -- increase or reduce the current instance count by the scaling adjustment, read as a percentage. Positive values scale up while negative values scale down; for example, a value of "-10" scales the fleet down by 10%.</p> </li>
    /// </ul>
    pub fn set_scaling_adjustment_type(
        mut self,
        input: std::option::Option<crate::types::ScalingAdjustmentType>,
    ) -> Self {
        self.scaling_adjustment_type = input;
        self
    }
    /// <p>Metric value used to trigger a scaling event.</p>
    pub fn threshold(mut self, input: f64) -> Self {
        self.threshold = Some(input);
        self
    }
    /// <p>Metric value used to trigger a scaling event.</p>
    pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
        self.threshold = input;
        self
    }
    /// <p>Comparison operator to use when measuring the metric against the threshold value.</p>
    pub fn comparison_operator(mut self, input: crate::types::ComparisonOperatorType) -> Self {
        self.comparison_operator = Some(input);
        self
    }
    /// <p>Comparison operator to use when measuring the metric against the threshold value.</p>
    pub fn set_comparison_operator(
        mut self,
        input: std::option::Option<crate::types::ComparisonOperatorType>,
    ) -> Self {
        self.comparison_operator = input;
        self
    }
    /// <p>Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.</p>
    pub fn evaluation_periods(mut self, input: i32) -> Self {
        self.evaluation_periods = Some(input);
        self
    }
    /// <p>Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.</p>
    pub fn set_evaluation_periods(mut self, input: std::option::Option<i32>) -> Self {
        self.evaluation_periods = input;
        self
    }
    /// <p>Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment. For detailed descriptions of fleet metrics, see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/monitoring-cloudwatch.html">Monitor Amazon GameLift with Amazon CloudWatch</a>. </p>
    /// <ul>
    /// <li> <p> <b>ActivatingGameSessions</b> -- Game sessions in the process of being created.</p> </li>
    /// <li> <p> <b>ActiveGameSessions</b> -- Game sessions that are currently running.</p> </li>
    /// <li> <p> <b>ActiveInstances</b> -- Fleet instances that are currently running at least one game session.</p> </li>
    /// <li> <p> <b>AvailableGameSessions</b> -- Additional game sessions that fleet could host simultaneously, given current capacity.</p> </li>
    /// <li> <p> <b>AvailablePlayerSessions</b> -- Empty player slots in currently active game sessions. This includes game sessions that are not currently accepting players. Reserved player slots are not included.</p> </li>
    /// <li> <p> <b>CurrentPlayerSessions</b> -- Player slots in active game sessions that are being used by a player or are reserved for a player. </p> </li>
    /// <li> <p> <b>IdleInstances</b> -- Active instances that are currently hosting zero game sessions. </p> </li>
    /// <li> <p> <b>PercentAvailableGameSessions</b> -- Unused percentage of the total number of game sessions that a fleet could host simultaneously, given current capacity. Use this metric for a target-based scaling policy.</p> </li>
    /// <li> <p> <b>PercentIdleInstances</b> -- Percentage of the total number of active instances that are hosting zero game sessions.</p> </li>
    /// <li> <p> <b>QueueDepth</b> -- Pending game session placement requests, in any queue, where the current fleet is the top-priority destination.</p> </li>
    /// <li> <p> <b>WaitTime</b> -- Current wait time for pending game session placement requests, in any queue, where the current fleet is the top-priority destination. </p> </li>
    /// </ul>
    pub fn metric_name(mut self, input: crate::types::MetricName) -> Self {
        self.metric_name = Some(input);
        self
    }
    /// <p>Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment. For detailed descriptions of fleet metrics, see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/monitoring-cloudwatch.html">Monitor Amazon GameLift with Amazon CloudWatch</a>. </p>
    /// <ul>
    /// <li> <p> <b>ActivatingGameSessions</b> -- Game sessions in the process of being created.</p> </li>
    /// <li> <p> <b>ActiveGameSessions</b> -- Game sessions that are currently running.</p> </li>
    /// <li> <p> <b>ActiveInstances</b> -- Fleet instances that are currently running at least one game session.</p> </li>
    /// <li> <p> <b>AvailableGameSessions</b> -- Additional game sessions that fleet could host simultaneously, given current capacity.</p> </li>
    /// <li> <p> <b>AvailablePlayerSessions</b> -- Empty player slots in currently active game sessions. This includes game sessions that are not currently accepting players. Reserved player slots are not included.</p> </li>
    /// <li> <p> <b>CurrentPlayerSessions</b> -- Player slots in active game sessions that are being used by a player or are reserved for a player. </p> </li>
    /// <li> <p> <b>IdleInstances</b> -- Active instances that are currently hosting zero game sessions. </p> </li>
    /// <li> <p> <b>PercentAvailableGameSessions</b> -- Unused percentage of the total number of game sessions that a fleet could host simultaneously, given current capacity. Use this metric for a target-based scaling policy.</p> </li>
    /// <li> <p> <b>PercentIdleInstances</b> -- Percentage of the total number of active instances that are hosting zero game sessions.</p> </li>
    /// <li> <p> <b>QueueDepth</b> -- Pending game session placement requests, in any queue, where the current fleet is the top-priority destination.</p> </li>
    /// <li> <p> <b>WaitTime</b> -- Current wait time for pending game session placement requests, in any queue, where the current fleet is the top-priority destination. </p> </li>
    /// </ul>
    pub fn set_metric_name(mut self, input: std::option::Option<crate::types::MetricName>) -> Self {
        self.metric_name = input;
        self
    }
    /// <p>The type of scaling policy to create. For a target-based policy, set the parameter <i>MetricName</i> to 'PercentAvailableGameSessions' and specify a <i>TargetConfiguration</i>. For a rule-based policy set the following parameters: <i>MetricName</i>, <i>ComparisonOperator</i>, <i>Threshold</i>, <i>EvaluationPeriods</i>, <i>ScalingAdjustmentType</i>, and <i>ScalingAdjustment</i>.</p>
    pub fn policy_type(mut self, input: crate::types::PolicyType) -> Self {
        self.policy_type = Some(input);
        self
    }
    /// <p>The type of scaling policy to create. For a target-based policy, set the parameter <i>MetricName</i> to 'PercentAvailableGameSessions' and specify a <i>TargetConfiguration</i>. For a rule-based policy set the following parameters: <i>MetricName</i>, <i>ComparisonOperator</i>, <i>Threshold</i>, <i>EvaluationPeriods</i>, <i>ScalingAdjustmentType</i>, and <i>ScalingAdjustment</i>.</p>
    pub fn set_policy_type(mut self, input: std::option::Option<crate::types::PolicyType>) -> Self {
        self.policy_type = input;
        self
    }
    /// <p>An object that contains settings for a target-based scaling policy.</p>
    pub fn target_configuration(mut self, input: crate::types::TargetConfiguration) -> Self {
        self.target_configuration = Some(input);
        self
    }
    /// <p>An object that contains settings for a target-based scaling policy.</p>
    pub fn set_target_configuration(
        mut self,
        input: std::option::Option<crate::types::TargetConfiguration>,
    ) -> Self {
        self.target_configuration = input;
        self
    }
    /// Consumes the builder and constructs a [`PutScalingPolicyInput`](crate::operation::put_scaling_policy::PutScalingPolicyInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::put_scaling_policy::PutScalingPolicyInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(
            crate::operation::put_scaling_policy::PutScalingPolicyInput {
                name: self.name,
                fleet_id: self.fleet_id,
                scaling_adjustment: self.scaling_adjustment.unwrap_or_default(),
                scaling_adjustment_type: self.scaling_adjustment_type,
                threshold: self.threshold.unwrap_or_default(),
                comparison_operator: self.comparison_operator,
                evaluation_periods: self.evaluation_periods,
                metric_name: self.metric_name,
                policy_type: self.policy_type,
                target_configuration: self.target_configuration,
            },
        )
    }
}
