// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `GameLift`.
///
/// This client allows ergonomic access to a `GameLift`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn accept_match(&self) -> fluent_builders::AcceptMatch<C, M, R> {
        fluent_builders::AcceptMatch::new(self.handle.clone())
    }
    pub fn claim_game_server(&self) -> fluent_builders::ClaimGameServer<C, M, R> {
        fluent_builders::ClaimGameServer::new(self.handle.clone())
    }
    pub fn create_alias(&self) -> fluent_builders::CreateAlias<C, M, R> {
        fluent_builders::CreateAlias::new(self.handle.clone())
    }
    pub fn create_build(&self) -> fluent_builders::CreateBuild<C, M, R> {
        fluent_builders::CreateBuild::new(self.handle.clone())
    }
    pub fn create_fleet(&self) -> fluent_builders::CreateFleet<C, M, R> {
        fluent_builders::CreateFleet::new(self.handle.clone())
    }
    pub fn create_fleet_locations(&self) -> fluent_builders::CreateFleetLocations<C, M, R> {
        fluent_builders::CreateFleetLocations::new(self.handle.clone())
    }
    pub fn create_game_server_group(&self) -> fluent_builders::CreateGameServerGroup<C, M, R> {
        fluent_builders::CreateGameServerGroup::new(self.handle.clone())
    }
    pub fn create_game_session(&self) -> fluent_builders::CreateGameSession<C, M, R> {
        fluent_builders::CreateGameSession::new(self.handle.clone())
    }
    pub fn create_game_session_queue(&self) -> fluent_builders::CreateGameSessionQueue<C, M, R> {
        fluent_builders::CreateGameSessionQueue::new(self.handle.clone())
    }
    pub fn create_matchmaking_configuration(
        &self,
    ) -> fluent_builders::CreateMatchmakingConfiguration<C, M, R> {
        fluent_builders::CreateMatchmakingConfiguration::new(self.handle.clone())
    }
    pub fn create_matchmaking_rule_set(
        &self,
    ) -> fluent_builders::CreateMatchmakingRuleSet<C, M, R> {
        fluent_builders::CreateMatchmakingRuleSet::new(self.handle.clone())
    }
    pub fn create_player_session(&self) -> fluent_builders::CreatePlayerSession<C, M, R> {
        fluent_builders::CreatePlayerSession::new(self.handle.clone())
    }
    pub fn create_player_sessions(&self) -> fluent_builders::CreatePlayerSessions<C, M, R> {
        fluent_builders::CreatePlayerSessions::new(self.handle.clone())
    }
    pub fn create_script(&self) -> fluent_builders::CreateScript<C, M, R> {
        fluent_builders::CreateScript::new(self.handle.clone())
    }
    pub fn create_vpc_peering_authorization(
        &self,
    ) -> fluent_builders::CreateVpcPeeringAuthorization<C, M, R> {
        fluent_builders::CreateVpcPeeringAuthorization::new(self.handle.clone())
    }
    pub fn create_vpc_peering_connection(
        &self,
    ) -> fluent_builders::CreateVpcPeeringConnection<C, M, R> {
        fluent_builders::CreateVpcPeeringConnection::new(self.handle.clone())
    }
    pub fn delete_alias(&self) -> fluent_builders::DeleteAlias<C, M, R> {
        fluent_builders::DeleteAlias::new(self.handle.clone())
    }
    pub fn delete_build(&self) -> fluent_builders::DeleteBuild<C, M, R> {
        fluent_builders::DeleteBuild::new(self.handle.clone())
    }
    pub fn delete_fleet(&self) -> fluent_builders::DeleteFleet<C, M, R> {
        fluent_builders::DeleteFleet::new(self.handle.clone())
    }
    pub fn delete_fleet_locations(&self) -> fluent_builders::DeleteFleetLocations<C, M, R> {
        fluent_builders::DeleteFleetLocations::new(self.handle.clone())
    }
    pub fn delete_game_server_group(&self) -> fluent_builders::DeleteGameServerGroup<C, M, R> {
        fluent_builders::DeleteGameServerGroup::new(self.handle.clone())
    }
    pub fn delete_game_session_queue(&self) -> fluent_builders::DeleteGameSessionQueue<C, M, R> {
        fluent_builders::DeleteGameSessionQueue::new(self.handle.clone())
    }
    pub fn delete_matchmaking_configuration(
        &self,
    ) -> fluent_builders::DeleteMatchmakingConfiguration<C, M, R> {
        fluent_builders::DeleteMatchmakingConfiguration::new(self.handle.clone())
    }
    pub fn delete_matchmaking_rule_set(
        &self,
    ) -> fluent_builders::DeleteMatchmakingRuleSet<C, M, R> {
        fluent_builders::DeleteMatchmakingRuleSet::new(self.handle.clone())
    }
    pub fn delete_scaling_policy(&self) -> fluent_builders::DeleteScalingPolicy<C, M, R> {
        fluent_builders::DeleteScalingPolicy::new(self.handle.clone())
    }
    pub fn delete_script(&self) -> fluent_builders::DeleteScript<C, M, R> {
        fluent_builders::DeleteScript::new(self.handle.clone())
    }
    pub fn delete_vpc_peering_authorization(
        &self,
    ) -> fluent_builders::DeleteVpcPeeringAuthorization<C, M, R> {
        fluent_builders::DeleteVpcPeeringAuthorization::new(self.handle.clone())
    }
    pub fn delete_vpc_peering_connection(
        &self,
    ) -> fluent_builders::DeleteVpcPeeringConnection<C, M, R> {
        fluent_builders::DeleteVpcPeeringConnection::new(self.handle.clone())
    }
    pub fn deregister_game_server(&self) -> fluent_builders::DeregisterGameServer<C, M, R> {
        fluent_builders::DeregisterGameServer::new(self.handle.clone())
    }
    pub fn describe_alias(&self) -> fluent_builders::DescribeAlias<C, M, R> {
        fluent_builders::DescribeAlias::new(self.handle.clone())
    }
    pub fn describe_build(&self) -> fluent_builders::DescribeBuild<C, M, R> {
        fluent_builders::DescribeBuild::new(self.handle.clone())
    }
    pub fn describe_ec2_instance_limits(
        &self,
    ) -> fluent_builders::DescribeEC2InstanceLimits<C, M, R> {
        fluent_builders::DescribeEC2InstanceLimits::new(self.handle.clone())
    }
    pub fn describe_fleet_attributes(&self) -> fluent_builders::DescribeFleetAttributes<C, M, R> {
        fluent_builders::DescribeFleetAttributes::new(self.handle.clone())
    }
    pub fn describe_fleet_capacity(&self) -> fluent_builders::DescribeFleetCapacity<C, M, R> {
        fluent_builders::DescribeFleetCapacity::new(self.handle.clone())
    }
    pub fn describe_fleet_events(&self) -> fluent_builders::DescribeFleetEvents<C, M, R> {
        fluent_builders::DescribeFleetEvents::new(self.handle.clone())
    }
    pub fn describe_fleet_location_attributes(
        &self,
    ) -> fluent_builders::DescribeFleetLocationAttributes<C, M, R> {
        fluent_builders::DescribeFleetLocationAttributes::new(self.handle.clone())
    }
    pub fn describe_fleet_location_capacity(
        &self,
    ) -> fluent_builders::DescribeFleetLocationCapacity<C, M, R> {
        fluent_builders::DescribeFleetLocationCapacity::new(self.handle.clone())
    }
    pub fn describe_fleet_location_utilization(
        &self,
    ) -> fluent_builders::DescribeFleetLocationUtilization<C, M, R> {
        fluent_builders::DescribeFleetLocationUtilization::new(self.handle.clone())
    }
    pub fn describe_fleet_port_settings(
        &self,
    ) -> fluent_builders::DescribeFleetPortSettings<C, M, R> {
        fluent_builders::DescribeFleetPortSettings::new(self.handle.clone())
    }
    pub fn describe_fleet_utilization(&self) -> fluent_builders::DescribeFleetUtilization<C, M, R> {
        fluent_builders::DescribeFleetUtilization::new(self.handle.clone())
    }
    pub fn describe_game_server(&self) -> fluent_builders::DescribeGameServer<C, M, R> {
        fluent_builders::DescribeGameServer::new(self.handle.clone())
    }
    pub fn describe_game_server_group(&self) -> fluent_builders::DescribeGameServerGroup<C, M, R> {
        fluent_builders::DescribeGameServerGroup::new(self.handle.clone())
    }
    pub fn describe_game_server_instances(
        &self,
    ) -> fluent_builders::DescribeGameServerInstances<C, M, R> {
        fluent_builders::DescribeGameServerInstances::new(self.handle.clone())
    }
    pub fn describe_game_session_details(
        &self,
    ) -> fluent_builders::DescribeGameSessionDetails<C, M, R> {
        fluent_builders::DescribeGameSessionDetails::new(self.handle.clone())
    }
    pub fn describe_game_session_placement(
        &self,
    ) -> fluent_builders::DescribeGameSessionPlacement<C, M, R> {
        fluent_builders::DescribeGameSessionPlacement::new(self.handle.clone())
    }
    pub fn describe_game_session_queues(
        &self,
    ) -> fluent_builders::DescribeGameSessionQueues<C, M, R> {
        fluent_builders::DescribeGameSessionQueues::new(self.handle.clone())
    }
    pub fn describe_game_sessions(&self) -> fluent_builders::DescribeGameSessions<C, M, R> {
        fluent_builders::DescribeGameSessions::new(self.handle.clone())
    }
    pub fn describe_instances(&self) -> fluent_builders::DescribeInstances<C, M, R> {
        fluent_builders::DescribeInstances::new(self.handle.clone())
    }
    pub fn describe_matchmaking(&self) -> fluent_builders::DescribeMatchmaking<C, M, R> {
        fluent_builders::DescribeMatchmaking::new(self.handle.clone())
    }
    pub fn describe_matchmaking_configurations(
        &self,
    ) -> fluent_builders::DescribeMatchmakingConfigurations<C, M, R> {
        fluent_builders::DescribeMatchmakingConfigurations::new(self.handle.clone())
    }
    pub fn describe_matchmaking_rule_sets(
        &self,
    ) -> fluent_builders::DescribeMatchmakingRuleSets<C, M, R> {
        fluent_builders::DescribeMatchmakingRuleSets::new(self.handle.clone())
    }
    pub fn describe_player_sessions(&self) -> fluent_builders::DescribePlayerSessions<C, M, R> {
        fluent_builders::DescribePlayerSessions::new(self.handle.clone())
    }
    pub fn describe_runtime_configuration(
        &self,
    ) -> fluent_builders::DescribeRuntimeConfiguration<C, M, R> {
        fluent_builders::DescribeRuntimeConfiguration::new(self.handle.clone())
    }
    pub fn describe_scaling_policies(&self) -> fluent_builders::DescribeScalingPolicies<C, M, R> {
        fluent_builders::DescribeScalingPolicies::new(self.handle.clone())
    }
    pub fn describe_script(&self) -> fluent_builders::DescribeScript<C, M, R> {
        fluent_builders::DescribeScript::new(self.handle.clone())
    }
    pub fn describe_vpc_peering_authorizations(
        &self,
    ) -> fluent_builders::DescribeVpcPeeringAuthorizations<C, M, R> {
        fluent_builders::DescribeVpcPeeringAuthorizations::new(self.handle.clone())
    }
    pub fn describe_vpc_peering_connections(
        &self,
    ) -> fluent_builders::DescribeVpcPeeringConnections<C, M, R> {
        fluent_builders::DescribeVpcPeeringConnections::new(self.handle.clone())
    }
    pub fn get_game_session_log_url(&self) -> fluent_builders::GetGameSessionLogUrl<C, M, R> {
        fluent_builders::GetGameSessionLogUrl::new(self.handle.clone())
    }
    pub fn get_instance_access(&self) -> fluent_builders::GetInstanceAccess<C, M, R> {
        fluent_builders::GetInstanceAccess::new(self.handle.clone())
    }
    pub fn list_aliases(&self) -> fluent_builders::ListAliases<C, M, R> {
        fluent_builders::ListAliases::new(self.handle.clone())
    }
    pub fn list_builds(&self) -> fluent_builders::ListBuilds<C, M, R> {
        fluent_builders::ListBuilds::new(self.handle.clone())
    }
    pub fn list_fleets(&self) -> fluent_builders::ListFleets<C, M, R> {
        fluent_builders::ListFleets::new(self.handle.clone())
    }
    pub fn list_game_server_groups(&self) -> fluent_builders::ListGameServerGroups<C, M, R> {
        fluent_builders::ListGameServerGroups::new(self.handle.clone())
    }
    pub fn list_game_servers(&self) -> fluent_builders::ListGameServers<C, M, R> {
        fluent_builders::ListGameServers::new(self.handle.clone())
    }
    pub fn list_scripts(&self) -> fluent_builders::ListScripts<C, M, R> {
        fluent_builders::ListScripts::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C, M, R> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn put_scaling_policy(&self) -> fluent_builders::PutScalingPolicy<C, M, R> {
        fluent_builders::PutScalingPolicy::new(self.handle.clone())
    }
    pub fn register_game_server(&self) -> fluent_builders::RegisterGameServer<C, M, R> {
        fluent_builders::RegisterGameServer::new(self.handle.clone())
    }
    pub fn request_upload_credentials(&self) -> fluent_builders::RequestUploadCredentials<C, M, R> {
        fluent_builders::RequestUploadCredentials::new(self.handle.clone())
    }
    pub fn resolve_alias(&self) -> fluent_builders::ResolveAlias<C, M, R> {
        fluent_builders::ResolveAlias::new(self.handle.clone())
    }
    pub fn resume_game_server_group(&self) -> fluent_builders::ResumeGameServerGroup<C, M, R> {
        fluent_builders::ResumeGameServerGroup::new(self.handle.clone())
    }
    pub fn search_game_sessions(&self) -> fluent_builders::SearchGameSessions<C, M, R> {
        fluent_builders::SearchGameSessions::new(self.handle.clone())
    }
    pub fn start_fleet_actions(&self) -> fluent_builders::StartFleetActions<C, M, R> {
        fluent_builders::StartFleetActions::new(self.handle.clone())
    }
    pub fn start_game_session_placement(
        &self,
    ) -> fluent_builders::StartGameSessionPlacement<C, M, R> {
        fluent_builders::StartGameSessionPlacement::new(self.handle.clone())
    }
    pub fn start_match_backfill(&self) -> fluent_builders::StartMatchBackfill<C, M, R> {
        fluent_builders::StartMatchBackfill::new(self.handle.clone())
    }
    pub fn start_matchmaking(&self) -> fluent_builders::StartMatchmaking<C, M, R> {
        fluent_builders::StartMatchmaking::new(self.handle.clone())
    }
    pub fn stop_fleet_actions(&self) -> fluent_builders::StopFleetActions<C, M, R> {
        fluent_builders::StopFleetActions::new(self.handle.clone())
    }
    pub fn stop_game_session_placement(
        &self,
    ) -> fluent_builders::StopGameSessionPlacement<C, M, R> {
        fluent_builders::StopGameSessionPlacement::new(self.handle.clone())
    }
    pub fn stop_matchmaking(&self) -> fluent_builders::StopMatchmaking<C, M, R> {
        fluent_builders::StopMatchmaking::new(self.handle.clone())
    }
    pub fn suspend_game_server_group(&self) -> fluent_builders::SuspendGameServerGroup<C, M, R> {
        fluent_builders::SuspendGameServerGroup::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C, M, R> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C, M, R> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_alias(&self) -> fluent_builders::UpdateAlias<C, M, R> {
        fluent_builders::UpdateAlias::new(self.handle.clone())
    }
    pub fn update_build(&self) -> fluent_builders::UpdateBuild<C, M, R> {
        fluent_builders::UpdateBuild::new(self.handle.clone())
    }
    pub fn update_fleet_attributes(&self) -> fluent_builders::UpdateFleetAttributes<C, M, R> {
        fluent_builders::UpdateFleetAttributes::new(self.handle.clone())
    }
    pub fn update_fleet_capacity(&self) -> fluent_builders::UpdateFleetCapacity<C, M, R> {
        fluent_builders::UpdateFleetCapacity::new(self.handle.clone())
    }
    pub fn update_fleet_port_settings(&self) -> fluent_builders::UpdateFleetPortSettings<C, M, R> {
        fluent_builders::UpdateFleetPortSettings::new(self.handle.clone())
    }
    pub fn update_game_server(&self) -> fluent_builders::UpdateGameServer<C, M, R> {
        fluent_builders::UpdateGameServer::new(self.handle.clone())
    }
    pub fn update_game_server_group(&self) -> fluent_builders::UpdateGameServerGroup<C, M, R> {
        fluent_builders::UpdateGameServerGroup::new(self.handle.clone())
    }
    pub fn update_game_session(&self) -> fluent_builders::UpdateGameSession<C, M, R> {
        fluent_builders::UpdateGameSession::new(self.handle.clone())
    }
    pub fn update_game_session_queue(&self) -> fluent_builders::UpdateGameSessionQueue<C, M, R> {
        fluent_builders::UpdateGameSessionQueue::new(self.handle.clone())
    }
    pub fn update_matchmaking_configuration(
        &self,
    ) -> fluent_builders::UpdateMatchmakingConfiguration<C, M, R> {
        fluent_builders::UpdateMatchmakingConfiguration::new(self.handle.clone())
    }
    pub fn update_runtime_configuration(
        &self,
    ) -> fluent_builders::UpdateRuntimeConfiguration<C, M, R> {
        fluent_builders::UpdateRuntimeConfiguration::new(self.handle.clone())
    }
    pub fn update_script(&self) -> fluent_builders::UpdateScript<C, M, R> {
        fluent_builders::UpdateScript::new(self.handle.clone())
    }
    pub fn validate_matchmaking_rule_set(
        &self,
    ) -> fluent_builders::ValidateMatchmakingRuleSet<C, M, R> {
        fluent_builders::ValidateMatchmakingRuleSet::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcceptMatch<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::accept_match_input::Builder,
    }
    impl<C, M, R> AcceptMatch<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptMatchOutput,
            smithy_http::result::SdkError<crate::error::AcceptMatchError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AcceptMatchInputOperationOutputAlias,
                crate::output::AcceptMatchOutput,
                crate::error::AcceptMatchError,
                crate::input::AcceptMatchInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for a matchmaking ticket. The ticket must be in status <code>REQUIRES_ACCEPTANCE</code>; otherwise this
        /// request will fail.</p>
        pub fn ticket_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ticket_id(inp);
            self
        }
        pub fn set_ticket_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ticket_id(input);
            self
        }
        /// Appends an item to `PlayerIds`.
        ///
        /// To override the contents of this collection use [`set_player_ids`](Self::set_player_ids).
        /// <p>A unique identifier for a player delivering the response. This parameter can include one or multiple
        /// player IDs.</p>
        pub fn player_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.player_ids(inp);
            self
        }
        pub fn set_player_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_player_ids(input);
            self
        }
        /// <p>Player response to the proposed match.</p>
        pub fn acceptance_type(mut self, inp: crate::model::AcceptanceType) -> Self {
            self.inner = self.inner.acceptance_type(inp);
            self
        }
        pub fn set_acceptance_type(
            mut self,
            input: std::option::Option<crate::model::AcceptanceType>,
        ) -> Self {
            self.inner = self.inner.set_acceptance_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ClaimGameServer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::claim_game_server_input::Builder,
    }
    impl<C, M, R> ClaimGameServer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ClaimGameServerOutput,
            smithy_http::result::SdkError<crate::error::ClaimGameServerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ClaimGameServerInputOperationOutputAlias,
                crate::output::ClaimGameServerOutput,
                crate::error::ClaimGameServerError,
                crate::input::ClaimGameServerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game server group where the game server is running.
        /// Use either the <a>GameServerGroup</a> name or ARN value. If you are not specifying a game server to claim, this value identifies
        /// where you want GameLift FleetIQ to look for an available game server to claim. </p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// <p>A custom string that uniquely identifies the game server to claim. If this parameter
        /// is left empty, GameLift FleetIQ searches for an available game server in the specified game
        /// server group.</p>
        pub fn game_server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_id(inp);
            self
        }
        pub fn set_game_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_id(input);
            self
        }
        /// <p>A set of custom game server properties, formatted as a single string value. This data
        /// is passed to a game client or service when it requests information on game servers using
        /// <a>ListGameServers</a> or <a>ClaimGameServer</a>. </p>
        pub fn game_server_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_data(inp);
            self
        }
        pub fn set_game_server_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_data(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAlias<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_alias_input::Builder,
    }
    impl<C, M, R> CreateAlias<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAliasOutput,
            smithy_http::result::SdkError<crate::error::CreateAliasError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateAliasInputOperationOutputAlias,
                crate::output::CreateAliasOutput,
                crate::error::CreateAliasError,
                crate::input::CreateAliasInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A descriptive label that is associated with an alias. Alias names do not need to be unique.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A human-readable description of the alias.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The routing configuration, including routing type and fleet target, for the alias. </p>
        pub fn routing_strategy(mut self, inp: crate::model::RoutingStrategy) -> Self {
            self.inner = self.inner.routing_strategy(inp);
            self
        }
        pub fn set_routing_strategy(
            mut self,
            input: std::option::Option<crate::model::RoutingStrategy>,
        ) -> Self {
            self.inner = self.inner.set_routing_strategy(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A list of labels to assign to the new alias resource. Tags are developer-defined
        /// key-value pairs. Tagging
        /// AWS resources are useful for resource management, access management and cost allocation.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging AWS Resources</a> in the
        /// <i>AWS General Reference</i>. Once the resource is created, you can
        /// use <a>TagResource</a>, <a>UntagResource</a>, and
        /// <a>ListTagsForResource</a> to add, remove, and view tags. The
        /// maximum tag limit may be lower than stated. See the AWS General Reference for actual
        /// tagging limits.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateBuild<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_build_input::Builder,
    }
    impl<C, M, R> CreateBuild<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateBuildOutput,
            smithy_http::result::SdkError<crate::error::CreateBuildError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateBuildInputOperationOutputAlias,
                crate::output::CreateBuildOutput,
                crate::error::CreateBuildError,
                crate::input::CreateBuildInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A descriptive label that is associated with a build. Build names do not need to be unique. You can use <a>UpdateBuild</a> to change this value later.
        /// </p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Version information that is associated with a build or script. Version strings do not need to be unique. You can use <a>UpdateBuild</a> to change this value later.
        /// </p>
        pub fn version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(inp);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>Information indicating where your game build files are stored. Use this parameter only
        /// when creating a build with files stored in an Amazon S3 bucket that you own. The storage
        /// location must specify an Amazon S3 bucket name and key. The location must also specify a role
        /// ARN that you set up to allow Amazon GameLift to access your Amazon S3 bucket. The S3 bucket and your
        /// new build must be in the same Region.</p>
        pub fn storage_location(mut self, inp: crate::model::S3Location) -> Self {
            self.inner = self.inner.storage_location(inp);
            self
        }
        pub fn set_storage_location(
            mut self,
            input: std::option::Option<crate::model::S3Location>,
        ) -> Self {
            self.inner = self.inner.set_storage_location(input);
            self
        }
        /// <p>The operating system that the game server binaries are built to run on. This value
        /// determines the type of fleet resources that you can use for this build. If your game
        /// build contains multiple executables, they all must run on the same operating system. If
        /// an operating system is not specified when creating a build, Amazon GameLift uses the
        /// default value (WINDOWS_2012). This value cannot be changed later.</p>
        pub fn operating_system(mut self, inp: crate::model::OperatingSystem) -> Self {
            self.inner = self.inner.operating_system(inp);
            self
        }
        pub fn set_operating_system(
            mut self,
            input: std::option::Option<crate::model::OperatingSystem>,
        ) -> Self {
            self.inner = self.inner.set_operating_system(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A list of labels to assign to the new build resource. Tags are developer-defined
        /// key-value pairs. Tagging
        /// AWS resources are useful for resource management, access management and cost allocation.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging AWS Resources</a> in the
        /// <i>AWS General Reference</i>. Once the resource is created, you can
        /// use <a>TagResource</a>, <a>UntagResource</a>, and
        /// <a>ListTagsForResource</a> to add, remove, and view tags. The
        /// maximum tag limit may be lower than stated. See the AWS General Reference for actual
        /// tagging limits.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFleet<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_fleet_input::Builder,
    }
    impl<C, M, R> CreateFleet<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFleetOutput,
            smithy_http::result::SdkError<crate::error::CreateFleetError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateFleetInputOperationOutputAlias,
                crate::output::CreateFleetOutput,
                crate::error::CreateFleetError,
                crate::input::CreateFleetInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A descriptive label that is associated with a fleet. Fleet names do not need to be unique.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A human-readable description of the fleet.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The unique identifier for a custom game server build to be deployed on fleet
        /// instances. You can use either the build ID or ARN. The build must be uploaded to GameLift
        /// and in <code>READY</code> status. This fleet property cannot be changed later.</p>
        pub fn build_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.build_id(inp);
            self
        }
        pub fn set_build_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_build_id(input);
            self
        }
        /// <p>The unique identifier for a Realtime configuration script to be deployed on fleet
        /// instances. You can use either the script ID or ARN. Scripts must be uploaded to GameLift
        /// prior to creating the fleet. This fleet property cannot be changed later.</p>
        pub fn script_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.script_id(inp);
            self
        }
        pub fn set_script_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_script_id(input);
            self
        }
        /// <p>
        /// <b>This parameter is no longer used.</b> Specify a server
        /// launch path using the <code>RuntimeConfiguration</code> parameter. Requests that use
        /// this parameter instead continue to be valid.</p>
        pub fn server_launch_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_launch_path(inp);
            self
        }
        pub fn set_server_launch_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_launch_path(input);
            self
        }
        /// <p>
        /// <b>This parameter is no longer used.</b> Specify server
        /// launch parameters using the <code>RuntimeConfiguration</code> parameter. Requests that
        /// use this parameter instead continue to be valid.</p>
        pub fn server_launch_parameters(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_launch_parameters(inp);
            self
        }
        pub fn set_server_launch_parameters(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_launch_parameters(input);
            self
        }
        /// Appends an item to `LogPaths`.
        ///
        /// To override the contents of this collection use [`set_log_paths`](Self::set_log_paths).
        /// <p>
        /// <b>This parameter is no longer used.</b> To specify where
        /// GameLift should store log files once a server process shuts down, use the GameLift server
        /// API <code>ProcessReady()</code> and specify one or more directory paths in
        /// <code>logParameters</code>. See more information in the <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api-ref.html#gamelift-sdk-server-api-ref-dataypes-process">Server API Reference</a>. </p>
        pub fn log_paths(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_paths(inp);
            self
        }
        pub fn set_log_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_log_paths(input);
            self
        }
        /// <p>The GameLift-supported EC2 instance type to use for all fleet instances. Instance
        /// type determines the computing resources that will be used to host your game servers,
        /// including CPU, memory, storage, and networking capacity. See <a href="http://aws.amazon.com/ec2/instance-types/">Amazon EC2 Instance Types</a> for detailed descriptions
        /// of EC2 instance types.</p>
        pub fn ec2_instance_type(mut self, inp: crate::model::Ec2InstanceType) -> Self {
            self.inner = self.inner.ec2_instance_type(inp);
            self
        }
        pub fn set_ec2_instance_type(
            mut self,
            input: std::option::Option<crate::model::Ec2InstanceType>,
        ) -> Self {
            self.inner = self.inner.set_ec2_instance_type(input);
            self
        }
        /// Appends an item to `EC2InboundPermissions`.
        ///
        /// To override the contents of this collection use [`set_ec2_inbound_permissions`](Self::set_ec2_inbound_permissions).
        /// <p>The allowed IP address ranges and port settings that allow inbound traffic to access
        /// game sessions on this fleet. If the fleet is hosting a custom game build, this property
        /// must be set before players can connect to game sessions. For Realtime Servers fleets, GameLift
        /// automatically sets TCP and UDP ranges. </p>
        pub fn ec2_inbound_permissions(
            mut self,
            inp: impl Into<crate::model::IpPermission>,
        ) -> Self {
            self.inner = self.inner.ec2_inbound_permissions(inp);
            self
        }
        pub fn set_ec2_inbound_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        ) -> Self {
            self.inner = self.inner.set_ec2_inbound_permissions(input);
            self
        }
        /// <p>The status of termination protection for active game sessions on the fleet. By
        /// default, this property is set to <code>NoProtection</code>. You can also set game
        /// session protection for an individual game session by calling <a>UpdateGameSession</a>.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>NoProtection</b> - Game sessions can be terminated
        /// during active gameplay as a result of a scale-down event. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>FullProtection</b> - Game sessions in
        /// <code>ACTIVE</code> status cannot be terminated during a scale-down
        /// event.</p>
        /// </li>
        /// </ul>
        pub fn new_game_session_protection_policy(
            mut self,
            inp: crate::model::ProtectionPolicy,
        ) -> Self {
            self.inner = self.inner.new_game_session_protection_policy(inp);
            self
        }
        pub fn set_new_game_session_protection_policy(
            mut self,
            input: std::option::Option<crate::model::ProtectionPolicy>,
        ) -> Self {
            self.inner = self.inner.set_new_game_session_protection_policy(input);
            self
        }
        /// <p>Instructions for how to launch and maintain server processes on instances in the
        /// fleet. The runtime configuration defines one or more server process configurations, each
        /// identifying a build executable or Realtime script file and the number of processes of
        /// that type to run concurrently. </p>
        /// <note>
        /// <p>The <code>RuntimeConfiguration</code> parameter is required unless the fleet is
        /// being configured using the older parameters <code>ServerLaunchPath</code> and
        /// <code>ServerLaunchParameters</code>, which are still supported for backward
        /// compatibility.</p>
        /// </note>
        pub fn runtime_configuration(mut self, inp: crate::model::RuntimeConfiguration) -> Self {
            self.inner = self.inner.runtime_configuration(inp);
            self
        }
        pub fn set_runtime_configuration(
            mut self,
            input: std::option::Option<crate::model::RuntimeConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_runtime_configuration(input);
            self
        }
        /// <p>A policy that limits the number of game sessions that an individual player can create
        /// on instances in this fleet within a specified span of time.</p>
        pub fn resource_creation_limit_policy(
            mut self,
            inp: crate::model::ResourceCreationLimitPolicy,
        ) -> Self {
            self.inner = self.inner.resource_creation_limit_policy(inp);
            self
        }
        pub fn set_resource_creation_limit_policy(
            mut self,
            input: std::option::Option<crate::model::ResourceCreationLimitPolicy>,
        ) -> Self {
            self.inner = self.inner.set_resource_creation_limit_policy(input);
            self
        }
        /// Appends an item to `MetricGroups`.
        ///
        /// To override the contents of this collection use [`set_metric_groups`](Self::set_metric_groups).
        /// <p>The name of an AWS CloudWatch metric group to add this fleet to. A metric group is
        /// used to aggregate the metrics for multiple fleets. You can specify an existing metric
        /// group name or set a new name to create a new metric group. A fleet can be included in
        /// only one metric group at a time. </p>
        pub fn metric_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_groups(inp);
            self
        }
        pub fn set_metric_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_metric_groups(input);
            self
        }
        /// <p>Used when peering your GameLift fleet with a VPC, the unique identifier for the AWS
        /// account that owns the VPC. You can find your account ID in the AWS Management Console under account
        /// settings. </p>
        pub fn peer_vpc_aws_account_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_vpc_aws_account_id(inp);
            self
        }
        pub fn set_peer_vpc_aws_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_peer_vpc_aws_account_id(input);
            self
        }
        /// <p>A unique identifier for a VPC with resources to be accessed by your GameLift fleet. The
        /// VPC must be in the same Region as your fleet. To look up a VPC ID, use the
        /// <a href="https://console.aws.amazon.com/vpc/">VPC Dashboard</a> in the AWS Management Console.
        /// Learn more about VPC peering in <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/vpc-peering.html">VPC Peering with GameLift Fleets</a>. </p>
        pub fn peer_vpc_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_vpc_id(inp);
            self
        }
        pub fn set_peer_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_peer_vpc_id(input);
            self
        }
        /// <p>Indicates whether to use On-Demand or Spot instances for this fleet. By default, this
        /// property is set to <code>ON_DEMAND</code>. Learn more about when to use <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-ec2-instances.html#gamelift-ec2-instances-spot"> On-Demand versus Spot Instances</a>. This property cannot be changed after the
        /// fleet is created.</p>
        pub fn fleet_type(mut self, inp: crate::model::FleetType) -> Self {
            self.inner = self.inner.fleet_type(inp);
            self
        }
        pub fn set_fleet_type(
            mut self,
            input: std::option::Option<crate::model::FleetType>,
        ) -> Self {
            self.inner = self.inner.set_fleet_type(input);
            self
        }
        /// <p>A unique identifier for an AWS IAM role that manages access to your AWS services.
        /// With an instance role ARN set, any application that runs on an instance in this fleet can assume the role,
        /// including install scripts, server processes, and daemons (background processes). Create a role or look up a role's
        /// ARN by using the <a href="https://console.aws.amazon.com/iam/">IAM dashboard</a> in the AWS Management Console.
        /// Learn more about using on-box credentials for your game servers at
        /// <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-resources.html">
        /// Access external resources from a game server</a>.  This property cannot be changed after the fleet is created.</p>
        pub fn instance_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_role_arn(inp);
            self
        }
        pub fn set_instance_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_role_arn(input);
            self
        }
        /// <p>Prompts GameLift to generate a TLS/SSL certificate for the fleet. TLS certificates are
        /// used for encrypting traffic between game clients and the game servers that are running
        /// on GameLift. By default, the <code>CertificateConfiguration</code> is set to
        /// <code>DISABLED</code>. Learn more at <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-howitworks.html#gamelift-howitworks-security">Securing Client/Server Communication</a>. This property cannot be changed after
        /// the fleet is created. </p>
        /// <p>Note: This feature requires the AWS Certificate Manager (ACM) service, which is not
        /// available in all AWS regions. When working in a region that does not support this
        /// feature, a fleet creation request with certificate generation fails with a 4xx
        /// error.</p>
        pub fn certificate_configuration(
            mut self,
            inp: crate::model::CertificateConfiguration,
        ) -> Self {
            self.inner = self.inner.certificate_configuration(inp);
            self
        }
        pub fn set_certificate_configuration(
            mut self,
            input: std::option::Option<crate::model::CertificateConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_certificate_configuration(input);
            self
        }
        /// Appends an item to `Locations`.
        ///
        /// To override the contents of this collection use [`set_locations`](Self::set_locations).
        /// <p>A set of remote locations to deploy additional instances to and manage as part of the
        /// fleet. This parameter can only be used when creating fleets in AWS Regions that support
        /// multiple locations. You can add any GameLift-supported AWS Region as a remote location,
        /// in the form of an AWS Region code such as <code>us-west-2</code>. To create a fleet with
        /// instances in the home Region only, omit this parameter. </p>
        pub fn locations(mut self, inp: impl Into<crate::model::LocationConfiguration>) -> Self {
            self.inner = self.inner.locations(inp);
            self
        }
        pub fn set_locations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LocationConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_locations(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A list of labels to assign to the new fleet resource. Tags are developer-defined
        /// key-value pairs. Tagging AWS resources are useful for resource management, access
        /// management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging AWS Resources</a> in the
        /// <i>AWS General Reference</i>. Once the fleet is created, you can use
        /// <a>TagResource</a>, <a>UntagResource</a>, and <a>ListTagsForResource</a> to add, remove, and view tags. The maximum tag limit
        /// may be lower than stated. See the <i>AWS General Reference</i> for actual
        /// tagging limits.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFleetLocations<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_fleet_locations_input::Builder,
    }
    impl<C, M, R> CreateFleetLocations<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFleetLocationsOutput,
            smithy_http::result::SdkError<crate::error::CreateFleetLocationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateFleetLocationsInputOperationOutputAlias,
                crate::output::CreateFleetLocationsOutput,
                crate::error::CreateFleetLocationsError,
                crate::input::CreateFleetLocationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to add locations to. You can use either the fleet ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// Appends an item to `Locations`.
        ///
        /// To override the contents of this collection use [`set_locations`](Self::set_locations).
        /// <p>A list of locations to deploy additional instances to and manage as part of the fleet.
        /// You can add any GameLift-supported AWS Region as a remote location, in the form of an AWS
        /// Region code such as <code>us-west-2</code>. </p>
        pub fn locations(mut self, inp: impl Into<crate::model::LocationConfiguration>) -> Self {
            self.inner = self.inner.locations(inp);
            self
        }
        pub fn set_locations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LocationConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_locations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateGameServerGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_game_server_group_input::Builder,
    }
    impl<C, M, R> CreateGameServerGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateGameServerGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateGameServerGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateGameServerGroupInputOperationOutputAlias,
                crate::output::CreateGameServerGroupOutput,
                crate::error::CreateGameServerGroupError,
                crate::input::CreateGameServerGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier for the new game server group. This value is used to generate unique ARN
        /// identifiers for the EC2 Auto Scaling group and the GameLift FleetIQ game server group. The name
        /// must be unique per Region per AWS account.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) for an IAM role that
        /// allows Amazon GameLift to access your EC2 Auto Scaling groups.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The minimum number of instances allowed in the EC2 Auto Scaling group. During
        /// automatic scaling events, GameLift FleetIQ and EC2 do not scale down the group below this
        /// minimum. In production, this value should be set to at least 1. After the Auto Scaling
        /// group is created, update this value directly in the Auto Scaling group using the AWS
        /// console or APIs.</p>
        pub fn min_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.min_size(inp);
            self
        }
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_size(input);
            self
        }
        /// <p>The maximum number of instances allowed in the EC2 Auto Scaling group. During
        /// automatic scaling events, GameLift FleetIQ and EC2 do not scale up the group above this maximum.
        /// After the Auto Scaling group is created, update this value directly in the Auto Scaling
        /// group using the AWS console or APIs.</p>
        pub fn max_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_size(inp);
            self
        }
        pub fn set_max_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_size(input);
            self
        }
        /// <p>The EC2 launch template that contains configuration settings and game server code to
        /// be deployed to all instances in the game server group. You can specify the template
        /// using either the template name or ID. For help with creating a launch template, see
        /// <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html">Creating a Launch
        /// Template for an Auto Scaling Group</a> in the <i>Amazon EC2 Auto Scaling
        /// User Guide</i>. After the Auto Scaling group is created, update this value
        /// directly in the Auto Scaling group using the AWS console or APIs.</p>
        /// <note>
        /// <p>If you specify network interfaces in your launch template, you must explicitly set
        /// the property <code>AssociatePublicIpAddress</code> to "true". If no network
        /// interface is specified in the launch template,  GameLift FleetIQ uses your account's default
        /// VPC.</p>
        /// </note>
        pub fn launch_template(mut self, inp: crate::model::LaunchTemplateSpecification) -> Self {
            self.inner = self.inner.launch_template(inp);
            self
        }
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpecification>,
        ) -> Self {
            self.inner = self.inner.set_launch_template(input);
            self
        }
        /// Appends an item to `InstanceDefinitions`.
        ///
        /// To override the contents of this collection use [`set_instance_definitions`](Self::set_instance_definitions).
        /// <p>The EC2 instance types and sizes to use in the Auto Scaling group. The instance
        /// definitions must specify at least two different instance types that are supported by
        /// GameLift FleetIQ. For more information on instance types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">EC2 Instance Types</a> in the
        /// <i>Amazon EC2 User Guide</i>. You can optionally specify capacity
        /// weighting for each instance type. If no weight value is specified for an instance type,
        /// it is set to the default value "1". For more information about capacity weighting, see
        /// <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-weighting.html"> Instance Weighting for
        /// Amazon EC2 Auto Scaling</a> in the Amazon EC2 Auto Scaling User Guide.</p>
        pub fn instance_definitions(
            mut self,
            inp: impl Into<crate::model::InstanceDefinition>,
        ) -> Self {
            self.inner = self.inner.instance_definitions(inp);
            self
        }
        pub fn set_instance_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceDefinition>>,
        ) -> Self {
            self.inner = self.inner.set_instance_definitions(input);
            self
        }
        /// <p>Configuration settings to define a scaling policy for the Auto Scaling group that is
        /// optimized for game hosting. The scaling policy uses the metric
        /// <code>"PercentUtilizedGameServers"</code> to maintain a buffer of idle game servers
        /// that can immediately accommodate new games and players. After the Auto Scaling group is
        /// created, update this value directly in the Auto Scaling group using the AWS console or
        /// APIs.</p>
        pub fn auto_scaling_policy(
            mut self,
            inp: crate::model::GameServerGroupAutoScalingPolicy,
        ) -> Self {
            self.inner = self.inner.auto_scaling_policy(inp);
            self
        }
        pub fn set_auto_scaling_policy(
            mut self,
            input: std::option::Option<crate::model::GameServerGroupAutoScalingPolicy>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_policy(input);
            self
        }
        /// <p>Indicates how GameLift FleetIQ balances the use of Spot Instances and On-Demand Instances in the
        /// game server group. Method options include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SPOT_ONLY</code> - Only Spot Instances are used in the game server group. If Spot
        /// Instances are unavailable or not viable for game hosting, the game server group
        /// provides no hosting capacity until Spot Instances can again be used. Until then,
        /// no new instances are started, and the existing nonviable Spot Instances are
        /// terminated (after current gameplay ends) and are not replaced.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SPOT_PREFERRED</code> - (default value) Spot Instances are used whenever available in
        /// the game server group. If Spot Instances are unavailable, the game server group
        /// continues to provide hosting capacity by falling back to On-Demand Instances.
        /// Existing nonviable Spot Instances are terminated (after current gameplay ends)
        /// and are replaced with new On-Demand Instances.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ON_DEMAND_ONLY</code> - Only On-Demand Instances are used in the game
        /// server group. No Spot Instances are used, even when available, while this
        /// balancing strategy is in force.</p>
        /// </li>
        /// </ul>
        pub fn balancing_strategy(mut self, inp: crate::model::BalancingStrategy) -> Self {
            self.inner = self.inner.balancing_strategy(inp);
            self
        }
        pub fn set_balancing_strategy(
            mut self,
            input: std::option::Option<crate::model::BalancingStrategy>,
        ) -> Self {
            self.inner = self.inner.set_balancing_strategy(input);
            self
        }
        /// <p>A flag that indicates whether instances in the game server group are protected
        /// from early termination. Unprotected instances that have active game servers running might
        /// be terminated during a scale-down event, causing players to be dropped from the game.
        /// Protected instances cannot be terminated while there are active game servers running except
        /// in the event of a forced game server group deletion (see ). An exception to this is with Spot
        /// Instances, which can be terminated by AWS regardless of protection status. This property is set to <code>NO_PROTECTION</code> by default.</p>
        pub fn game_server_protection_policy(
            mut self,
            inp: crate::model::GameServerProtectionPolicy,
        ) -> Self {
            self.inner = self.inner.game_server_protection_policy(inp);
            self
        }
        pub fn set_game_server_protection_policy(
            mut self,
            input: std::option::Option<crate::model::GameServerProtectionPolicy>,
        ) -> Self {
            self.inner = self.inner.set_game_server_protection_policy(input);
            self
        }
        /// Appends an item to `VpcSubnets`.
        ///
        /// To override the contents of this collection use [`set_vpc_subnets`](Self::set_vpc_subnets).
        /// <p>A list of virtual private cloud (VPC) subnets to use with instances in the game server
        /// group. By default, all GameLift FleetIQ-supported Availability Zones are used. You can use this
        /// parameter to specify VPCs that you've set up. This property cannot be updated after the
        /// game server group is created, and the corresponding Auto Scaling group will always use
        /// the property value that is set with this request, even if the Auto Scaling group is
        /// updated directly.</p>
        pub fn vpc_subnets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_subnets(inp);
            self
        }
        pub fn set_vpc_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_subnets(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A list of labels to assign to the new game server group resource. Tags are
        /// developer-defined key-value pairs. Tagging AWS resources is useful for resource
        /// management, access management, and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging AWS
        /// Resources</a> in the <i>AWS General Reference</i>. Once the
        /// resource is created, you can use <a>TagResource</a>, <a>UntagResource</a>, and <a>ListTagsForResource</a> to add, remove,
        /// and view tags, respectively. The maximum tag limit may be lower than stated. See the
        /// AWS General Reference for actual tagging limits.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateGameSession<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_game_session_input::Builder,
    }
    impl<C, M, R> CreateGameSession<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateGameSessionOutput,
            smithy_http::result::SdkError<crate::error::CreateGameSessionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateGameSessionInputOperationOutputAlias,
                crate::output::CreateGameSessionOutput,
                crate::error::CreateGameSessionError,
                crate::input::CreateGameSessionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to create a game session in. You can use either the fleet ID or ARN value. Each
        /// request must reference either a fleet ID or alias ID, but not both.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>A unique identifier for the alias associated with the fleet to create a game session in. You can use either the
        /// alias ID or ARN value. Each request must reference either a fleet ID or alias ID, but
        /// not both.</p>
        pub fn alias_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alias_id(inp);
            self
        }
        pub fn set_alias_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alias_id(input);
            self
        }
        /// <p>The maximum number of players that can be connected simultaneously to the game session.</p>
        pub fn maximum_player_session_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_player_session_count(inp);
            self
        }
        pub fn set_maximum_player_session_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_player_session_count(input);
            self
        }
        /// <p>A descriptive label that is associated with a game session. Session names do not need to be unique.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// Appends an item to `GameProperties`.
        ///
        /// To override the contents of this collection use [`set_game_properties`](Self::set_game_properties).
        /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process in the
        /// <a>GameSession</a> object with a request to start a new game session.</p>
        pub fn game_properties(mut self, inp: impl Into<crate::model::GameProperty>) -> Self {
            self.inner = self.inner.game_properties(inp);
            self
        }
        pub fn set_game_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GameProperty>>,
        ) -> Self {
            self.inner = self.inner.set_game_properties(input);
            self
        }
        /// <p>A unique identifier for a player or entity creating the game session. This parameter is required when
        /// requesting a new game session on a fleet with a resource creation limit policy. This
        /// type of policy limits the number of concurrent active game sessions that one player can
        /// create within a certain time span. GameLift uses the CreatorId to evaluate the new
        /// request against the policy.</p>
        pub fn creator_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_id(inp);
            self
        }
        pub fn set_creator_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_creator_id(input);
            self
        }
        /// <p>
        /// <i>This parameter is no longer preferred. Please use
        /// <code>IdempotencyToken</code> instead.</i> Custom string that uniquely
        /// identifies a request for a new game session. Maximum token length is 48 characters. If
        /// provided, this string is included in the new game session's ID.</p>
        pub fn game_session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_id(inp);
            self
        }
        pub fn set_game_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_id(input);
            self
        }
        /// <p>Custom string that uniquely identifies the new game session request.  This is useful
        /// for ensuring that game session requests with the same idempotency token are processed
        /// only once. Subsequent requests with the same string return the original
        /// <code>GameSession</code> object, with an updated status. Maximum token length is 48
        /// characters. If provided, this string is included in the new game session's ID.
        /// A game session ARN has the following format:
        /// <code>arn:aws:gamelift:<region>::gamesession/<fleet ID>/<custom ID string or idempotency token></code>. Idempotency tokens remain in use for 30 days after a game session has ended;
        /// game session objects are retained for this time period and then deleted.</p>
        pub fn idempotency_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.idempotency_token(inp);
            self
        }
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_idempotency_token(input);
            self
        }
        /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process in the
        /// <a>GameSession</a> object with a request to start a new game session.</p>
        pub fn game_session_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_data(inp);
            self
        }
        pub fn set_game_session_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_data(input);
            self
        }
        /// <p>A fleet's remote location to place the new game session in. If this parameter is not
        /// set, the new game session is placed in the fleet's home Region. Specify a remote
        /// location with an AWS Region code such as <code>us-west-2</code>.  </p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateGameSessionQueue<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_game_session_queue_input::Builder,
    }
    impl<C, M, R> CreateGameSessionQueue<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateGameSessionQueueOutput,
            smithy_http::result::SdkError<crate::error::CreateGameSessionQueueError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateGameSessionQueueInputOperationOutputAlias,
                crate::output::CreateGameSessionQueueOutput,
                crate::error::CreateGameSessionQueueError,
                crate::input::CreateGameSessionQueueInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A descriptive label that is associated with game session queue. Queue names must be unique within each Region.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The maximum time, in seconds, that a new game session placement request remains in the queue. When a request exceeds this time, the game session placement changes to a <code>TIMED_OUT</code> status.</p>
        pub fn timeout_in_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.timeout_in_seconds(inp);
            self
        }
        pub fn set_timeout_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_timeout_in_seconds(input);
            self
        }
        /// Appends an item to `PlayerLatencyPolicies`.
        ///
        /// To override the contents of this collection use [`set_player_latency_policies`](Self::set_player_latency_policies).
        /// <p>A set of policies that act as a sliding cap on player latency. FleetIQ works to
        /// deliver low latency for most players in a game session. These policies ensure that no
        /// individual player can be placed into a game with unreasonably high latency. Use multiple
        /// policies to gradually relax latency requirements a step at a time. Multiple policies are applied based on their
        /// maximum allowed latency, starting with the lowest value.</p>
        pub fn player_latency_policies(
            mut self,
            inp: impl Into<crate::model::PlayerLatencyPolicy>,
        ) -> Self {
            self.inner = self.inner.player_latency_policies(inp);
            self
        }
        pub fn set_player_latency_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlayerLatencyPolicy>>,
        ) -> Self {
            self.inner = self.inner.set_player_latency_policies(input);
            self
        }
        /// Appends an item to `Destinations`.
        ///
        /// To override the contents of this collection use [`set_destinations`](Self::set_destinations).
        /// <p>A list of fleets and/or fleet aliases that can be used to fulfill game session placement requests in the queue.
        /// Destinations are identified by either a fleet ARN or a fleet alias ARN, and are listed in order of placement preference.</p>
        pub fn destinations(
            mut self,
            inp: impl Into<crate::model::GameSessionQueueDestination>,
        ) -> Self {
            self.inner = self.inner.destinations(inp);
            self
        }
        pub fn set_destinations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GameSessionQueueDestination>>,
        ) -> Self {
            self.inner = self.inner.set_destinations(input);
            self
        }
        /// <p>A list of locations where a queue is allowed to place new game sessions. Locations
        /// are specified in the form of AWS Region codes, such as <code>us-west-2</code>. If this parameter is
        /// not set, game sessions can be placed in any queue location. </p>
        pub fn filter_configuration(mut self, inp: crate::model::FilterConfiguration) -> Self {
            self.inner = self.inner.filter_configuration(inp);
            self
        }
        pub fn set_filter_configuration(
            mut self,
            input: std::option::Option<crate::model::FilterConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_filter_configuration(input);
            self
        }
        /// <p>Custom settings to use when prioritizing destinations and locations for game session placements. This
        /// configuration replaces the FleetIQ default prioritization process. Priority types that are not explicitly
        /// named will be automatically applied at the end of the prioritization process. </p>
        pub fn priority_configuration(mut self, inp: crate::model::PriorityConfiguration) -> Self {
            self.inner = self.inner.priority_configuration(inp);
            self
        }
        pub fn set_priority_configuration(
            mut self,
            input: std::option::Option<crate::model::PriorityConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_priority_configuration(input);
            self
        }
        /// <p>
        /// Information to be added to all events that are related to this game session queue.
        /// </p>
        pub fn custom_event_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.custom_event_data(inp);
            self
        }
        pub fn set_custom_event_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_custom_event_data(input);
            self
        }
        /// <p>An SNS topic ARN that is set up to receive game session placement notifications. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/queue-notification.html">
        /// Setting up notifications for game session placement</a>.</p>
        pub fn notification_target(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_target(inp);
            self
        }
        pub fn set_notification_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_target(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A list of labels to assign to the new game session queue resource. Tags are developer-defined
        /// key-value pairs. Tagging
        /// AWS resources are useful for resource management, access management and cost allocation.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging AWS Resources</a> in the
        /// <i>AWS General Reference</i>. Once the resource is created, you can
        /// use <a>TagResource</a>, <a>UntagResource</a>, and
        /// <a>ListTagsForResource</a> to add, remove, and view tags. The
        /// maximum tag limit may be lower than stated. See the AWS General Reference for actual
        /// tagging limits.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMatchmakingConfiguration<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_matchmaking_configuration_input::Builder,
    }
    impl<C, M, R> CreateMatchmakingConfiguration<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateMatchmakingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateMatchmakingConfigurationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateMatchmakingConfigurationInputOperationOutputAlias,
                crate::output::CreateMatchmakingConfigurationOutput,
                crate::error::CreateMatchmakingConfigurationError,
                crate::input::CreateMatchmakingConfigurationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the matchmaking configuration. This name is used to identify the configuration associated with a
        /// matchmaking request or ticket.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A human-readable description of the matchmaking configuration. </p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Appends an item to `GameSessionQueueArns`.
        ///
        /// To override the contents of this collection use [`set_game_session_queue_arns`](Self::set_game_session_queue_arns).
        /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) that is assigned to a GameLift game session queue resource and uniquely identifies it. ARNs are unique across all Regions. Format is <code>arn:aws:gamelift:<region>::gamesessionqueue/<queue name></code>. Queues can be located in any Region. Queues are used to start new
        /// GameLift-hosted game sessions for matches that are created with this matchmaking
        /// configuration. If <code>FlexMatchMode</code> is set to <code>STANDALONE</code>, do not
        /// set this parameter.  </p>
        pub fn game_session_queue_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_queue_arns(inp);
            self
        }
        pub fn set_game_session_queue_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_game_session_queue_arns(input);
            self
        }
        /// <p>The maximum duration, in seconds, that a matchmaking ticket can remain in process
        /// before timing out. Requests that fail due to timing out can be resubmitted as
        /// needed.</p>
        pub fn request_timeout_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.request_timeout_seconds(inp);
            self
        }
        pub fn set_request_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_request_timeout_seconds(input);
            self
        }
        /// <p>The length of time (in seconds) to wait for players to accept a proposed match, if
        /// acceptance is required. </p>
        pub fn acceptance_timeout_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.acceptance_timeout_seconds(inp);
            self
        }
        pub fn set_acceptance_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_acceptance_timeout_seconds(input);
            self
        }
        /// <p>A flag that determines whether a match that was created with this configuration must
        /// be accepted by the matched players. To require acceptance, set to <code>TRUE</code>.
        /// With this option enabled, matchmaking tickets use the status
        /// <code>REQUIRES_ACCEPTANCE</code> to indicate when a completed potential match is
        /// waiting for player acceptance. </p>
        pub fn acceptance_required(mut self, inp: bool) -> Self {
            self.inner = self.inner.acceptance_required(inp);
            self
        }
        pub fn set_acceptance_required(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_acceptance_required(input);
            self
        }
        /// <p>A unique identifier for the matchmaking rule set to use with this configuration. You can use either the rule set name or ARN
        /// value. A matchmaking configuration can only use rule sets that are defined in the same
        /// Region.</p>
        pub fn rule_set_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(inp);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
        /// <p>An SNS topic ARN that is set up to receive matchmaking notifications. See <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-notification.html">
        /// Setting up notifications for matchmaking</a> for more information.</p>
        pub fn notification_target(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_target(inp);
            self
        }
        pub fn set_notification_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_target(input);
            self
        }
        /// <p>The number of player slots in a match to keep open for future players. For example, if the configuration's rule set specifies
        /// a match for a single 12-person team, and the additional player count is set to 2, only 10 players are selected for the match. This parameter is not used if <code>FlexMatchMode</code> is set to
        /// <code>STANDALONE</code>.</p>
        pub fn additional_player_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.additional_player_count(inp);
            self
        }
        pub fn set_additional_player_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_additional_player_count(input);
            self
        }
        /// <p>Information to be added to all events related to this matchmaking configuration.
        /// </p>
        pub fn custom_event_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.custom_event_data(inp);
            self
        }
        pub fn set_custom_event_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_custom_event_data(input);
            self
        }
        /// Appends an item to `GameProperties`.
        ///
        /// To override the contents of this collection use [`set_game_properties`](Self::set_game_properties).
        /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process in the
        /// <a>GameSession</a> object with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <a>GameSession</a>
        /// object that is created for a successful match. This parameter is not used if
        /// <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
        pub fn game_properties(mut self, inp: impl Into<crate::model::GameProperty>) -> Self {
            self.inner = self.inner.game_properties(inp);
            self
        }
        pub fn set_game_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GameProperty>>,
        ) -> Self {
            self.inner = self.inner.set_game_properties(input);
            self
        }
        /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process in the
        /// <a>GameSession</a> object with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <a>GameSession</a> object
        /// that is created for a successful match. This parameter is not used if
        /// <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
        pub fn game_session_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_data(inp);
            self
        }
        pub fn set_game_session_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_data(input);
            self
        }
        /// <p>The method used to backfill game sessions that are created with this matchmaking
        /// configuration. Specify <code>MANUAL</code> when your game manages backfill requests
        /// manually or does not use the match backfill feature. Specify <code>AUTOMATIC</code> to
        /// have GameLift create a <a>StartMatchBackfill</a> request whenever a game
        /// session has one or more open slots. Learn more about manual and automatic backfill in
        /// <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-backfill.html"> Backfill Existing Games with FlexMatch</a>. Automatic backfill is not
        /// available when <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
        pub fn backfill_mode(mut self, inp: crate::model::BackfillMode) -> Self {
            self.inner = self.inner.backfill_mode(inp);
            self
        }
        pub fn set_backfill_mode(
            mut self,
            input: std::option::Option<crate::model::BackfillMode>,
        ) -> Self {
            self.inner = self.inner.set_backfill_mode(input);
            self
        }
        /// <p>Indicates whether this matchmaking configuration is being used with GameLift hosting or
        /// as a standalone matchmaking solution. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>STANDALONE</b> - FlexMatch forms matches and returns
        /// match information, including players and team assignments, in a
        /// <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-events.html#match-events-matchmakingsucceeded">
        /// MatchmakingSucceeded</a> event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>WITH_QUEUE</b> - FlexMatch forms matches and uses the specified GameLift queue to
        /// start a game session for the match. </p>
        /// </li>
        /// </ul>
        pub fn flex_match_mode(mut self, inp: crate::model::FlexMatchMode) -> Self {
            self.inner = self.inner.flex_match_mode(inp);
            self
        }
        pub fn set_flex_match_mode(
            mut self,
            input: std::option::Option<crate::model::FlexMatchMode>,
        ) -> Self {
            self.inner = self.inner.set_flex_match_mode(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A list of labels to assign to the new matchmaking configuration resource. Tags are developer-defined
        /// key-value pairs. Tagging
        /// AWS resources are useful for resource management, access management and cost allocation.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging AWS Resources</a> in the
        /// <i>AWS General Reference</i>. Once the resource is created, you can
        /// use <a>TagResource</a>, <a>UntagResource</a>, and
        /// <a>ListTagsForResource</a> to add, remove, and view tags. The
        /// maximum tag limit may be lower than stated. See the AWS General Reference for actual
        /// tagging limits.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMatchmakingRuleSet<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_matchmaking_rule_set_input::Builder,
    }
    impl<C, M, R> CreateMatchmakingRuleSet<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateMatchmakingRuleSetOutput,
            smithy_http::result::SdkError<crate::error::CreateMatchmakingRuleSetError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateMatchmakingRuleSetInputOperationOutputAlias,
                crate::output::CreateMatchmakingRuleSetOutput,
                crate::error::CreateMatchmakingRuleSetError,
                crate::input::CreateMatchmakingRuleSetInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the matchmaking rule set. A matchmaking configuration identifies the rule set it uses by this name
        /// value. Note that the rule set name is different from the optional <code>name</code>
        /// field in the rule set body.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A collection of matchmaking rules, formatted as a JSON string. Comments are not
        /// allowed in JSON, but most elements support a description field.</p>
        pub fn rule_set_body(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_body(inp);
            self
        }
        pub fn set_rule_set_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_body(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A list of labels to assign to the new matchmaking rule set resource. Tags are developer-defined
        /// key-value pairs. Tagging
        /// AWS resources are useful for resource management, access management and cost allocation.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging AWS Resources</a> in the
        /// <i>AWS General Reference</i>. Once the resource is created, you can
        /// use <a>TagResource</a>, <a>UntagResource</a>, and
        /// <a>ListTagsForResource</a> to add, remove, and view tags. The
        /// maximum tag limit may be lower than stated. See the AWS General Reference for actual
        /// tagging limits.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePlayerSession<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_player_session_input::Builder,
    }
    impl<C, M, R> CreatePlayerSession<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePlayerSessionOutput,
            smithy_http::result::SdkError<crate::error::CreatePlayerSessionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreatePlayerSessionInputOperationOutputAlias,
                crate::output::CreatePlayerSessionOutput,
                crate::error::CreatePlayerSessionError,
                crate::input::CreatePlayerSessionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game session to add a player to.</p>
        pub fn game_session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_id(inp);
            self
        }
        pub fn set_game_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_id(input);
            self
        }
        /// <p>A unique identifier for a player. Player IDs are developer-defined.</p>
        pub fn player_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.player_id(inp);
            self
        }
        pub fn set_player_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_player_id(input);
            self
        }
        /// <p>Developer-defined information related to a player. GameLift does not use this data, so it can be formatted as needed for use in the game.</p>
        pub fn player_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.player_data(inp);
            self
        }
        pub fn set_player_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_player_data(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePlayerSessions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_player_sessions_input::Builder,
    }
    impl<C, M, R> CreatePlayerSessions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePlayerSessionsOutput,
            smithy_http::result::SdkError<crate::error::CreatePlayerSessionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreatePlayerSessionsInputOperationOutputAlias,
                crate::output::CreatePlayerSessionsOutput,
                crate::error::CreatePlayerSessionsError,
                crate::input::CreatePlayerSessionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game session to add players to.</p>
        pub fn game_session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_id(inp);
            self
        }
        pub fn set_game_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_id(input);
            self
        }
        /// Appends an item to `PlayerIds`.
        ///
        /// To override the contents of this collection use [`set_player_ids`](Self::set_player_ids).
        /// <p>List of unique identifiers for the players to be added.</p>
        pub fn player_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.player_ids(inp);
            self
        }
        pub fn set_player_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_player_ids(input);
            self
        }
        /// Adds a key-value pair to `PlayerDataMap`.
        ///
        /// To override the contents of this collection use [`set_player_data_map`](Self::set_player_data_map).
        /// <p>Map of string pairs, each specifying a player ID and a set of developer-defined
        /// information related to the player. Amazon GameLift does not use this data, so it can be formatted
        /// as needed for use in the game. Any player data strings for player IDs that are not
        /// included in the <code>PlayerIds</code> parameter are ignored. </p>
        pub fn player_data_map(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.player_data_map(k, v);
            self
        }
        pub fn set_player_data_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_player_data_map(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateScript<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_script_input::Builder,
    }
    impl<C, M, R> CreateScript<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateScriptOutput,
            smithy_http::result::SdkError<crate::error::CreateScriptError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateScriptInputOperationOutputAlias,
                crate::output::CreateScriptOutput,
                crate::error::CreateScriptError,
                crate::input::CreateScriptInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A descriptive label that is associated with a script. Script names do not need to be unique. You can use <a>UpdateScript</a> to change this value later.
        /// </p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Version information that is associated with a build or script. Version strings do not need to be unique. You can use <a>UpdateScript</a> to change this value later.
        /// </p>
        pub fn version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(inp);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>The location of the Amazon S3 bucket where a zipped file containing your Realtime scripts is
        /// stored. The storage location must specify the Amazon S3 bucket name, the zip file name (the
        /// "key"), and a role ARN that allows Amazon GameLift to access the Amazon S3 storage location. The S3
        /// bucket must be in the same Region where you want to create a new script. By default,
        /// Amazon GameLift uploads the latest version of the zip file; if you have S3 object versioning
        /// turned on, you can use the <code>ObjectVersion</code> parameter to specify an earlier
        /// version. </p>
        pub fn storage_location(mut self, inp: crate::model::S3Location) -> Self {
            self.inner = self.inner.storage_location(inp);
            self
        }
        pub fn set_storage_location(
            mut self,
            input: std::option::Option<crate::model::S3Location>,
        ) -> Self {
            self.inner = self.inner.set_storage_location(input);
            self
        }
        /// <p>A data object containing your Realtime scripts and dependencies as a zip file. The zip
        /// file can have one or multiple files. Maximum size of a zip file is 5 MB.</p>
        /// <p>When using the AWS CLI tool to create a script, this parameter is set to the zip file name. It must be prepended with the
        /// string "fileb://" to indicate that the file data is a binary object. For example: <code>--zip-file fileb://myRealtimeScript.zip</code>.</p>
        pub fn zip_file(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.zip_file(inp);
            self
        }
        pub fn set_zip_file(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_zip_file(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A list of labels to assign to the new script resource. Tags are developer-defined
        /// key-value pairs. Tagging
        /// AWS resources are useful for resource management, access management and cost allocation.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging AWS Resources</a> in the
        /// <i>AWS General Reference</i>. Once the resource is created, you can
        /// use <a>TagResource</a>, <a>UntagResource</a>, and
        /// <a>ListTagsForResource</a> to add, remove, and view tags. The
        /// maximum tag limit may be lower than stated. See the AWS General Reference for actual
        /// tagging limits.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVpcPeeringAuthorization<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_vpc_peering_authorization_input::Builder,
    }
    impl<C, M, R> CreateVpcPeeringAuthorization<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVpcPeeringAuthorizationOutput,
            smithy_http::result::SdkError<crate::error::CreateVpcPeeringAuthorizationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateVpcPeeringAuthorizationInputOperationOutputAlias,
                crate::output::CreateVpcPeeringAuthorizationOutput,
                crate::error::CreateVpcPeeringAuthorizationError,
                crate::input::CreateVpcPeeringAuthorizationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the AWS account that you use to manage your GameLift fleet.
        /// You can find your Account ID in the AWS Management Console under account settings.</p>
        pub fn game_lift_aws_account_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_lift_aws_account_id(inp);
            self
        }
        pub fn set_game_lift_aws_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_lift_aws_account_id(input);
            self
        }
        /// <p>A unique identifier for a VPC with resources to be accessed by your GameLift fleet. The
        /// VPC must be in the same Region as your fleet. To look up a VPC ID, use the
        /// <a href="https://console.aws.amazon.com/vpc/">VPC Dashboard</a> in the AWS Management Console.
        /// Learn more about VPC peering in <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/vpc-peering.html">VPC Peering with GameLift Fleets</a>.</p>
        pub fn peer_vpc_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_vpc_id(inp);
            self
        }
        pub fn set_peer_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_peer_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVpcPeeringConnection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_vpc_peering_connection_input::Builder,
    }
    impl<C, M, R> CreateVpcPeeringConnection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVpcPeeringConnectionOutput,
            smithy_http::result::SdkError<crate::error::CreateVpcPeeringConnectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateVpcPeeringConnectionInputOperationOutputAlias,
                crate::output::CreateVpcPeeringConnectionOutput,
                crate::error::CreateVpcPeeringConnectionError,
                crate::input::CreateVpcPeeringConnectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet. You can use either the fleet ID or ARN value. This tells Amazon GameLift which GameLift
        /// VPC to peer with. </p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>A unique identifier for the AWS account with the VPC that you want to peer your
        /// Amazon GameLift fleet with. You can find your Account ID in the AWS Management Console under account
        /// settings.</p>
        pub fn peer_vpc_aws_account_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_vpc_aws_account_id(inp);
            self
        }
        pub fn set_peer_vpc_aws_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_peer_vpc_aws_account_id(input);
            self
        }
        /// <p>A unique identifier for a VPC with resources to be accessed by your GameLift fleet. The
        /// VPC must be in the same Region as your fleet. To look up a VPC ID, use the
        /// <a href="https://console.aws.amazon.com/vpc/">VPC Dashboard</a> in the AWS Management Console.
        /// Learn more about VPC peering in <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/vpc-peering.html">VPC Peering with GameLift Fleets</a>.</p>
        pub fn peer_vpc_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_vpc_id(inp);
            self
        }
        pub fn set_peer_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_peer_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAlias<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_alias_input::Builder,
    }
    impl<C, M, R> DeleteAlias<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAliasOutput,
            smithy_http::result::SdkError<crate::error::DeleteAliasError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteAliasInputOperationOutputAlias,
                crate::output::DeleteAliasOutput,
                crate::error::DeleteAliasError,
                crate::input::DeleteAliasInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier of the alias that you want to delete. You can use either the alias
        /// ID or ARN value.</p>
        pub fn alias_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alias_id(inp);
            self
        }
        pub fn set_alias_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alias_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBuild<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_build_input::Builder,
    }
    impl<C, M, R> DeleteBuild<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBuildOutput,
            smithy_http::result::SdkError<crate::error::DeleteBuildError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteBuildInputOperationOutputAlias,
                crate::output::DeleteBuildOutput,
                crate::error::DeleteBuildError,
                crate::input::DeleteBuildInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the build to delete. You can use either the build ID or ARN value. </p>
        pub fn build_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.build_id(inp);
            self
        }
        pub fn set_build_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_build_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFleet<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_fleet_input::Builder,
    }
    impl<C, M, R> DeleteFleet<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFleetOutput,
            smithy_http::result::SdkError<crate::error::DeleteFleetError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteFleetInputOperationOutputAlias,
                crate::output::DeleteFleetOutput,
                crate::error::DeleteFleetError,
                crate::input::DeleteFleetInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to be deleted. You can use either the fleet ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFleetLocations<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_fleet_locations_input::Builder,
    }
    impl<C, M, R> DeleteFleetLocations<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFleetLocationsOutput,
            smithy_http::result::SdkError<crate::error::DeleteFleetLocationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteFleetLocationsInputOperationOutputAlias,
                crate::output::DeleteFleetLocationsOutput,
                crate::error::DeleteFleetLocationsError,
                crate::input::DeleteFleetLocationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to delete locations for.
        /// You can use either the fleet ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// Appends an item to `Locations`.
        ///
        /// To override the contents of this collection use [`set_locations`](Self::set_locations).
        /// <p>The list of fleet locations to delete. Specify locations in the form of an AWS Region code, such as
        /// <code>us-west-2</code>.</p>
        pub fn locations(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.locations(inp);
            self
        }
        pub fn set_locations(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_locations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteGameServerGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_game_server_group_input::Builder,
    }
    impl<C, M, R> DeleteGameServerGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteGameServerGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteGameServerGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteGameServerGroupInputOperationOutputAlias,
                crate::output::DeleteGameServerGroupOutput,
                crate::error::DeleteGameServerGroupError,
                crate::input::DeleteGameServerGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game server group. Use either the <a>GameServerGroup</a> name or ARN value.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// <p>The type of delete to perform. Options include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SAFE_DELETE</code>  (default) Terminates the game server group and
        /// EC2 Auto Scaling group only when it has no game servers that are in
        /// <code>UTILIZED</code> status.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FORCE_DELETE</code>  Terminates the game server group, including all
        /// active game servers regardless of their utilization status, and the EC2 Auto
        /// Scaling group. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RETAIN</code>  Does a safe delete of the game server group but retains
        /// the EC2 Auto Scaling group as is.</p>
        /// </li>
        /// </ul>
        pub fn delete_option(mut self, inp: crate::model::GameServerGroupDeleteOption) -> Self {
            self.inner = self.inner.delete_option(inp);
            self
        }
        pub fn set_delete_option(
            mut self,
            input: std::option::Option<crate::model::GameServerGroupDeleteOption>,
        ) -> Self {
            self.inner = self.inner.set_delete_option(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteGameSessionQueue<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_game_session_queue_input::Builder,
    }
    impl<C, M, R> DeleteGameSessionQueue<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteGameSessionQueueOutput,
            smithy_http::result::SdkError<crate::error::DeleteGameSessionQueueError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteGameSessionQueueInputOperationOutputAlias,
                crate::output::DeleteGameSessionQueueOutput,
                crate::error::DeleteGameSessionQueueError,
                crate::input::DeleteGameSessionQueueInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A descriptive label that is associated with game session queue. Queue names must be unique within each Region. You can use either the queue ID or ARN value. </p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMatchmakingConfiguration<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_matchmaking_configuration_input::Builder,
    }
    impl<C, M, R> DeleteMatchmakingConfiguration<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMatchmakingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteMatchmakingConfigurationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteMatchmakingConfigurationInputOperationOutputAlias,
                crate::output::DeleteMatchmakingConfigurationOutput,
                crate::error::DeleteMatchmakingConfigurationError,
                crate::input::DeleteMatchmakingConfigurationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the matchmaking configuration.  You can use either the configuration name or ARN value.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMatchmakingRuleSet<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_matchmaking_rule_set_input::Builder,
    }
    impl<C, M, R> DeleteMatchmakingRuleSet<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMatchmakingRuleSetOutput,
            smithy_http::result::SdkError<crate::error::DeleteMatchmakingRuleSetError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteMatchmakingRuleSetInputOperationOutputAlias,
                crate::output::DeleteMatchmakingRuleSetOutput,
                crate::error::DeleteMatchmakingRuleSetError,
                crate::input::DeleteMatchmakingRuleSetInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the matchmaking rule set to be deleted. (Note: The rule set name is different from the optional "name"
        /// field in the rule set body.)  You can use either the rule set name or ARN value.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteScalingPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_scaling_policy_input::Builder,
    }
    impl<C, M, R> DeleteScalingPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteScalingPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteScalingPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteScalingPolicyInputOperationOutputAlias,
                crate::output::DeleteScalingPolicyOutput,
                crate::error::DeleteScalingPolicyError,
                crate::input::DeleteScalingPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A unique identifier for the fleet to be deleted. You can use either the fleet ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteScript<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_script_input::Builder,
    }
    impl<C, M, R> DeleteScript<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteScriptOutput,
            smithy_http::result::SdkError<crate::error::DeleteScriptError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteScriptInputOperationOutputAlias,
                crate::output::DeleteScriptOutput,
                crate::error::DeleteScriptError,
                crate::input::DeleteScriptInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the Realtime script to delete. You can use either the script ID or ARN value.</p>
        pub fn script_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.script_id(inp);
            self
        }
        pub fn set_script_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_script_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVpcPeeringAuthorization<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_vpc_peering_authorization_input::Builder,
    }
    impl<C, M, R> DeleteVpcPeeringAuthorization<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVpcPeeringAuthorizationOutput,
            smithy_http::result::SdkError<crate::error::DeleteVpcPeeringAuthorizationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteVpcPeeringAuthorizationInputOperationOutputAlias,
                crate::output::DeleteVpcPeeringAuthorizationOutput,
                crate::error::DeleteVpcPeeringAuthorizationError,
                crate::input::DeleteVpcPeeringAuthorizationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the AWS account that you use to manage your GameLift fleet.
        /// You can find your Account ID in the AWS Management Console under account settings.</p>
        pub fn game_lift_aws_account_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_lift_aws_account_id(inp);
            self
        }
        pub fn set_game_lift_aws_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_lift_aws_account_id(input);
            self
        }
        /// <p>A unique identifier for a VPC with resources to be accessed by your GameLift fleet. The
        /// VPC must be in the same Region as your fleet. To look up a VPC ID, use the
        /// <a href="https://console.aws.amazon.com/vpc/">VPC Dashboard</a> in the AWS Management Console.
        /// Learn more about VPC peering in <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/vpc-peering.html">VPC Peering with GameLift Fleets</a>.</p>
        pub fn peer_vpc_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_vpc_id(inp);
            self
        }
        pub fn set_peer_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_peer_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVpcPeeringConnection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_vpc_peering_connection_input::Builder,
    }
    impl<C, M, R> DeleteVpcPeeringConnection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVpcPeeringConnectionOutput,
            smithy_http::result::SdkError<crate::error::DeleteVpcPeeringConnectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteVpcPeeringConnectionInputOperationOutputAlias,
                crate::output::DeleteVpcPeeringConnectionOutput,
                crate::error::DeleteVpcPeeringConnectionError,
                crate::input::DeleteVpcPeeringConnectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet. This fleet specified must match the fleet referenced in the VPC peering
        /// connection record. You can use either the fleet ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>A unique identifier for a VPC peering connection. This value is included in the <a>VpcPeeringConnection</a> object, which can be retrieved by calling <a>DescribeVpcPeeringConnections</a>.</p>
        pub fn vpc_peering_connection_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_peering_connection_id(inp);
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_peering_connection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterGameServer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::deregister_game_server_input::Builder,
    }
    impl<C, M, R> DeregisterGameServer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterGameServerOutput,
            smithy_http::result::SdkError<crate::error::DeregisterGameServerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeregisterGameServerInputOperationOutputAlias,
                crate::output::DeregisterGameServerOutput,
                crate::error::DeregisterGameServerError,
                crate::input::DeregisterGameServerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game server group where the game server is running.
        /// Use either the <a>GameServerGroup</a> name or ARN value.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// <p>A custom string that uniquely identifies the game server to deregister.</p>
        pub fn game_server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_id(inp);
            self
        }
        pub fn set_game_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAlias<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_alias_input::Builder,
    }
    impl<C, M, R> DescribeAlias<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAliasOutput,
            smithy_http::result::SdkError<crate::error::DescribeAliasError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeAliasInputOperationOutputAlias,
                crate::output::DescribeAliasOutput,
                crate::error::DescribeAliasError,
                crate::input::DescribeAliasInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for the fleet alias that you want to retrieve. You can use
        /// either the alias ID or ARN value. </p>
        pub fn alias_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alias_id(inp);
            self
        }
        pub fn set_alias_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alias_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBuild<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_build_input::Builder,
    }
    impl<C, M, R> DescribeBuild<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBuildOutput,
            smithy_http::result::SdkError<crate::error::DescribeBuildError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeBuildInputOperationOutputAlias,
                crate::output::DescribeBuildOutput,
                crate::error::DescribeBuildError,
                crate::input::DescribeBuildInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the build to retrieve properties for. You can use either the build ID or ARN value. </p>
        pub fn build_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.build_id(inp);
            self
        }
        pub fn set_build_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_build_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEC2InstanceLimits<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_ec2_instance_limits_input::Builder,
    }
    impl<C, M, R> DescribeEC2InstanceLimits<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEc2InstanceLimitsOutput,
            smithy_http::result::SdkError<crate::error::DescribeEC2InstanceLimitsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeEc2InstanceLimitsInputOperationOutputAlias,
                crate::output::DescribeEc2InstanceLimitsOutput,
                crate::error::DescribeEC2InstanceLimitsError,
                crate::input::DescribeEc2InstanceLimitsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of an EC2 instance type that is supported in GameLift. A fleet instance type
        /// determines the computing resources of each instance in the fleet, including CPU, memory,
        /// storage, and networking capacity. Do not specify a value for this parameter to retrieve
        /// limits for all instance types.</p>
        pub fn ec2_instance_type(mut self, inp: crate::model::Ec2InstanceType) -> Self {
            self.inner = self.inner.ec2_instance_type(inp);
            self
        }
        pub fn set_ec2_instance_type(
            mut self,
            input: std::option::Option<crate::model::Ec2InstanceType>,
        ) -> Self {
            self.inner = self.inner.set_ec2_instance_type(input);
            self
        }
        /// <p>The name of a remote location to request instance limits for, in the form of an AWS
        /// Region code such as <code>us-west-2</code>.</p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFleetAttributes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_fleet_attributes_input::Builder,
    }
    impl<C, M, R> DescribeFleetAttributes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFleetAttributesOutput,
            smithy_http::result::SdkError<crate::error::DescribeFleetAttributesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeFleetAttributesInputOperationOutputAlias,
                crate::output::DescribeFleetAttributesOutput,
                crate::error::DescribeFleetAttributesError,
                crate::input::DescribeFleetAttributesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `FleetIds`.
        ///
        /// To override the contents of this collection use [`set_fleet_ids`](Self::set_fleet_ids).
        /// <p>A list of unique fleet identifiers to retrieve attributes for. You can use either the
        /// fleet ID or ARN value. To retrieve attributes for all current fleets, do not include
        /// this parameter. </p>
        pub fn fleet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_ids(inp);
            self
        }
        pub fn set_fleet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_fleet_ids(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages. This parameter is ignored when the request specifies one or a list of fleet
        /// IDs.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value. This parameter is ignored when the request specifies one or a list of fleet
        /// IDs.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFleetCapacity<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_fleet_capacity_input::Builder,
    }
    impl<C, M, R> DescribeFleetCapacity<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFleetCapacityOutput,
            smithy_http::result::SdkError<crate::error::DescribeFleetCapacityError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeFleetCapacityInputOperationOutputAlias,
                crate::output::DescribeFleetCapacityOutput,
                crate::error::DescribeFleetCapacityError,
                crate::input::DescribeFleetCapacityInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `FleetIds`.
        ///
        /// To override the contents of this collection use [`set_fleet_ids`](Self::set_fleet_ids).
        /// <p>A unique identifier for the fleet(s) to retrieve capacity information for. You can use either the fleet ID or ARN
        /// value. Leave this parameter empty to retrieve capacity information for all
        /// fleets.</p>
        pub fn fleet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_ids(inp);
            self
        }
        pub fn set_fleet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_fleet_ids(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages. This parameter is ignored when the request specifies one or a list of fleet
        /// IDs.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value. This parameter is ignored when the request specifies one or a list of fleet
        /// IDs.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFleetEvents<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_fleet_events_input::Builder,
    }
    impl<C, M, R> DescribeFleetEvents<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFleetEventsOutput,
            smithy_http::result::SdkError<crate::error::DescribeFleetEventsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeFleetEventsInputOperationOutputAlias,
                crate::output::DescribeFleetEventsOutput,
                crate::error::DescribeFleetEventsError,
                crate::input::DescribeFleetEventsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to get event logs for.  You can use either the fleet ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>The earliest date to retrieve event logs for. If no start time is specified, this call
        /// returns entries starting from when the fleet was created to the specified end time.
        /// Format is a number expressed in Unix time as milliseconds (ex: "1469498468.057").</p>
        pub fn start_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(inp);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The most recent date to retrieve event logs for. If no end time is specified, this
        /// call returns entries from the specified start time up to the present. Format is a number
        /// expressed in Unix time as milliseconds (ex: "1469498468.057").</p>
        pub fn end_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(inp);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFleetLocationAttributes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_fleet_location_attributes_input::Builder,
    }
    impl<C, M, R> DescribeFleetLocationAttributes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFleetLocationAttributesOutput,
            smithy_http::result::SdkError<crate::error::DescribeFleetLocationAttributesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeFleetLocationAttributesInputOperationOutputAlias,
                crate::output::DescribeFleetLocationAttributesOutput,
                crate::error::DescribeFleetLocationAttributesError,
                crate::input::DescribeFleetLocationAttributesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to retrieve remote locations for. You can use either the fleet ID or ARN
        /// value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// Appends an item to `Locations`.
        ///
        /// To override the contents of this collection use [`set_locations`](Self::set_locations).
        /// <p>A list of fleet locations to retrieve information for. Specify locations in the form of an AWS Region code, such as
        /// <code>us-west-2</code>.</p>
        pub fn locations(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.locations(inp);
            self
        }
        pub fn set_locations(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_locations(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages. This limit is not currently enforced. </p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFleetLocationCapacity<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_fleet_location_capacity_input::Builder,
    }
    impl<C, M, R> DescribeFleetLocationCapacity<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFleetLocationCapacityOutput,
            smithy_http::result::SdkError<crate::error::DescribeFleetLocationCapacityError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeFleetLocationCapacityInputOperationOutputAlias,
                crate::output::DescribeFleetLocationCapacityOutput,
                crate::error::DescribeFleetLocationCapacityError,
                crate::input::DescribeFleetLocationCapacityInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to request location capacity for.
        /// You can use either the fleet ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>The fleet location to retrieve capacity information for. Specify a location in the form of an AWS Region code, such as
        /// <code>us-west-2</code>.</p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFleetLocationUtilization<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_fleet_location_utilization_input::Builder,
    }
    impl<C, M, R> DescribeFleetLocationUtilization<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFleetLocationUtilizationOutput,
            smithy_http::result::SdkError<crate::error::DescribeFleetLocationUtilizationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeFleetLocationUtilizationInputOperationOutputAlias,
                crate::output::DescribeFleetLocationUtilizationOutput,
                crate::error::DescribeFleetLocationUtilizationError,
                crate::input::DescribeFleetLocationUtilizationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to request location utilization for.
        /// You can use either the fleet ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>The fleet location to retrieve utilization information for. Specify a location in the form of an AWS Region code, such as
        /// <code>us-west-2</code>.</p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFleetPortSettings<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_fleet_port_settings_input::Builder,
    }
    impl<C, M, R> DescribeFleetPortSettings<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFleetPortSettingsOutput,
            smithy_http::result::SdkError<crate::error::DescribeFleetPortSettingsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeFleetPortSettingsInputOperationOutputAlias,
                crate::output::DescribeFleetPortSettingsOutput,
                crate::error::DescribeFleetPortSettingsError,
                crate::input::DescribeFleetPortSettingsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to retrieve port settings for. You can use either the fleet ID or ARN
        /// value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>A remote location to check for status of port setting updates. Use the AWS Region code
        /// format, such as <code>us-west-2</code>.</p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFleetUtilization<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_fleet_utilization_input::Builder,
    }
    impl<C, M, R> DescribeFleetUtilization<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFleetUtilizationOutput,
            smithy_http::result::SdkError<crate::error::DescribeFleetUtilizationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeFleetUtilizationInputOperationOutputAlias,
                crate::output::DescribeFleetUtilizationOutput,
                crate::error::DescribeFleetUtilizationError,
                crate::input::DescribeFleetUtilizationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `FleetIds`.
        ///
        /// To override the contents of this collection use [`set_fleet_ids`](Self::set_fleet_ids).
        /// <p>A unique identifier for the fleet(s) to retrieve utilization data for. You can use either the fleet ID or ARN
        /// value. To retrieve attributes for all current fleets, do not include this parameter. </p>
        pub fn fleet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_ids(inp);
            self
        }
        pub fn set_fleet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_fleet_ids(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages. This parameter is ignored when the request specifies one or a list of fleet
        /// IDs.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value. This parameter is ignored when the request specifies one or a list of fleet
        /// IDs.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeGameServer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_game_server_input::Builder,
    }
    impl<C, M, R> DescribeGameServer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeGameServerOutput,
            smithy_http::result::SdkError<crate::error::DescribeGameServerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeGameServerInputOperationOutputAlias,
                crate::output::DescribeGameServerOutput,
                crate::error::DescribeGameServerError,
                crate::input::DescribeGameServerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game server group where the game server is running.
        /// Use either the <a>GameServerGroup</a> name or ARN value.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// <p>A custom string that uniquely identifies the game server information to be retrieved.</p>
        pub fn game_server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_id(inp);
            self
        }
        pub fn set_game_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeGameServerGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_game_server_group_input::Builder,
    }
    impl<C, M, R> DescribeGameServerGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeGameServerGroupOutput,
            smithy_http::result::SdkError<crate::error::DescribeGameServerGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeGameServerGroupInputOperationOutputAlias,
                crate::output::DescribeGameServerGroupOutput,
                crate::error::DescribeGameServerGroupError,
                crate::input::DescribeGameServerGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game server group. Use either the <a>GameServerGroup</a> name or ARN value.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeGameServerInstances<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_game_server_instances_input::Builder,
    }
    impl<C, M, R> DescribeGameServerInstances<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeGameServerInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeGameServerInstancesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeGameServerInstancesInputOperationOutputAlias,
                crate::output::DescribeGameServerInstancesOutput,
                crate::error::DescribeGameServerInstancesError,
                crate::input::DescribeGameServerInstancesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game server group. Use either the <a>GameServerGroup</a> name or ARN value.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// Appends an item to `InstanceIds`.
        ///
        /// To override the contents of this collection use [`set_instance_ids`](Self::set_instance_ids).
        /// <p>The EC2 instance IDs that you want to retrieve status on. EC2 instance IDs use a
        /// 17-character format, for example: <code>i-1234567890abcdef0</code>. To retrieve all
        /// instances in the game server group, leave this parameter empty. </p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>
        /// The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.
        /// </p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>
        /// A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeGameSessionDetails<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_game_session_details_input::Builder,
    }
    impl<C, M, R> DescribeGameSessionDetails<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeGameSessionDetailsOutput,
            smithy_http::result::SdkError<crate::error::DescribeGameSessionDetailsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeGameSessionDetailsInputOperationOutputAlias,
                crate::output::DescribeGameSessionDetailsOutput,
                crate::error::DescribeGameSessionDetailsError,
                crate::input::DescribeGameSessionDetailsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to retrieve all game sessions active on the fleet. You can use either the fleet
        /// ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>A unique identifier for the game session to retrieve. </p>
        pub fn game_session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_id(inp);
            self
        }
        pub fn set_game_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_id(input);
            self
        }
        /// <p>A unique identifier for the alias associated with the fleet to retrieve all game sessions for. You can use either
        /// the alias ID or ARN value.</p>
        pub fn alias_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alias_id(inp);
            self
        }
        pub fn set_alias_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alias_id(input);
            self
        }
        /// <p>A fleet location to get game sessions for. You can specify a fleet's home Region or a
        /// remote location. Use the AWS Region code format, such as <code>us-west-2</code>. </p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
        /// <p>Game session status to filter results on. Possible game session statuses include
        /// <code>ACTIVE</code>, <code>TERMINATED</code>, <code>ACTIVATING</code> and
        /// <code>TERMINATING</code> (the last two are transitory). </p>
        pub fn status_filter(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status_filter(inp);
            self
        }
        pub fn set_status_filter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_status_filter(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeGameSessionPlacement<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_game_session_placement_input::Builder,
    }
    impl<C, M, R> DescribeGameSessionPlacement<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeGameSessionPlacementOutput,
            smithy_http::result::SdkError<crate::error::DescribeGameSessionPlacementError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeGameSessionPlacementInputOperationOutputAlias,
                crate::output::DescribeGameSessionPlacementOutput,
                crate::error::DescribeGameSessionPlacementError,
                crate::input::DescribeGameSessionPlacementInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for a game session placement to retrieve.</p>
        pub fn placement_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.placement_id(inp);
            self
        }
        pub fn set_placement_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_placement_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeGameSessionQueues<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_game_session_queues_input::Builder,
    }
    impl<C, M, R> DescribeGameSessionQueues<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeGameSessionQueuesOutput,
            smithy_http::result::SdkError<crate::error::DescribeGameSessionQueuesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeGameSessionQueuesInputOperationOutputAlias,
                crate::output::DescribeGameSessionQueuesOutput,
                crate::error::DescribeGameSessionQueuesError,
                crate::input::DescribeGameSessionQueuesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `Names`.
        ///
        /// To override the contents of this collection use [`set_names`](Self::set_names).
        /// <p>A list of queue names to retrieve information for. You can use either the queue ID or
        /// ARN value. To request settings for all queues, leave this parameter empty. </p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages. You can request up to 50 results.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeGameSessions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_game_sessions_input::Builder,
    }
    impl<C, M, R> DescribeGameSessions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeGameSessionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeGameSessionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeGameSessionsInputOperationOutputAlias,
                crate::output::DescribeGameSessionsOutput,
                crate::error::DescribeGameSessionsError,
                crate::input::DescribeGameSessionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to retrieve game sessions for. You can use either the fleet ID or ARN value. </p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>A unique identifier for the game session to retrieve. </p>
        pub fn game_session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_id(inp);
            self
        }
        pub fn set_game_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_id(input);
            self
        }
        /// <p>A unique identifier for the alias associated with the fleet to retrieve game sessions for. You can use either the
        /// alias ID or ARN value.</p>
        pub fn alias_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alias_id(inp);
            self
        }
        pub fn set_alias_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alias_id(input);
            self
        }
        /// <p>A fleet location to get game session details for. You can specify a fleet's home
        /// Region or a remote location. Use the AWS Region code format, such as
        /// <code>us-west-2</code>. </p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
        /// <p>Game session status to filter results on. You can filter on the following states:
        /// <code>ACTIVE</code>, <code>TERMINATED</code>, <code>ACTIVATING</code>, and
        /// <code>TERMINATING</code>. The last two are transitory and used for only very brief
        /// periods of time. </p>
        pub fn status_filter(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status_filter(inp);
            self
        }
        pub fn set_status_filter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_status_filter(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInstances<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_instances_input::Builder,
    }
    impl<C, M, R> DescribeInstances<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstancesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeInstancesInputOperationOutputAlias,
                crate::output::DescribeInstancesOutput,
                crate::error::DescribeInstancesError,
                crate::input::DescribeInstancesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to retrieve instance information for.  You can use either the fleet ID or ARN
        /// value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>A unique identifier for an instance to retrieve. Specify an instance ID or leave
        /// blank to retrieve all instances in the fleet.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The name of a location to retrieve instance information for, in the form of an AWS
        /// Region code such as <code>us-west-2</code>. </p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMatchmaking<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_matchmaking_input::Builder,
    }
    impl<C, M, R> DescribeMatchmaking<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMatchmakingOutput,
            smithy_http::result::SdkError<crate::error::DescribeMatchmakingError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeMatchmakingInputOperationOutputAlias,
                crate::output::DescribeMatchmakingOutput,
                crate::error::DescribeMatchmakingError,
                crate::input::DescribeMatchmakingInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `TicketIds`.
        ///
        /// To override the contents of this collection use [`set_ticket_ids`](Self::set_ticket_ids).
        /// <p>A unique identifier for a matchmaking ticket. You can include up to 10 ID values. </p>
        pub fn ticket_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ticket_ids(inp);
            self
        }
        pub fn set_ticket_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_ticket_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMatchmakingConfigurations<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_matchmaking_configurations_input::Builder,
    }
    impl<C, M, R> DescribeMatchmakingConfigurations<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMatchmakingConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeMatchmakingConfigurationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeMatchmakingConfigurationsInputOperationOutputAlias,
                crate::output::DescribeMatchmakingConfigurationsOutput,
                crate::error::DescribeMatchmakingConfigurationsError,
                crate::input::DescribeMatchmakingConfigurationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `Names`.
        ///
        /// To override the contents of this collection use [`set_names`](Self::set_names).
        /// <p>A unique identifier for the matchmaking configuration(s) to retrieve. You can use either the configuration name or ARN value. To
        /// request all existing configurations, leave this parameter empty.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
        /// <p>A unique identifier for the matchmaking rule set. You can use either the rule set name or ARN value. Use this parameter to
        /// retrieve all matchmaking configurations that use this rule set.</p>
        pub fn rule_set_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(inp);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages. This parameter is limited to 10.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMatchmakingRuleSets<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_matchmaking_rule_sets_input::Builder,
    }
    impl<C, M, R> DescribeMatchmakingRuleSets<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMatchmakingRuleSetsOutput,
            smithy_http::result::SdkError<crate::error::DescribeMatchmakingRuleSetsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeMatchmakingRuleSetsInputOperationOutputAlias,
                crate::output::DescribeMatchmakingRuleSetsOutput,
                crate::error::DescribeMatchmakingRuleSetsError,
                crate::input::DescribeMatchmakingRuleSetsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `Names`.
        ///
        /// To override the contents of this collection use [`set_names`](Self::set_names).
        /// <p>A list of one or more matchmaking rule set names to retrieve details for. (Note: The
        /// rule set name is different from the optional "name" field in the rule set body.) You can
        /// use either the rule set name or ARN value. </p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePlayerSessions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_player_sessions_input::Builder,
    }
    impl<C, M, R> DescribePlayerSessions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePlayerSessionsOutput,
            smithy_http::result::SdkError<crate::error::DescribePlayerSessionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribePlayerSessionsInputOperationOutputAlias,
                crate::output::DescribePlayerSessionsOutput,
                crate::error::DescribePlayerSessionsError,
                crate::input::DescribePlayerSessionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game session to retrieve player sessions for.</p>
        pub fn game_session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_id(inp);
            self
        }
        pub fn set_game_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_id(input);
            self
        }
        /// <p>A unique identifier for a player to retrieve player sessions for.</p>
        pub fn player_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.player_id(inp);
            self
        }
        pub fn set_player_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_player_id(input);
            self
        }
        /// <p>A unique identifier for a player session to retrieve.</p>
        pub fn player_session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.player_session_id(inp);
            self
        }
        pub fn set_player_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_player_session_id(input);
            self
        }
        /// <p>Player session status to filter results on.</p>
        /// <p>Possible player session statuses include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>RESERVED</b> -- The player session request has been
        /// received, but the player has not yet connected to the server process and/or been
        /// validated. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>ACTIVE</b> -- The player has been validated by the
        /// server process and is currently connected.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>COMPLETED</b> -- The player connection has been
        /// dropped.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>TIMEDOUT</b> -- A player session request was
        /// received, but the player did not connect and/or was not validated within the
        /// timeout limit (60 seconds).</p>
        /// </li>
        /// </ul>
        pub fn player_session_status_filter(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.player_session_status_filter(inp);
            self
        }
        pub fn set_player_session_status_filter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_player_session_status_filter(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages. If a player session ID is specified, this parameter is ignored.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value. If a player session ID is specified, this parameter is ignored.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRuntimeConfiguration<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_runtime_configuration_input::Builder,
    }
    impl<C, M, R> DescribeRuntimeConfiguration<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRuntimeConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DescribeRuntimeConfigurationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeRuntimeConfigurationInputOperationOutputAlias,
                crate::output::DescribeRuntimeConfigurationOutput,
                crate::error::DescribeRuntimeConfigurationError,
                crate::input::DescribeRuntimeConfigurationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to get the runtime configuration for. You can use either the fleet ID or ARN
        /// value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScalingPolicies<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_scaling_policies_input::Builder,
    }
    impl<C, M, R> DescribeScalingPolicies<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScalingPoliciesOutput,
            smithy_http::result::SdkError<crate::error::DescribeScalingPoliciesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeScalingPoliciesInputOperationOutputAlias,
                crate::output::DescribeScalingPoliciesOutput,
                crate::error::DescribeScalingPoliciesError,
                crate::input::DescribeScalingPoliciesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to retrieve scaling policies for. You can use either the fleet ID or ARN
        /// value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>Scaling policy status to filter results on. A scaling policy is only in force when
        /// in an <code>ACTIVE</code> status.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>ACTIVE</b> -- The scaling policy is currently in
        /// force.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>UPDATEREQUESTED</b> -- A request to update the
        /// scaling policy has been received.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>UPDATING</b> -- A change is being made to the
        /// scaling policy.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>DELETEREQUESTED</b> -- A request to delete the
        /// scaling policy has been received.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>DELETING</b> -- The scaling policy is being
        /// deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>DELETED</b> -- The scaling policy has been
        /// deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>ERROR</b> -- An error occurred in creating the
        /// policy. It should be removed and recreated.</p>
        /// </li>
        /// </ul>
        pub fn status_filter(mut self, inp: crate::model::ScalingStatusType) -> Self {
            self.inner = self.inner.status_filter(inp);
            self
        }
        pub fn set_status_filter(
            mut self,
            input: std::option::Option<crate::model::ScalingStatusType>,
        ) -> Self {
            self.inner = self.inner.set_status_filter(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>
        /// CONTENT TODO
        /// </p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScript<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_script_input::Builder,
    }
    impl<C, M, R> DescribeScript<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScriptOutput,
            smithy_http::result::SdkError<crate::error::DescribeScriptError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeScriptInputOperationOutputAlias,
                crate::output::DescribeScriptOutput,
                crate::error::DescribeScriptError,
                crate::input::DescribeScriptInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the Realtime script to retrieve properties for. You can use either the script ID or ARN
        /// value.</p>
        pub fn script_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.script_id(inp);
            self
        }
        pub fn set_script_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_script_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcPeeringAuthorizations<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_vpc_peering_authorizations_input::Builder,
    }
    impl<C, M, R> DescribeVpcPeeringAuthorizations<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcPeeringAuthorizationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpcPeeringAuthorizationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeVpcPeeringAuthorizationsInputOperationOutputAlias,
                crate::output::DescribeVpcPeeringAuthorizationsOutput,
                crate::error::DescribeVpcPeeringAuthorizationsError,
                crate::input::DescribeVpcPeeringAuthorizationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcPeeringConnections<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_vpc_peering_connections_input::Builder,
    }
    impl<C, M, R> DescribeVpcPeeringConnections<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcPeeringConnectionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpcPeeringConnectionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeVpcPeeringConnectionsInputOperationOutputAlias,
                crate::output::DescribeVpcPeeringConnectionsOutput,
                crate::error::DescribeVpcPeeringConnectionsError,
                crate::input::DescribeVpcPeeringConnectionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet. You can use either the fleet ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetGameSessionLogUrl<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_game_session_log_url_input::Builder,
    }
    impl<C, M, R> GetGameSessionLogUrl<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetGameSessionLogUrlOutput,
            smithy_http::result::SdkError<crate::error::GetGameSessionLogUrlError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetGameSessionLogUrlInputOperationOutputAlias,
                crate::output::GetGameSessionLogUrlOutput,
                crate::error::GetGameSessionLogUrlError,
                crate::input::GetGameSessionLogUrlInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game session to get logs for. </p>
        pub fn game_session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_id(inp);
            self
        }
        pub fn set_game_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstanceAccess<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_instance_access_input::Builder,
    }
    impl<C, M, R> GetInstanceAccess<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstanceAccessOutput,
            smithy_http::result::SdkError<crate::error::GetInstanceAccessError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetInstanceAccessInputOperationOutputAlias,
                crate::output::GetInstanceAccessOutput,
                crate::error::GetInstanceAccessError,
                crate::input::GetInstanceAccessInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet that contains the instance you want access to. You can use either the fleet ID
        /// or ARN value. The fleet can be in any of the following statuses:
        /// <code>ACTIVATING</code>, <code>ACTIVE</code>, or <code>ERROR</code>. Fleets with an
        /// <code>ERROR</code> status may be accessible for a short time before they are
        /// deleted.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>A unique identifier for the instance you want to get access to. You can access an instance in any
        /// status.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAliases<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_aliases_input::Builder,
    }
    impl<C, M, R> ListAliases<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAliasesOutput,
            smithy_http::result::SdkError<crate::error::ListAliasesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListAliasesInputOperationOutputAlias,
                crate::output::ListAliasesOutput,
                crate::error::ListAliasesError,
                crate::input::ListAliasesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The routing type to filter results on. Use this parameter to retrieve only aliases
        /// with a certain routing type. To retrieve all aliases, leave this parameter empty.</p>
        /// <p>Possible routing types include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>SIMPLE</b> -- The alias resolves to one specific
        /// fleet. Use this type when routing to active fleets.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>TERMINAL</b> -- The alias does not resolve to a
        /// fleet but instead can be used to display a message to the user. A terminal alias
        /// throws a TerminalRoutingStrategyException with the <a>RoutingStrategy</a> message embedded.</p>
        /// </li>
        /// </ul>
        pub fn routing_strategy_type(mut self, inp: crate::model::RoutingStrategyType) -> Self {
            self.inner = self.inner.routing_strategy_type(inp);
            self
        }
        pub fn set_routing_strategy_type(
            mut self,
            input: std::option::Option<crate::model::RoutingStrategyType>,
        ) -> Self {
            self.inner = self.inner.set_routing_strategy_type(input);
            self
        }
        /// <p>A descriptive label that is associated with an alias. Alias names do not need to be unique.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBuilds<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_builds_input::Builder,
    }
    impl<C, M, R> ListBuilds<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListBuildsOutput,
            smithy_http::result::SdkError<crate::error::ListBuildsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListBuildsInputOperationOutputAlias,
                crate::output::ListBuildsOutput,
                crate::error::ListBuildsError,
                crate::input::ListBuildsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Build status to filter results by. To retrieve all builds, leave this parameter
        /// empty.</p>
        /// <p>Possible build statuses include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>INITIALIZED</b> -- A new build has been defined,
        /// but no files have been uploaded. You cannot create fleets for builds that are in
        /// this status. When a build is successfully created, the build status is set to
        /// this value. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>READY</b> -- The game build has been successfully
        /// uploaded. You can now create new fleets for this build.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>FAILED</b> -- The game build upload failed. You
        /// cannot create new fleets for this build. </p>
        /// </li>
        /// </ul>
        pub fn status(mut self, inp: crate::model::BuildStatus) -> Self {
            self.inner = self.inner.status(inp);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::BuildStatus>) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFleets<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_fleets_input::Builder,
    }
    impl<C, M, R> ListFleets<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFleetsOutput,
            smithy_http::result::SdkError<crate::error::ListFleetsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListFleetsInputOperationOutputAlias,
                crate::output::ListFleetsOutput,
                crate::error::ListFleetsError,
                crate::input::ListFleetsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the build to request fleets for. Use this parameter to return only fleets using a
        /// specified build. Use either the build ID or ARN value.</p>
        pub fn build_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.build_id(inp);
            self
        }
        pub fn set_build_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_build_id(input);
            self
        }
        /// <p>A unique identifier for the Realtime script to request fleets for. Use this parameter to return only fleets using a
        /// specified script. Use either the script ID or ARN value.</p>
        pub fn script_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.script_id(inp);
            self
        }
        pub fn set_script_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_script_id(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGameServerGroups<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_game_server_groups_input::Builder,
    }
    impl<C, M, R> ListGameServerGroups<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListGameServerGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListGameServerGroupsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListGameServerGroupsInputOperationOutputAlias,
                crate::output::ListGameServerGroupsOutput,
                crate::error::ListGameServerGroupsError,
                crate::input::ListGameServerGroupsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGameServers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_game_servers_input::Builder,
    }
    impl<C, M, R> ListGameServers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListGameServersOutput,
            smithy_http::result::SdkError<crate::error::ListGameServersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListGameServersInputOperationOutputAlias,
                crate::output::ListGameServersOutput,
                crate::error::ListGameServersError,
                crate::input::ListGameServersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier for the game server group to retrieve a list of game servers from.
        /// Use either the <a>GameServerGroup</a> name or ARN value.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// <p>Indicates how to sort the returned data based on game server registration timestamp.
        /// Use <code>ASCENDING</code> to retrieve oldest game servers first, or use
        /// <code>DESCENDING</code> to retrieve newest game servers first. If this parameter is
        /// left empty, game servers are returned in no particular order.</p>
        pub fn sort_order(mut self, inp: crate::model::SortOrder) -> Self {
            self.inner = self.inner.sort_order(inp);
            self
        }
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrder>,
        ) -> Self {
            self.inner = self.inner.set_sort_order(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListScripts<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_scripts_input::Builder,
    }
    impl<C, M, R> ListScripts<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListScriptsOutput,
            smithy_http::result::SdkError<crate::error::ListScriptsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListScriptsInputOperationOutputAlias,
                crate::output::ListScriptsOutput,
                crate::error::ListScriptsError,
                crate::input::ListScriptsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C, M, R> ListTagsForResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForResourceInputOperationOutputAlias,
                crate::output::ListTagsForResourceOutput,
                crate::error::ListTagsForResourceError,
                crate::input::ListTagsForResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The Amazon Resource Name
        /// (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>)
        /// that is assigned to and uniquely identifies the GameLift resource that you want to retrieve
        /// tags for. GameLift resource ARNs are included in the data object for the resource, which
        /// can be retrieved by calling a List or Describe operation for the resource type. </p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutScalingPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_scaling_policy_input::Builder,
    }
    impl<C, M, R> PutScalingPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutScalingPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutScalingPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutScalingPolicyInputOperationOutputAlias,
                crate::output::PutScalingPolicyOutput,
                crate::error::PutScalingPolicyError,
                crate::input::PutScalingPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique. A fleet can have only one scaling policy with the same name.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A unique identifier for the fleet to apply this policy to. You can use either the fleet ID or ARN value. The fleet
        /// cannot be in any of the following statuses: ERROR or DELETING.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>Amount of adjustment to make, based on the scaling adjustment type.</p>
        pub fn scaling_adjustment(mut self, inp: i32) -> Self {
            self.inner = self.inner.scaling_adjustment(inp);
            self
        }
        pub fn set_scaling_adjustment(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_scaling_adjustment(input);
            self
        }
        /// <p>The type of adjustment to make to a fleet's instance count (see <a>FleetCapacity</a>):</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>ChangeInCapacity</b> -- add (or subtract) the
        /// scaling adjustment value from the current instance count. Positive values scale
        /// up while negative values scale down.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>ExactCapacity</b> -- set the instance count to the
        /// scaling adjustment value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>PercentChangeInCapacity</b> -- increase or reduce
        /// the current instance count by the scaling adjustment, read as a percentage.
        /// Positive values scale up while negative values scale down; for example, a value
        /// of "-10" scales the fleet down by 10%.</p>
        /// </li>
        /// </ul>
        pub fn scaling_adjustment_type(mut self, inp: crate::model::ScalingAdjustmentType) -> Self {
            self.inner = self.inner.scaling_adjustment_type(inp);
            self
        }
        pub fn set_scaling_adjustment_type(
            mut self,
            input: std::option::Option<crate::model::ScalingAdjustmentType>,
        ) -> Self {
            self.inner = self.inner.set_scaling_adjustment_type(input);
            self
        }
        /// <p>Metric value used to trigger a scaling event.</p>
        pub fn threshold(mut self, inp: f64) -> Self {
            self.inner = self.inner.threshold(inp);
            self
        }
        pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
            self.inner = self.inner.set_threshold(input);
            self
        }
        /// <p>Comparison operator to use when measuring the metric against the threshold
        /// value.</p>
        pub fn comparison_operator(mut self, inp: crate::model::ComparisonOperatorType) -> Self {
            self.inner = self.inner.comparison_operator(inp);
            self
        }
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<crate::model::ComparisonOperatorType>,
        ) -> Self {
            self.inner = self.inner.set_comparison_operator(input);
            self
        }
        /// <p>Length of time (in minutes) the metric must be at or beyond the threshold before a
        /// scaling event is triggered.</p>
        pub fn evaluation_periods(mut self, inp: i32) -> Self {
            self.inner = self.inner.evaluation_periods(inp);
            self
        }
        pub fn set_evaluation_periods(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_evaluation_periods(input);
            self
        }
        /// <p>Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment. For
        /// detailed descriptions of fleet metrics, see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/monitoring-cloudwatch.html">Monitor Amazon GameLift
        /// with Amazon CloudWatch</a>. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>ActivatingGameSessions</b> -- Game sessions in
        /// the process of being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>ActiveGameSessions</b> -- Game sessions that
        /// are currently running.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>ActiveInstances</b> -- Fleet instances that
        /// are currently running at least one game session.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>AvailableGameSessions</b> -- Additional game
        /// sessions that fleet could host simultaneously, given current capacity.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>AvailablePlayerSessions</b> -- Empty player
        /// slots in currently active game sessions. This includes game sessions that are
        /// not currently accepting players. Reserved player slots are not
        /// included.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>CurrentPlayerSessions</b> -- Player slots in
        /// active game sessions that are being used by a player or are reserved for a
        /// player. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>IdleInstances</b> -- Active instances that are
        /// currently hosting zero game sessions. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>PercentAvailableGameSessions</b> -- Unused
        /// percentage of the total number of game sessions that a fleet could host
        /// simultaneously, given current capacity. Use this metric for a target-based
        /// scaling policy.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>PercentIdleInstances</b> -- Percentage of the
        /// total number of active instances that are hosting zero game sessions.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>QueueDepth</b> -- Pending game session
        /// placement requests, in any queue, where the current fleet is the top-priority
        /// destination.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>WaitTime</b> -- Current wait time for pending
        /// game session placement requests, in any queue, where the current fleet is the
        /// top-priority destination. </p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, inp: crate::model::MetricName) -> Self {
            self.inner = self.inner.metric_name(inp);
            self
        }
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::MetricName>,
        ) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The type of scaling policy to create. For a target-based policy, set the parameter
        /// <i>MetricName</i> to 'PercentAvailableGameSessions' and specify a
        /// <i>TargetConfiguration</i>. For a rule-based policy set the following
        /// parameters: <i>MetricName</i>, <i>ComparisonOperator</i>,
        /// <i>Threshold</i>, <i>EvaluationPeriods</i>,
        /// <i>ScalingAdjustmentType</i>, and
        /// <i>ScalingAdjustment</i>.</p>
        pub fn policy_type(mut self, inp: crate::model::PolicyType) -> Self {
            self.inner = self.inner.policy_type(inp);
            self
        }
        pub fn set_policy_type(
            mut self,
            input: std::option::Option<crate::model::PolicyType>,
        ) -> Self {
            self.inner = self.inner.set_policy_type(input);
            self
        }
        /// <p>An object that contains settings for a target-based scaling policy.</p>
        pub fn target_configuration(mut self, inp: crate::model::TargetConfiguration) -> Self {
            self.inner = self.inner.target_configuration(inp);
            self
        }
        pub fn set_target_configuration(
            mut self,
            input: std::option::Option<crate::model::TargetConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_target_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterGameServer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::register_game_server_input::Builder,
    }
    impl<C, M, R> RegisterGameServer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterGameServerOutput,
            smithy_http::result::SdkError<crate::error::RegisterGameServerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RegisterGameServerInputOperationOutputAlias,
                crate::output::RegisterGameServerOutput,
                crate::error::RegisterGameServerError,
                crate::input::RegisterGameServerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game server group where the game server is running.
        /// Use either the <a>GameServerGroup</a> name or ARN value.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// <p>A custom string that uniquely identifies the game server to register.  
        /// Game server IDs are developer-defined and must be unique across all game server groups in your AWS account.</p>
        pub fn game_server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_id(inp);
            self
        }
        pub fn set_game_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_id(input);
            self
        }
        /// <p>The unique identifier for the instance where the game server is running. This ID is
        /// available in the instance metadata. EC2 instance IDs
        /// use a 17-character format, for example: <code>i-1234567890abcdef0</code>.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>Information that is needed to make inbound client connections to the game server. This
        /// might include the IP address and port, DNS name, and other information.</p>
        pub fn connection_info(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_info(inp);
            self
        }
        pub fn set_connection_info(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_connection_info(input);
            self
        }
        /// <p>A set of custom game server properties, formatted as a single string value. This data
        /// is passed to a game client or service when it requests information on game servers using
        /// <a>ListGameServers</a> or <a>ClaimGameServer</a>. </p>
        pub fn game_server_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_data(inp);
            self
        }
        pub fn set_game_server_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_data(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RequestUploadCredentials<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::request_upload_credentials_input::Builder,
    }
    impl<C, M, R> RequestUploadCredentials<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RequestUploadCredentialsOutput,
            smithy_http::result::SdkError<crate::error::RequestUploadCredentialsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RequestUploadCredentialsInputOperationOutputAlias,
                crate::output::RequestUploadCredentialsOutput,
                crate::error::RequestUploadCredentialsError,
                crate::input::RequestUploadCredentialsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the build to get credentials for. You can use either the build ID or ARN value. </p>
        pub fn build_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.build_id(inp);
            self
        }
        pub fn set_build_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_build_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResolveAlias<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::resolve_alias_input::Builder,
    }
    impl<C, M, R> ResolveAlias<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResolveAliasOutput,
            smithy_http::result::SdkError<crate::error::ResolveAliasError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ResolveAliasInputOperationOutputAlias,
                crate::output::ResolveAliasOutput,
                crate::error::ResolveAliasError,
                crate::input::ResolveAliasInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the alias that you want to retrieve a fleet ID for. You can
        /// use either the alias ID or ARN value.</p>
        pub fn alias_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alias_id(inp);
            self
        }
        pub fn set_alias_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alias_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResumeGameServerGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::resume_game_server_group_input::Builder,
    }
    impl<C, M, R> ResumeGameServerGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResumeGameServerGroupOutput,
            smithy_http::result::SdkError<crate::error::ResumeGameServerGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ResumeGameServerGroupInputOperationOutputAlias,
                crate::output::ResumeGameServerGroupOutput,
                crate::error::ResumeGameServerGroupError,
                crate::input::ResumeGameServerGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game server group. Use either the <a>GameServerGroup</a> name or ARN value.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// Appends an item to `ResumeActions`.
        ///
        /// To override the contents of this collection use [`set_resume_actions`](Self::set_resume_actions).
        /// <p>The activity to resume for this game server group.</p>
        pub fn resume_actions(
            mut self,
            inp: impl Into<crate::model::GameServerGroupAction>,
        ) -> Self {
            self.inner = self.inner.resume_actions(inp);
            self
        }
        pub fn set_resume_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GameServerGroupAction>>,
        ) -> Self {
            self.inner = self.inner.set_resume_actions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchGameSessions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::search_game_sessions_input::Builder,
    }
    impl<C, M, R> SearchGameSessions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchGameSessionsOutput,
            smithy_http::result::SdkError<crate::error::SearchGameSessionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SearchGameSessionsInputOperationOutputAlias,
                crate::output::SearchGameSessionsOutput,
                crate::error::SearchGameSessionsError,
                crate::input::SearchGameSessionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to search for active game sessions. You can use either the fleet ID or ARN
        /// value. Each request must reference either a fleet ID or alias ID, but not both.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>A unique identifier for the alias associated with the fleet to search for active game sessions. You can use either
        /// the alias ID or ARN value. Each request must reference either a fleet ID or alias ID,
        /// but not both.</p>
        pub fn alias_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alias_id(inp);
            self
        }
        pub fn set_alias_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alias_id(input);
            self
        }
        /// <p>A fleet location to search for game sessions. You can specify a fleet's home Region or
        /// a remote location. Use the AWS Region code format, such as <code>us-west-2</code>. </p>
        /// <p> </p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
        /// <p>String containing the search criteria for the session search. If no filter
        /// expression is included, the request returns results for all game sessions in the fleet
        /// that are in <code>ACTIVE</code> status.</p>
        /// <p>A filter expression can contain one or multiple conditions. Each condition consists
        /// of the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Operand</b> -- Name of a game session
        /// attribute. Valid values are <code>gameSessionName</code>,
        /// <code>gameSessionId</code>, <code>gameSessionProperties</code>,
        /// <code>maximumSessions</code>, <code>creationTimeMillis</code>,
        /// <code>playerSessionCount</code>,
        /// <code>hasAvailablePlayerSessions</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Comparator</b> -- Valid comparators are:
        /// <code>=</code>, <code><></code>, <code><</code>, <code>></code>,
        /// <code><=</code>, <code>>=</code>. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Value</b> -- Value to be searched for. Values
        /// may be numbers, boolean values (true/false) or strings depending on the operand.
        /// String values are case sensitive and must be enclosed in single quotes. Special
        /// characters must be escaped. Boolean and string values can only be used with the
        /// comparators <code>=</code> and <code><></code>. For example, the following
        /// filter expression searches on <code>gameSessionName</code>:
        /// "<code>FilterExpression": "gameSessionName = 'Matt\\'s Awesome Game
        /// 1'"</code>. </p>
        /// </li>
        /// </ul>
        /// <p>To chain multiple conditions in a single expression, use the logical keywords
        /// <code>AND</code>, <code>OR</code>, and <code>NOT</code> and parentheses as needed.
        /// For example: <code>x AND y AND NOT z</code>, <code>NOT (x OR y)</code>.</p>
        /// <p>Session search evaluates conditions from left to right using the following
        /// precedence rules:</p>
        /// <ol>
        /// <li>
        /// <p>
        /// <code>=</code>, <code><></code>, <code><</code>, <code>></code>,
        /// <code><=</code>, <code>>=</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Parentheses</p>
        /// </li>
        /// <li>
        /// <p>NOT</p>
        /// </li>
        /// <li>
        /// <p>AND</p>
        /// </li>
        /// <li>
        /// <p>OR</p>
        /// </li>
        /// </ol>
        /// <p>For example, this filter expression retrieves game sessions hosting at least ten
        /// players that have an open player slot: <code>"maximumSessions>=10 AND
        /// hasAvailablePlayerSessions=true"</code>. </p>
        pub fn filter_expression(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_expression(inp);
            self
        }
        pub fn set_filter_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_expression(input);
            self
        }
        /// <p>Instructions on how to sort the search results. If no sort expression is included,
        /// the request returns results in random order. A sort expression consists of the following
        /// elements:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Operand</b> -- Name of a game session attribute.
        /// Valid values are <code>gameSessionName</code>, <code>gameSessionId</code>,
        /// <code>gameSessionProperties</code>, <code>maximumSessions</code>,
        /// <code>creationTimeMillis</code>, <code>playerSessionCount</code>,
        /// <code>hasAvailablePlayerSessions</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Order</b> -- Valid sort orders are <code>ASC</code>
        /// (ascending) and <code>DESC</code> (descending).</p>
        /// </li>
        /// </ul>
        /// <p>For example, this sort expression returns the oldest active sessions first:
        /// <code>"SortExpression": "creationTimeMillis ASC"</code>. Results with a null value
        /// for the sort operand are returned at the end of the list.</p>
        pub fn sort_expression(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sort_expression(inp);
            self
        }
        pub fn set_sort_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sort_expression(input);
            self
        }
        /// <p>The maximum number of results to return. Use this parameter with <code>NextToken</code> to get results as a set of sequential pages. The maximum number of results returned is 20, even if this value is not set
        /// or is set higher than 20. </p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>A token that indicates the start of the next sequential page of results. Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartFleetActions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_fleet_actions_input::Builder,
    }
    impl<C, M, R> StartFleetActions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartFleetActionsOutput,
            smithy_http::result::SdkError<crate::error::StartFleetActionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartFleetActionsInputOperationOutputAlias,
                crate::output::StartFleetActionsOutput,
                crate::error::StartFleetActionsError,
                crate::input::StartFleetActionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to restart actions on.  You can use either the fleet ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// Appends an item to `Actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        /// <p>List of actions to restart on the fleet.</p>
        pub fn actions(mut self, inp: impl Into<crate::model::FleetAction>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FleetAction>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
        /// <p>The fleet location to restart fleet actions for. Specify a location in the form of
        /// an AWS Region code, such as <code>us-west-2</code>.</p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartGameSessionPlacement<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_game_session_placement_input::Builder,
    }
    impl<C, M, R> StartGameSessionPlacement<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartGameSessionPlacementOutput,
            smithy_http::result::SdkError<crate::error::StartGameSessionPlacementError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartGameSessionPlacementInputOperationOutputAlias,
                crate::output::StartGameSessionPlacementOutput,
                crate::error::StartGameSessionPlacementError,
                crate::input::StartGameSessionPlacementInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier to assign to the new game session placement. This value is
        /// developer-defined. The value must be unique across all Regions and cannot be reused
        /// unless you are resubmitting a canceled or timed-out placement request.</p>
        pub fn placement_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.placement_id(inp);
            self
        }
        pub fn set_placement_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_placement_id(input);
            self
        }
        /// <p>Name of the queue to use to place the new game session. You can use either the queue name
        /// or ARN value. </p>
        pub fn game_session_queue_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_queue_name(inp);
            self
        }
        pub fn set_game_session_queue_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_queue_name(input);
            self
        }
        /// Appends an item to `GameProperties`.
        ///
        /// To override the contents of this collection use [`set_game_properties`](Self::set_game_properties).
        /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process in the
        /// <a>GameSession</a> object with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
        pub fn game_properties(mut self, inp: impl Into<crate::model::GameProperty>) -> Self {
            self.inner = self.inner.game_properties(inp);
            self
        }
        pub fn set_game_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GameProperty>>,
        ) -> Self {
            self.inner = self.inner.set_game_properties(input);
            self
        }
        /// <p>The maximum number of players that can be connected simultaneously to the game session.</p>
        pub fn maximum_player_session_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_player_session_count(inp);
            self
        }
        pub fn set_maximum_player_session_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_player_session_count(input);
            self
        }
        /// <p>A descriptive label that is associated with a game session. Session names do not need to be unique.</p>
        pub fn game_session_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_name(inp);
            self
        }
        pub fn set_game_session_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_name(input);
            self
        }
        /// Appends an item to `PlayerLatencies`.
        ///
        /// To override the contents of this collection use [`set_player_latencies`](Self::set_player_latencies).
        /// <p>A set of values, expressed in milliseconds, that indicates the amount of latency that a player experiences when connected to AWS Regions. This information is used to try to place the new game session where
        /// it can offer the best possible gameplay experience for the players. </p>
        pub fn player_latencies(mut self, inp: impl Into<crate::model::PlayerLatency>) -> Self {
            self.inner = self.inner.player_latencies(inp);
            self
        }
        pub fn set_player_latencies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlayerLatency>>,
        ) -> Self {
            self.inner = self.inner.set_player_latencies(input);
            self
        }
        /// Appends an item to `DesiredPlayerSessions`.
        ///
        /// To override the contents of this collection use [`set_desired_player_sessions`](Self::set_desired_player_sessions).
        /// <p>Set of information on each player to create a player session for.</p>
        pub fn desired_player_sessions(
            mut self,
            inp: impl Into<crate::model::DesiredPlayerSession>,
        ) -> Self {
            self.inner = self.inner.desired_player_sessions(inp);
            self
        }
        pub fn set_desired_player_sessions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DesiredPlayerSession>>,
        ) -> Self {
            self.inner = self.inner.set_desired_player_sessions(input);
            self
        }
        /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process in the
        /// <a>GameSession</a> object with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>).</p>
        pub fn game_session_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_data(inp);
            self
        }
        pub fn set_game_session_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_data(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartMatchBackfill<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_match_backfill_input::Builder,
    }
    impl<C, M, R> StartMatchBackfill<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartMatchBackfillOutput,
            smithy_http::result::SdkError<crate::error::StartMatchBackfillError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartMatchBackfillInputOperationOutputAlias,
                crate::output::StartMatchBackfillOutput,
                crate::error::StartMatchBackfillError,
                crate::input::StartMatchBackfillInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for a matchmaking ticket. If no ticket ID is specified here, Amazon GameLift will generate one in the form of
        /// a UUID. Use this identifier to track the match backfill ticket status and retrieve match
        /// results.</p>
        pub fn ticket_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ticket_id(inp);
            self
        }
        pub fn set_ticket_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ticket_id(input);
            self
        }
        /// <p>Name of the matchmaker to use for this request. You can use either the configuration
        /// name or ARN value. The ARN of the matchmaker that was used with the original game
        /// session is listed in the <a>GameSession</a> object,
        /// <code>MatchmakerData</code> property.</p>
        pub fn configuration_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_name(inp);
            self
        }
        pub fn set_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_name(input);
            self
        }
        /// <p>A unique identifier for the game session. Use the game session ID. When using FlexMatch as a standalone matchmaking
        /// solution, this parameter is not needed. </p>
        pub fn game_session_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_arn(inp);
            self
        }
        pub fn set_game_session_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_arn(input);
            self
        }
        /// Appends an item to `Players`.
        ///
        /// To override the contents of this collection use [`set_players`](Self::set_players).
        /// <p>Match information on all players that are currently assigned to the game session.
        /// This information is used by the matchmaker to find new players and add them to the
        /// existing game.</p>
        /// <ul>
        /// <li>
        /// <p>PlayerID, PlayerAttributes, Team -- This information is maintained in the
        /// <a>GameSession</a> object, <code>MatchmakerData</code> property,
        /// for all players who are currently assigned to the game session. The matchmaker
        /// data is in JSON syntax, formatted as a string. For more details, see <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-server.html#match-server-data">
        /// Match Data</a>. </p>
        /// </li>
        /// <li>
        /// <p>LatencyInMs -- If the matchmaker uses player latency, include a latency
        /// value, in milliseconds, for the Region that the game session is currently in. Do
        /// not include latency values for any other Region.</p>
        /// </li>
        /// </ul>
        pub fn players(mut self, inp: impl Into<crate::model::Player>) -> Self {
            self.inner = self.inner.players(inp);
            self
        }
        pub fn set_players(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Player>>,
        ) -> Self {
            self.inner = self.inner.set_players(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartMatchmaking<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_matchmaking_input::Builder,
    }
    impl<C, M, R> StartMatchmaking<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartMatchmakingOutput,
            smithy_http::result::SdkError<crate::error::StartMatchmakingError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartMatchmakingInputOperationOutputAlias,
                crate::output::StartMatchmakingOutput,
                crate::error::StartMatchmakingError,
                crate::input::StartMatchmakingInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for a matchmaking ticket. If no ticket ID is specified here, Amazon GameLift will generate one in the form of
        /// a UUID. Use this identifier to track the matchmaking ticket status and retrieve match
        /// results.</p>
        pub fn ticket_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ticket_id(inp);
            self
        }
        pub fn set_ticket_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ticket_id(input);
            self
        }
        /// <p>Name of the matchmaking configuration to use for this request. Matchmaking
        /// configurations must exist in the same Region as this request. You can use either the
        /// configuration name or ARN value.</p>
        pub fn configuration_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.configuration_name(inp);
            self
        }
        pub fn set_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_configuration_name(input);
            self
        }
        /// Appends an item to `Players`.
        ///
        /// To override the contents of this collection use [`set_players`](Self::set_players).
        /// <p>Information on each player to be matched. This information must include a player
        /// ID, and may contain player attributes and latency data to be used in the matchmaking
        /// process. After a successful match, <code>Player</code> objects contain the name of the
        /// team the player is assigned to.</p>
        pub fn players(mut self, inp: impl Into<crate::model::Player>) -> Self {
            self.inner = self.inner.players(inp);
            self
        }
        pub fn set_players(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Player>>,
        ) -> Self {
            self.inner = self.inner.set_players(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopFleetActions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::stop_fleet_actions_input::Builder,
    }
    impl<C, M, R> StopFleetActions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopFleetActionsOutput,
            smithy_http::result::SdkError<crate::error::StopFleetActionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StopFleetActionsInputOperationOutputAlias,
                crate::output::StopFleetActionsOutput,
                crate::error::StopFleetActionsError,
                crate::input::StopFleetActionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to stop actions on.  You can use either the fleet ID or ARN value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// Appends an item to `Actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        /// <p>List of actions to suspend on the fleet. </p>
        pub fn actions(mut self, inp: impl Into<crate::model::FleetAction>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FleetAction>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
        /// <p>The fleet location to stop fleet actions for. Specify a location in the form of an AWS Region code, such as
        /// <code>us-west-2</code>.</p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopGameSessionPlacement<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::stop_game_session_placement_input::Builder,
    }
    impl<C, M, R> StopGameSessionPlacement<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopGameSessionPlacementOutput,
            smithy_http::result::SdkError<crate::error::StopGameSessionPlacementError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StopGameSessionPlacementInputOperationOutputAlias,
                crate::output::StopGameSessionPlacementOutput,
                crate::error::StopGameSessionPlacementError,
                crate::input::StopGameSessionPlacementInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for a game session placement to cancel.</p>
        pub fn placement_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.placement_id(inp);
            self
        }
        pub fn set_placement_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_placement_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopMatchmaking<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::stop_matchmaking_input::Builder,
    }
    impl<C, M, R> StopMatchmaking<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopMatchmakingOutput,
            smithy_http::result::SdkError<crate::error::StopMatchmakingError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StopMatchmakingInputOperationOutputAlias,
                crate::output::StopMatchmakingOutput,
                crate::error::StopMatchmakingError,
                crate::input::StopMatchmakingInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for a matchmaking ticket.</p>
        pub fn ticket_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ticket_id(inp);
            self
        }
        pub fn set_ticket_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ticket_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SuspendGameServerGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::suspend_game_server_group_input::Builder,
    }
    impl<C, M, R> SuspendGameServerGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SuspendGameServerGroupOutput,
            smithy_http::result::SdkError<crate::error::SuspendGameServerGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SuspendGameServerGroupInputOperationOutputAlias,
                crate::output::SuspendGameServerGroupOutput,
                crate::error::SuspendGameServerGroupError,
                crate::input::SuspendGameServerGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game server group. Use either the <a>GameServerGroup</a> name or ARN value.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// Appends an item to `SuspendActions`.
        ///
        /// To override the contents of this collection use [`set_suspend_actions`](Self::set_suspend_actions).
        /// <p>The activity to suspend for this game server group.</p>
        pub fn suspend_actions(
            mut self,
            inp: impl Into<crate::model::GameServerGroupAction>,
        ) -> Self {
            self.inner = self.inner.suspend_actions(inp);
            self
        }
        pub fn set_suspend_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GameServerGroupAction>>,
        ) -> Self {
            self.inner = self.inner.set_suspend_actions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C, M, R> TagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagResourceInputOperationOutputAlias,
                crate::output::TagResourceOutput,
                crate::error::TagResourceError,
                crate::input::TagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The Amazon Resource Name
        /// (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>)
        /// that is assigned to and uniquely identifies the GameLift resource that you want to assign
        /// tags to. GameLift resource ARNs are included in the data object for the resource, which
        /// can be retrieved by calling a List or Describe operation for the resource type. </p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A list of one or more tags to assign to the specified GameLift resource.
        /// Tags are developer-defined and structured as key-value pairs.
        /// The maximum tag limit may be lower than stated. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging AWS Resources</a>
        /// for actual tagging limits.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C, M, R> UntagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagResourceInputOperationOutputAlias,
                crate::output::UntagResourceOutput,
                crate::error::UntagResourceError,
                crate::input::UntagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) that is assigned to and
        /// uniquely identifies the GameLift resource that you want to remove tags from. GameLift
        /// resource ARNs are included in the data object for the resource, which can be retrieved
        /// by calling a List or Describe operation for the resource type. </p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `TagKeys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        /// <p>A list of one or more tag keys to remove from the specified GameLift resource. An
        /// AWS resource can have only one tag with a specific tag key, so specifying the tag key
        /// identifies which tag to remove. </p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAlias<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_alias_input::Builder,
    }
    impl<C, M, R> UpdateAlias<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAliasOutput,
            smithy_http::result::SdkError<crate::error::UpdateAliasError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateAliasInputOperationOutputAlias,
                crate::output::UpdateAliasOutput,
                crate::error::UpdateAliasError,
                crate::input::UpdateAliasInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the alias that you want to update. You can use either the
        /// alias ID or ARN value.</p>
        pub fn alias_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alias_id(inp);
            self
        }
        pub fn set_alias_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alias_id(input);
            self
        }
        /// <p>A descriptive label that is associated with an alias. Alias names do not need to be unique.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A human-readable description of the alias.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The routing configuration, including routing type and fleet target, for the
        /// alias.</p>
        pub fn routing_strategy(mut self, inp: crate::model::RoutingStrategy) -> Self {
            self.inner = self.inner.routing_strategy(inp);
            self
        }
        pub fn set_routing_strategy(
            mut self,
            input: std::option::Option<crate::model::RoutingStrategy>,
        ) -> Self {
            self.inner = self.inner.set_routing_strategy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateBuild<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_build_input::Builder,
    }
    impl<C, M, R> UpdateBuild<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateBuildOutput,
            smithy_http::result::SdkError<crate::error::UpdateBuildError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateBuildInputOperationOutputAlias,
                crate::output::UpdateBuildOutput,
                crate::error::UpdateBuildError,
                crate::input::UpdateBuildInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the build to update. You can use either the build ID or ARN value.  </p>
        pub fn build_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.build_id(inp);
            self
        }
        pub fn set_build_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_build_id(input);
            self
        }
        /// <p>A descriptive label that is associated with a build. Build names do not need to be unique. </p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Version information that is associated with a build or script. Version strings do not need to be unique.</p>
        pub fn version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(inp);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFleetAttributes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_fleet_attributes_input::Builder,
    }
    impl<C, M, R> UpdateFleetAttributes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFleetAttributesOutput,
            smithy_http::result::SdkError<crate::error::UpdateFleetAttributesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateFleetAttributesInputOperationOutputAlias,
                crate::output::UpdateFleetAttributesOutput,
                crate::error::UpdateFleetAttributesError,
                crate::input::UpdateFleetAttributesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to update attribute metadata for. You can use either the fleet ID or ARN
        /// value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>A descriptive label that is associated with a fleet. Fleet names do not need to be unique.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A human-readable description of a fleet.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The game session protection policy to apply to all new instances created in this
        /// fleet. Instances that already exist are not affected. You can set protection for
        /// individual instances using <a>UpdateGameSession</a>.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>NoProtection</b> -- The game session can be
        /// terminated during a scale-down event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>FullProtection</b> -- If the game session is in an
        /// <code>ACTIVE</code> status, it cannot be terminated during a scale-down
        /// event.</p>
        /// </li>
        /// </ul>
        pub fn new_game_session_protection_policy(
            mut self,
            inp: crate::model::ProtectionPolicy,
        ) -> Self {
            self.inner = self.inner.new_game_session_protection_policy(inp);
            self
        }
        pub fn set_new_game_session_protection_policy(
            mut self,
            input: std::option::Option<crate::model::ProtectionPolicy>,
        ) -> Self {
            self.inner = self.inner.set_new_game_session_protection_policy(input);
            self
        }
        /// <p>Policy settings that limit the number of game sessions an individual player can create
        /// over a span of time. </p>
        pub fn resource_creation_limit_policy(
            mut self,
            inp: crate::model::ResourceCreationLimitPolicy,
        ) -> Self {
            self.inner = self.inner.resource_creation_limit_policy(inp);
            self
        }
        pub fn set_resource_creation_limit_policy(
            mut self,
            input: std::option::Option<crate::model::ResourceCreationLimitPolicy>,
        ) -> Self {
            self.inner = self.inner.set_resource_creation_limit_policy(input);
            self
        }
        /// Appends an item to `MetricGroups`.
        ///
        /// To override the contents of this collection use [`set_metric_groups`](Self::set_metric_groups).
        /// <p>The name of a metric group to add this fleet to. Use a metric group in Amazon
        /// CloudWatch to aggregate the metrics from multiple fleets. Provide an existing metric
        /// group name, or create a new metric group by providing a new name. A fleet can only be in
        /// one metric group at a time.</p>
        pub fn metric_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_groups(inp);
            self
        }
        pub fn set_metric_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_metric_groups(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFleetCapacity<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_fleet_capacity_input::Builder,
    }
    impl<C, M, R> UpdateFleetCapacity<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFleetCapacityOutput,
            smithy_http::result::SdkError<crate::error::UpdateFleetCapacityError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateFleetCapacityInputOperationOutputAlias,
                crate::output::UpdateFleetCapacityOutput,
                crate::error::UpdateFleetCapacityError,
                crate::input::UpdateFleetCapacityInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to update capacity settings for. You can use either the fleet ID or ARN
        /// value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>The number of EC2 instances you want to maintain in the specified fleet location.
        /// This value must fall between the minimum and maximum size limits.</p>
        pub fn desired_instances(mut self, inp: i32) -> Self {
            self.inner = self.inner.desired_instances(inp);
            self
        }
        pub fn set_desired_instances(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_desired_instances(input);
            self
        }
        /// <p>The minimum number of instances that are allowed in the specified fleet location. If
        /// this parameter is not set, the default is 0.</p>
        pub fn min_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.min_size(inp);
            self
        }
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_size(input);
            self
        }
        /// <p>The maximum number of instances that are allowed in the specified fleet location. If
        /// this parameter is not set, the default is 1.</p>
        pub fn max_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_size(inp);
            self
        }
        pub fn set_max_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_size(input);
            self
        }
        /// <p>The name of a remote location to update fleet capacity settings for, in the form of an
        /// AWS Region code such as <code>us-west-2</code>.</p>
        pub fn location(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location(inp);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFleetPortSettings<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_fleet_port_settings_input::Builder,
    }
    impl<C, M, R> UpdateFleetPortSettings<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFleetPortSettingsOutput,
            smithy_http::result::SdkError<crate::error::UpdateFleetPortSettingsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateFleetPortSettingsInputOperationOutputAlias,
                crate::output::UpdateFleetPortSettingsOutput,
                crate::error::UpdateFleetPortSettingsError,
                crate::input::UpdateFleetPortSettingsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to update port settings for. You can use either the fleet ID or ARN
        /// value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// Appends an item to `InboundPermissionAuthorizations`.
        ///
        /// To override the contents of this collection use [`set_inbound_permission_authorizations`](Self::set_inbound_permission_authorizations).
        /// <p>A collection of port settings to be added to the fleet resource.</p>
        pub fn inbound_permission_authorizations(
            mut self,
            inp: impl Into<crate::model::IpPermission>,
        ) -> Self {
            self.inner = self.inner.inbound_permission_authorizations(inp);
            self
        }
        pub fn set_inbound_permission_authorizations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        ) -> Self {
            self.inner = self.inner.set_inbound_permission_authorizations(input);
            self
        }
        /// Appends an item to `InboundPermissionRevocations`.
        ///
        /// To override the contents of this collection use [`set_inbound_permission_revocations`](Self::set_inbound_permission_revocations).
        /// <p>A collection of port settings to be removed from the fleet resource.</p>
        pub fn inbound_permission_revocations(
            mut self,
            inp: impl Into<crate::model::IpPermission>,
        ) -> Self {
            self.inner = self.inner.inbound_permission_revocations(inp);
            self
        }
        pub fn set_inbound_permission_revocations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        ) -> Self {
            self.inner = self.inner.set_inbound_permission_revocations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateGameServer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_game_server_input::Builder,
    }
    impl<C, M, R> UpdateGameServer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateGameServerOutput,
            smithy_http::result::SdkError<crate::error::UpdateGameServerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateGameServerInputOperationOutputAlias,
                crate::output::UpdateGameServerOutput,
                crate::error::UpdateGameServerError,
                crate::input::UpdateGameServerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game server group where the game server is running.
        /// Use either the <a>GameServerGroup</a> name or ARN value.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// <p>A custom string that uniquely identifies the game server to update.</p>
        pub fn game_server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_id(inp);
            self
        }
        pub fn set_game_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_id(input);
            self
        }
        /// <p>A set of custom game server properties, formatted as a single string value. This data
        /// is passed to a game client or service when it requests information on game servers using
        /// <a>ListGameServers</a> or <a>ClaimGameServer</a>. </p>
        pub fn game_server_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_data(inp);
            self
        }
        pub fn set_game_server_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_data(input);
            self
        }
        /// <p>Indicates whether the game server is available or is currently hosting
        /// gameplay.</p>
        pub fn utilization_status(
            mut self,
            inp: crate::model::GameServerUtilizationStatus,
        ) -> Self {
            self.inner = self.inner.utilization_status(inp);
            self
        }
        pub fn set_utilization_status(
            mut self,
            input: std::option::Option<crate::model::GameServerUtilizationStatus>,
        ) -> Self {
            self.inner = self.inner.set_utilization_status(input);
            self
        }
        /// <p>Indicates health status of the game server. A request that includes this parameter
        /// updates the game server's <i>LastHealthCheckTime</i> timestamp. </p>
        pub fn health_check(mut self, inp: crate::model::GameServerHealthCheck) -> Self {
            self.inner = self.inner.health_check(inp);
            self
        }
        pub fn set_health_check(
            mut self,
            input: std::option::Option<crate::model::GameServerHealthCheck>,
        ) -> Self {
            self.inner = self.inner.set_health_check(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateGameServerGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_game_server_group_input::Builder,
    }
    impl<C, M, R> UpdateGameServerGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateGameServerGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateGameServerGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateGameServerGroupInputOperationOutputAlias,
                crate::output::UpdateGameServerGroupOutput,
                crate::error::UpdateGameServerGroupError,
                crate::input::UpdateGameServerGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game server group. Use either the <a>GameServerGroup</a> name or ARN value.</p>
        pub fn game_server_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_server_group_name(inp);
            self
        }
        pub fn set_game_server_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_server_group_name(input);
            self
        }
        /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) for an IAM role that
        /// allows Amazon GameLift to access your EC2 Auto Scaling groups.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// Appends an item to `InstanceDefinitions`.
        ///
        /// To override the contents of this collection use [`set_instance_definitions`](Self::set_instance_definitions).
        /// <p>An updated list of EC2 instance types to use in the Auto Scaling group. The instance
        /// definitions must specify at least two different instance types that are supported by
        /// GameLift FleetIQ. This updated list replaces the entire current list of instance definitions for
        /// the game server group. For more information on instance types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">EC2 Instance
        /// Types</a> in the <i>Amazon EC2 User Guide</i>. You can optionally
        /// specify capacity weighting for each instance type. If no weight value is specified for
        /// an instance type, it is set to the default value "1". For more information about
        /// capacity weighting, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-weighting.html"> Instance Weighting for
        /// Amazon EC2 Auto Scaling</a> in the Amazon EC2 Auto Scaling User Guide.</p>
        pub fn instance_definitions(
            mut self,
            inp: impl Into<crate::model::InstanceDefinition>,
        ) -> Self {
            self.inner = self.inner.instance_definitions(inp);
            self
        }
        pub fn set_instance_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceDefinition>>,
        ) -> Self {
            self.inner = self.inner.set_instance_definitions(input);
            self
        }
        /// <p>A flag that indicates whether instances in the game server group are protected
        /// from early termination. Unprotected instances that have active game servers running might
        /// be terminated during a scale-down event, causing players to be dropped from the game.
        /// Protected instances cannot be terminated while there are active game servers running except
        /// in the event of a forced game server group deletion (see ). An exception to this is with Spot
        /// Instances, which can be terminated by AWS regardless of protection status. This property is set to <code>NO_PROTECTION</code> by default.</p>
        pub fn game_server_protection_policy(
            mut self,
            inp: crate::model::GameServerProtectionPolicy,
        ) -> Self {
            self.inner = self.inner.game_server_protection_policy(inp);
            self
        }
        pub fn set_game_server_protection_policy(
            mut self,
            input: std::option::Option<crate::model::GameServerProtectionPolicy>,
        ) -> Self {
            self.inner = self.inner.set_game_server_protection_policy(input);
            self
        }
        /// <p>Indicates how GameLift FleetIQ balances the use of Spot Instances and On-Demand Instances in the
        /// game server group. Method options include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SPOT_ONLY</code> - Only Spot Instances are used in the game server group. If Spot
        /// Instances are unavailable or not viable for game hosting, the game server group
        /// provides no hosting capacity until Spot Instances can again be used. Until then,
        /// no new instances are started, and the existing nonviable Spot Instances are
        /// terminated (after current gameplay ends) and are not replaced.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SPOT_PREFERRED</code> - (default value) Spot Instances are used whenever available in
        /// the game server group. If Spot Instances are unavailable, the game server group
        /// continues to provide hosting capacity by falling back to On-Demand Instances.
        /// Existing nonviable Spot Instances are terminated (after current gameplay ends)
        /// and are replaced with new On-Demand Instances.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ON_DEMAND_ONLY</code> - Only On-Demand Instances are used in the game
        /// server group. No Spot Instances are used, even when available, while this
        /// balancing strategy is in force.</p>
        /// </li>
        /// </ul>
        pub fn balancing_strategy(mut self, inp: crate::model::BalancingStrategy) -> Self {
            self.inner = self.inner.balancing_strategy(inp);
            self
        }
        pub fn set_balancing_strategy(
            mut self,
            input: std::option::Option<crate::model::BalancingStrategy>,
        ) -> Self {
            self.inner = self.inner.set_balancing_strategy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateGameSession<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_game_session_input::Builder,
    }
    impl<C, M, R> UpdateGameSession<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateGameSessionOutput,
            smithy_http::result::SdkError<crate::error::UpdateGameSessionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateGameSessionInputOperationOutputAlias,
                crate::output::UpdateGameSessionOutput,
                crate::error::UpdateGameSessionError,
                crate::input::UpdateGameSessionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the game session to update. </p>
        pub fn game_session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_id(inp);
            self
        }
        pub fn set_game_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_id(input);
            self
        }
        /// <p>The maximum number of players that can be connected simultaneously to the game session.</p>
        pub fn maximum_player_session_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_player_session_count(inp);
            self
        }
        pub fn set_maximum_player_session_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_player_session_count(input);
            self
        }
        /// <p>A descriptive label that is associated with a game session. Session names do not need to be unique.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A policy that determines whether the game session is accepting new players.</p>
        pub fn player_session_creation_policy(
            mut self,
            inp: crate::model::PlayerSessionCreationPolicy,
        ) -> Self {
            self.inner = self.inner.player_session_creation_policy(inp);
            self
        }
        pub fn set_player_session_creation_policy(
            mut self,
            input: std::option::Option<crate::model::PlayerSessionCreationPolicy>,
        ) -> Self {
            self.inner = self.inner.set_player_session_creation_policy(input);
            self
        }
        /// <p>Game session protection policy to apply to this game session only.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>NoProtection</b> -- The game session can be
        /// terminated during a scale-down event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>FullProtection</b> -- If the game session is in an
        /// <code>ACTIVE</code> status, it cannot be terminated during a scale-down
        /// event.</p>
        /// </li>
        /// </ul>
        pub fn protection_policy(mut self, inp: crate::model::ProtectionPolicy) -> Self {
            self.inner = self.inner.protection_policy(inp);
            self
        }
        pub fn set_protection_policy(
            mut self,
            input: std::option::Option<crate::model::ProtectionPolicy>,
        ) -> Self {
            self.inner = self.inner.set_protection_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateGameSessionQueue<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_game_session_queue_input::Builder,
    }
    impl<C, M, R> UpdateGameSessionQueue<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateGameSessionQueueOutput,
            smithy_http::result::SdkError<crate::error::UpdateGameSessionQueueError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateGameSessionQueueInputOperationOutputAlias,
                crate::output::UpdateGameSessionQueueOutput,
                crate::error::UpdateGameSessionQueueError,
                crate::input::UpdateGameSessionQueueInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A descriptive label that is associated with game session queue. Queue names must be unique within each Region. You can use either the queue ID or ARN value. </p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The maximum time, in seconds, that a new game session placement request remains in the queue. When a request exceeds this time, the game session placement changes to a <code>TIMED_OUT</code> status.</p>
        pub fn timeout_in_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.timeout_in_seconds(inp);
            self
        }
        pub fn set_timeout_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_timeout_in_seconds(input);
            self
        }
        /// Appends an item to `PlayerLatencyPolicies`.
        ///
        /// To override the contents of this collection use [`set_player_latency_policies`](Self::set_player_latency_policies).
        /// <p>A set of policies that act as a sliding cap on player latency. FleetIQ works to
        /// deliver low latency for most players in a game session. These policies ensure that no
        /// individual player can be placed into a game with unreasonably high latency. Use multiple
        /// policies to gradually relax latency requirements a step at a time. Multiple policies are applied based on their
        /// maximum allowed latency, starting with the lowest value. When updating policies, provide a complete collection of
        /// policies.</p>
        pub fn player_latency_policies(
            mut self,
            inp: impl Into<crate::model::PlayerLatencyPolicy>,
        ) -> Self {
            self.inner = self.inner.player_latency_policies(inp);
            self
        }
        pub fn set_player_latency_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlayerLatencyPolicy>>,
        ) -> Self {
            self.inner = self.inner.set_player_latency_policies(input);
            self
        }
        /// Appends an item to `Destinations`.
        ///
        /// To override the contents of this collection use [`set_destinations`](Self::set_destinations).
        /// <p>A list of fleets and/or fleet aliases that can be used to fulfill game session placement requests in the queue.
        /// Destinations are identified by either a fleet ARN or a fleet alias ARN, and are listed in order of placement preference. When updating this list, provide a complete list of destinations.</p>
        pub fn destinations(
            mut self,
            inp: impl Into<crate::model::GameSessionQueueDestination>,
        ) -> Self {
            self.inner = self.inner.destinations(inp);
            self
        }
        pub fn set_destinations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GameSessionQueueDestination>>,
        ) -> Self {
            self.inner = self.inner.set_destinations(input);
            self
        }
        /// <p>A list of locations where a queue is allowed to place new game sessions. Locations
        /// are specified in the form of AWS Region codes, such as <code>us-west-2</code>. If this parameter is
        /// not set, game sessions can be placed in any queue location. To remove an existing filter configuration, pass in an empty set.</p>
        pub fn filter_configuration(mut self, inp: crate::model::FilterConfiguration) -> Self {
            self.inner = self.inner.filter_configuration(inp);
            self
        }
        pub fn set_filter_configuration(
            mut self,
            input: std::option::Option<crate::model::FilterConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_filter_configuration(input);
            self
        }
        /// <p>Custom settings to use when prioritizing destinations and locations for game session placements. This
        /// configuration replaces the FleetIQ default prioritization process. Priority types that are not explicitly
        /// named will be automatically applied at the end of the prioritization process. To remove an existing priority configuration, pass in an empty set.</p>
        pub fn priority_configuration(mut self, inp: crate::model::PriorityConfiguration) -> Self {
            self.inner = self.inner.priority_configuration(inp);
            self
        }
        pub fn set_priority_configuration(
            mut self,
            input: std::option::Option<crate::model::PriorityConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_priority_configuration(input);
            self
        }
        /// <p>
        /// Information to be added to all events that are related to this game session queue.
        /// </p>
        pub fn custom_event_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.custom_event_data(inp);
            self
        }
        pub fn set_custom_event_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_custom_event_data(input);
            self
        }
        /// <p>An SNS topic ARN that is set up to receive game session placement notifications. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/queue-notification.html">
        /// Setting up notifications for game session placement</a>.</p>
        pub fn notification_target(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_target(inp);
            self
        }
        pub fn set_notification_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_target(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateMatchmakingConfiguration<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_matchmaking_configuration_input::Builder,
    }
    impl<C, M, R> UpdateMatchmakingConfiguration<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateMatchmakingConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateMatchmakingConfigurationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateMatchmakingConfigurationInputOperationOutputAlias,
                crate::output::UpdateMatchmakingConfigurationOutput,
                crate::error::UpdateMatchmakingConfigurationError,
                crate::input::UpdateMatchmakingConfigurationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the matchmaking configuration to update. You can use either the configuration name or ARN value. </p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A descriptive label that is associated with matchmaking configuration.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Appends an item to `GameSessionQueueArns`.
        ///
        /// To override the contents of this collection use [`set_game_session_queue_arns`](Self::set_game_session_queue_arns).
        /// <p>The Amazon Resource Name (<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html">ARN</a>) that is assigned to a GameLift game session queue resource and uniquely identifies it. ARNs are unique across all Regions. Format is <code>arn:aws:gamelift:<region>::gamesessionqueue/<queue name></code>. Queues can be located in any Region. Queues are used to start new
        /// GameLift-hosted game sessions for matches that are created with this matchmaking
        /// configuration. If <code>FlexMatchMode</code> is set to <code>STANDALONE</code>, do not
        /// set this parameter.</p>
        pub fn game_session_queue_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_queue_arns(inp);
            self
        }
        pub fn set_game_session_queue_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_game_session_queue_arns(input);
            self
        }
        /// <p>The maximum duration, in seconds, that a matchmaking ticket can remain in process
        /// before timing out. Requests that fail due to timing out can be resubmitted as
        /// needed.</p>
        pub fn request_timeout_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.request_timeout_seconds(inp);
            self
        }
        pub fn set_request_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_request_timeout_seconds(input);
            self
        }
        /// <p>The length of time (in seconds) to wait for players to accept a proposed match, if
        /// acceptance is required.</p>
        pub fn acceptance_timeout_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.acceptance_timeout_seconds(inp);
            self
        }
        pub fn set_acceptance_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_acceptance_timeout_seconds(input);
            self
        }
        /// <p>A flag that indicates whether a match that was created with this configuration must be
        /// accepted by the matched players. To require acceptance, set to TRUE. With this option
        /// enabled, matchmaking tickets use the status <code>REQUIRES_ACCEPTANCE</code> to indicate
        /// when a completed potential match is waiting for player acceptance. </p>
        pub fn acceptance_required(mut self, inp: bool) -> Self {
            self.inner = self.inner.acceptance_required(inp);
            self
        }
        pub fn set_acceptance_required(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_acceptance_required(input);
            self
        }
        /// <p>A unique identifier for the matchmaking rule set to use with this configuration. You can use either the rule set name or ARN
        /// value. A matchmaking configuration can only use rule sets that are defined in the same
        /// Region.</p>
        pub fn rule_set_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_name(inp);
            self
        }
        pub fn set_rule_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_name(input);
            self
        }
        /// <p>An SNS topic ARN that is set up to receive matchmaking notifications. See <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-notification.html">
        /// Setting up notifications for matchmaking</a> for more information.</p>
        pub fn notification_target(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_target(inp);
            self
        }
        pub fn set_notification_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_target(input);
            self
        }
        /// <p>The number of player slots in a match to keep open for future players. For example, if the configuration's rule set specifies
        /// a match for a single 12-person team, and the additional player count is set to 2, only 10 players are selected for the match. This parameter is not used if <code>FlexMatchMode</code> is set to
        /// <code>STANDALONE</code>.</p>
        pub fn additional_player_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.additional_player_count(inp);
            self
        }
        pub fn set_additional_player_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_additional_player_count(input);
            self
        }
        /// <p>Information to add to all events related to the matchmaking configuration. </p>
        pub fn custom_event_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.custom_event_data(inp);
            self
        }
        pub fn set_custom_event_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_custom_event_data(input);
            self
        }
        /// Appends an item to `GameProperties`.
        ///
        /// To override the contents of this collection use [`set_game_properties`](Self::set_game_properties).
        /// <p>A set of custom properties for a game session, formatted as key:value pairs. These properties are passed to a game server process in the
        /// <a>GameSession</a> object with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <a>GameSession</a>
        /// object that is created for a successful match.  This parameter is not used if
        /// <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
        pub fn game_properties(mut self, inp: impl Into<crate::model::GameProperty>) -> Self {
            self.inner = self.inner.game_properties(inp);
            self
        }
        pub fn set_game_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GameProperty>>,
        ) -> Self {
            self.inner = self.inner.set_game_properties(input);
            self
        }
        /// <p>A set of custom game session properties, formatted as a single string value. This data is passed to a game server process in the
        /// <a>GameSession</a> object with a request to start a new game session (see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession">Start a Game Session</a>). This information is added to the new <a>GameSession</a> object
        /// that is created for a successful match.  This parameter is not used if
        /// <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
        pub fn game_session_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.game_session_data(inp);
            self
        }
        pub fn set_game_session_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_game_session_data(input);
            self
        }
        /// <p>The method that is used to backfill game sessions created with this matchmaking
        /// configuration. Specify MANUAL when your game manages backfill requests manually or does
        /// not use the match backfill feature. Specify AUTOMATIC to have GameLift create a <a>StartMatchBackfill</a> request whenever a game session has one or more open
        /// slots. Learn more about manual and automatic backfill in <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-backfill.html">Backfill Existing Games
        /// with FlexMatch</a>. Automatic backfill is not available when
        /// <code>FlexMatchMode</code> is set to <code>STANDALONE</code>.</p>
        pub fn backfill_mode(mut self, inp: crate::model::BackfillMode) -> Self {
            self.inner = self.inner.backfill_mode(inp);
            self
        }
        pub fn set_backfill_mode(
            mut self,
            input: std::option::Option<crate::model::BackfillMode>,
        ) -> Self {
            self.inner = self.inner.set_backfill_mode(input);
            self
        }
        /// <p>Indicates whether this matchmaking configuration is being used with GameLift hosting or
        /// as a standalone matchmaking solution. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>STANDALONE</b> - FlexMatch forms matches and returns
        /// match information, including players and team assignments, in a
        /// <a href="https://docs.aws.amazon.com/gamelift/latest/flexmatchguide/match-events.html#match-events-matchmakingsucceeded">
        /// MatchmakingSucceeded</a> event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>WITH_QUEUE</b> - FlexMatch forms matches and uses the specified GameLift queue to
        /// start a game session for the match. </p>
        /// </li>
        /// </ul>
        pub fn flex_match_mode(mut self, inp: crate::model::FlexMatchMode) -> Self {
            self.inner = self.inner.flex_match_mode(inp);
            self
        }
        pub fn set_flex_match_mode(
            mut self,
            input: std::option::Option<crate::model::FlexMatchMode>,
        ) -> Self {
            self.inner = self.inner.set_flex_match_mode(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRuntimeConfiguration<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_runtime_configuration_input::Builder,
    }
    impl<C, M, R> UpdateRuntimeConfiguration<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRuntimeConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateRuntimeConfigurationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateRuntimeConfigurationInputOperationOutputAlias,
                crate::output::UpdateRuntimeConfigurationOutput,
                crate::error::UpdateRuntimeConfigurationError,
                crate::input::UpdateRuntimeConfigurationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the fleet to update runtime configuration for. You can use either the fleet ID or ARN
        /// value.</p>
        pub fn fleet_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(inp);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>Instructions for launching server processes on each instance in the fleet. Server
        /// processes run either a custom game build executable or a Realtime Servers script. The runtime
        /// configuration lists the types of server processes to run on an instance, how to launch
        /// them, and the number of processes to run concurrently.</p>
        pub fn runtime_configuration(mut self, inp: crate::model::RuntimeConfiguration) -> Self {
            self.inner = self.inner.runtime_configuration(inp);
            self
        }
        pub fn set_runtime_configuration(
            mut self,
            input: std::option::Option<crate::model::RuntimeConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_runtime_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateScript<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_script_input::Builder,
    }
    impl<C, M, R> UpdateScript<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateScriptOutput,
            smithy_http::result::SdkError<crate::error::UpdateScriptError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateScriptInputOperationOutputAlias,
                crate::output::UpdateScriptOutput,
                crate::error::UpdateScriptError,
                crate::input::UpdateScriptInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the Realtime script to update. You can use either the script ID or ARN value.</p>
        pub fn script_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.script_id(inp);
            self
        }
        pub fn set_script_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_script_id(input);
            self
        }
        /// <p>A descriptive label that is associated with a script. Script names do not need to be unique.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Version information that is associated with a build or script. Version strings do not need to be unique.</p>
        pub fn version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(inp);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>The location of the Amazon S3 bucket where a zipped file containing your Realtime scripts is
        /// stored. The storage location must specify the Amazon S3 bucket name, the zip file name (the
        /// "key"), and a role ARN that allows Amazon GameLift to access the Amazon S3 storage location. The S3
        /// bucket must be in the same Region where you want to create a new script. By default,
        /// Amazon GameLift uploads the latest version of the zip file; if you have S3 object versioning
        /// turned on, you can use the <code>ObjectVersion</code> parameter to specify an earlier
        /// version. </p>
        pub fn storage_location(mut self, inp: crate::model::S3Location) -> Self {
            self.inner = self.inner.storage_location(inp);
            self
        }
        pub fn set_storage_location(
            mut self,
            input: std::option::Option<crate::model::S3Location>,
        ) -> Self {
            self.inner = self.inner.set_storage_location(input);
            self
        }
        /// <p>A data object containing your Realtime scripts and dependencies as a zip file. The zip
        /// file can have one or multiple files. Maximum size of a zip file is 5 MB.</p>
        /// <p>When using the AWS CLI tool to create a script, this parameter is set to the zip file
        /// name. It must be prepended with the string "fileb://" to indicate that the file data is
        /// a binary object. For example: <code>--zip-file
        /// fileb://myRealtimeScript.zip</code>.</p>
        pub fn zip_file(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.zip_file(inp);
            self
        }
        pub fn set_zip_file(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_zip_file(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ValidateMatchmakingRuleSet<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::validate_matchmaking_rule_set_input::Builder,
    }
    impl<C, M, R> ValidateMatchmakingRuleSet<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ValidateMatchmakingRuleSetOutput,
            smithy_http::result::SdkError<crate::error::ValidateMatchmakingRuleSetError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ValidateMatchmakingRuleSetInputOperationOutputAlias,
                crate::output::ValidateMatchmakingRuleSetOutput,
                crate::error::ValidateMatchmakingRuleSetError,
                crate::input::ValidateMatchmakingRuleSetInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A collection of matchmaking rules to validate, formatted as a JSON string.</p>
        pub fn rule_set_body(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_set_body(inp);
            self
        }
        pub fn set_rule_set_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_set_body(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
