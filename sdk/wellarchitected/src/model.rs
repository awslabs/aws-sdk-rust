// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Stores information about a field passed inside a request that resulted in an exception.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationExceptionField {
    /// <p>The field name for which validation failed.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationExceptionField {
    /// <p>The field name for which validation failed.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Description of the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
pub mod validation_exception_field {

    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The field name for which validation failed.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The field name for which validation failed.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        pub fn build(self) -> crate::model::ValidationExceptionField {
            crate::model::ValidationExceptionField {
                name: self.name,
                message: self.message,
            }
        }
    }
}

/// When writing a match expression against `ValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let validationexceptionreason = unimplemented!();
/// match validationexceptionreason {
///     ValidationExceptionReason::CannotParse => { /* ... */ },
///     ValidationExceptionReason::FieldValidationFailed => { /* ... */ },
///     ValidationExceptionReason::Other => { /* ... */ },
///     ValidationExceptionReason::UnknownOperation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `validationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The reason why the request failed validation.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    CannotParse,
    #[allow(missing_docs)] // documentation missing in model
    FieldValidationFailed,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    UnknownOperation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "CANNOT_PARSE" => ValidationExceptionReason::CannotParse,
            "FIELD_VALIDATION_FAILED" => ValidationExceptionReason::FieldValidationFailed,
            "OTHER" => ValidationExceptionReason::Other,
            "UNKNOWN_OPERATION" => ValidationExceptionReason::UnknownOperation,
            other => ValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValidationExceptionReason::from(s))
    }
}
impl ValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidationExceptionReason::CannotParse => "CANNOT_PARSE",
            ValidationExceptionReason::FieldValidationFailed => "FIELD_VALIDATION_FAILED",
            ValidationExceptionReason::Other => "OTHER",
            ValidationExceptionReason::UnknownOperation => "UNKNOWN_OPERATION",
            ValidationExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANNOT_PARSE",
            "FIELD_VALIDATION_FAILED",
            "OTHER",
            "UNKNOWN_OPERATION",
        ]
    }
}
impl AsRef<str> for ValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A workload share return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkloadShare {
    /// <p>The ID associated with the workload share.</p>
    #[doc(hidden)]
    pub share_id: std::option::Option<std::string::String>,
    /// <p>An Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub shared_by: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
    #[doc(hidden)]
    pub shared_with: std::option::Option<std::string::String>,
    /// <p>Permission granted on a workload share.</p>
    #[doc(hidden)]
    pub permission_type: std::option::Option<crate::model::PermissionType>,
    /// <p>The status of a workload share.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ShareStatus>,
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    #[doc(hidden)]
    pub workload_name: std::option::Option<std::string::String>,
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub workload_id: std::option::Option<std::string::String>,
}
impl WorkloadShare {
    /// <p>The ID associated with the workload share.</p>
    pub fn share_id(&self) -> std::option::Option<&str> {
        self.share_id.as_deref()
    }
    /// <p>An Amazon Web Services account ID.</p>
    pub fn shared_by(&self) -> std::option::Option<&str> {
        self.shared_by.as_deref()
    }
    /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
    pub fn shared_with(&self) -> std::option::Option<&str> {
        self.shared_with.as_deref()
    }
    /// <p>Permission granted on a workload share.</p>
    pub fn permission_type(&self) -> std::option::Option<&crate::model::PermissionType> {
        self.permission_type.as_ref()
    }
    /// <p>The status of a workload share.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ShareStatus> {
        self.status.as_ref()
    }
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    pub fn workload_name(&self) -> std::option::Option<&str> {
        self.workload_name.as_deref()
    }
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
}
impl WorkloadShare {
    /// Creates a new builder-style object to manufacture [`WorkloadShare`](crate::model::WorkloadShare).
    pub fn builder() -> crate::model::workload_share::Builder {
        crate::model::workload_share::Builder::default()
    }
}

/// See [`WorkloadShare`](crate::model::WorkloadShare).
pub mod workload_share {

    /// A builder for [`WorkloadShare`](crate::model::WorkloadShare).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) share_id: std::option::Option<std::string::String>,
        pub(crate) shared_by: std::option::Option<std::string::String>,
        pub(crate) shared_with: std::option::Option<std::string::String>,
        pub(crate) permission_type: std::option::Option<crate::model::PermissionType>,
        pub(crate) status: std::option::Option<crate::model::ShareStatus>,
        pub(crate) workload_name: std::option::Option<std::string::String>,
        pub(crate) workload_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID associated with the workload share.</p>
        pub fn share_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_id = Some(input.into());
            self
        }
        /// <p>The ID associated with the workload share.</p>
        pub fn set_share_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.share_id = input;
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn shared_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_by = Some(input.into());
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn set_shared_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.shared_by = input;
            self
        }
        /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
        pub fn shared_with(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_with = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
        pub fn set_shared_with(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.shared_with = input;
            self
        }
        /// <p>Permission granted on a workload share.</p>
        pub fn permission_type(mut self, input: crate::model::PermissionType) -> Self {
            self.permission_type = Some(input);
            self
        }
        /// <p>Permission granted on a workload share.</p>
        pub fn set_permission_type(
            mut self,
            input: std::option::Option<crate::model::PermissionType>,
        ) -> Self {
            self.permission_type = input;
            self
        }
        /// <p>The status of a workload share.</p>
        pub fn status(mut self, input: crate::model::ShareStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of a workload share.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ShareStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn workload_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_name = Some(input.into());
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn set_workload_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workload_name = input;
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkloadShare`](crate::model::WorkloadShare).
        pub fn build(self) -> crate::model::WorkloadShare {
            crate::model::WorkloadShare {
                share_id: self.share_id,
                shared_by: self.shared_by,
                shared_with: self.shared_with,
                permission_type: self.permission_type,
                status: self.status,
                workload_name: self.workload_name,
                workload_id: self.workload_id,
            }
        }
    }
}

/// When writing a match expression against `ShareStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sharestatus = unimplemented!();
/// match sharestatus {
///     ShareStatus::Accepted => { /* ... */ },
///     ShareStatus::Associated => { /* ... */ },
///     ShareStatus::Associating => { /* ... */ },
///     ShareStatus::Expired => { /* ... */ },
///     ShareStatus::Failed => { /* ... */ },
///     ShareStatus::Pending => { /* ... */ },
///     ShareStatus::Rejected => { /* ... */ },
///     ShareStatus::Revoked => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sharestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ShareStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ShareStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ShareStatus::NewFeature` is defined.
/// Specifically, when `sharestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ShareStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The status of a workload share.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ShareStatus {
    #[allow(missing_docs)] // documentation missing in model
    Accepted,
    #[allow(missing_docs)] // documentation missing in model
    Associated,
    #[allow(missing_docs)] // documentation missing in model
    Associating,
    #[allow(missing_docs)] // documentation missing in model
    Expired,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    #[allow(missing_docs)] // documentation missing in model
    Revoked,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ShareStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACCEPTED" => ShareStatus::Accepted,
            "ASSOCIATED" => ShareStatus::Associated,
            "ASSOCIATING" => ShareStatus::Associating,
            "EXPIRED" => ShareStatus::Expired,
            "FAILED" => ShareStatus::Failed,
            "PENDING" => ShareStatus::Pending,
            "REJECTED" => ShareStatus::Rejected,
            "REVOKED" => ShareStatus::Revoked,
            other => ShareStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ShareStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ShareStatus::from(s))
    }
}
impl ShareStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ShareStatus::Accepted => "ACCEPTED",
            ShareStatus::Associated => "ASSOCIATED",
            ShareStatus::Associating => "ASSOCIATING",
            ShareStatus::Expired => "EXPIRED",
            ShareStatus::Failed => "FAILED",
            ShareStatus::Pending => "PENDING",
            ShareStatus::Rejected => "REJECTED",
            ShareStatus::Revoked => "REVOKED",
            ShareStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCEPTED",
            "ASSOCIATED",
            "ASSOCIATING",
            "EXPIRED",
            "FAILED",
            "PENDING",
            "REJECTED",
            "REVOKED",
        ]
    }
}
impl AsRef<str> for ShareStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PermissionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let permissiontype = unimplemented!();
/// match permissiontype {
///     PermissionType::Contributor => { /* ... */ },
///     PermissionType::Readonly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `permissiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PermissionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PermissionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PermissionType::NewFeature` is defined.
/// Specifically, when `permissiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PermissionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Permission granted on a workload share.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PermissionType {
    #[allow(missing_docs)] // documentation missing in model
    Contributor,
    #[allow(missing_docs)] // documentation missing in model
    Readonly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PermissionType {
    fn from(s: &str) -> Self {
        match s {
            "CONTRIBUTOR" => PermissionType::Contributor,
            "READONLY" => PermissionType::Readonly,
            other => PermissionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PermissionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PermissionType::from(s))
    }
}
impl PermissionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PermissionType::Contributor => "CONTRIBUTOR",
            PermissionType::Readonly => "READONLY",
            PermissionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONTRIBUTOR", "READONLY"]
    }
}
impl AsRef<str> for PermissionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A workload return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Workload {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The ARN for the workload.</p>
    #[doc(hidden)]
    pub workload_arn: std::option::Option<std::string::String>,
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    #[doc(hidden)]
    pub workload_name: std::option::Option<std::string::String>,
    /// <p>The description for the workload.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The environment for the workload.</p>
    #[doc(hidden)]
    pub environment: std::option::Option<crate::model::WorkloadEnvironment>,
    /// <p>The date and time recorded.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
    #[doc(hidden)]
    pub account_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
    #[doc(hidden)]
    pub aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
    #[doc(hidden)]
    pub non_aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The URL of the architectural design for the workload.</p>
    #[doc(hidden)]
    pub architectural_design: std::option::Option<std::string::String>,
    /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
    #[doc(hidden)]
    pub review_owner: std::option::Option<std::string::String>,
    /// <p>The date and time recorded.</p>
    #[doc(hidden)]
    pub review_restriction_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Flag indicating whether the workload owner has acknowledged that the <i>Review owner</i> field is required.</p>
    /// <p>If a <b>Review owner</b> is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.</p>
    #[doc(hidden)]
    pub is_review_owner_update_acknowledged: bool,
    /// <p>The industry type for the workload.</p>
    /// <p>If specified, must be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>Agriculture</code> </p> </li>
    /// <li> <p> <code>Automobile</code> </p> </li>
    /// <li> <p> <code>Defense</code> </p> </li>
    /// <li> <p> <code>Design and Engineering</code> </p> </li>
    /// <li> <p> <code>Digital Advertising</code> </p> </li>
    /// <li> <p> <code>Education</code> </p> </li>
    /// <li> <p> <code>Environmental Protection</code> </p> </li>
    /// <li> <p> <code>Financial Services</code> </p> </li>
    /// <li> <p> <code>Gaming</code> </p> </li>
    /// <li> <p> <code>General Public Services</code> </p> </li>
    /// <li> <p> <code>Healthcare</code> </p> </li>
    /// <li> <p> <code>Hospitality</code> </p> </li>
    /// <li> <p> <code>InfoTech</code> </p> </li>
    /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
    /// <li> <p> <code>Life Sciences</code> </p> </li>
    /// <li> <p> <code>Manufacturing</code> </p> </li>
    /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
    /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
    /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
    /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
    /// <li> <p> <code>Professional Services</code> </p> </li>
    /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
    /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
    /// <li> <p> <code>Social Protection</code> </p> </li>
    /// <li> <p> <code>Telecommunications</code> </p> </li>
    /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
    /// <li> <p> <code>Other</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub industry_type: std::option::Option<std::string::String>,
    /// <p>The industry for the workload.</p>
    #[doc(hidden)]
    pub industry: std::option::Option<std::string::String>,
    /// <p>The notes associated with the workload.</p>
    #[doc(hidden)]
    pub notes: std::option::Option<std::string::String>,
    /// <p>The improvement status for a workload.</p>
    #[doc(hidden)]
    pub improvement_status: std::option::Option<crate::model::WorkloadImprovementStatus>,
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    #[doc(hidden)]
    pub risk_counts: std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
    /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
    #[doc(hidden)]
    pub pillar_priorities: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    #[doc(hidden)]
    pub lenses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>The ID assigned to the share invitation.</p>
    #[doc(hidden)]
    pub share_invitation_id: std::option::Option<std::string::String>,
    /// <p>The tags associated with the workload.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Discovery configuration associated to the workload.</p>
    #[doc(hidden)]
    pub discovery_config: std::option::Option<crate::model::WorkloadDiscoveryConfig>,
    /// <p>List of AppRegistry application ARNs associated to the workload.</p>
    #[doc(hidden)]
    pub applications: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl Workload {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The ARN for the workload.</p>
    pub fn workload_arn(&self) -> std::option::Option<&str> {
        self.workload_arn.as_deref()
    }
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    pub fn workload_name(&self) -> std::option::Option<&str> {
        self.workload_name.as_deref()
    }
    /// <p>The description for the workload.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The environment for the workload.</p>
    pub fn environment(&self) -> std::option::Option<&crate::model::WorkloadEnvironment> {
        self.environment.as_ref()
    }
    /// <p>The date and time recorded.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
    pub fn account_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.account_ids.as_deref()
    }
    /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
    pub fn aws_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.aws_regions.as_deref()
    }
    /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
    pub fn non_aws_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.non_aws_regions.as_deref()
    }
    /// <p>The URL of the architectural design for the workload.</p>
    pub fn architectural_design(&self) -> std::option::Option<&str> {
        self.architectural_design.as_deref()
    }
    /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
    pub fn review_owner(&self) -> std::option::Option<&str> {
        self.review_owner.as_deref()
    }
    /// <p>The date and time recorded.</p>
    pub fn review_restriction_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.review_restriction_date.as_ref()
    }
    /// <p>Flag indicating whether the workload owner has acknowledged that the <i>Review owner</i> field is required.</p>
    /// <p>If a <b>Review owner</b> is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.</p>
    pub fn is_review_owner_update_acknowledged(&self) -> bool {
        self.is_review_owner_update_acknowledged
    }
    /// <p>The industry type for the workload.</p>
    /// <p>If specified, must be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>Agriculture</code> </p> </li>
    /// <li> <p> <code>Automobile</code> </p> </li>
    /// <li> <p> <code>Defense</code> </p> </li>
    /// <li> <p> <code>Design and Engineering</code> </p> </li>
    /// <li> <p> <code>Digital Advertising</code> </p> </li>
    /// <li> <p> <code>Education</code> </p> </li>
    /// <li> <p> <code>Environmental Protection</code> </p> </li>
    /// <li> <p> <code>Financial Services</code> </p> </li>
    /// <li> <p> <code>Gaming</code> </p> </li>
    /// <li> <p> <code>General Public Services</code> </p> </li>
    /// <li> <p> <code>Healthcare</code> </p> </li>
    /// <li> <p> <code>Hospitality</code> </p> </li>
    /// <li> <p> <code>InfoTech</code> </p> </li>
    /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
    /// <li> <p> <code>Life Sciences</code> </p> </li>
    /// <li> <p> <code>Manufacturing</code> </p> </li>
    /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
    /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
    /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
    /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
    /// <li> <p> <code>Professional Services</code> </p> </li>
    /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
    /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
    /// <li> <p> <code>Social Protection</code> </p> </li>
    /// <li> <p> <code>Telecommunications</code> </p> </li>
    /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
    /// <li> <p> <code>Other</code> </p> </li>
    /// </ul>
    pub fn industry_type(&self) -> std::option::Option<&str> {
        self.industry_type.as_deref()
    }
    /// <p>The industry for the workload.</p>
    pub fn industry(&self) -> std::option::Option<&str> {
        self.industry.as_deref()
    }
    /// <p>The notes associated with the workload.</p>
    pub fn notes(&self) -> std::option::Option<&str> {
        self.notes.as_deref()
    }
    /// <p>The improvement status for a workload.</p>
    pub fn improvement_status(
        &self,
    ) -> std::option::Option<&crate::model::WorkloadImprovementStatus> {
        self.improvement_status.as_ref()
    }
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    pub fn risk_counts(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Risk, i32>> {
        self.risk_counts.as_ref()
    }
    /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_priorities(&self) -> std::option::Option<&[std::string::String]> {
        self.pillar_priorities.as_deref()
    }
    /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lenses(&self) -> std::option::Option<&[std::string::String]> {
        self.lenses.as_deref()
    }
    /// <p>An Amazon Web Services account ID.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>The ID assigned to the share invitation.</p>
    pub fn share_invitation_id(&self) -> std::option::Option<&str> {
        self.share_invitation_id.as_deref()
    }
    /// <p>The tags associated with the workload.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>Discovery configuration associated to the workload.</p>
    pub fn discovery_config(&self) -> std::option::Option<&crate::model::WorkloadDiscoveryConfig> {
        self.discovery_config.as_ref()
    }
    /// <p>List of AppRegistry application ARNs associated to the workload.</p>
    pub fn applications(&self) -> std::option::Option<&[std::string::String]> {
        self.applications.as_deref()
    }
}
impl Workload {
    /// Creates a new builder-style object to manufacture [`Workload`](crate::model::Workload).
    pub fn builder() -> crate::model::workload::Builder {
        crate::model::workload::Builder::default()
    }
}

/// See [`Workload`](crate::model::Workload).
pub mod workload {

    /// A builder for [`Workload`](crate::model::Workload).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) workload_arn: std::option::Option<std::string::String>,
        pub(crate) workload_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<crate::model::WorkloadEnvironment>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) account_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) non_aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) architectural_design: std::option::Option<std::string::String>,
        pub(crate) review_owner: std::option::Option<std::string::String>,
        pub(crate) review_restriction_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) is_review_owner_update_acknowledged: std::option::Option<bool>,
        pub(crate) industry_type: std::option::Option<std::string::String>,
        pub(crate) industry: std::option::Option<std::string::String>,
        pub(crate) notes: std::option::Option<std::string::String>,
        pub(crate) improvement_status: std::option::Option<crate::model::WorkloadImprovementStatus>,
        pub(crate) risk_counts:
            std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
        pub(crate) pillar_priorities: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) lenses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) share_invitation_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) discovery_config: std::option::Option<crate::model::WorkloadDiscoveryConfig>,
        pub(crate) applications: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The ARN for the workload.</p>
        pub fn workload_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the workload.</p>
        pub fn set_workload_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_arn = input;
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn workload_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_name = Some(input.into());
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn set_workload_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workload_name = input;
            self
        }
        /// <p>The description for the workload.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description for the workload.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The environment for the workload.</p>
        pub fn environment(mut self, input: crate::model::WorkloadEnvironment) -> Self {
            self.environment = Some(input);
            self
        }
        /// <p>The environment for the workload.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<crate::model::WorkloadEnvironment>,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Appends an item to `account_ids`.
        ///
        /// To override the contents of this collection use [`set_account_ids`](Self::set_account_ids).
        ///
        /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
        pub fn account_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.account_ids.unwrap_or_default();
            v.push(input.into());
            self.account_ids = Some(v);
            self
        }
        /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
        pub fn set_account_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.account_ids = input;
            self
        }
        /// Appends an item to `aws_regions`.
        ///
        /// To override the contents of this collection use [`set_aws_regions`](Self::set_aws_regions).
        ///
        /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
        pub fn aws_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.aws_regions.unwrap_or_default();
            v.push(input.into());
            self.aws_regions = Some(v);
            self
        }
        /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
        pub fn set_aws_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.aws_regions = input;
            self
        }
        /// Appends an item to `non_aws_regions`.
        ///
        /// To override the contents of this collection use [`set_non_aws_regions`](Self::set_non_aws_regions).
        ///
        /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
        pub fn non_aws_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.non_aws_regions.unwrap_or_default();
            v.push(input.into());
            self.non_aws_regions = Some(v);
            self
        }
        /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
        pub fn set_non_aws_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.non_aws_regions = input;
            self
        }
        /// <p>The URL of the architectural design for the workload.</p>
        pub fn architectural_design(mut self, input: impl Into<std::string::String>) -> Self {
            self.architectural_design = Some(input.into());
            self
        }
        /// <p>The URL of the architectural design for the workload.</p>
        pub fn set_architectural_design(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.architectural_design = input;
            self
        }
        /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
        pub fn review_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.review_owner = Some(input.into());
            self
        }
        /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
        pub fn set_review_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.review_owner = input;
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn review_restriction_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.review_restriction_date = Some(input);
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn set_review_restriction_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.review_restriction_date = input;
            self
        }
        /// <p>Flag indicating whether the workload owner has acknowledged that the <i>Review owner</i> field is required.</p>
        /// <p>If a <b>Review owner</b> is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.</p>
        pub fn is_review_owner_update_acknowledged(mut self, input: bool) -> Self {
            self.is_review_owner_update_acknowledged = Some(input);
            self
        }
        /// <p>Flag indicating whether the workload owner has acknowledged that the <i>Review owner</i> field is required.</p>
        /// <p>If a <b>Review owner</b> is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.</p>
        pub fn set_is_review_owner_update_acknowledged(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.is_review_owner_update_acknowledged = input;
            self
        }
        /// <p>The industry type for the workload.</p>
        /// <p>If specified, must be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>Agriculture</code> </p> </li>
        /// <li> <p> <code>Automobile</code> </p> </li>
        /// <li> <p> <code>Defense</code> </p> </li>
        /// <li> <p> <code>Design and Engineering</code> </p> </li>
        /// <li> <p> <code>Digital Advertising</code> </p> </li>
        /// <li> <p> <code>Education</code> </p> </li>
        /// <li> <p> <code>Environmental Protection</code> </p> </li>
        /// <li> <p> <code>Financial Services</code> </p> </li>
        /// <li> <p> <code>Gaming</code> </p> </li>
        /// <li> <p> <code>General Public Services</code> </p> </li>
        /// <li> <p> <code>Healthcare</code> </p> </li>
        /// <li> <p> <code>Hospitality</code> </p> </li>
        /// <li> <p> <code>InfoTech</code> </p> </li>
        /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
        /// <li> <p> <code>Life Sciences</code> </p> </li>
        /// <li> <p> <code>Manufacturing</code> </p> </li>
        /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
        /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
        /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
        /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
        /// <li> <p> <code>Professional Services</code> </p> </li>
        /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
        /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
        /// <li> <p> <code>Social Protection</code> </p> </li>
        /// <li> <p> <code>Telecommunications</code> </p> </li>
        /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
        /// <li> <p> <code>Other</code> </p> </li>
        /// </ul>
        pub fn industry_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.industry_type = Some(input.into());
            self
        }
        /// <p>The industry type for the workload.</p>
        /// <p>If specified, must be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>Agriculture</code> </p> </li>
        /// <li> <p> <code>Automobile</code> </p> </li>
        /// <li> <p> <code>Defense</code> </p> </li>
        /// <li> <p> <code>Design and Engineering</code> </p> </li>
        /// <li> <p> <code>Digital Advertising</code> </p> </li>
        /// <li> <p> <code>Education</code> </p> </li>
        /// <li> <p> <code>Environmental Protection</code> </p> </li>
        /// <li> <p> <code>Financial Services</code> </p> </li>
        /// <li> <p> <code>Gaming</code> </p> </li>
        /// <li> <p> <code>General Public Services</code> </p> </li>
        /// <li> <p> <code>Healthcare</code> </p> </li>
        /// <li> <p> <code>Hospitality</code> </p> </li>
        /// <li> <p> <code>InfoTech</code> </p> </li>
        /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
        /// <li> <p> <code>Life Sciences</code> </p> </li>
        /// <li> <p> <code>Manufacturing</code> </p> </li>
        /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
        /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
        /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
        /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
        /// <li> <p> <code>Professional Services</code> </p> </li>
        /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
        /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
        /// <li> <p> <code>Social Protection</code> </p> </li>
        /// <li> <p> <code>Telecommunications</code> </p> </li>
        /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
        /// <li> <p> <code>Other</code> </p> </li>
        /// </ul>
        pub fn set_industry_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.industry_type = input;
            self
        }
        /// <p>The industry for the workload.</p>
        pub fn industry(mut self, input: impl Into<std::string::String>) -> Self {
            self.industry = Some(input.into());
            self
        }
        /// <p>The industry for the workload.</p>
        pub fn set_industry(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.industry = input;
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.notes = Some(input.into());
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn set_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notes = input;
            self
        }
        /// <p>The improvement status for a workload.</p>
        pub fn improvement_status(
            mut self,
            input: crate::model::WorkloadImprovementStatus,
        ) -> Self {
            self.improvement_status = Some(input);
            self
        }
        /// <p>The improvement status for a workload.</p>
        pub fn set_improvement_status(
            mut self,
            input: std::option::Option<crate::model::WorkloadImprovementStatus>,
        ) -> Self {
            self.improvement_status = input;
            self
        }
        /// Adds a key-value pair to `risk_counts`.
        ///
        /// To override the contents of this collection use [`set_risk_counts`](Self::set_risk_counts).
        ///
        /// <p>A map from risk names to the count of how questions have that rating.</p>
        pub fn risk_counts(mut self, k: crate::model::Risk, v: i32) -> Self {
            let mut hash_map = self.risk_counts.unwrap_or_default();
            hash_map.insert(k, v);
            self.risk_counts = Some(hash_map);
            self
        }
        /// <p>A map from risk names to the count of how questions have that rating.</p>
        pub fn set_risk_counts(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
        ) -> Self {
            self.risk_counts = input;
            self
        }
        /// Appends an item to `pillar_priorities`.
        ///
        /// To override the contents of this collection use [`set_pillar_priorities`](Self::set_pillar_priorities).
        ///
        /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_priorities(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.pillar_priorities.unwrap_or_default();
            v.push(input.into());
            self.pillar_priorities = Some(v);
            self
        }
        /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_priorities(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.pillar_priorities = input;
            self
        }
        /// Appends an item to `lenses`.
        ///
        /// To override the contents of this collection use [`set_lenses`](Self::set_lenses).
        ///
        /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lenses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.lenses.unwrap_or_default();
            v.push(input.into());
            self.lenses = Some(v);
            self
        }
        /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lenses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.lenses = input;
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The ID assigned to the share invitation.</p>
        pub fn share_invitation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_invitation_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the share invitation.</p>
        pub fn set_share_invitation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.share_invitation_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags associated with the workload.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags associated with the workload.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Discovery configuration associated to the workload.</p>
        pub fn discovery_config(mut self, input: crate::model::WorkloadDiscoveryConfig) -> Self {
            self.discovery_config = Some(input);
            self
        }
        /// <p>Discovery configuration associated to the workload.</p>
        pub fn set_discovery_config(
            mut self,
            input: std::option::Option<crate::model::WorkloadDiscoveryConfig>,
        ) -> Self {
            self.discovery_config = input;
            self
        }
        /// Appends an item to `applications`.
        ///
        /// To override the contents of this collection use [`set_applications`](Self::set_applications).
        ///
        /// <p>List of AppRegistry application ARNs associated to the workload.</p>
        pub fn applications(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.applications.unwrap_or_default();
            v.push(input.into());
            self.applications = Some(v);
            self
        }
        /// <p>List of AppRegistry application ARNs associated to the workload.</p>
        pub fn set_applications(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.applications = input;
            self
        }
        /// Consumes the builder and constructs a [`Workload`](crate::model::Workload).
        pub fn build(self) -> crate::model::Workload {
            crate::model::Workload {
                workload_id: self.workload_id,
                workload_arn: self.workload_arn,
                workload_name: self.workload_name,
                description: self.description,
                environment: self.environment,
                updated_at: self.updated_at,
                account_ids: self.account_ids,
                aws_regions: self.aws_regions,
                non_aws_regions: self.non_aws_regions,
                architectural_design: self.architectural_design,
                review_owner: self.review_owner,
                review_restriction_date: self.review_restriction_date,
                is_review_owner_update_acknowledged: self
                    .is_review_owner_update_acknowledged
                    .unwrap_or_default(),
                industry_type: self.industry_type,
                industry: self.industry,
                notes: self.notes,
                improvement_status: self.improvement_status,
                risk_counts: self.risk_counts,
                pillar_priorities: self.pillar_priorities,
                lenses: self.lenses,
                owner: self.owner,
                share_invitation_id: self.share_invitation_id,
                tags: self.tags,
                discovery_config: self.discovery_config,
                applications: self.applications,
            }
        }
    }
}

/// <p>Discovery configuration associated to the workload.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkloadDiscoveryConfig {
    /// <p>Discovery integration status in respect to Trusted Advisor for the workload.</p>
    #[doc(hidden)]
    pub trusted_advisor_integration_status:
        std::option::Option<crate::model::TrustedAdvisorIntegrationStatus>,
}
impl WorkloadDiscoveryConfig {
    /// <p>Discovery integration status in respect to Trusted Advisor for the workload.</p>
    pub fn trusted_advisor_integration_status(
        &self,
    ) -> std::option::Option<&crate::model::TrustedAdvisorIntegrationStatus> {
        self.trusted_advisor_integration_status.as_ref()
    }
}
impl WorkloadDiscoveryConfig {
    /// Creates a new builder-style object to manufacture [`WorkloadDiscoveryConfig`](crate::model::WorkloadDiscoveryConfig).
    pub fn builder() -> crate::model::workload_discovery_config::Builder {
        crate::model::workload_discovery_config::Builder::default()
    }
}

/// See [`WorkloadDiscoveryConfig`](crate::model::WorkloadDiscoveryConfig).
pub mod workload_discovery_config {

    /// A builder for [`WorkloadDiscoveryConfig`](crate::model::WorkloadDiscoveryConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trusted_advisor_integration_status:
            std::option::Option<crate::model::TrustedAdvisorIntegrationStatus>,
    }
    impl Builder {
        /// <p>Discovery integration status in respect to Trusted Advisor for the workload.</p>
        pub fn trusted_advisor_integration_status(
            mut self,
            input: crate::model::TrustedAdvisorIntegrationStatus,
        ) -> Self {
            self.trusted_advisor_integration_status = Some(input);
            self
        }
        /// <p>Discovery integration status in respect to Trusted Advisor for the workload.</p>
        pub fn set_trusted_advisor_integration_status(
            mut self,
            input: std::option::Option<crate::model::TrustedAdvisorIntegrationStatus>,
        ) -> Self {
            self.trusted_advisor_integration_status = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkloadDiscoveryConfig`](crate::model::WorkloadDiscoveryConfig).
        pub fn build(self) -> crate::model::WorkloadDiscoveryConfig {
            crate::model::WorkloadDiscoveryConfig {
                trusted_advisor_integration_status: self.trusted_advisor_integration_status,
            }
        }
    }
}

/// When writing a match expression against `TrustedAdvisorIntegrationStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let trustedadvisorintegrationstatus = unimplemented!();
/// match trustedadvisorintegrationstatus {
///     TrustedAdvisorIntegrationStatus::Disabled => { /* ... */ },
///     TrustedAdvisorIntegrationStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `trustedadvisorintegrationstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TrustedAdvisorIntegrationStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TrustedAdvisorIntegrationStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TrustedAdvisorIntegrationStatus::NewFeature` is defined.
/// Specifically, when `trustedadvisorintegrationstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TrustedAdvisorIntegrationStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrustedAdvisorIntegrationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TrustedAdvisorIntegrationStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => TrustedAdvisorIntegrationStatus::Disabled,
            "ENABLED" => TrustedAdvisorIntegrationStatus::Enabled,
            other => TrustedAdvisorIntegrationStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for TrustedAdvisorIntegrationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrustedAdvisorIntegrationStatus::from(s))
    }
}
impl TrustedAdvisorIntegrationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrustedAdvisorIntegrationStatus::Disabled => "DISABLED",
            TrustedAdvisorIntegrationStatus::Enabled => "ENABLED",
            TrustedAdvisorIntegrationStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for TrustedAdvisorIntegrationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Risk`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let risk = unimplemented!();
/// match risk {
///     Risk::High => { /* ... */ },
///     Risk::Medium => { /* ... */ },
///     Risk::None => { /* ... */ },
///     Risk::NotApplicable => { /* ... */ },
///     Risk::Unanswered => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `risk` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Risk::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Risk::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Risk::NewFeature` is defined.
/// Specifically, when `risk` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Risk::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The risk for a given workload, lens review, pillar, or question.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Risk {
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    NotApplicable,
    #[allow(missing_docs)] // documentation missing in model
    Unanswered,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Risk {
    fn from(s: &str) -> Self {
        match s {
            "HIGH" => Risk::High,
            "MEDIUM" => Risk::Medium,
            "NONE" => Risk::None,
            "NOT_APPLICABLE" => Risk::NotApplicable,
            "UNANSWERED" => Risk::Unanswered,
            other => Risk::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Risk {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Risk::from(s))
    }
}
impl Risk {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Risk::High => "HIGH",
            Risk::Medium => "MEDIUM",
            Risk::None => "NONE",
            Risk::NotApplicable => "NOT_APPLICABLE",
            Risk::Unanswered => "UNANSWERED",
            Risk::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HIGH", "MEDIUM", "NONE", "NOT_APPLICABLE", "UNANSWERED"]
    }
}
impl AsRef<str> for Risk {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WorkloadImprovementStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workloadimprovementstatus = unimplemented!();
/// match workloadimprovementstatus {
///     WorkloadImprovementStatus::Complete => { /* ... */ },
///     WorkloadImprovementStatus::InProgress => { /* ... */ },
///     WorkloadImprovementStatus::NotApplicable => { /* ... */ },
///     WorkloadImprovementStatus::NotStarted => { /* ... */ },
///     WorkloadImprovementStatus::RiskAcknowledged => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workloadimprovementstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkloadImprovementStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkloadImprovementStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkloadImprovementStatus::NewFeature` is defined.
/// Specifically, when `workloadimprovementstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkloadImprovementStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The improvement status for a workload.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkloadImprovementStatus {
    #[allow(missing_docs)] // documentation missing in model
    Complete,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotApplicable,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    #[allow(missing_docs)] // documentation missing in model
    RiskAcknowledged,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkloadImprovementStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETE" => WorkloadImprovementStatus::Complete,
            "IN_PROGRESS" => WorkloadImprovementStatus::InProgress,
            "NOT_APPLICABLE" => WorkloadImprovementStatus::NotApplicable,
            "NOT_STARTED" => WorkloadImprovementStatus::NotStarted,
            "RISK_ACKNOWLEDGED" => WorkloadImprovementStatus::RiskAcknowledged,
            other => WorkloadImprovementStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for WorkloadImprovementStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkloadImprovementStatus::from(s))
    }
}
impl WorkloadImprovementStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkloadImprovementStatus::Complete => "COMPLETE",
            WorkloadImprovementStatus::InProgress => "IN_PROGRESS",
            WorkloadImprovementStatus::NotApplicable => "NOT_APPLICABLE",
            WorkloadImprovementStatus::NotStarted => "NOT_STARTED",
            WorkloadImprovementStatus::RiskAcknowledged => "RISK_ACKNOWLEDGED",
            WorkloadImprovementStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETE",
            "IN_PROGRESS",
            "NOT_APPLICABLE",
            "NOT_STARTED",
            "RISK_ACKNOWLEDGED",
        ]
    }
}
impl AsRef<str> for WorkloadImprovementStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WorkloadEnvironment`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workloadenvironment = unimplemented!();
/// match workloadenvironment {
///     WorkloadEnvironment::Preproduction => { /* ... */ },
///     WorkloadEnvironment::Production => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workloadenvironment` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkloadEnvironment::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkloadEnvironment::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkloadEnvironment::NewFeature` is defined.
/// Specifically, when `workloadenvironment` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkloadEnvironment::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The environment for the workload.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkloadEnvironment {
    #[allow(missing_docs)] // documentation missing in model
    Preproduction,
    #[allow(missing_docs)] // documentation missing in model
    Production,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkloadEnvironment {
    fn from(s: &str) -> Self {
        match s {
            "PREPRODUCTION" => WorkloadEnvironment::Preproduction,
            "PRODUCTION" => WorkloadEnvironment::Production,
            other => {
                WorkloadEnvironment::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WorkloadEnvironment {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkloadEnvironment::from(s))
    }
}
impl WorkloadEnvironment {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkloadEnvironment::Preproduction => "PREPRODUCTION",
            WorkloadEnvironment::Production => "PRODUCTION",
            WorkloadEnvironment::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PREPRODUCTION", "PRODUCTION"]
    }
}
impl AsRef<str> for WorkloadEnvironment {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The share invitation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ShareInvitation {
    /// <p>The ID assigned to the share invitation.</p>
    #[doc(hidden)]
    pub share_invitation_id: std::option::Option<std::string::String>,
    /// <p>The resource type of the share invitation.</p>
    #[doc(hidden)]
    pub share_resource_type: std::option::Option<crate::model::ShareResourceType>,
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    #[doc(hidden)]
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The ARN for the lens.</p>
    #[doc(hidden)]
    pub lens_arn: std::option::Option<std::string::String>,
}
impl ShareInvitation {
    /// <p>The ID assigned to the share invitation.</p>
    pub fn share_invitation_id(&self) -> std::option::Option<&str> {
        self.share_invitation_id.as_deref()
    }
    /// <p>The resource type of the share invitation.</p>
    pub fn share_resource_type(&self) -> std::option::Option<&crate::model::ShareResourceType> {
        self.share_resource_type.as_ref()
    }
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The ARN for the lens.</p>
    pub fn lens_arn(&self) -> std::option::Option<&str> {
        self.lens_arn.as_deref()
    }
}
impl ShareInvitation {
    /// Creates a new builder-style object to manufacture [`ShareInvitation`](crate::model::ShareInvitation).
    pub fn builder() -> crate::model::share_invitation::Builder {
        crate::model::share_invitation::Builder::default()
    }
}

/// See [`ShareInvitation`](crate::model::ShareInvitation).
pub mod share_invitation {

    /// A builder for [`ShareInvitation`](crate::model::ShareInvitation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) share_invitation_id: std::option::Option<std::string::String>,
        pub(crate) share_resource_type: std::option::Option<crate::model::ShareResourceType>,
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) lens_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID assigned to the share invitation.</p>
        pub fn share_invitation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_invitation_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the share invitation.</p>
        pub fn set_share_invitation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.share_invitation_id = input;
            self
        }
        /// <p>The resource type of the share invitation.</p>
        pub fn share_resource_type(mut self, input: crate::model::ShareResourceType) -> Self {
            self.share_resource_type = Some(input);
            self
        }
        /// <p>The resource type of the share invitation.</p>
        pub fn set_share_resource_type(
            mut self,
            input: std::option::Option<crate::model::ShareResourceType>,
        ) -> Self {
            self.share_resource_type = input;
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn lens_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn set_lens_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ShareInvitation`](crate::model::ShareInvitation).
        pub fn build(self) -> crate::model::ShareInvitation {
            crate::model::ShareInvitation {
                share_invitation_id: self.share_invitation_id,
                share_resource_type: self.share_resource_type,
                workload_id: self.workload_id,
                lens_alias: self.lens_alias,
                lens_arn: self.lens_arn,
            }
        }
    }
}

/// When writing a match expression against `ShareResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let shareresourcetype = unimplemented!();
/// match shareresourcetype {
///     ShareResourceType::Lens => { /* ... */ },
///     ShareResourceType::Workload => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `shareresourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ShareResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ShareResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ShareResourceType::NewFeature` is defined.
/// Specifically, when `shareresourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ShareResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ShareResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Lens,
    #[allow(missing_docs)] // documentation missing in model
    Workload,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ShareResourceType {
    fn from(s: &str) -> Self {
        match s {
            "LENS" => ShareResourceType::Lens,
            "WORKLOAD" => ShareResourceType::Workload,
            other => {
                ShareResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ShareResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ShareResourceType::from(s))
    }
}
impl ShareResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ShareResourceType::Lens => "LENS",
            ShareResourceType::Workload => "WORKLOAD",
            ShareResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LENS", "WORKLOAD"]
    }
}
impl AsRef<str> for ShareResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ShareInvitationAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let shareinvitationaction = unimplemented!();
/// match shareinvitationaction {
///     ShareInvitationAction::Accept => { /* ... */ },
///     ShareInvitationAction::Reject => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `shareinvitationaction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ShareInvitationAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ShareInvitationAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ShareInvitationAction::NewFeature` is defined.
/// Specifically, when `shareinvitationaction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ShareInvitationAction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Share invitation action taken by contributor.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ShareInvitationAction {
    #[allow(missing_docs)] // documentation missing in model
    Accept,
    #[allow(missing_docs)] // documentation missing in model
    Reject,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ShareInvitationAction {
    fn from(s: &str) -> Self {
        match s {
            "ACCEPT" => ShareInvitationAction::Accept,
            "REJECT" => ShareInvitationAction::Reject,
            other => {
                ShareInvitationAction::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ShareInvitationAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ShareInvitationAction::from(s))
    }
}
impl ShareInvitationAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ShareInvitationAction::Accept => "ACCEPT",
            ShareInvitationAction::Reject => "REJECT",
            ShareInvitationAction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACCEPT", "REJECT"]
    }
}
impl AsRef<str> for ShareInvitationAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A lens review of a question.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LensReview {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    #[doc(hidden)]
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The ARN for the lens.</p>
    #[doc(hidden)]
    pub lens_arn: std::option::Option<std::string::String>,
    /// <p>The version of the lens.</p>
    #[doc(hidden)]
    pub lens_version: std::option::Option<std::string::String>,
    /// <p>The full name of the lens.</p>
    #[doc(hidden)]
    pub lens_name: std::option::Option<std::string::String>,
    /// <p>The status of the lens.</p>
    #[doc(hidden)]
    pub lens_status: std::option::Option<crate::model::LensStatus>,
    /// <p>List of pillar review summaries of lens review in a workload.</p>
    #[doc(hidden)]
    pub pillar_review_summaries:
        std::option::Option<std::vec::Vec<crate::model::PillarReviewSummary>>,
    /// <p>The date and time recorded.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The notes associated with the workload.</p>
    #[doc(hidden)]
    pub notes: std::option::Option<std::string::String>,
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    #[doc(hidden)]
    pub risk_counts: std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
    /// <p>The token to use to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl LensReview {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The ARN for the lens.</p>
    pub fn lens_arn(&self) -> std::option::Option<&str> {
        self.lens_arn.as_deref()
    }
    /// <p>The version of the lens.</p>
    pub fn lens_version(&self) -> std::option::Option<&str> {
        self.lens_version.as_deref()
    }
    /// <p>The full name of the lens.</p>
    pub fn lens_name(&self) -> std::option::Option<&str> {
        self.lens_name.as_deref()
    }
    /// <p>The status of the lens.</p>
    pub fn lens_status(&self) -> std::option::Option<&crate::model::LensStatus> {
        self.lens_status.as_ref()
    }
    /// <p>List of pillar review summaries of lens review in a workload.</p>
    pub fn pillar_review_summaries(
        &self,
    ) -> std::option::Option<&[crate::model::PillarReviewSummary]> {
        self.pillar_review_summaries.as_deref()
    }
    /// <p>The date and time recorded.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The notes associated with the workload.</p>
    pub fn notes(&self) -> std::option::Option<&str> {
        self.notes.as_deref()
    }
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    pub fn risk_counts(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Risk, i32>> {
        self.risk_counts.as_ref()
    }
    /// <p>The token to use to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl LensReview {
    /// Creates a new builder-style object to manufacture [`LensReview`](crate::model::LensReview).
    pub fn builder() -> crate::model::lens_review::Builder {
        crate::model::lens_review::Builder::default()
    }
}

/// See [`LensReview`](crate::model::LensReview).
pub mod lens_review {

    /// A builder for [`LensReview`](crate::model::LensReview).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) lens_arn: std::option::Option<std::string::String>,
        pub(crate) lens_version: std::option::Option<std::string::String>,
        pub(crate) lens_name: std::option::Option<std::string::String>,
        pub(crate) lens_status: std::option::Option<crate::model::LensStatus>,
        pub(crate) pillar_review_summaries:
            std::option::Option<std::vec::Vec<crate::model::PillarReviewSummary>>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) notes: std::option::Option<std::string::String>,
        pub(crate) risk_counts:
            std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn lens_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn set_lens_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_arn = input;
            self
        }
        /// <p>The version of the lens.</p>
        pub fn lens_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_version = Some(input.into());
            self
        }
        /// <p>The version of the lens.</p>
        pub fn set_lens_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_version = input;
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn lens_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_name = Some(input.into());
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn set_lens_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_name = input;
            self
        }
        /// <p>The status of the lens.</p>
        pub fn lens_status(mut self, input: crate::model::LensStatus) -> Self {
            self.lens_status = Some(input);
            self
        }
        /// <p>The status of the lens.</p>
        pub fn set_lens_status(
            mut self,
            input: std::option::Option<crate::model::LensStatus>,
        ) -> Self {
            self.lens_status = input;
            self
        }
        /// Appends an item to `pillar_review_summaries`.
        ///
        /// To override the contents of this collection use [`set_pillar_review_summaries`](Self::set_pillar_review_summaries).
        ///
        /// <p>List of pillar review summaries of lens review in a workload.</p>
        pub fn pillar_review_summaries(mut self, input: crate::model::PillarReviewSummary) -> Self {
            let mut v = self.pillar_review_summaries.unwrap_or_default();
            v.push(input);
            self.pillar_review_summaries = Some(v);
            self
        }
        /// <p>List of pillar review summaries of lens review in a workload.</p>
        pub fn set_pillar_review_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PillarReviewSummary>>,
        ) -> Self {
            self.pillar_review_summaries = input;
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.notes = Some(input.into());
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn set_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notes = input;
            self
        }
        /// Adds a key-value pair to `risk_counts`.
        ///
        /// To override the contents of this collection use [`set_risk_counts`](Self::set_risk_counts).
        ///
        /// <p>A map from risk names to the count of how questions have that rating.</p>
        pub fn risk_counts(mut self, k: crate::model::Risk, v: i32) -> Self {
            let mut hash_map = self.risk_counts.unwrap_or_default();
            hash_map.insert(k, v);
            self.risk_counts = Some(hash_map);
            self
        }
        /// <p>A map from risk names to the count of how questions have that rating.</p>
        pub fn set_risk_counts(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
        ) -> Self {
            self.risk_counts = input;
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`LensReview`](crate::model::LensReview).
        pub fn build(self) -> crate::model::LensReview {
            crate::model::LensReview {
                lens_alias: self.lens_alias,
                lens_arn: self.lens_arn,
                lens_version: self.lens_version,
                lens_name: self.lens_name,
                lens_status: self.lens_status,
                pillar_review_summaries: self.pillar_review_summaries,
                updated_at: self.updated_at,
                notes: self.notes,
                risk_counts: self.risk_counts,
                next_token: self.next_token,
            }
        }
    }
}

/// <p>A pillar review summary of a lens review.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PillarReviewSummary {
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    #[doc(hidden)]
    pub pillar_id: std::option::Option<std::string::String>,
    /// <p>The name of the pillar.</p>
    #[doc(hidden)]
    pub pillar_name: std::option::Option<std::string::String>,
    /// <p>The notes associated with the workload.</p>
    #[doc(hidden)]
    pub notes: std::option::Option<std::string::String>,
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    #[doc(hidden)]
    pub risk_counts: std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
}
impl PillarReviewSummary {
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_id(&self) -> std::option::Option<&str> {
        self.pillar_id.as_deref()
    }
    /// <p>The name of the pillar.</p>
    pub fn pillar_name(&self) -> std::option::Option<&str> {
        self.pillar_name.as_deref()
    }
    /// <p>The notes associated with the workload.</p>
    pub fn notes(&self) -> std::option::Option<&str> {
        self.notes.as_deref()
    }
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    pub fn risk_counts(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Risk, i32>> {
        self.risk_counts.as_ref()
    }
}
impl PillarReviewSummary {
    /// Creates a new builder-style object to manufacture [`PillarReviewSummary`](crate::model::PillarReviewSummary).
    pub fn builder() -> crate::model::pillar_review_summary::Builder {
        crate::model::pillar_review_summary::Builder::default()
    }
}

/// See [`PillarReviewSummary`](crate::model::PillarReviewSummary).
pub mod pillar_review_summary {

    /// A builder for [`PillarReviewSummary`](crate::model::PillarReviewSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pillar_id: std::option::Option<std::string::String>,
        pub(crate) pillar_name: std::option::Option<std::string::String>,
        pub(crate) notes: std::option::Option<std::string::String>,
        pub(crate) risk_counts:
            std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
    }
    impl Builder {
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pillar_id = Some(input.into());
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pillar_id = input;
            self
        }
        /// <p>The name of the pillar.</p>
        pub fn pillar_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.pillar_name = Some(input.into());
            self
        }
        /// <p>The name of the pillar.</p>
        pub fn set_pillar_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pillar_name = input;
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.notes = Some(input.into());
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn set_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notes = input;
            self
        }
        /// Adds a key-value pair to `risk_counts`.
        ///
        /// To override the contents of this collection use [`set_risk_counts`](Self::set_risk_counts).
        ///
        /// <p>A map from risk names to the count of how questions have that rating.</p>
        pub fn risk_counts(mut self, k: crate::model::Risk, v: i32) -> Self {
            let mut hash_map = self.risk_counts.unwrap_or_default();
            hash_map.insert(k, v);
            self.risk_counts = Some(hash_map);
            self
        }
        /// <p>A map from risk names to the count of how questions have that rating.</p>
        pub fn set_risk_counts(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
        ) -> Self {
            self.risk_counts = input;
            self
        }
        /// Consumes the builder and constructs a [`PillarReviewSummary`](crate::model::PillarReviewSummary).
        pub fn build(self) -> crate::model::PillarReviewSummary {
            crate::model::PillarReviewSummary {
                pillar_id: self.pillar_id,
                pillar_name: self.pillar_name,
                notes: self.notes,
                risk_counts: self.risk_counts,
            }
        }
    }
}

/// When writing a match expression against `LensStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lensstatus = unimplemented!();
/// match lensstatus {
///     LensStatus::Current => { /* ... */ },
///     LensStatus::Deleted => { /* ... */ },
///     LensStatus::Deprecated => { /* ... */ },
///     LensStatus::NotCurrent => { /* ... */ },
///     LensStatus::Unshared => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lensstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LensStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LensStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LensStatus::NewFeature` is defined.
/// Specifically, when `lensstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LensStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LensStatus {
    #[allow(missing_docs)] // documentation missing in model
    Current,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deprecated,
    #[allow(missing_docs)] // documentation missing in model
    NotCurrent,
    #[allow(missing_docs)] // documentation missing in model
    Unshared,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LensStatus {
    fn from(s: &str) -> Self {
        match s {
            "CURRENT" => LensStatus::Current,
            "DELETED" => LensStatus::Deleted,
            "DEPRECATED" => LensStatus::Deprecated,
            "NOT_CURRENT" => LensStatus::NotCurrent,
            "UNSHARED" => LensStatus::Unshared,
            other => LensStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LensStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LensStatus::from(s))
    }
}
impl LensStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LensStatus::Current => "CURRENT",
            LensStatus::Deleted => "DELETED",
            LensStatus::Deprecated => "DEPRECATED",
            LensStatus::NotCurrent => "NOT_CURRENT",
            LensStatus::Unshared => "UNSHARED",
            LensStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CURRENT",
            "DELETED",
            "DEPRECATED",
            "NOT_CURRENT",
            "UNSHARED",
        ]
    }
}
impl AsRef<str> for LensStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `OrganizationSharingStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let organizationsharingstatus = unimplemented!();
/// match organizationsharingstatus {
///     OrganizationSharingStatus::Disabled => { /* ... */ },
///     OrganizationSharingStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `organizationsharingstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrganizationSharingStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrganizationSharingStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrganizationSharingStatus::NewFeature` is defined.
/// Specifically, when `organizationsharingstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrganizationSharingStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrganizationSharingStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrganizationSharingStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => OrganizationSharingStatus::Disabled,
            "ENABLED" => OrganizationSharingStatus::Enabled,
            other => OrganizationSharingStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for OrganizationSharingStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrganizationSharingStatus::from(s))
    }
}
impl OrganizationSharingStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrganizationSharingStatus::Disabled => "DISABLED",
            OrganizationSharingStatus::Enabled => "ENABLED",
            OrganizationSharingStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for OrganizationSharingStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An answer of the question.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Answer {
    /// <p>The ID of the question.</p>
    #[doc(hidden)]
    pub question_id: std::option::Option<std::string::String>,
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    #[doc(hidden)]
    pub pillar_id: std::option::Option<std::string::String>,
    /// <p>The title of the question.</p>
    #[doc(hidden)]
    pub question_title: std::option::Option<std::string::String>,
    /// <p>The description of the question.</p>
    #[doc(hidden)]
    pub question_description: std::option::Option<std::string::String>,
    /// <p>The improvement plan URL for a question.</p>
    /// <p>This value is only available if the question has been answered.</p>
    #[doc(hidden)]
    pub improvement_plan_url: std::option::Option<std::string::String>,
    /// <p>The helpful resource URL for a question.</p>
    #[doc(hidden)]
    pub helpful_resource_url: std::option::Option<std::string::String>,
    /// <p>The helpful resource text to be displayed.</p>
    #[doc(hidden)]
    pub helpful_resource_display_text: std::option::Option<std::string::String>,
    /// <p>List of choices available for a question.</p>
    #[doc(hidden)]
    pub choices: std::option::Option<std::vec::Vec<crate::model::Choice>>,
    /// <p>List of selected choice IDs in a question answer.</p>
    /// <p>The values entered replace the previously selected choices.</p>
    #[doc(hidden)]
    pub selected_choices: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of selected choices to a question in your workload.</p>
    #[doc(hidden)]
    pub choice_answers: std::option::Option<std::vec::Vec<crate::model::ChoiceAnswer>>,
    /// <p>Defines whether this question is applicable to a lens review.</p>
    #[doc(hidden)]
    pub is_applicable: bool,
    /// <p>The risk for a given workload, lens review, pillar, or question.</p>
    #[doc(hidden)]
    pub risk: std::option::Option<crate::model::Risk>,
    /// <p>The notes associated with the workload.</p>
    #[doc(hidden)]
    pub notes: std::option::Option<std::string::String>,
    /// <p>The reason why the question is not applicable to your workload.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::AnswerReason>,
}
impl Answer {
    /// <p>The ID of the question.</p>
    pub fn question_id(&self) -> std::option::Option<&str> {
        self.question_id.as_deref()
    }
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_id(&self) -> std::option::Option<&str> {
        self.pillar_id.as_deref()
    }
    /// <p>The title of the question.</p>
    pub fn question_title(&self) -> std::option::Option<&str> {
        self.question_title.as_deref()
    }
    /// <p>The description of the question.</p>
    pub fn question_description(&self) -> std::option::Option<&str> {
        self.question_description.as_deref()
    }
    /// <p>The improvement plan URL for a question.</p>
    /// <p>This value is only available if the question has been answered.</p>
    pub fn improvement_plan_url(&self) -> std::option::Option<&str> {
        self.improvement_plan_url.as_deref()
    }
    /// <p>The helpful resource URL for a question.</p>
    pub fn helpful_resource_url(&self) -> std::option::Option<&str> {
        self.helpful_resource_url.as_deref()
    }
    /// <p>The helpful resource text to be displayed.</p>
    pub fn helpful_resource_display_text(&self) -> std::option::Option<&str> {
        self.helpful_resource_display_text.as_deref()
    }
    /// <p>List of choices available for a question.</p>
    pub fn choices(&self) -> std::option::Option<&[crate::model::Choice]> {
        self.choices.as_deref()
    }
    /// <p>List of selected choice IDs in a question answer.</p>
    /// <p>The values entered replace the previously selected choices.</p>
    pub fn selected_choices(&self) -> std::option::Option<&[std::string::String]> {
        self.selected_choices.as_deref()
    }
    /// <p>A list of selected choices to a question in your workload.</p>
    pub fn choice_answers(&self) -> std::option::Option<&[crate::model::ChoiceAnswer]> {
        self.choice_answers.as_deref()
    }
    /// <p>Defines whether this question is applicable to a lens review.</p>
    pub fn is_applicable(&self) -> bool {
        self.is_applicable
    }
    /// <p>The risk for a given workload, lens review, pillar, or question.</p>
    pub fn risk(&self) -> std::option::Option<&crate::model::Risk> {
        self.risk.as_ref()
    }
    /// <p>The notes associated with the workload.</p>
    pub fn notes(&self) -> std::option::Option<&str> {
        self.notes.as_deref()
    }
    /// <p>The reason why the question is not applicable to your workload.</p>
    pub fn reason(&self) -> std::option::Option<&crate::model::AnswerReason> {
        self.reason.as_ref()
    }
}
impl Answer {
    /// Creates a new builder-style object to manufacture [`Answer`](crate::model::Answer).
    pub fn builder() -> crate::model::answer::Builder {
        crate::model::answer::Builder::default()
    }
}

/// See [`Answer`](crate::model::Answer).
pub mod answer {

    /// A builder for [`Answer`](crate::model::Answer).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) question_id: std::option::Option<std::string::String>,
        pub(crate) pillar_id: std::option::Option<std::string::String>,
        pub(crate) question_title: std::option::Option<std::string::String>,
        pub(crate) question_description: std::option::Option<std::string::String>,
        pub(crate) improvement_plan_url: std::option::Option<std::string::String>,
        pub(crate) helpful_resource_url: std::option::Option<std::string::String>,
        pub(crate) helpful_resource_display_text: std::option::Option<std::string::String>,
        pub(crate) choices: std::option::Option<std::vec::Vec<crate::model::Choice>>,
        pub(crate) selected_choices: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) choice_answers: std::option::Option<std::vec::Vec<crate::model::ChoiceAnswer>>,
        pub(crate) is_applicable: std::option::Option<bool>,
        pub(crate) risk: std::option::Option<crate::model::Risk>,
        pub(crate) notes: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::AnswerReason>,
    }
    impl Builder {
        /// <p>The ID of the question.</p>
        pub fn question_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_id = Some(input.into());
            self
        }
        /// <p>The ID of the question.</p>
        pub fn set_question_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.question_id = input;
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pillar_id = Some(input.into());
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pillar_id = input;
            self
        }
        /// <p>The title of the question.</p>
        pub fn question_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_title = Some(input.into());
            self
        }
        /// <p>The title of the question.</p>
        pub fn set_question_title(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.question_title = input;
            self
        }
        /// <p>The description of the question.</p>
        pub fn question_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_description = Some(input.into());
            self
        }
        /// <p>The description of the question.</p>
        pub fn set_question_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.question_description = input;
            self
        }
        /// <p>The improvement plan URL for a question.</p>
        /// <p>This value is only available if the question has been answered.</p>
        pub fn improvement_plan_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.improvement_plan_url = Some(input.into());
            self
        }
        /// <p>The improvement plan URL for a question.</p>
        /// <p>This value is only available if the question has been answered.</p>
        pub fn set_improvement_plan_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.improvement_plan_url = input;
            self
        }
        /// <p>The helpful resource URL for a question.</p>
        pub fn helpful_resource_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.helpful_resource_url = Some(input.into());
            self
        }
        /// <p>The helpful resource URL for a question.</p>
        pub fn set_helpful_resource_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.helpful_resource_url = input;
            self
        }
        /// <p>The helpful resource text to be displayed.</p>
        pub fn helpful_resource_display_text(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.helpful_resource_display_text = Some(input.into());
            self
        }
        /// <p>The helpful resource text to be displayed.</p>
        pub fn set_helpful_resource_display_text(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.helpful_resource_display_text = input;
            self
        }
        /// Appends an item to `choices`.
        ///
        /// To override the contents of this collection use [`set_choices`](Self::set_choices).
        ///
        /// <p>List of choices available for a question.</p>
        pub fn choices(mut self, input: crate::model::Choice) -> Self {
            let mut v = self.choices.unwrap_or_default();
            v.push(input);
            self.choices = Some(v);
            self
        }
        /// <p>List of choices available for a question.</p>
        pub fn set_choices(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Choice>>,
        ) -> Self {
            self.choices = input;
            self
        }
        /// Appends an item to `selected_choices`.
        ///
        /// To override the contents of this collection use [`set_selected_choices`](Self::set_selected_choices).
        ///
        /// <p>List of selected choice IDs in a question answer.</p>
        /// <p>The values entered replace the previously selected choices.</p>
        pub fn selected_choices(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.selected_choices.unwrap_or_default();
            v.push(input.into());
            self.selected_choices = Some(v);
            self
        }
        /// <p>List of selected choice IDs in a question answer.</p>
        /// <p>The values entered replace the previously selected choices.</p>
        pub fn set_selected_choices(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.selected_choices = input;
            self
        }
        /// Appends an item to `choice_answers`.
        ///
        /// To override the contents of this collection use [`set_choice_answers`](Self::set_choice_answers).
        ///
        /// <p>A list of selected choices to a question in your workload.</p>
        pub fn choice_answers(mut self, input: crate::model::ChoiceAnswer) -> Self {
            let mut v = self.choice_answers.unwrap_or_default();
            v.push(input);
            self.choice_answers = Some(v);
            self
        }
        /// <p>A list of selected choices to a question in your workload.</p>
        pub fn set_choice_answers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChoiceAnswer>>,
        ) -> Self {
            self.choice_answers = input;
            self
        }
        /// <p>Defines whether this question is applicable to a lens review.</p>
        pub fn is_applicable(mut self, input: bool) -> Self {
            self.is_applicable = Some(input);
            self
        }
        /// <p>Defines whether this question is applicable to a lens review.</p>
        pub fn set_is_applicable(mut self, input: std::option::Option<bool>) -> Self {
            self.is_applicable = input;
            self
        }
        /// <p>The risk for a given workload, lens review, pillar, or question.</p>
        pub fn risk(mut self, input: crate::model::Risk) -> Self {
            self.risk = Some(input);
            self
        }
        /// <p>The risk for a given workload, lens review, pillar, or question.</p>
        pub fn set_risk(mut self, input: std::option::Option<crate::model::Risk>) -> Self {
            self.risk = input;
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.notes = Some(input.into());
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn set_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notes = input;
            self
        }
        /// <p>The reason why the question is not applicable to your workload.</p>
        pub fn reason(mut self, input: crate::model::AnswerReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>The reason why the question is not applicable to your workload.</p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::AnswerReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`Answer`](crate::model::Answer).
        pub fn build(self) -> crate::model::Answer {
            crate::model::Answer {
                question_id: self.question_id,
                pillar_id: self.pillar_id,
                question_title: self.question_title,
                question_description: self.question_description,
                improvement_plan_url: self.improvement_plan_url,
                helpful_resource_url: self.helpful_resource_url,
                helpful_resource_display_text: self.helpful_resource_display_text,
                choices: self.choices,
                selected_choices: self.selected_choices,
                choice_answers: self.choice_answers,
                is_applicable: self.is_applicable.unwrap_or_default(),
                risk: self.risk,
                notes: self.notes,
                reason: self.reason,
            }
        }
    }
}

/// When writing a match expression against `AnswerReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let answerreason = unimplemented!();
/// match answerreason {
///     AnswerReason::ArchitectureConstraints => { /* ... */ },
///     AnswerReason::BusinessPriorities => { /* ... */ },
///     AnswerReason::None => { /* ... */ },
///     AnswerReason::Other => { /* ... */ },
///     AnswerReason::OutOfScope => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `answerreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AnswerReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AnswerReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AnswerReason::NewFeature` is defined.
/// Specifically, when `answerreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AnswerReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AnswerReason {
    #[allow(missing_docs)] // documentation missing in model
    ArchitectureConstraints,
    #[allow(missing_docs)] // documentation missing in model
    BusinessPriorities,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    OutOfScope,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AnswerReason {
    fn from(s: &str) -> Self {
        match s {
            "ARCHITECTURE_CONSTRAINTS" => AnswerReason::ArchitectureConstraints,
            "BUSINESS_PRIORITIES" => AnswerReason::BusinessPriorities,
            "NONE" => AnswerReason::None,
            "OTHER" => AnswerReason::Other,
            "OUT_OF_SCOPE" => AnswerReason::OutOfScope,
            other => AnswerReason::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AnswerReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AnswerReason::from(s))
    }
}
impl AnswerReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AnswerReason::ArchitectureConstraints => "ARCHITECTURE_CONSTRAINTS",
            AnswerReason::BusinessPriorities => "BUSINESS_PRIORITIES",
            AnswerReason::None => "NONE",
            AnswerReason::Other => "OTHER",
            AnswerReason::OutOfScope => "OUT_OF_SCOPE",
            AnswerReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ARCHITECTURE_CONSTRAINTS",
            "BUSINESS_PRIORITIES",
            "NONE",
            "OTHER",
            "OUT_OF_SCOPE",
        ]
    }
}
impl AsRef<str> for AnswerReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A choice that has been answered on a question in your workload.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChoiceAnswer {
    /// <p>The ID of a choice.</p>
    #[doc(hidden)]
    pub choice_id: std::option::Option<std::string::String>,
    /// <p>The status of a choice.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ChoiceStatus>,
    /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::ChoiceReason>,
    /// <p>The notes associated with a choice.</p>
    #[doc(hidden)]
    pub notes: std::option::Option<std::string::String>,
}
impl ChoiceAnswer {
    /// <p>The ID of a choice.</p>
    pub fn choice_id(&self) -> std::option::Option<&str> {
        self.choice_id.as_deref()
    }
    /// <p>The status of a choice.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ChoiceStatus> {
        self.status.as_ref()
    }
    /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
    pub fn reason(&self) -> std::option::Option<&crate::model::ChoiceReason> {
        self.reason.as_ref()
    }
    /// <p>The notes associated with a choice.</p>
    pub fn notes(&self) -> std::option::Option<&str> {
        self.notes.as_deref()
    }
}
impl ChoiceAnswer {
    /// Creates a new builder-style object to manufacture [`ChoiceAnswer`](crate::model::ChoiceAnswer).
    pub fn builder() -> crate::model::choice_answer::Builder {
        crate::model::choice_answer::Builder::default()
    }
}

/// See [`ChoiceAnswer`](crate::model::ChoiceAnswer).
pub mod choice_answer {

    /// A builder for [`ChoiceAnswer`](crate::model::ChoiceAnswer).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) choice_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ChoiceStatus>,
        pub(crate) reason: std::option::Option<crate::model::ChoiceReason>,
        pub(crate) notes: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a choice.</p>
        pub fn choice_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.choice_id = Some(input.into());
            self
        }
        /// <p>The ID of a choice.</p>
        pub fn set_choice_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.choice_id = input;
            self
        }
        /// <p>The status of a choice.</p>
        pub fn status(mut self, input: crate::model::ChoiceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of a choice.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ChoiceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
        pub fn reason(mut self, input: crate::model::ChoiceReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::ChoiceReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// <p>The notes associated with a choice.</p>
        pub fn notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.notes = Some(input.into());
            self
        }
        /// <p>The notes associated with a choice.</p>
        pub fn set_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notes = input;
            self
        }
        /// Consumes the builder and constructs a [`ChoiceAnswer`](crate::model::ChoiceAnswer).
        pub fn build(self) -> crate::model::ChoiceAnswer {
            crate::model::ChoiceAnswer {
                choice_id: self.choice_id,
                status: self.status,
                reason: self.reason,
                notes: self.notes,
            }
        }
    }
}

/// When writing a match expression against `ChoiceReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let choicereason = unimplemented!();
/// match choicereason {
///     ChoiceReason::ArchitectureConstraints => { /* ... */ },
///     ChoiceReason::BusinessPriorities => { /* ... */ },
///     ChoiceReason::None => { /* ... */ },
///     ChoiceReason::Other => { /* ... */ },
///     ChoiceReason::OutOfScope => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `choicereason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChoiceReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChoiceReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChoiceReason::NewFeature` is defined.
/// Specifically, when `choicereason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChoiceReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChoiceReason {
    #[allow(missing_docs)] // documentation missing in model
    ArchitectureConstraints,
    #[allow(missing_docs)] // documentation missing in model
    BusinessPriorities,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    OutOfScope,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ChoiceReason {
    fn from(s: &str) -> Self {
        match s {
            "ARCHITECTURE_CONSTRAINTS" => ChoiceReason::ArchitectureConstraints,
            "BUSINESS_PRIORITIES" => ChoiceReason::BusinessPriorities,
            "NONE" => ChoiceReason::None,
            "OTHER" => ChoiceReason::Other,
            "OUT_OF_SCOPE" => ChoiceReason::OutOfScope,
            other => ChoiceReason::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ChoiceReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChoiceReason::from(s))
    }
}
impl ChoiceReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChoiceReason::ArchitectureConstraints => "ARCHITECTURE_CONSTRAINTS",
            ChoiceReason::BusinessPriorities => "BUSINESS_PRIORITIES",
            ChoiceReason::None => "NONE",
            ChoiceReason::Other => "OTHER",
            ChoiceReason::OutOfScope => "OUT_OF_SCOPE",
            ChoiceReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ARCHITECTURE_CONSTRAINTS",
            "BUSINESS_PRIORITIES",
            "NONE",
            "OTHER",
            "OUT_OF_SCOPE",
        ]
    }
}
impl AsRef<str> for ChoiceReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ChoiceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let choicestatus = unimplemented!();
/// match choicestatus {
///     ChoiceStatus::NotApplicable => { /* ... */ },
///     ChoiceStatus::Selected => { /* ... */ },
///     ChoiceStatus::Unselected => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `choicestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChoiceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChoiceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChoiceStatus::NewFeature` is defined.
/// Specifically, when `choicestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChoiceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChoiceStatus {
    #[allow(missing_docs)] // documentation missing in model
    NotApplicable,
    #[allow(missing_docs)] // documentation missing in model
    Selected,
    #[allow(missing_docs)] // documentation missing in model
    Unselected,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ChoiceStatus {
    fn from(s: &str) -> Self {
        match s {
            "NOT_APPLICABLE" => ChoiceStatus::NotApplicable,
            "SELECTED" => ChoiceStatus::Selected,
            "UNSELECTED" => ChoiceStatus::Unselected,
            other => ChoiceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ChoiceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChoiceStatus::from(s))
    }
}
impl ChoiceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChoiceStatus::NotApplicable => "NOT_APPLICABLE",
            ChoiceStatus::Selected => "SELECTED",
            ChoiceStatus::Unselected => "UNSELECTED",
            ChoiceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NOT_APPLICABLE", "SELECTED", "UNSELECTED"]
    }
}
impl AsRef<str> for ChoiceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A choice available to answer question.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Choice {
    /// <p>The ID of a choice.</p>
    #[doc(hidden)]
    pub choice_id: std::option::Option<std::string::String>,
    /// <p>The title of a choice.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The description of a choice.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The choice level helpful resource.</p>
    #[doc(hidden)]
    pub helpful_resource: std::option::Option<crate::model::ChoiceContent>,
    /// <p>The choice level improvement plan.</p>
    #[doc(hidden)]
    pub improvement_plan: std::option::Option<crate::model::ChoiceContent>,
    /// <p>The additional resources for a choice. A choice can have up to two additional resources: one of type <code>HELPFUL_RESOURCE</code>, one of type <code>IMPROVEMENT_PLAN</code>, or both.</p>
    #[doc(hidden)]
    pub additional_resources: std::option::Option<std::vec::Vec<crate::model::AdditionalResources>>,
}
impl Choice {
    /// <p>The ID of a choice.</p>
    pub fn choice_id(&self) -> std::option::Option<&str> {
        self.choice_id.as_deref()
    }
    /// <p>The title of a choice.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The description of a choice.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The choice level helpful resource.</p>
    pub fn helpful_resource(&self) -> std::option::Option<&crate::model::ChoiceContent> {
        self.helpful_resource.as_ref()
    }
    /// <p>The choice level improvement plan.</p>
    pub fn improvement_plan(&self) -> std::option::Option<&crate::model::ChoiceContent> {
        self.improvement_plan.as_ref()
    }
    /// <p>The additional resources for a choice. A choice can have up to two additional resources: one of type <code>HELPFUL_RESOURCE</code>, one of type <code>IMPROVEMENT_PLAN</code>, or both.</p>
    pub fn additional_resources(
        &self,
    ) -> std::option::Option<&[crate::model::AdditionalResources]> {
        self.additional_resources.as_deref()
    }
}
impl Choice {
    /// Creates a new builder-style object to manufacture [`Choice`](crate::model::Choice).
    pub fn builder() -> crate::model::choice::Builder {
        crate::model::choice::Builder::default()
    }
}

/// See [`Choice`](crate::model::Choice).
pub mod choice {

    /// A builder for [`Choice`](crate::model::Choice).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) choice_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) helpful_resource: std::option::Option<crate::model::ChoiceContent>,
        pub(crate) improvement_plan: std::option::Option<crate::model::ChoiceContent>,
        pub(crate) additional_resources:
            std::option::Option<std::vec::Vec<crate::model::AdditionalResources>>,
    }
    impl Builder {
        /// <p>The ID of a choice.</p>
        pub fn choice_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.choice_id = Some(input.into());
            self
        }
        /// <p>The ID of a choice.</p>
        pub fn set_choice_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.choice_id = input;
            self
        }
        /// <p>The title of a choice.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of a choice.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The description of a choice.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of a choice.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The choice level helpful resource.</p>
        pub fn helpful_resource(mut self, input: crate::model::ChoiceContent) -> Self {
            self.helpful_resource = Some(input);
            self
        }
        /// <p>The choice level helpful resource.</p>
        pub fn set_helpful_resource(
            mut self,
            input: std::option::Option<crate::model::ChoiceContent>,
        ) -> Self {
            self.helpful_resource = input;
            self
        }
        /// <p>The choice level improvement plan.</p>
        pub fn improvement_plan(mut self, input: crate::model::ChoiceContent) -> Self {
            self.improvement_plan = Some(input);
            self
        }
        /// <p>The choice level improvement plan.</p>
        pub fn set_improvement_plan(
            mut self,
            input: std::option::Option<crate::model::ChoiceContent>,
        ) -> Self {
            self.improvement_plan = input;
            self
        }
        /// Appends an item to `additional_resources`.
        ///
        /// To override the contents of this collection use [`set_additional_resources`](Self::set_additional_resources).
        ///
        /// <p>The additional resources for a choice. A choice can have up to two additional resources: one of type <code>HELPFUL_RESOURCE</code>, one of type <code>IMPROVEMENT_PLAN</code>, or both.</p>
        pub fn additional_resources(mut self, input: crate::model::AdditionalResources) -> Self {
            let mut v = self.additional_resources.unwrap_or_default();
            v.push(input);
            self.additional_resources = Some(v);
            self
        }
        /// <p>The additional resources for a choice. A choice can have up to two additional resources: one of type <code>HELPFUL_RESOURCE</code>, one of type <code>IMPROVEMENT_PLAN</code>, or both.</p>
        pub fn set_additional_resources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AdditionalResources>>,
        ) -> Self {
            self.additional_resources = input;
            self
        }
        /// Consumes the builder and constructs a [`Choice`](crate::model::Choice).
        pub fn build(self) -> crate::model::Choice {
            crate::model::Choice {
                choice_id: self.choice_id,
                title: self.title,
                description: self.description,
                helpful_resource: self.helpful_resource,
                improvement_plan: self.improvement_plan,
                additional_resources: self.additional_resources,
            }
        }
    }
}

/// <p>The choice level additional resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdditionalResources {
    /// <p>Type of additional resource.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::AdditionalResourceType>,
    /// <p>The URLs for additional resources, either helpful resources or improvement plans. Up to five additional URLs can be specified.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::vec::Vec<crate::model::ChoiceContent>>,
}
impl AdditionalResources {
    /// <p>Type of additional resource.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::AdditionalResourceType> {
        self.r#type.as_ref()
    }
    /// <p>The URLs for additional resources, either helpful resources or improvement plans. Up to five additional URLs can be specified.</p>
    pub fn content(&self) -> std::option::Option<&[crate::model::ChoiceContent]> {
        self.content.as_deref()
    }
}
impl AdditionalResources {
    /// Creates a new builder-style object to manufacture [`AdditionalResources`](crate::model::AdditionalResources).
    pub fn builder() -> crate::model::additional_resources::Builder {
        crate::model::additional_resources::Builder::default()
    }
}

/// See [`AdditionalResources`](crate::model::AdditionalResources).
pub mod additional_resources {

    /// A builder for [`AdditionalResources`](crate::model::AdditionalResources).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::AdditionalResourceType>,
        pub(crate) content: std::option::Option<std::vec::Vec<crate::model::ChoiceContent>>,
    }
    impl Builder {
        /// <p>Type of additional resource.</p>
        pub fn r#type(mut self, input: crate::model::AdditionalResourceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Type of additional resource.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::AdditionalResourceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `content`.
        ///
        /// To override the contents of this collection use [`set_content`](Self::set_content).
        ///
        /// <p>The URLs for additional resources, either helpful resources or improvement plans. Up to five additional URLs can be specified.</p>
        pub fn content(mut self, input: crate::model::ChoiceContent) -> Self {
            let mut v = self.content.unwrap_or_default();
            v.push(input);
            self.content = Some(v);
            self
        }
        /// <p>The URLs for additional resources, either helpful resources or improvement plans. Up to five additional URLs can be specified.</p>
        pub fn set_content(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChoiceContent>>,
        ) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`AdditionalResources`](crate::model::AdditionalResources).
        pub fn build(self) -> crate::model::AdditionalResources {
            crate::model::AdditionalResources {
                r#type: self.r#type,
                content: self.content,
            }
        }
    }
}

/// <p>The choice content.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChoiceContent {
    /// <p>The display text for the choice content.</p>
    #[doc(hidden)]
    pub display_text: std::option::Option<std::string::String>,
    /// <p>The URL for the choice content.</p>
    #[doc(hidden)]
    pub url: std::option::Option<std::string::String>,
}
impl ChoiceContent {
    /// <p>The display text for the choice content.</p>
    pub fn display_text(&self) -> std::option::Option<&str> {
        self.display_text.as_deref()
    }
    /// <p>The URL for the choice content.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
}
impl ChoiceContent {
    /// Creates a new builder-style object to manufacture [`ChoiceContent`](crate::model::ChoiceContent).
    pub fn builder() -> crate::model::choice_content::Builder {
        crate::model::choice_content::Builder::default()
    }
}

/// See [`ChoiceContent`](crate::model::ChoiceContent).
pub mod choice_content {

    /// A builder for [`ChoiceContent`](crate::model::ChoiceContent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) display_text: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The display text for the choice content.</p>
        pub fn display_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_text = Some(input.into());
            self
        }
        /// <p>The display text for the choice content.</p>
        pub fn set_display_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_text = input;
            self
        }
        /// <p>The URL for the choice content.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL for the choice content.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`ChoiceContent`](crate::model::ChoiceContent).
        pub fn build(self) -> crate::model::ChoiceContent {
            crate::model::ChoiceContent {
                display_text: self.display_text,
                url: self.url,
            }
        }
    }
}

/// When writing a match expression against `AdditionalResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let additionalresourcetype = unimplemented!();
/// match additionalresourcetype {
///     AdditionalResourceType::HelpfulResource => { /* ... */ },
///     AdditionalResourceType::ImprovementPlan => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `additionalresourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AdditionalResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AdditionalResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AdditionalResourceType::NewFeature` is defined.
/// Specifically, when `additionalresourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AdditionalResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AdditionalResourceType {
    #[allow(missing_docs)] // documentation missing in model
    HelpfulResource,
    #[allow(missing_docs)] // documentation missing in model
    ImprovementPlan,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AdditionalResourceType {
    fn from(s: &str) -> Self {
        match s {
            "HELPFUL_RESOURCE" => AdditionalResourceType::HelpfulResource,
            "IMPROVEMENT_PLAN" => AdditionalResourceType::ImprovementPlan,
            other => {
                AdditionalResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AdditionalResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AdditionalResourceType::from(s))
    }
}
impl AdditionalResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AdditionalResourceType::HelpfulResource => "HELPFUL_RESOURCE",
            AdditionalResourceType::ImprovementPlan => "IMPROVEMENT_PLAN",
            AdditionalResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HELPFUL_RESOURCE", "IMPROVEMENT_PLAN"]
    }
}
impl AsRef<str> for AdditionalResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of choices to be updated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChoiceUpdate {
    /// <p>The status of a choice.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ChoiceStatus>,
    /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::ChoiceReason>,
    /// <p>The notes associated with a choice.</p>
    #[doc(hidden)]
    pub notes: std::option::Option<std::string::String>,
}
impl ChoiceUpdate {
    /// <p>The status of a choice.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ChoiceStatus> {
        self.status.as_ref()
    }
    /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
    pub fn reason(&self) -> std::option::Option<&crate::model::ChoiceReason> {
        self.reason.as_ref()
    }
    /// <p>The notes associated with a choice.</p>
    pub fn notes(&self) -> std::option::Option<&str> {
        self.notes.as_deref()
    }
}
impl ChoiceUpdate {
    /// Creates a new builder-style object to manufacture [`ChoiceUpdate`](crate::model::ChoiceUpdate).
    pub fn builder() -> crate::model::choice_update::Builder {
        crate::model::choice_update::Builder::default()
    }
}

/// See [`ChoiceUpdate`](crate::model::ChoiceUpdate).
pub mod choice_update {

    /// A builder for [`ChoiceUpdate`](crate::model::ChoiceUpdate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ChoiceStatus>,
        pub(crate) reason: std::option::Option<crate::model::ChoiceReason>,
        pub(crate) notes: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of a choice.</p>
        pub fn status(mut self, input: crate::model::ChoiceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of a choice.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ChoiceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
        pub fn reason(mut self, input: crate::model::ChoiceReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::ChoiceReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// <p>The notes associated with a choice.</p>
        pub fn notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.notes = Some(input.into());
            self
        }
        /// <p>The notes associated with a choice.</p>
        pub fn set_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notes = input;
            self
        }
        /// Consumes the builder and constructs a [`ChoiceUpdate`](crate::model::ChoiceUpdate).
        pub fn build(self) -> crate::model::ChoiceUpdate {
            crate::model::ChoiceUpdate {
                status: self.status,
                reason: self.reason,
                notes: self.notes,
            }
        }
    }
}

/// <p>A workload share summary return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkloadShareSummary {
    /// <p>The ID associated with the workload share.</p>
    #[doc(hidden)]
    pub share_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
    #[doc(hidden)]
    pub shared_with: std::option::Option<std::string::String>,
    /// <p>Permission granted on a workload share.</p>
    #[doc(hidden)]
    pub permission_type: std::option::Option<crate::model::PermissionType>,
    /// <p>The status of a workload share.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ShareStatus>,
    /// <p>Optional message to compliment the Status field.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
}
impl WorkloadShareSummary {
    /// <p>The ID associated with the workload share.</p>
    pub fn share_id(&self) -> std::option::Option<&str> {
        self.share_id.as_deref()
    }
    /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
    pub fn shared_with(&self) -> std::option::Option<&str> {
        self.shared_with.as_deref()
    }
    /// <p>Permission granted on a workload share.</p>
    pub fn permission_type(&self) -> std::option::Option<&crate::model::PermissionType> {
        self.permission_type.as_ref()
    }
    /// <p>The status of a workload share.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ShareStatus> {
        self.status.as_ref()
    }
    /// <p>Optional message to compliment the Status field.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
impl WorkloadShareSummary {
    /// Creates a new builder-style object to manufacture [`WorkloadShareSummary`](crate::model::WorkloadShareSummary).
    pub fn builder() -> crate::model::workload_share_summary::Builder {
        crate::model::workload_share_summary::Builder::default()
    }
}

/// See [`WorkloadShareSummary`](crate::model::WorkloadShareSummary).
pub mod workload_share_summary {

    /// A builder for [`WorkloadShareSummary`](crate::model::WorkloadShareSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) share_id: std::option::Option<std::string::String>,
        pub(crate) shared_with: std::option::Option<std::string::String>,
        pub(crate) permission_type: std::option::Option<crate::model::PermissionType>,
        pub(crate) status: std::option::Option<crate::model::ShareStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID associated with the workload share.</p>
        pub fn share_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_id = Some(input.into());
            self
        }
        /// <p>The ID associated with the workload share.</p>
        pub fn set_share_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.share_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
        pub fn shared_with(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_with = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
        pub fn set_shared_with(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.shared_with = input;
            self
        }
        /// <p>Permission granted on a workload share.</p>
        pub fn permission_type(mut self, input: crate::model::PermissionType) -> Self {
            self.permission_type = Some(input);
            self
        }
        /// <p>Permission granted on a workload share.</p>
        pub fn set_permission_type(
            mut self,
            input: std::option::Option<crate::model::PermissionType>,
        ) -> Self {
            self.permission_type = input;
            self
        }
        /// <p>The status of a workload share.</p>
        pub fn status(mut self, input: crate::model::ShareStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of a workload share.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ShareStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>Optional message to compliment the Status field.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>Optional message to compliment the Status field.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkloadShareSummary`](crate::model::WorkloadShareSummary).
        pub fn build(self) -> crate::model::WorkloadShareSummary {
            crate::model::WorkloadShareSummary {
                share_id: self.share_id,
                shared_with: self.shared_with,
                permission_type: self.permission_type,
                status: self.status,
                status_message: self.status_message,
            }
        }
    }
}

/// <p>A workload summary return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkloadSummary {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The ARN for the workload.</p>
    #[doc(hidden)]
    pub workload_arn: std::option::Option<std::string::String>,
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    #[doc(hidden)]
    pub workload_name: std::option::Option<std::string::String>,
    /// <p>An Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>The date and time recorded.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    #[doc(hidden)]
    pub lenses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    #[doc(hidden)]
    pub risk_counts: std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
    /// <p>The improvement status for a workload.</p>
    #[doc(hidden)]
    pub improvement_status: std::option::Option<crate::model::WorkloadImprovementStatus>,
}
impl WorkloadSummary {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The ARN for the workload.</p>
    pub fn workload_arn(&self) -> std::option::Option<&str> {
        self.workload_arn.as_deref()
    }
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    pub fn workload_name(&self) -> std::option::Option<&str> {
        self.workload_name.as_deref()
    }
    /// <p>An Amazon Web Services account ID.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>The date and time recorded.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lenses(&self) -> std::option::Option<&[std::string::String]> {
        self.lenses.as_deref()
    }
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    pub fn risk_counts(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Risk, i32>> {
        self.risk_counts.as_ref()
    }
    /// <p>The improvement status for a workload.</p>
    pub fn improvement_status(
        &self,
    ) -> std::option::Option<&crate::model::WorkloadImprovementStatus> {
        self.improvement_status.as_ref()
    }
}
impl WorkloadSummary {
    /// Creates a new builder-style object to manufacture [`WorkloadSummary`](crate::model::WorkloadSummary).
    pub fn builder() -> crate::model::workload_summary::Builder {
        crate::model::workload_summary::Builder::default()
    }
}

/// See [`WorkloadSummary`](crate::model::WorkloadSummary).
pub mod workload_summary {

    /// A builder for [`WorkloadSummary`](crate::model::WorkloadSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) workload_arn: std::option::Option<std::string::String>,
        pub(crate) workload_name: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) lenses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) risk_counts:
            std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
        pub(crate) improvement_status: std::option::Option<crate::model::WorkloadImprovementStatus>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The ARN for the workload.</p>
        pub fn workload_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the workload.</p>
        pub fn set_workload_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_arn = input;
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn workload_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_name = Some(input.into());
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn set_workload_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workload_name = input;
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Appends an item to `lenses`.
        ///
        /// To override the contents of this collection use [`set_lenses`](Self::set_lenses).
        ///
        /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lenses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.lenses.unwrap_or_default();
            v.push(input.into());
            self.lenses = Some(v);
            self
        }
        /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lenses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.lenses = input;
            self
        }
        /// Adds a key-value pair to `risk_counts`.
        ///
        /// To override the contents of this collection use [`set_risk_counts`](Self::set_risk_counts).
        ///
        /// <p>A map from risk names to the count of how questions have that rating.</p>
        pub fn risk_counts(mut self, k: crate::model::Risk, v: i32) -> Self {
            let mut hash_map = self.risk_counts.unwrap_or_default();
            hash_map.insert(k, v);
            self.risk_counts = Some(hash_map);
            self
        }
        /// <p>A map from risk names to the count of how questions have that rating.</p>
        pub fn set_risk_counts(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
        ) -> Self {
            self.risk_counts = input;
            self
        }
        /// <p>The improvement status for a workload.</p>
        pub fn improvement_status(
            mut self,
            input: crate::model::WorkloadImprovementStatus,
        ) -> Self {
            self.improvement_status = Some(input);
            self
        }
        /// <p>The improvement status for a workload.</p>
        pub fn set_improvement_status(
            mut self,
            input: std::option::Option<crate::model::WorkloadImprovementStatus>,
        ) -> Self {
            self.improvement_status = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkloadSummary`](crate::model::WorkloadSummary).
        pub fn build(self) -> crate::model::WorkloadSummary {
            crate::model::WorkloadSummary {
                workload_id: self.workload_id,
                workload_arn: self.workload_arn,
                workload_name: self.workload_name,
                owner: self.owner,
                updated_at: self.updated_at,
                lenses: self.lenses,
                risk_counts: self.risk_counts,
                improvement_status: self.improvement_status,
            }
        }
    }
}

/// <p>A share invitation summary return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ShareInvitationSummary {
    /// <p>The ID assigned to the share invitation.</p>
    #[doc(hidden)]
    pub share_invitation_id: std::option::Option<std::string::String>,
    /// <p>An Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub shared_by: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
    #[doc(hidden)]
    pub shared_with: std::option::Option<std::string::String>,
    /// <p>Permission granted on a workload share.</p>
    #[doc(hidden)]
    pub permission_type: std::option::Option<crate::model::PermissionType>,
    /// <p>The resource type of the share invitation.</p>
    #[doc(hidden)]
    pub share_resource_type: std::option::Option<crate::model::ShareResourceType>,
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    #[doc(hidden)]
    pub workload_name: std::option::Option<std::string::String>,
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The full name of the lens.</p>
    #[doc(hidden)]
    pub lens_name: std::option::Option<std::string::String>,
    /// <p>The ARN for the lens.</p>
    #[doc(hidden)]
    pub lens_arn: std::option::Option<std::string::String>,
}
impl ShareInvitationSummary {
    /// <p>The ID assigned to the share invitation.</p>
    pub fn share_invitation_id(&self) -> std::option::Option<&str> {
        self.share_invitation_id.as_deref()
    }
    /// <p>An Amazon Web Services account ID.</p>
    pub fn shared_by(&self) -> std::option::Option<&str> {
        self.shared_by.as_deref()
    }
    /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
    pub fn shared_with(&self) -> std::option::Option<&str> {
        self.shared_with.as_deref()
    }
    /// <p>Permission granted on a workload share.</p>
    pub fn permission_type(&self) -> std::option::Option<&crate::model::PermissionType> {
        self.permission_type.as_ref()
    }
    /// <p>The resource type of the share invitation.</p>
    pub fn share_resource_type(&self) -> std::option::Option<&crate::model::ShareResourceType> {
        self.share_resource_type.as_ref()
    }
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    pub fn workload_name(&self) -> std::option::Option<&str> {
        self.workload_name.as_deref()
    }
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The full name of the lens.</p>
    pub fn lens_name(&self) -> std::option::Option<&str> {
        self.lens_name.as_deref()
    }
    /// <p>The ARN for the lens.</p>
    pub fn lens_arn(&self) -> std::option::Option<&str> {
        self.lens_arn.as_deref()
    }
}
impl ShareInvitationSummary {
    /// Creates a new builder-style object to manufacture [`ShareInvitationSummary`](crate::model::ShareInvitationSummary).
    pub fn builder() -> crate::model::share_invitation_summary::Builder {
        crate::model::share_invitation_summary::Builder::default()
    }
}

/// See [`ShareInvitationSummary`](crate::model::ShareInvitationSummary).
pub mod share_invitation_summary {

    /// A builder for [`ShareInvitationSummary`](crate::model::ShareInvitationSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) share_invitation_id: std::option::Option<std::string::String>,
        pub(crate) shared_by: std::option::Option<std::string::String>,
        pub(crate) shared_with: std::option::Option<std::string::String>,
        pub(crate) permission_type: std::option::Option<crate::model::PermissionType>,
        pub(crate) share_resource_type: std::option::Option<crate::model::ShareResourceType>,
        pub(crate) workload_name: std::option::Option<std::string::String>,
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_name: std::option::Option<std::string::String>,
        pub(crate) lens_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID assigned to the share invitation.</p>
        pub fn share_invitation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_invitation_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the share invitation.</p>
        pub fn set_share_invitation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.share_invitation_id = input;
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn shared_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_by = Some(input.into());
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn set_shared_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.shared_by = input;
            self
        }
        /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
        pub fn shared_with(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_with = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
        pub fn set_shared_with(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.shared_with = input;
            self
        }
        /// <p>Permission granted on a workload share.</p>
        pub fn permission_type(mut self, input: crate::model::PermissionType) -> Self {
            self.permission_type = Some(input);
            self
        }
        /// <p>Permission granted on a workload share.</p>
        pub fn set_permission_type(
            mut self,
            input: std::option::Option<crate::model::PermissionType>,
        ) -> Self {
            self.permission_type = input;
            self
        }
        /// <p>The resource type of the share invitation.</p>
        pub fn share_resource_type(mut self, input: crate::model::ShareResourceType) -> Self {
            self.share_resource_type = Some(input);
            self
        }
        /// <p>The resource type of the share invitation.</p>
        pub fn set_share_resource_type(
            mut self,
            input: std::option::Option<crate::model::ShareResourceType>,
        ) -> Self {
            self.share_resource_type = input;
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn workload_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_name = Some(input.into());
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn set_workload_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workload_name = input;
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn lens_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_name = Some(input.into());
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn set_lens_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_name = input;
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn lens_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn set_lens_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ShareInvitationSummary`](crate::model::ShareInvitationSummary).
        pub fn build(self) -> crate::model::ShareInvitationSummary {
            crate::model::ShareInvitationSummary {
                share_invitation_id: self.share_invitation_id,
                shared_by: self.shared_by,
                shared_with: self.shared_with,
                permission_type: self.permission_type,
                share_resource_type: self.share_resource_type,
                workload_name: self.workload_name,
                workload_id: self.workload_id,
                lens_name: self.lens_name,
                lens_arn: self.lens_arn,
            }
        }
    }
}

/// <p>A notification summary return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotificationSummary {
    /// <p>The type of notification.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::NotificationType>,
    /// <p>Summary of lens upgrade.</p>
    #[doc(hidden)]
    pub lens_upgrade_summary: std::option::Option<crate::model::LensUpgradeSummary>,
}
impl NotificationSummary {
    /// <p>The type of notification.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::NotificationType> {
        self.r#type.as_ref()
    }
    /// <p>Summary of lens upgrade.</p>
    pub fn lens_upgrade_summary(&self) -> std::option::Option<&crate::model::LensUpgradeSummary> {
        self.lens_upgrade_summary.as_ref()
    }
}
impl NotificationSummary {
    /// Creates a new builder-style object to manufacture [`NotificationSummary`](crate::model::NotificationSummary).
    pub fn builder() -> crate::model::notification_summary::Builder {
        crate::model::notification_summary::Builder::default()
    }
}

/// See [`NotificationSummary`](crate::model::NotificationSummary).
pub mod notification_summary {

    /// A builder for [`NotificationSummary`](crate::model::NotificationSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::NotificationType>,
        pub(crate) lens_upgrade_summary: std::option::Option<crate::model::LensUpgradeSummary>,
    }
    impl Builder {
        /// <p>The type of notification.</p>
        pub fn r#type(mut self, input: crate::model::NotificationType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of notification.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::NotificationType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Summary of lens upgrade.</p>
        pub fn lens_upgrade_summary(mut self, input: crate::model::LensUpgradeSummary) -> Self {
            self.lens_upgrade_summary = Some(input);
            self
        }
        /// <p>Summary of lens upgrade.</p>
        pub fn set_lens_upgrade_summary(
            mut self,
            input: std::option::Option<crate::model::LensUpgradeSummary>,
        ) -> Self {
            self.lens_upgrade_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`NotificationSummary`](crate::model::NotificationSummary).
        pub fn build(self) -> crate::model::NotificationSummary {
            crate::model::NotificationSummary {
                r#type: self.r#type,
                lens_upgrade_summary: self.lens_upgrade_summary,
            }
        }
    }
}

/// <p>Lens upgrade summary return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LensUpgradeSummary {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    #[doc(hidden)]
    pub workload_name: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    #[doc(hidden)]
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The ARN for the lens.</p>
    #[doc(hidden)]
    pub lens_arn: std::option::Option<std::string::String>,
    /// <p>The current version of the lens.</p>
    #[doc(hidden)]
    pub current_lens_version: std::option::Option<std::string::String>,
    /// <p>The latest version of the lens.</p>
    #[doc(hidden)]
    pub latest_lens_version: std::option::Option<std::string::String>,
}
impl LensUpgradeSummary {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    pub fn workload_name(&self) -> std::option::Option<&str> {
        self.workload_name.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The ARN for the lens.</p>
    pub fn lens_arn(&self) -> std::option::Option<&str> {
        self.lens_arn.as_deref()
    }
    /// <p>The current version of the lens.</p>
    pub fn current_lens_version(&self) -> std::option::Option<&str> {
        self.current_lens_version.as_deref()
    }
    /// <p>The latest version of the lens.</p>
    pub fn latest_lens_version(&self) -> std::option::Option<&str> {
        self.latest_lens_version.as_deref()
    }
}
impl LensUpgradeSummary {
    /// Creates a new builder-style object to manufacture [`LensUpgradeSummary`](crate::model::LensUpgradeSummary).
    pub fn builder() -> crate::model::lens_upgrade_summary::Builder {
        crate::model::lens_upgrade_summary::Builder::default()
    }
}

/// See [`LensUpgradeSummary`](crate::model::LensUpgradeSummary).
pub mod lens_upgrade_summary {

    /// A builder for [`LensUpgradeSummary`](crate::model::LensUpgradeSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) workload_name: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) lens_arn: std::option::Option<std::string::String>,
        pub(crate) current_lens_version: std::option::Option<std::string::String>,
        pub(crate) latest_lens_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn workload_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_name = Some(input.into());
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn set_workload_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workload_name = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn lens_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn set_lens_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_arn = input;
            self
        }
        /// <p>The current version of the lens.</p>
        pub fn current_lens_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_lens_version = Some(input.into());
            self
        }
        /// <p>The current version of the lens.</p>
        pub fn set_current_lens_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_lens_version = input;
            self
        }
        /// <p>The latest version of the lens.</p>
        pub fn latest_lens_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.latest_lens_version = Some(input.into());
            self
        }
        /// <p>The latest version of the lens.</p>
        pub fn set_latest_lens_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.latest_lens_version = input;
            self
        }
        /// Consumes the builder and constructs a [`LensUpgradeSummary`](crate::model::LensUpgradeSummary).
        pub fn build(self) -> crate::model::LensUpgradeSummary {
            crate::model::LensUpgradeSummary {
                workload_id: self.workload_id,
                workload_name: self.workload_name,
                lens_alias: self.lens_alias,
                lens_arn: self.lens_arn,
                current_lens_version: self.current_lens_version,
                latest_lens_version: self.latest_lens_version,
            }
        }
    }
}

/// When writing a match expression against `NotificationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let notificationtype = unimplemented!();
/// match notificationtype {
///     NotificationType::LensVersionDeprecated => { /* ... */ },
///     NotificationType::LensVersionUpgraded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `notificationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NotificationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NotificationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NotificationType::NewFeature` is defined.
/// Specifically, when `notificationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NotificationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotificationType {
    #[allow(missing_docs)] // documentation missing in model
    LensVersionDeprecated,
    #[allow(missing_docs)] // documentation missing in model
    LensVersionUpgraded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NotificationType {
    fn from(s: &str) -> Self {
        match s {
            "LENS_VERSION_DEPRECATED" => NotificationType::LensVersionDeprecated,
            "LENS_VERSION_UPGRADED" => NotificationType::LensVersionUpgraded,
            other => NotificationType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for NotificationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotificationType::from(s))
    }
}
impl NotificationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotificationType::LensVersionDeprecated => "LENS_VERSION_DEPRECATED",
            NotificationType::LensVersionUpgraded => "LENS_VERSION_UPGRADED",
            NotificationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LENS_VERSION_DEPRECATED", "LENS_VERSION_UPGRADED"]
    }
}
impl AsRef<str> for NotificationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A milestone summary return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MilestoneSummary {
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    #[doc(hidden)]
    pub milestone_number: i32,
    /// <p>The name of the milestone in a workload.</p>
    /// <p>Milestone names must be unique within a workload.</p>
    #[doc(hidden)]
    pub milestone_name: std::option::Option<std::string::String>,
    /// <p>The date and time recorded.</p>
    #[doc(hidden)]
    pub recorded_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A workload summary return object.</p>
    #[doc(hidden)]
    pub workload_summary: std::option::Option<crate::model::WorkloadSummary>,
}
impl MilestoneSummary {
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub fn milestone_number(&self) -> i32 {
        self.milestone_number
    }
    /// <p>The name of the milestone in a workload.</p>
    /// <p>Milestone names must be unique within a workload.</p>
    pub fn milestone_name(&self) -> std::option::Option<&str> {
        self.milestone_name.as_deref()
    }
    /// <p>The date and time recorded.</p>
    pub fn recorded_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.recorded_at.as_ref()
    }
    /// <p>A workload summary return object.</p>
    pub fn workload_summary(&self) -> std::option::Option<&crate::model::WorkloadSummary> {
        self.workload_summary.as_ref()
    }
}
impl MilestoneSummary {
    /// Creates a new builder-style object to manufacture [`MilestoneSummary`](crate::model::MilestoneSummary).
    pub fn builder() -> crate::model::milestone_summary::Builder {
        crate::model::milestone_summary::Builder::default()
    }
}

/// See [`MilestoneSummary`](crate::model::MilestoneSummary).
pub mod milestone_summary {

    /// A builder for [`MilestoneSummary`](crate::model::MilestoneSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) milestone_number: std::option::Option<i32>,
        pub(crate) milestone_name: std::option::Option<std::string::String>,
        pub(crate) recorded_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) workload_summary: std::option::Option<crate::model::WorkloadSummary>,
    }
    impl Builder {
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn milestone_number(mut self, input: i32) -> Self {
            self.milestone_number = Some(input);
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn set_milestone_number(mut self, input: std::option::Option<i32>) -> Self {
            self.milestone_number = input;
            self
        }
        /// <p>The name of the milestone in a workload.</p>
        /// <p>Milestone names must be unique within a workload.</p>
        pub fn milestone_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.milestone_name = Some(input.into());
            self
        }
        /// <p>The name of the milestone in a workload.</p>
        /// <p>Milestone names must be unique within a workload.</p>
        pub fn set_milestone_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.milestone_name = input;
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn recorded_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.recorded_at = Some(input);
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn set_recorded_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.recorded_at = input;
            self
        }
        /// <p>A workload summary return object.</p>
        pub fn workload_summary(mut self, input: crate::model::WorkloadSummary) -> Self {
            self.workload_summary = Some(input);
            self
        }
        /// <p>A workload summary return object.</p>
        pub fn set_workload_summary(
            mut self,
            input: std::option::Option<crate::model::WorkloadSummary>,
        ) -> Self {
            self.workload_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`MilestoneSummary`](crate::model::MilestoneSummary).
        pub fn build(self) -> crate::model::MilestoneSummary {
            crate::model::MilestoneSummary {
                milestone_number: self.milestone_number.unwrap_or_default(),
                milestone_name: self.milestone_name,
                recorded_at: self.recorded_at,
                workload_summary: self.workload_summary,
            }
        }
    }
}

/// <p>A lens share summary return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LensShareSummary {
    /// <p>The ID associated with the workload share.</p>
    #[doc(hidden)]
    pub share_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
    #[doc(hidden)]
    pub shared_with: std::option::Option<std::string::String>,
    /// <p>The status of a workload share.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ShareStatus>,
    /// <p>Optional message to compliment the Status field.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
}
impl LensShareSummary {
    /// <p>The ID associated with the workload share.</p>
    pub fn share_id(&self) -> std::option::Option<&str> {
        self.share_id.as_deref()
    }
    /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
    pub fn shared_with(&self) -> std::option::Option<&str> {
        self.shared_with.as_deref()
    }
    /// <p>The status of a workload share.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ShareStatus> {
        self.status.as_ref()
    }
    /// <p>Optional message to compliment the Status field.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
impl LensShareSummary {
    /// Creates a new builder-style object to manufacture [`LensShareSummary`](crate::model::LensShareSummary).
    pub fn builder() -> crate::model::lens_share_summary::Builder {
        crate::model::lens_share_summary::Builder::default()
    }
}

/// See [`LensShareSummary`](crate::model::LensShareSummary).
pub mod lens_share_summary {

    /// A builder for [`LensShareSummary`](crate::model::LensShareSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) share_id: std::option::Option<std::string::String>,
        pub(crate) shared_with: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ShareStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID associated with the workload share.</p>
        pub fn share_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_id = Some(input.into());
            self
        }
        /// <p>The ID associated with the workload share.</p>
        pub fn set_share_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.share_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
        pub fn shared_with(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_with = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID, IAM role, organization ID, or organizational unit (OU) ID with which the workload is shared.</p>
        pub fn set_shared_with(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.shared_with = input;
            self
        }
        /// <p>The status of a workload share.</p>
        pub fn status(mut self, input: crate::model::ShareStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of a workload share.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ShareStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>Optional message to compliment the Status field.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>Optional message to compliment the Status field.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`LensShareSummary`](crate::model::LensShareSummary).
        pub fn build(self) -> crate::model::LensShareSummary {
            crate::model::LensShareSummary {
                share_id: self.share_id,
                shared_with: self.shared_with,
                status: self.status,
                status_message: self.status_message,
            }
        }
    }
}

/// <p>A lens review summary of a workload.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LensReviewSummary {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    #[doc(hidden)]
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The ARN for the lens.</p>
    #[doc(hidden)]
    pub lens_arn: std::option::Option<std::string::String>,
    /// <p>The version of the lens.</p>
    #[doc(hidden)]
    pub lens_version: std::option::Option<std::string::String>,
    /// <p>The full name of the lens.</p>
    #[doc(hidden)]
    pub lens_name: std::option::Option<std::string::String>,
    /// <p>The status of the lens.</p>
    #[doc(hidden)]
    pub lens_status: std::option::Option<crate::model::LensStatus>,
    /// <p>The date and time recorded.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    #[doc(hidden)]
    pub risk_counts: std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
}
impl LensReviewSummary {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The ARN for the lens.</p>
    pub fn lens_arn(&self) -> std::option::Option<&str> {
        self.lens_arn.as_deref()
    }
    /// <p>The version of the lens.</p>
    pub fn lens_version(&self) -> std::option::Option<&str> {
        self.lens_version.as_deref()
    }
    /// <p>The full name of the lens.</p>
    pub fn lens_name(&self) -> std::option::Option<&str> {
        self.lens_name.as_deref()
    }
    /// <p>The status of the lens.</p>
    pub fn lens_status(&self) -> std::option::Option<&crate::model::LensStatus> {
        self.lens_status.as_ref()
    }
    /// <p>The date and time recorded.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>A map from risk names to the count of how questions have that rating.</p>
    pub fn risk_counts(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::Risk, i32>> {
        self.risk_counts.as_ref()
    }
}
impl LensReviewSummary {
    /// Creates a new builder-style object to manufacture [`LensReviewSummary`](crate::model::LensReviewSummary).
    pub fn builder() -> crate::model::lens_review_summary::Builder {
        crate::model::lens_review_summary::Builder::default()
    }
}

/// See [`LensReviewSummary`](crate::model::LensReviewSummary).
pub mod lens_review_summary {

    /// A builder for [`LensReviewSummary`](crate::model::LensReviewSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) lens_arn: std::option::Option<std::string::String>,
        pub(crate) lens_version: std::option::Option<std::string::String>,
        pub(crate) lens_name: std::option::Option<std::string::String>,
        pub(crate) lens_status: std::option::Option<crate::model::LensStatus>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) risk_counts:
            std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
    }
    impl Builder {
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn lens_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn set_lens_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_arn = input;
            self
        }
        /// <p>The version of the lens.</p>
        pub fn lens_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_version = Some(input.into());
            self
        }
        /// <p>The version of the lens.</p>
        pub fn set_lens_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_version = input;
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn lens_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_name = Some(input.into());
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn set_lens_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_name = input;
            self
        }
        /// <p>The status of the lens.</p>
        pub fn lens_status(mut self, input: crate::model::LensStatus) -> Self {
            self.lens_status = Some(input);
            self
        }
        /// <p>The status of the lens.</p>
        pub fn set_lens_status(
            mut self,
            input: std::option::Option<crate::model::LensStatus>,
        ) -> Self {
            self.lens_status = input;
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Adds a key-value pair to `risk_counts`.
        ///
        /// To override the contents of this collection use [`set_risk_counts`](Self::set_risk_counts).
        ///
        /// <p>A map from risk names to the count of how questions have that rating.</p>
        pub fn risk_counts(mut self, k: crate::model::Risk, v: i32) -> Self {
            let mut hash_map = self.risk_counts.unwrap_or_default();
            hash_map.insert(k, v);
            self.risk_counts = Some(hash_map);
            self
        }
        /// <p>A map from risk names to the count of how questions have that rating.</p>
        pub fn set_risk_counts(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::Risk, i32>>,
        ) -> Self {
            self.risk_counts = input;
            self
        }
        /// Consumes the builder and constructs a [`LensReviewSummary`](crate::model::LensReviewSummary).
        pub fn build(self) -> crate::model::LensReviewSummary {
            crate::model::LensReviewSummary {
                lens_alias: self.lens_alias,
                lens_arn: self.lens_arn,
                lens_version: self.lens_version,
                lens_name: self.lens_name,
                lens_status: self.lens_status,
                updated_at: self.updated_at,
                risk_counts: self.risk_counts,
            }
        }
    }
}

/// <p>An improvement summary of a lens review in a workload.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImprovementSummary {
    /// <p>The ID of the question.</p>
    #[doc(hidden)]
    pub question_id: std::option::Option<std::string::String>,
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    #[doc(hidden)]
    pub pillar_id: std::option::Option<std::string::String>,
    /// <p>The title of the question.</p>
    #[doc(hidden)]
    pub question_title: std::option::Option<std::string::String>,
    /// <p>The risk for a given workload, lens review, pillar, or question.</p>
    #[doc(hidden)]
    pub risk: std::option::Option<crate::model::Risk>,
    /// <p>The improvement plan URL for a question.</p>
    /// <p>This value is only available if the question has been answered.</p>
    #[doc(hidden)]
    pub improvement_plan_url: std::option::Option<std::string::String>,
    /// <p>The improvement plan details.</p>
    #[doc(hidden)]
    pub improvement_plans: std::option::Option<std::vec::Vec<crate::model::ChoiceImprovementPlan>>,
}
impl ImprovementSummary {
    /// <p>The ID of the question.</p>
    pub fn question_id(&self) -> std::option::Option<&str> {
        self.question_id.as_deref()
    }
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_id(&self) -> std::option::Option<&str> {
        self.pillar_id.as_deref()
    }
    /// <p>The title of the question.</p>
    pub fn question_title(&self) -> std::option::Option<&str> {
        self.question_title.as_deref()
    }
    /// <p>The risk for a given workload, lens review, pillar, or question.</p>
    pub fn risk(&self) -> std::option::Option<&crate::model::Risk> {
        self.risk.as_ref()
    }
    /// <p>The improvement plan URL for a question.</p>
    /// <p>This value is only available if the question has been answered.</p>
    pub fn improvement_plan_url(&self) -> std::option::Option<&str> {
        self.improvement_plan_url.as_deref()
    }
    /// <p>The improvement plan details.</p>
    pub fn improvement_plans(&self) -> std::option::Option<&[crate::model::ChoiceImprovementPlan]> {
        self.improvement_plans.as_deref()
    }
}
impl ImprovementSummary {
    /// Creates a new builder-style object to manufacture [`ImprovementSummary`](crate::model::ImprovementSummary).
    pub fn builder() -> crate::model::improvement_summary::Builder {
        crate::model::improvement_summary::Builder::default()
    }
}

/// See [`ImprovementSummary`](crate::model::ImprovementSummary).
pub mod improvement_summary {

    /// A builder for [`ImprovementSummary`](crate::model::ImprovementSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) question_id: std::option::Option<std::string::String>,
        pub(crate) pillar_id: std::option::Option<std::string::String>,
        pub(crate) question_title: std::option::Option<std::string::String>,
        pub(crate) risk: std::option::Option<crate::model::Risk>,
        pub(crate) improvement_plan_url: std::option::Option<std::string::String>,
        pub(crate) improvement_plans:
            std::option::Option<std::vec::Vec<crate::model::ChoiceImprovementPlan>>,
    }
    impl Builder {
        /// <p>The ID of the question.</p>
        pub fn question_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_id = Some(input.into());
            self
        }
        /// <p>The ID of the question.</p>
        pub fn set_question_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.question_id = input;
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pillar_id = Some(input.into());
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pillar_id = input;
            self
        }
        /// <p>The title of the question.</p>
        pub fn question_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_title = Some(input.into());
            self
        }
        /// <p>The title of the question.</p>
        pub fn set_question_title(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.question_title = input;
            self
        }
        /// <p>The risk for a given workload, lens review, pillar, or question.</p>
        pub fn risk(mut self, input: crate::model::Risk) -> Self {
            self.risk = Some(input);
            self
        }
        /// <p>The risk for a given workload, lens review, pillar, or question.</p>
        pub fn set_risk(mut self, input: std::option::Option<crate::model::Risk>) -> Self {
            self.risk = input;
            self
        }
        /// <p>The improvement plan URL for a question.</p>
        /// <p>This value is only available if the question has been answered.</p>
        pub fn improvement_plan_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.improvement_plan_url = Some(input.into());
            self
        }
        /// <p>The improvement plan URL for a question.</p>
        /// <p>This value is only available if the question has been answered.</p>
        pub fn set_improvement_plan_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.improvement_plan_url = input;
            self
        }
        /// Appends an item to `improvement_plans`.
        ///
        /// To override the contents of this collection use [`set_improvement_plans`](Self::set_improvement_plans).
        ///
        /// <p>The improvement plan details.</p>
        pub fn improvement_plans(mut self, input: crate::model::ChoiceImprovementPlan) -> Self {
            let mut v = self.improvement_plans.unwrap_or_default();
            v.push(input);
            self.improvement_plans = Some(v);
            self
        }
        /// <p>The improvement plan details.</p>
        pub fn set_improvement_plans(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChoiceImprovementPlan>>,
        ) -> Self {
            self.improvement_plans = input;
            self
        }
        /// Consumes the builder and constructs a [`ImprovementSummary`](crate::model::ImprovementSummary).
        pub fn build(self) -> crate::model::ImprovementSummary {
            crate::model::ImprovementSummary {
                question_id: self.question_id,
                pillar_id: self.pillar_id,
                question_title: self.question_title,
                risk: self.risk,
                improvement_plan_url: self.improvement_plan_url,
                improvement_plans: self.improvement_plans,
            }
        }
    }
}

/// <p>The choice level improvement plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChoiceImprovementPlan {
    /// <p>The ID of a choice.</p>
    #[doc(hidden)]
    pub choice_id: std::option::Option<std::string::String>,
    /// <p>The display text for the improvement plan.</p>
    #[doc(hidden)]
    pub display_text: std::option::Option<std::string::String>,
    /// <p>The improvement plan URL for a question.</p>
    /// <p>This value is only available if the question has been answered.</p>
    #[doc(hidden)]
    pub improvement_plan_url: std::option::Option<std::string::String>,
}
impl ChoiceImprovementPlan {
    /// <p>The ID of a choice.</p>
    pub fn choice_id(&self) -> std::option::Option<&str> {
        self.choice_id.as_deref()
    }
    /// <p>The display text for the improvement plan.</p>
    pub fn display_text(&self) -> std::option::Option<&str> {
        self.display_text.as_deref()
    }
    /// <p>The improvement plan URL for a question.</p>
    /// <p>This value is only available if the question has been answered.</p>
    pub fn improvement_plan_url(&self) -> std::option::Option<&str> {
        self.improvement_plan_url.as_deref()
    }
}
impl ChoiceImprovementPlan {
    /// Creates a new builder-style object to manufacture [`ChoiceImprovementPlan`](crate::model::ChoiceImprovementPlan).
    pub fn builder() -> crate::model::choice_improvement_plan::Builder {
        crate::model::choice_improvement_plan::Builder::default()
    }
}

/// See [`ChoiceImprovementPlan`](crate::model::ChoiceImprovementPlan).
pub mod choice_improvement_plan {

    /// A builder for [`ChoiceImprovementPlan`](crate::model::ChoiceImprovementPlan).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) choice_id: std::option::Option<std::string::String>,
        pub(crate) display_text: std::option::Option<std::string::String>,
        pub(crate) improvement_plan_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a choice.</p>
        pub fn choice_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.choice_id = Some(input.into());
            self
        }
        /// <p>The ID of a choice.</p>
        pub fn set_choice_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.choice_id = input;
            self
        }
        /// <p>The display text for the improvement plan.</p>
        pub fn display_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_text = Some(input.into());
            self
        }
        /// <p>The display text for the improvement plan.</p>
        pub fn set_display_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_text = input;
            self
        }
        /// <p>The improvement plan URL for a question.</p>
        /// <p>This value is only available if the question has been answered.</p>
        pub fn improvement_plan_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.improvement_plan_url = Some(input.into());
            self
        }
        /// <p>The improvement plan URL for a question.</p>
        /// <p>This value is only available if the question has been answered.</p>
        pub fn set_improvement_plan_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.improvement_plan_url = input;
            self
        }
        /// Consumes the builder and constructs a [`ChoiceImprovementPlan`](crate::model::ChoiceImprovementPlan).
        pub fn build(self) -> crate::model::ChoiceImprovementPlan {
            crate::model::ChoiceImprovementPlan {
                choice_id: self.choice_id,
                display_text: self.display_text,
                improvement_plan_url: self.improvement_plan_url,
            }
        }
    }
}

/// <p>A lens summary of a lens.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LensSummary {
    /// <p>The ARN of the lens.</p>
    #[doc(hidden)]
    pub lens_arn: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    #[doc(hidden)]
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The full name of the lens.</p>
    #[doc(hidden)]
    pub lens_name: std::option::Option<std::string::String>,
    /// <p>The type of the lens.</p>
    #[doc(hidden)]
    pub lens_type: std::option::Option<crate::model::LensType>,
    /// <p>The description of the lens.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time recorded.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time recorded.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The version of the lens.</p>
    #[doc(hidden)]
    pub lens_version: std::option::Option<std::string::String>,
    /// <p>An Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>The status of the lens.</p>
    #[doc(hidden)]
    pub lens_status: std::option::Option<crate::model::LensStatus>,
}
impl LensSummary {
    /// <p>The ARN of the lens.</p>
    pub fn lens_arn(&self) -> std::option::Option<&str> {
        self.lens_arn.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The full name of the lens.</p>
    pub fn lens_name(&self) -> std::option::Option<&str> {
        self.lens_name.as_deref()
    }
    /// <p>The type of the lens.</p>
    pub fn lens_type(&self) -> std::option::Option<&crate::model::LensType> {
        self.lens_type.as_ref()
    }
    /// <p>The description of the lens.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date and time recorded.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date and time recorded.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The version of the lens.</p>
    pub fn lens_version(&self) -> std::option::Option<&str> {
        self.lens_version.as_deref()
    }
    /// <p>An Amazon Web Services account ID.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>The status of the lens.</p>
    pub fn lens_status(&self) -> std::option::Option<&crate::model::LensStatus> {
        self.lens_status.as_ref()
    }
}
impl LensSummary {
    /// Creates a new builder-style object to manufacture [`LensSummary`](crate::model::LensSummary).
    pub fn builder() -> crate::model::lens_summary::Builder {
        crate::model::lens_summary::Builder::default()
    }
}

/// See [`LensSummary`](crate::model::LensSummary).
pub mod lens_summary {

    /// A builder for [`LensSummary`](crate::model::LensSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_arn: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) lens_name: std::option::Option<std::string::String>,
        pub(crate) lens_type: std::option::Option<crate::model::LensType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) lens_version: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) lens_status: std::option::Option<crate::model::LensStatus>,
    }
    impl Builder {
        /// <p>The ARN of the lens.</p>
        pub fn lens_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the lens.</p>
        pub fn set_lens_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_arn = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn lens_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_name = Some(input.into());
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn set_lens_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_name = input;
            self
        }
        /// <p>The type of the lens.</p>
        pub fn lens_type(mut self, input: crate::model::LensType) -> Self {
            self.lens_type = Some(input);
            self
        }
        /// <p>The type of the lens.</p>
        pub fn set_lens_type(mut self, input: std::option::Option<crate::model::LensType>) -> Self {
            self.lens_type = input;
            self
        }
        /// <p>The description of the lens.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the lens.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The version of the lens.</p>
        pub fn lens_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_version = Some(input.into());
            self
        }
        /// <p>The version of the lens.</p>
        pub fn set_lens_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_version = input;
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The status of the lens.</p>
        pub fn lens_status(mut self, input: crate::model::LensStatus) -> Self {
            self.lens_status = Some(input);
            self
        }
        /// <p>The status of the lens.</p>
        pub fn set_lens_status(
            mut self,
            input: std::option::Option<crate::model::LensStatus>,
        ) -> Self {
            self.lens_status = input;
            self
        }
        /// Consumes the builder and constructs a [`LensSummary`](crate::model::LensSummary).
        pub fn build(self) -> crate::model::LensSummary {
            crate::model::LensSummary {
                lens_arn: self.lens_arn,
                lens_alias: self.lens_alias,
                lens_name: self.lens_name,
                lens_type: self.lens_type,
                description: self.description,
                created_at: self.created_at,
                updated_at: self.updated_at,
                lens_version: self.lens_version,
                owner: self.owner,
                lens_status: self.lens_status,
            }
        }
    }
}

/// When writing a match expression against `LensType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lenstype = unimplemented!();
/// match lenstype {
///     LensType::AwsOfficial => { /* ... */ },
///     LensType::CustomSelf => { /* ... */ },
///     LensType::CustomShared => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lenstype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LensType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LensType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LensType::NewFeature` is defined.
/// Specifically, when `lenstype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LensType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LensType {
    #[allow(missing_docs)] // documentation missing in model
    AwsOfficial,
    #[allow(missing_docs)] // documentation missing in model
    CustomSelf,
    #[allow(missing_docs)] // documentation missing in model
    CustomShared,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LensType {
    fn from(s: &str) -> Self {
        match s {
            "AWS_OFFICIAL" => LensType::AwsOfficial,
            "CUSTOM_SELF" => LensType::CustomSelf,
            "CUSTOM_SHARED" => LensType::CustomShared,
            other => LensType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LensType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LensType::from(s))
    }
}
impl LensType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LensType::AwsOfficial => "AWS_OFFICIAL",
            LensType::CustomSelf => "CUSTOM_SELF",
            LensType::CustomShared => "CUSTOM_SHARED",
            LensType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS_OFFICIAL", "CUSTOM_SELF", "CUSTOM_SHARED"]
    }
}
impl AsRef<str> for LensType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LensStatusType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lensstatustype = unimplemented!();
/// match lensstatustype {
///     LensStatusType::All => { /* ... */ },
///     LensStatusType::Draft => { /* ... */ },
///     LensStatusType::Published => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lensstatustype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LensStatusType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LensStatusType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LensStatusType::NewFeature` is defined.
/// Specifically, when `lensstatustype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LensStatusType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LensStatusType {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Draft,
    #[allow(missing_docs)] // documentation missing in model
    Published,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LensStatusType {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => LensStatusType::All,
            "DRAFT" => LensStatusType::Draft,
            "PUBLISHED" => LensStatusType::Published,
            other => LensStatusType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LensStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LensStatusType::from(s))
    }
}
impl LensStatusType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LensStatusType::All => "ALL",
            LensStatusType::Draft => "DRAFT",
            LensStatusType::Published => "PUBLISHED",
            LensStatusType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "DRAFT", "PUBLISHED"]
    }
}
impl AsRef<str> for LensStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Trusted Advisor check summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CheckSummary {
    /// <p>Trusted Advisor check ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Trusted Advisor check name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Provider of the check related to the best practice.</p>
    #[doc(hidden)]
    pub provider: std::option::Option<crate::model::CheckProvider>,
    /// <p>Trusted Advisor check description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time recorded.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Well-Architected Lens ARN associated to the check.</p>
    #[doc(hidden)]
    pub lens_arn: std::option::Option<std::string::String>,
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    #[doc(hidden)]
    pub pillar_id: std::option::Option<std::string::String>,
    /// <p>The ID of the question.</p>
    #[doc(hidden)]
    pub question_id: std::option::Option<std::string::String>,
    /// <p>The ID of a choice.</p>
    #[doc(hidden)]
    pub choice_id: std::option::Option<std::string::String>,
    /// <p>Status associated to the check.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::CheckStatus>,
    /// <p>Account summary associated to the check.</p>
    #[doc(hidden)]
    pub account_summary:
        std::option::Option<std::collections::HashMap<crate::model::CheckStatus, i32>>,
}
impl CheckSummary {
    /// <p>Trusted Advisor check ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>Trusted Advisor check name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Provider of the check related to the best practice.</p>
    pub fn provider(&self) -> std::option::Option<&crate::model::CheckProvider> {
        self.provider.as_ref()
    }
    /// <p>Trusted Advisor check description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date and time recorded.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>Well-Architected Lens ARN associated to the check.</p>
    pub fn lens_arn(&self) -> std::option::Option<&str> {
        self.lens_arn.as_deref()
    }
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_id(&self) -> std::option::Option<&str> {
        self.pillar_id.as_deref()
    }
    /// <p>The ID of the question.</p>
    pub fn question_id(&self) -> std::option::Option<&str> {
        self.question_id.as_deref()
    }
    /// <p>The ID of a choice.</p>
    pub fn choice_id(&self) -> std::option::Option<&str> {
        self.choice_id.as_deref()
    }
    /// <p>Status associated to the check.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::CheckStatus> {
        self.status.as_ref()
    }
    /// <p>Account summary associated to the check.</p>
    pub fn account_summary(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::CheckStatus, i32>> {
        self.account_summary.as_ref()
    }
}
impl CheckSummary {
    /// Creates a new builder-style object to manufacture [`CheckSummary`](crate::model::CheckSummary).
    pub fn builder() -> crate::model::check_summary::Builder {
        crate::model::check_summary::Builder::default()
    }
}

/// See [`CheckSummary`](crate::model::CheckSummary).
pub mod check_summary {

    /// A builder for [`CheckSummary`](crate::model::CheckSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) provider: std::option::Option<crate::model::CheckProvider>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) lens_arn: std::option::Option<std::string::String>,
        pub(crate) pillar_id: std::option::Option<std::string::String>,
        pub(crate) question_id: std::option::Option<std::string::String>,
        pub(crate) choice_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::CheckStatus>,
        pub(crate) account_summary:
            std::option::Option<std::collections::HashMap<crate::model::CheckStatus, i32>>,
    }
    impl Builder {
        /// <p>Trusted Advisor check ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>Trusted Advisor check ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Trusted Advisor check name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Trusted Advisor check name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Provider of the check related to the best practice.</p>
        pub fn provider(mut self, input: crate::model::CheckProvider) -> Self {
            self.provider = Some(input);
            self
        }
        /// <p>Provider of the check related to the best practice.</p>
        pub fn set_provider(
            mut self,
            input: std::option::Option<crate::model::CheckProvider>,
        ) -> Self {
            self.provider = input;
            self
        }
        /// <p>Trusted Advisor check description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Trusted Advisor check description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>Well-Architected Lens ARN associated to the check.</p>
        pub fn lens_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_arn = Some(input.into());
            self
        }
        /// <p>Well-Architected Lens ARN associated to the check.</p>
        pub fn set_lens_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_arn = input;
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pillar_id = Some(input.into());
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pillar_id = input;
            self
        }
        /// <p>The ID of the question.</p>
        pub fn question_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_id = Some(input.into());
            self
        }
        /// <p>The ID of the question.</p>
        pub fn set_question_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.question_id = input;
            self
        }
        /// <p>The ID of a choice.</p>
        pub fn choice_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.choice_id = Some(input.into());
            self
        }
        /// <p>The ID of a choice.</p>
        pub fn set_choice_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.choice_id = input;
            self
        }
        /// <p>Status associated to the check.</p>
        pub fn status(mut self, input: crate::model::CheckStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status associated to the check.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::CheckStatus>) -> Self {
            self.status = input;
            self
        }
        /// Adds a key-value pair to `account_summary`.
        ///
        /// To override the contents of this collection use [`set_account_summary`](Self::set_account_summary).
        ///
        /// <p>Account summary associated to the check.</p>
        pub fn account_summary(mut self, k: crate::model::CheckStatus, v: i32) -> Self {
            let mut hash_map = self.account_summary.unwrap_or_default();
            hash_map.insert(k, v);
            self.account_summary = Some(hash_map);
            self
        }
        /// <p>Account summary associated to the check.</p>
        pub fn set_account_summary(
            mut self,
            input: std::option::Option<std::collections::HashMap<crate::model::CheckStatus, i32>>,
        ) -> Self {
            self.account_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`CheckSummary`](crate::model::CheckSummary).
        pub fn build(self) -> crate::model::CheckSummary {
            crate::model::CheckSummary {
                id: self.id,
                name: self.name,
                provider: self.provider,
                description: self.description,
                updated_at: self.updated_at,
                lens_arn: self.lens_arn,
                pillar_id: self.pillar_id,
                question_id: self.question_id,
                choice_id: self.choice_id,
                status: self.status,
                account_summary: self.account_summary,
            }
        }
    }
}

/// When writing a match expression against `CheckStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let checkstatus = unimplemented!();
/// match checkstatus {
///     CheckStatus::Error => { /* ... */ },
///     CheckStatus::FetchFailed => { /* ... */ },
///     CheckStatus::NotAvailable => { /* ... */ },
///     CheckStatus::Okay => { /* ... */ },
///     CheckStatus::Warning => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `checkstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CheckStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CheckStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CheckStatus::NewFeature` is defined.
/// Specifically, when `checkstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CheckStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CheckStatus {
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    FetchFailed,
    #[allow(missing_docs)] // documentation missing in model
    NotAvailable,
    #[allow(missing_docs)] // documentation missing in model
    Okay,
    #[allow(missing_docs)] // documentation missing in model
    Warning,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CheckStatus {
    fn from(s: &str) -> Self {
        match s {
            "ERROR" => CheckStatus::Error,
            "FETCH_FAILED" => CheckStatus::FetchFailed,
            "NOT_AVAILABLE" => CheckStatus::NotAvailable,
            "OKAY" => CheckStatus::Okay,
            "WARNING" => CheckStatus::Warning,
            other => CheckStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CheckStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CheckStatus::from(s))
    }
}
impl CheckStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CheckStatus::Error => "ERROR",
            CheckStatus::FetchFailed => "FETCH_FAILED",
            CheckStatus::NotAvailable => "NOT_AVAILABLE",
            CheckStatus::Okay => "OKAY",
            CheckStatus::Warning => "WARNING",
            CheckStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ERROR", "FETCH_FAILED", "NOT_AVAILABLE", "OKAY", "WARNING"]
    }
}
impl AsRef<str> for CheckStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `CheckProvider`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let checkprovider = unimplemented!();
/// match checkprovider {
///     CheckProvider::TrustedAdvisor => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `checkprovider` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CheckProvider::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CheckProvider::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CheckProvider::NewFeature` is defined.
/// Specifically, when `checkprovider` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CheckProvider::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CheckProvider {
    #[allow(missing_docs)] // documentation missing in model
    TrustedAdvisor,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CheckProvider {
    fn from(s: &str) -> Self {
        match s {
            "TRUSTED_ADVISOR" => CheckProvider::TrustedAdvisor,
            other => CheckProvider::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CheckProvider {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CheckProvider::from(s))
    }
}
impl CheckProvider {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CheckProvider::TrustedAdvisor => "TRUSTED_ADVISOR",
            CheckProvider::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["TRUSTED_ADVISOR"]
    }
}
impl AsRef<str> for CheckProvider {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Account details for a Well-Architected best practice in relation to Trusted Advisor checks.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CheckDetail {
    /// <p>Trusted Advisor check ID.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Trusted Advisor check name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Trusted Advisor check description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Provider of the check related to the best practice.</p>
    #[doc(hidden)]
    pub provider: std::option::Option<crate::model::CheckProvider>,
    /// <p>Well-Architected Lens ARN associated to the check.</p>
    #[doc(hidden)]
    pub lens_arn: std::option::Option<std::string::String>,
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    #[doc(hidden)]
    pub pillar_id: std::option::Option<std::string::String>,
    /// <p>The ID of the question.</p>
    #[doc(hidden)]
    pub question_id: std::option::Option<std::string::String>,
    /// <p>The ID of a choice.</p>
    #[doc(hidden)]
    pub choice_id: std::option::Option<std::string::String>,
    /// <p>Status associated to the check.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::CheckStatus>,
    /// <p>An Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>Count of flagged resources associated to the check.</p>
    #[doc(hidden)]
    pub flagged_resources: i32,
    /// <p>Reason associated to the check.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::CheckFailureReason>,
    /// <p>The date and time recorded.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl CheckDetail {
    /// <p>Trusted Advisor check ID.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>Trusted Advisor check name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Trusted Advisor check description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Provider of the check related to the best practice.</p>
    pub fn provider(&self) -> std::option::Option<&crate::model::CheckProvider> {
        self.provider.as_ref()
    }
    /// <p>Well-Architected Lens ARN associated to the check.</p>
    pub fn lens_arn(&self) -> std::option::Option<&str> {
        self.lens_arn.as_deref()
    }
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_id(&self) -> std::option::Option<&str> {
        self.pillar_id.as_deref()
    }
    /// <p>The ID of the question.</p>
    pub fn question_id(&self) -> std::option::Option<&str> {
        self.question_id.as_deref()
    }
    /// <p>The ID of a choice.</p>
    pub fn choice_id(&self) -> std::option::Option<&str> {
        self.choice_id.as_deref()
    }
    /// <p>Status associated to the check.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::CheckStatus> {
        self.status.as_ref()
    }
    /// <p>An Amazon Web Services account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>Count of flagged resources associated to the check.</p>
    pub fn flagged_resources(&self) -> i32 {
        self.flagged_resources
    }
    /// <p>Reason associated to the check.</p>
    pub fn reason(&self) -> std::option::Option<&crate::model::CheckFailureReason> {
        self.reason.as_ref()
    }
    /// <p>The date and time recorded.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
}
impl CheckDetail {
    /// Creates a new builder-style object to manufacture [`CheckDetail`](crate::model::CheckDetail).
    pub fn builder() -> crate::model::check_detail::Builder {
        crate::model::check_detail::Builder::default()
    }
}

/// See [`CheckDetail`](crate::model::CheckDetail).
pub mod check_detail {

    /// A builder for [`CheckDetail`](crate::model::CheckDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) provider: std::option::Option<crate::model::CheckProvider>,
        pub(crate) lens_arn: std::option::Option<std::string::String>,
        pub(crate) pillar_id: std::option::Option<std::string::String>,
        pub(crate) question_id: std::option::Option<std::string::String>,
        pub(crate) choice_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::CheckStatus>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) flagged_resources: std::option::Option<i32>,
        pub(crate) reason: std::option::Option<crate::model::CheckFailureReason>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Trusted Advisor check ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>Trusted Advisor check ID.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Trusted Advisor check name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Trusted Advisor check name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Trusted Advisor check description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Trusted Advisor check description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Provider of the check related to the best practice.</p>
        pub fn provider(mut self, input: crate::model::CheckProvider) -> Self {
            self.provider = Some(input);
            self
        }
        /// <p>Provider of the check related to the best practice.</p>
        pub fn set_provider(
            mut self,
            input: std::option::Option<crate::model::CheckProvider>,
        ) -> Self {
            self.provider = input;
            self
        }
        /// <p>Well-Architected Lens ARN associated to the check.</p>
        pub fn lens_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_arn = Some(input.into());
            self
        }
        /// <p>Well-Architected Lens ARN associated to the check.</p>
        pub fn set_lens_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_arn = input;
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pillar_id = Some(input.into());
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pillar_id = input;
            self
        }
        /// <p>The ID of the question.</p>
        pub fn question_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_id = Some(input.into());
            self
        }
        /// <p>The ID of the question.</p>
        pub fn set_question_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.question_id = input;
            self
        }
        /// <p>The ID of a choice.</p>
        pub fn choice_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.choice_id = Some(input.into());
            self
        }
        /// <p>The ID of a choice.</p>
        pub fn set_choice_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.choice_id = input;
            self
        }
        /// <p>Status associated to the check.</p>
        pub fn status(mut self, input: crate::model::CheckStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status associated to the check.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::CheckStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>An Amazon Web Services account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>Count of flagged resources associated to the check.</p>
        pub fn flagged_resources(mut self, input: i32) -> Self {
            self.flagged_resources = Some(input);
            self
        }
        /// <p>Count of flagged resources associated to the check.</p>
        pub fn set_flagged_resources(mut self, input: std::option::Option<i32>) -> Self {
            self.flagged_resources = input;
            self
        }
        /// <p>Reason associated to the check.</p>
        pub fn reason(mut self, input: crate::model::CheckFailureReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>Reason associated to the check.</p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::CheckFailureReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`CheckDetail`](crate::model::CheckDetail).
        pub fn build(self) -> crate::model::CheckDetail {
            crate::model::CheckDetail {
                id: self.id,
                name: self.name,
                description: self.description,
                provider: self.provider,
                lens_arn: self.lens_arn,
                pillar_id: self.pillar_id,
                question_id: self.question_id,
                choice_id: self.choice_id,
                status: self.status,
                account_id: self.account_id,
                flagged_resources: self.flagged_resources.unwrap_or_default(),
                reason: self.reason,
                updated_at: self.updated_at,
            }
        }
    }
}

/// When writing a match expression against `CheckFailureReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let checkfailurereason = unimplemented!();
/// match checkfailurereason {
///     CheckFailureReason::AccessDenied => { /* ... */ },
///     CheckFailureReason::AssumeRoleError => { /* ... */ },
///     CheckFailureReason::PremiumSupportRequired => { /* ... */ },
///     CheckFailureReason::UnknownError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `checkfailurereason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CheckFailureReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CheckFailureReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CheckFailureReason::NewFeature` is defined.
/// Specifically, when `checkfailurereason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CheckFailureReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CheckFailureReason {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    AssumeRoleError,
    #[allow(missing_docs)] // documentation missing in model
    PremiumSupportRequired,
    #[allow(missing_docs)] // documentation missing in model
    UnknownError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CheckFailureReason {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_DENIED" => CheckFailureReason::AccessDenied,
            "ASSUME_ROLE_ERROR" => CheckFailureReason::AssumeRoleError,
            "PREMIUM_SUPPORT_REQUIRED" => CheckFailureReason::PremiumSupportRequired,
            "UNKNOWN_ERROR" => CheckFailureReason::UnknownError,
            other => {
                CheckFailureReason::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CheckFailureReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CheckFailureReason::from(s))
    }
}
impl CheckFailureReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CheckFailureReason::AccessDenied => "ACCESS_DENIED",
            CheckFailureReason::AssumeRoleError => "ASSUME_ROLE_ERROR",
            CheckFailureReason::PremiumSupportRequired => "PREMIUM_SUPPORT_REQUIRED",
            CheckFailureReason::UnknownError => "UNKNOWN_ERROR",
            CheckFailureReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCESS_DENIED",
            "ASSUME_ROLE_ERROR",
            "PREMIUM_SUPPORT_REQUIRED",
            "UNKNOWN_ERROR",
        ]
    }
}
impl AsRef<str> for CheckFailureReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An answer summary of a lens review in a workload.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnswerSummary {
    /// <p>The ID of the question.</p>
    #[doc(hidden)]
    pub question_id: std::option::Option<std::string::String>,
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    #[doc(hidden)]
    pub pillar_id: std::option::Option<std::string::String>,
    /// <p>The title of the question.</p>
    #[doc(hidden)]
    pub question_title: std::option::Option<std::string::String>,
    /// <p>List of choices available for a question.</p>
    #[doc(hidden)]
    pub choices: std::option::Option<std::vec::Vec<crate::model::Choice>>,
    /// <p>List of selected choice IDs in a question answer.</p>
    /// <p>The values entered replace the previously selected choices.</p>
    #[doc(hidden)]
    pub selected_choices: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of selected choices to a question in your workload.</p>
    #[doc(hidden)]
    pub choice_answer_summaries:
        std::option::Option<std::vec::Vec<crate::model::ChoiceAnswerSummary>>,
    /// <p>Defines whether this question is applicable to a lens review.</p>
    #[doc(hidden)]
    pub is_applicable: bool,
    /// <p>The risk for a given workload, lens review, pillar, or question.</p>
    #[doc(hidden)]
    pub risk: std::option::Option<crate::model::Risk>,
    /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::AnswerReason>,
}
impl AnswerSummary {
    /// <p>The ID of the question.</p>
    pub fn question_id(&self) -> std::option::Option<&str> {
        self.question_id.as_deref()
    }
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_id(&self) -> std::option::Option<&str> {
        self.pillar_id.as_deref()
    }
    /// <p>The title of the question.</p>
    pub fn question_title(&self) -> std::option::Option<&str> {
        self.question_title.as_deref()
    }
    /// <p>List of choices available for a question.</p>
    pub fn choices(&self) -> std::option::Option<&[crate::model::Choice]> {
        self.choices.as_deref()
    }
    /// <p>List of selected choice IDs in a question answer.</p>
    /// <p>The values entered replace the previously selected choices.</p>
    pub fn selected_choices(&self) -> std::option::Option<&[std::string::String]> {
        self.selected_choices.as_deref()
    }
    /// <p>A list of selected choices to a question in your workload.</p>
    pub fn choice_answer_summaries(
        &self,
    ) -> std::option::Option<&[crate::model::ChoiceAnswerSummary]> {
        self.choice_answer_summaries.as_deref()
    }
    /// <p>Defines whether this question is applicable to a lens review.</p>
    pub fn is_applicable(&self) -> bool {
        self.is_applicable
    }
    /// <p>The risk for a given workload, lens review, pillar, or question.</p>
    pub fn risk(&self) -> std::option::Option<&crate::model::Risk> {
        self.risk.as_ref()
    }
    /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
    pub fn reason(&self) -> std::option::Option<&crate::model::AnswerReason> {
        self.reason.as_ref()
    }
}
impl AnswerSummary {
    /// Creates a new builder-style object to manufacture [`AnswerSummary`](crate::model::AnswerSummary).
    pub fn builder() -> crate::model::answer_summary::Builder {
        crate::model::answer_summary::Builder::default()
    }
}

/// See [`AnswerSummary`](crate::model::AnswerSummary).
pub mod answer_summary {

    /// A builder for [`AnswerSummary`](crate::model::AnswerSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) question_id: std::option::Option<std::string::String>,
        pub(crate) pillar_id: std::option::Option<std::string::String>,
        pub(crate) question_title: std::option::Option<std::string::String>,
        pub(crate) choices: std::option::Option<std::vec::Vec<crate::model::Choice>>,
        pub(crate) selected_choices: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) choice_answer_summaries:
            std::option::Option<std::vec::Vec<crate::model::ChoiceAnswerSummary>>,
        pub(crate) is_applicable: std::option::Option<bool>,
        pub(crate) risk: std::option::Option<crate::model::Risk>,
        pub(crate) reason: std::option::Option<crate::model::AnswerReason>,
    }
    impl Builder {
        /// <p>The ID of the question.</p>
        pub fn question_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_id = Some(input.into());
            self
        }
        /// <p>The ID of the question.</p>
        pub fn set_question_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.question_id = input;
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pillar_id = Some(input.into());
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pillar_id = input;
            self
        }
        /// <p>The title of the question.</p>
        pub fn question_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_title = Some(input.into());
            self
        }
        /// <p>The title of the question.</p>
        pub fn set_question_title(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.question_title = input;
            self
        }
        /// Appends an item to `choices`.
        ///
        /// To override the contents of this collection use [`set_choices`](Self::set_choices).
        ///
        /// <p>List of choices available for a question.</p>
        pub fn choices(mut self, input: crate::model::Choice) -> Self {
            let mut v = self.choices.unwrap_or_default();
            v.push(input);
            self.choices = Some(v);
            self
        }
        /// <p>List of choices available for a question.</p>
        pub fn set_choices(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Choice>>,
        ) -> Self {
            self.choices = input;
            self
        }
        /// Appends an item to `selected_choices`.
        ///
        /// To override the contents of this collection use [`set_selected_choices`](Self::set_selected_choices).
        ///
        /// <p>List of selected choice IDs in a question answer.</p>
        /// <p>The values entered replace the previously selected choices.</p>
        pub fn selected_choices(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.selected_choices.unwrap_or_default();
            v.push(input.into());
            self.selected_choices = Some(v);
            self
        }
        /// <p>List of selected choice IDs in a question answer.</p>
        /// <p>The values entered replace the previously selected choices.</p>
        pub fn set_selected_choices(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.selected_choices = input;
            self
        }
        /// Appends an item to `choice_answer_summaries`.
        ///
        /// To override the contents of this collection use [`set_choice_answer_summaries`](Self::set_choice_answer_summaries).
        ///
        /// <p>A list of selected choices to a question in your workload.</p>
        pub fn choice_answer_summaries(mut self, input: crate::model::ChoiceAnswerSummary) -> Self {
            let mut v = self.choice_answer_summaries.unwrap_or_default();
            v.push(input);
            self.choice_answer_summaries = Some(v);
            self
        }
        /// <p>A list of selected choices to a question in your workload.</p>
        pub fn set_choice_answer_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChoiceAnswerSummary>>,
        ) -> Self {
            self.choice_answer_summaries = input;
            self
        }
        /// <p>Defines whether this question is applicable to a lens review.</p>
        pub fn is_applicable(mut self, input: bool) -> Self {
            self.is_applicable = Some(input);
            self
        }
        /// <p>Defines whether this question is applicable to a lens review.</p>
        pub fn set_is_applicable(mut self, input: std::option::Option<bool>) -> Self {
            self.is_applicable = input;
            self
        }
        /// <p>The risk for a given workload, lens review, pillar, or question.</p>
        pub fn risk(mut self, input: crate::model::Risk) -> Self {
            self.risk = Some(input);
            self
        }
        /// <p>The risk for a given workload, lens review, pillar, or question.</p>
        pub fn set_risk(mut self, input: std::option::Option<crate::model::Risk>) -> Self {
            self.risk = input;
            self
        }
        /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
        pub fn reason(mut self, input: crate::model::AnswerReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::AnswerReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`AnswerSummary`](crate::model::AnswerSummary).
        pub fn build(self) -> crate::model::AnswerSummary {
            crate::model::AnswerSummary {
                question_id: self.question_id,
                pillar_id: self.pillar_id,
                question_title: self.question_title,
                choices: self.choices,
                selected_choices: self.selected_choices,
                choice_answer_summaries: self.choice_answer_summaries,
                is_applicable: self.is_applicable.unwrap_or_default(),
                risk: self.risk,
                reason: self.reason,
            }
        }
    }
}

/// <p>A choice summary that has been answered on a question in your workload.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChoiceAnswerSummary {
    /// <p>The ID of a choice.</p>
    #[doc(hidden)]
    pub choice_id: std::option::Option<std::string::String>,
    /// <p>The status of a choice.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ChoiceStatus>,
    /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::ChoiceReason>,
}
impl ChoiceAnswerSummary {
    /// <p>The ID of a choice.</p>
    pub fn choice_id(&self) -> std::option::Option<&str> {
        self.choice_id.as_deref()
    }
    /// <p>The status of a choice.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ChoiceStatus> {
        self.status.as_ref()
    }
    /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
    pub fn reason(&self) -> std::option::Option<&crate::model::ChoiceReason> {
        self.reason.as_ref()
    }
}
impl ChoiceAnswerSummary {
    /// Creates a new builder-style object to manufacture [`ChoiceAnswerSummary`](crate::model::ChoiceAnswerSummary).
    pub fn builder() -> crate::model::choice_answer_summary::Builder {
        crate::model::choice_answer_summary::Builder::default()
    }
}

/// See [`ChoiceAnswerSummary`](crate::model::ChoiceAnswerSummary).
pub mod choice_answer_summary {

    /// A builder for [`ChoiceAnswerSummary`](crate::model::ChoiceAnswerSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) choice_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ChoiceStatus>,
        pub(crate) reason: std::option::Option<crate::model::ChoiceReason>,
    }
    impl Builder {
        /// <p>The ID of a choice.</p>
        pub fn choice_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.choice_id = Some(input.into());
            self
        }
        /// <p>The ID of a choice.</p>
        pub fn set_choice_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.choice_id = input;
            self
        }
        /// <p>The status of a choice.</p>
        pub fn status(mut self, input: crate::model::ChoiceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of a choice.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ChoiceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
        pub fn reason(mut self, input: crate::model::ChoiceReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>The reason why a choice is non-applicable to a question in your workload.</p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::ChoiceReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`ChoiceAnswerSummary`](crate::model::ChoiceAnswerSummary).
        pub fn build(self) -> crate::model::ChoiceAnswerSummary {
            crate::model::ChoiceAnswerSummary {
                choice_id: self.choice_id,
                status: self.status,
                reason: self.reason,
            }
        }
    }
}

/// When writing a match expression against `ImportLensStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let importlensstatus = unimplemented!();
/// match importlensstatus {
///     ImportLensStatus::Complete => { /* ... */ },
///     ImportLensStatus::Error => { /* ... */ },
///     ImportLensStatus::InProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `importlensstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ImportLensStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ImportLensStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ImportLensStatus::NewFeature` is defined.
/// Specifically, when `importlensstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ImportLensStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImportLensStatus {
    #[allow(missing_docs)] // documentation missing in model
    Complete,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ImportLensStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETE" => ImportLensStatus::Complete,
            "ERROR" => ImportLensStatus::Error,
            "IN_PROGRESS" => ImportLensStatus::InProgress,
            other => ImportLensStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ImportLensStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImportLensStatus::from(s))
    }
}
impl ImportLensStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImportLensStatus::Complete => "COMPLETE",
            ImportLensStatus::Error => "ERROR",
            ImportLensStatus::InProgress => "IN_PROGRESS",
            ImportLensStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLETE", "ERROR", "IN_PROGRESS"]
    }
}
impl AsRef<str> for ImportLensStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A milestone return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Milestone {
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    #[doc(hidden)]
    pub milestone_number: i32,
    /// <p>The name of the milestone in a workload.</p>
    /// <p>Milestone names must be unique within a workload.</p>
    #[doc(hidden)]
    pub milestone_name: std::option::Option<std::string::String>,
    /// <p>The date and time recorded.</p>
    #[doc(hidden)]
    pub recorded_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A workload return object.</p>
    #[doc(hidden)]
    pub workload: std::option::Option<crate::model::Workload>,
}
impl Milestone {
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub fn milestone_number(&self) -> i32 {
        self.milestone_number
    }
    /// <p>The name of the milestone in a workload.</p>
    /// <p>Milestone names must be unique within a workload.</p>
    pub fn milestone_name(&self) -> std::option::Option<&str> {
        self.milestone_name.as_deref()
    }
    /// <p>The date and time recorded.</p>
    pub fn recorded_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.recorded_at.as_ref()
    }
    /// <p>A workload return object.</p>
    pub fn workload(&self) -> std::option::Option<&crate::model::Workload> {
        self.workload.as_ref()
    }
}
impl Milestone {
    /// Creates a new builder-style object to manufacture [`Milestone`](crate::model::Milestone).
    pub fn builder() -> crate::model::milestone::Builder {
        crate::model::milestone::Builder::default()
    }
}

/// See [`Milestone`](crate::model::Milestone).
pub mod milestone {

    /// A builder for [`Milestone`](crate::model::Milestone).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) milestone_number: std::option::Option<i32>,
        pub(crate) milestone_name: std::option::Option<std::string::String>,
        pub(crate) recorded_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) workload: std::option::Option<crate::model::Workload>,
    }
    impl Builder {
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn milestone_number(mut self, input: i32) -> Self {
            self.milestone_number = Some(input);
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn set_milestone_number(mut self, input: std::option::Option<i32>) -> Self {
            self.milestone_number = input;
            self
        }
        /// <p>The name of the milestone in a workload.</p>
        /// <p>Milestone names must be unique within a workload.</p>
        pub fn milestone_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.milestone_name = Some(input.into());
            self
        }
        /// <p>The name of the milestone in a workload.</p>
        /// <p>Milestone names must be unique within a workload.</p>
        pub fn set_milestone_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.milestone_name = input;
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn recorded_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.recorded_at = Some(input);
            self
        }
        /// <p>The date and time recorded.</p>
        pub fn set_recorded_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.recorded_at = input;
            self
        }
        /// <p>A workload return object.</p>
        pub fn workload(mut self, input: crate::model::Workload) -> Self {
            self.workload = Some(input);
            self
        }
        /// <p>A workload return object.</p>
        pub fn set_workload(mut self, input: std::option::Option<crate::model::Workload>) -> Self {
            self.workload = input;
            self
        }
        /// Consumes the builder and constructs a [`Milestone`](crate::model::Milestone).
        pub fn build(self) -> crate::model::Milestone {
            crate::model::Milestone {
                milestone_number: self.milestone_number.unwrap_or_default(),
                milestone_name: self.milestone_name,
                recorded_at: self.recorded_at,
                workload: self.workload,
            }
        }
    }
}

/// <p>The differences between the base and latest versions of the lens.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VersionDifferences {
    /// <p>The differences between the base and latest versions of the lens.</p>
    #[doc(hidden)]
    pub pillar_differences: std::option::Option<std::vec::Vec<crate::model::PillarDifference>>,
}
impl VersionDifferences {
    /// <p>The differences between the base and latest versions of the lens.</p>
    pub fn pillar_differences(&self) -> std::option::Option<&[crate::model::PillarDifference]> {
        self.pillar_differences.as_deref()
    }
}
impl VersionDifferences {
    /// Creates a new builder-style object to manufacture [`VersionDifferences`](crate::model::VersionDifferences).
    pub fn builder() -> crate::model::version_differences::Builder {
        crate::model::version_differences::Builder::default()
    }
}

/// See [`VersionDifferences`](crate::model::VersionDifferences).
pub mod version_differences {

    /// A builder for [`VersionDifferences`](crate::model::VersionDifferences).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pillar_differences:
            std::option::Option<std::vec::Vec<crate::model::PillarDifference>>,
    }
    impl Builder {
        /// Appends an item to `pillar_differences`.
        ///
        /// To override the contents of this collection use [`set_pillar_differences`](Self::set_pillar_differences).
        ///
        /// <p>The differences between the base and latest versions of the lens.</p>
        pub fn pillar_differences(mut self, input: crate::model::PillarDifference) -> Self {
            let mut v = self.pillar_differences.unwrap_or_default();
            v.push(input);
            self.pillar_differences = Some(v);
            self
        }
        /// <p>The differences between the base and latest versions of the lens.</p>
        pub fn set_pillar_differences(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PillarDifference>>,
        ) -> Self {
            self.pillar_differences = input;
            self
        }
        /// Consumes the builder and constructs a [`VersionDifferences`](crate::model::VersionDifferences).
        pub fn build(self) -> crate::model::VersionDifferences {
            crate::model::VersionDifferences {
                pillar_differences: self.pillar_differences,
            }
        }
    }
}

/// <p>A pillar difference return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PillarDifference {
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    #[doc(hidden)]
    pub pillar_id: std::option::Option<std::string::String>,
    /// <p>The name of the pillar.</p>
    #[doc(hidden)]
    pub pillar_name: std::option::Option<std::string::String>,
    /// <p>Indicates the type of change to the pillar.</p>
    #[doc(hidden)]
    pub difference_status: std::option::Option<crate::model::DifferenceStatus>,
    /// <p>List of question differences.</p>
    #[doc(hidden)]
    pub question_differences: std::option::Option<std::vec::Vec<crate::model::QuestionDifference>>,
}
impl PillarDifference {
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_id(&self) -> std::option::Option<&str> {
        self.pillar_id.as_deref()
    }
    /// <p>The name of the pillar.</p>
    pub fn pillar_name(&self) -> std::option::Option<&str> {
        self.pillar_name.as_deref()
    }
    /// <p>Indicates the type of change to the pillar.</p>
    pub fn difference_status(&self) -> std::option::Option<&crate::model::DifferenceStatus> {
        self.difference_status.as_ref()
    }
    /// <p>List of question differences.</p>
    pub fn question_differences(&self) -> std::option::Option<&[crate::model::QuestionDifference]> {
        self.question_differences.as_deref()
    }
}
impl PillarDifference {
    /// Creates a new builder-style object to manufacture [`PillarDifference`](crate::model::PillarDifference).
    pub fn builder() -> crate::model::pillar_difference::Builder {
        crate::model::pillar_difference::Builder::default()
    }
}

/// See [`PillarDifference`](crate::model::PillarDifference).
pub mod pillar_difference {

    /// A builder for [`PillarDifference`](crate::model::PillarDifference).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pillar_id: std::option::Option<std::string::String>,
        pub(crate) pillar_name: std::option::Option<std::string::String>,
        pub(crate) difference_status: std::option::Option<crate::model::DifferenceStatus>,
        pub(crate) question_differences:
            std::option::Option<std::vec::Vec<crate::model::QuestionDifference>>,
    }
    impl Builder {
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pillar_id = Some(input.into());
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pillar_id = input;
            self
        }
        /// <p>The name of the pillar.</p>
        pub fn pillar_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.pillar_name = Some(input.into());
            self
        }
        /// <p>The name of the pillar.</p>
        pub fn set_pillar_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pillar_name = input;
            self
        }
        /// <p>Indicates the type of change to the pillar.</p>
        pub fn difference_status(mut self, input: crate::model::DifferenceStatus) -> Self {
            self.difference_status = Some(input);
            self
        }
        /// <p>Indicates the type of change to the pillar.</p>
        pub fn set_difference_status(
            mut self,
            input: std::option::Option<crate::model::DifferenceStatus>,
        ) -> Self {
            self.difference_status = input;
            self
        }
        /// Appends an item to `question_differences`.
        ///
        /// To override the contents of this collection use [`set_question_differences`](Self::set_question_differences).
        ///
        /// <p>List of question differences.</p>
        pub fn question_differences(mut self, input: crate::model::QuestionDifference) -> Self {
            let mut v = self.question_differences.unwrap_or_default();
            v.push(input);
            self.question_differences = Some(v);
            self
        }
        /// <p>List of question differences.</p>
        pub fn set_question_differences(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QuestionDifference>>,
        ) -> Self {
            self.question_differences = input;
            self
        }
        /// Consumes the builder and constructs a [`PillarDifference`](crate::model::PillarDifference).
        pub fn build(self) -> crate::model::PillarDifference {
            crate::model::PillarDifference {
                pillar_id: self.pillar_id,
                pillar_name: self.pillar_name,
                difference_status: self.difference_status,
                question_differences: self.question_differences,
            }
        }
    }
}

/// <p>A question difference return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QuestionDifference {
    /// <p>The ID of the question.</p>
    #[doc(hidden)]
    pub question_id: std::option::Option<std::string::String>,
    /// <p>The title of the question.</p>
    #[doc(hidden)]
    pub question_title: std::option::Option<std::string::String>,
    /// <p>Indicates the type of change to the question.</p>
    #[doc(hidden)]
    pub difference_status: std::option::Option<crate::model::DifferenceStatus>,
}
impl QuestionDifference {
    /// <p>The ID of the question.</p>
    pub fn question_id(&self) -> std::option::Option<&str> {
        self.question_id.as_deref()
    }
    /// <p>The title of the question.</p>
    pub fn question_title(&self) -> std::option::Option<&str> {
        self.question_title.as_deref()
    }
    /// <p>Indicates the type of change to the question.</p>
    pub fn difference_status(&self) -> std::option::Option<&crate::model::DifferenceStatus> {
        self.difference_status.as_ref()
    }
}
impl QuestionDifference {
    /// Creates a new builder-style object to manufacture [`QuestionDifference`](crate::model::QuestionDifference).
    pub fn builder() -> crate::model::question_difference::Builder {
        crate::model::question_difference::Builder::default()
    }
}

/// See [`QuestionDifference`](crate::model::QuestionDifference).
pub mod question_difference {

    /// A builder for [`QuestionDifference`](crate::model::QuestionDifference).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) question_id: std::option::Option<std::string::String>,
        pub(crate) question_title: std::option::Option<std::string::String>,
        pub(crate) difference_status: std::option::Option<crate::model::DifferenceStatus>,
    }
    impl Builder {
        /// <p>The ID of the question.</p>
        pub fn question_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_id = Some(input.into());
            self
        }
        /// <p>The ID of the question.</p>
        pub fn set_question_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.question_id = input;
            self
        }
        /// <p>The title of the question.</p>
        pub fn question_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_title = Some(input.into());
            self
        }
        /// <p>The title of the question.</p>
        pub fn set_question_title(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.question_title = input;
            self
        }
        /// <p>Indicates the type of change to the question.</p>
        pub fn difference_status(mut self, input: crate::model::DifferenceStatus) -> Self {
            self.difference_status = Some(input);
            self
        }
        /// <p>Indicates the type of change to the question.</p>
        pub fn set_difference_status(
            mut self,
            input: std::option::Option<crate::model::DifferenceStatus>,
        ) -> Self {
            self.difference_status = input;
            self
        }
        /// Consumes the builder and constructs a [`QuestionDifference`](crate::model::QuestionDifference).
        pub fn build(self) -> crate::model::QuestionDifference {
            crate::model::QuestionDifference {
                question_id: self.question_id,
                question_title: self.question_title,
                difference_status: self.difference_status,
            }
        }
    }
}

/// When writing a match expression against `DifferenceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let differencestatus = unimplemented!();
/// match differencestatus {
///     DifferenceStatus::Deleted => { /* ... */ },
///     DifferenceStatus::New => { /* ... */ },
///     DifferenceStatus::Updated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `differencestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DifferenceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DifferenceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DifferenceStatus::NewFeature` is defined.
/// Specifically, when `differencestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DifferenceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DifferenceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    New,
    #[allow(missing_docs)] // documentation missing in model
    Updated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DifferenceStatus {
    fn from(s: &str) -> Self {
        match s {
            "DELETED" => DifferenceStatus::Deleted,
            "NEW" => DifferenceStatus::New,
            "UPDATED" => DifferenceStatus::Updated,
            other => DifferenceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DifferenceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DifferenceStatus::from(s))
    }
}
impl DifferenceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DifferenceStatus::Deleted => "DELETED",
            DifferenceStatus::New => "NEW",
            DifferenceStatus::Updated => "UPDATED",
            DifferenceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELETED", "NEW", "UPDATED"]
    }
}
impl AsRef<str> for DifferenceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A report of a lens review.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LensReviewReport {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    #[doc(hidden)]
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The ARN for the lens.</p>
    #[doc(hidden)]
    pub lens_arn: std::option::Option<std::string::String>,
    /// <p>The Base64-encoded string representation of a lens review report.</p>
    /// <p>This data can be used to create a PDF file.</p>
    #[doc(hidden)]
    pub base64_string: std::option::Option<std::string::String>,
}
impl LensReviewReport {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The ARN for the lens.</p>
    pub fn lens_arn(&self) -> std::option::Option<&str> {
        self.lens_arn.as_deref()
    }
    /// <p>The Base64-encoded string representation of a lens review report.</p>
    /// <p>This data can be used to create a PDF file.</p>
    pub fn base64_string(&self) -> std::option::Option<&str> {
        self.base64_string.as_deref()
    }
}
impl LensReviewReport {
    /// Creates a new builder-style object to manufacture [`LensReviewReport`](crate::model::LensReviewReport).
    pub fn builder() -> crate::model::lens_review_report::Builder {
        crate::model::lens_review_report::Builder::default()
    }
}

/// See [`LensReviewReport`](crate::model::LensReviewReport).
pub mod lens_review_report {

    /// A builder for [`LensReviewReport`](crate::model::LensReviewReport).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) lens_arn: std::option::Option<std::string::String>,
        pub(crate) base64_string: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn lens_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the lens.</p>
        pub fn set_lens_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_arn = input;
            self
        }
        /// <p>The Base64-encoded string representation of a lens review report.</p>
        /// <p>This data can be used to create a PDF file.</p>
        pub fn base64_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.base64_string = Some(input.into());
            self
        }
        /// <p>The Base64-encoded string representation of a lens review report.</p>
        /// <p>This data can be used to create a PDF file.</p>
        pub fn set_base64_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.base64_string = input;
            self
        }
        /// Consumes the builder and constructs a [`LensReviewReport`](crate::model::LensReviewReport).
        pub fn build(self) -> crate::model::LensReviewReport {
            crate::model::LensReviewReport {
                lens_alias: self.lens_alias,
                lens_arn: self.lens_arn,
                base64_string: self.base64_string,
            }
        }
    }
}

/// <p>A lens return object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Lens {
    /// <p>The ARN of a lens.</p>
    #[doc(hidden)]
    pub lens_arn: std::option::Option<std::string::String>,
    /// <p>The version of a lens.</p>
    #[doc(hidden)]
    pub lens_version: std::option::Option<std::string::String>,
    /// <p>The full name of the lens.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the lens.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID that owns the lens.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>The ID assigned to the share invitation.</p>
    #[doc(hidden)]
    pub share_invitation_id: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the lens.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Lens {
    /// <p>The ARN of a lens.</p>
    pub fn lens_arn(&self) -> std::option::Option<&str> {
        self.lens_arn.as_deref()
    }
    /// <p>The version of a lens.</p>
    pub fn lens_version(&self) -> std::option::Option<&str> {
        self.lens_version.as_deref()
    }
    /// <p>The full name of the lens.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the lens.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The Amazon Web Services account ID that owns the lens.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>The ID assigned to the share invitation.</p>
    pub fn share_invitation_id(&self) -> std::option::Option<&str> {
        self.share_invitation_id.as_deref()
    }
    /// <p>The tags assigned to the lens.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl Lens {
    /// Creates a new builder-style object to manufacture [`Lens`](crate::model::Lens).
    pub fn builder() -> crate::model::lens::Builder {
        crate::model::lens::Builder::default()
    }
}

/// See [`Lens`](crate::model::Lens).
pub mod lens {

    /// A builder for [`Lens`](crate::model::Lens).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_arn: std::option::Option<std::string::String>,
        pub(crate) lens_version: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) share_invitation_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ARN of a lens.</p>
        pub fn lens_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a lens.</p>
        pub fn set_lens_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_arn = input;
            self
        }
        /// <p>The version of a lens.</p>
        pub fn lens_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_version = Some(input.into());
            self
        }
        /// <p>The version of a lens.</p>
        pub fn set_lens_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_version = input;
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the lens.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the lens.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The Amazon Web Services account ID that owns the lens.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID that owns the lens.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The ID assigned to the share invitation.</p>
        pub fn share_invitation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_invitation_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the share invitation.</p>
        pub fn set_share_invitation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.share_invitation_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the lens.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the lens.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Lens`](crate::model::Lens).
        pub fn build(self) -> crate::model::Lens {
            crate::model::Lens {
                lens_arn: self.lens_arn,
                lens_version: self.lens_version,
                name: self.name,
                description: self.description,
                owner: self.owner,
                share_invitation_id: self.share_invitation_id,
                tags: self.tags,
            }
        }
    }
}
