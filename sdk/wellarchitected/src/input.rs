// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`AssociateLensesInput`](crate::input::AssociateLensesInput)
pub mod associate_lenses_input {

    /// A builder for [`AssociateLensesInput`](crate::input::AssociateLensesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_aliases: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// Appends an item to `lens_aliases`.
        ///
        /// To override the contents of this collection use [`set_lens_aliases`](Self::set_lens_aliases).
        ///
        /// <p>List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified.</p>
        /// <p>Identify a lens using its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_aliases(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.lens_aliases.unwrap_or_default();
            v.push(input.into());
            self.lens_aliases = Some(v);
            self
        }
        /// <p>List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified.</p>
        /// <p>Identify a lens using its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_aliases(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.lens_aliases = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateLensesInput`](crate::input::AssociateLensesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateLensesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateLensesInput {
                workload_id: self.workload_id,
                lens_aliases: self.lens_aliases,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateLensesInputOperationOutputAlias = crate::operation::AssociateLenses;
#[doc(hidden)]
pub type AssociateLensesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AssociateLensesInput {
    /// Consumes the builder and constructs an Operation<[`AssociateLenses`](crate::operation::AssociateLenses)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateLenses,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateLensesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_1 = &_input.workload_id;
                let input_1 = input_1.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_1, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/associateLenses",
                    WorkloadId = workload_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateLensesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_lenses(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateLenses::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateLenses",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociateLensesInput`](crate::input::AssociateLensesInput)
    pub fn builder() -> crate::input::associate_lenses_input::Builder {
        crate::input::associate_lenses_input::Builder::default()
    }
}

/// See [`CreateLensShareInput`](crate::input::CreateLensShareInput)
pub mod create_lens_share_input {

    /// A builder for [`CreateLensShareInput`](crate::input::CreateLensShareInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) shared_with: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
        pub fn shared_with(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_with = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
        pub fn set_shared_with(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.shared_with = input;
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLensShareInput`](crate::input::CreateLensShareInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateLensShareInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateLensShareInput {
                lens_alias: self.lens_alias,
                shared_with: self.shared_with,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateLensShareInputOperationOutputAlias = crate::operation::CreateLensShare;
#[doc(hidden)]
pub type CreateLensShareInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateLensShareInput {
    /// Consumes the builder and constructs an Operation<[`CreateLensShare`](crate::operation::CreateLensShare)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateLensShare,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateLensShareInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_2 = &_input.lens_alias;
                let input_2 = input_2.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_2, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/lenses/{LensAlias}/shares", LensAlias = lens_alias)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateLensShareInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_lens_share(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateLensShare::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateLensShare",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateLensShareInput`](crate::input::CreateLensShareInput)
    pub fn builder() -> crate::input::create_lens_share_input::Builder {
        crate::input::create_lens_share_input::Builder::default()
    }
}

/// See [`CreateLensVersionInput`](crate::input::CreateLensVersionInput)
pub mod create_lens_version_input {

    /// A builder for [`CreateLensVersionInput`](crate::input::CreateLensVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) lens_version: std::option::Option<std::string::String>,
        pub(crate) is_major_version: std::option::Option<bool>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The version of the lens being created.</p>
        pub fn lens_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_version = Some(input.into());
            self
        }
        /// <p>The version of the lens being created.</p>
        pub fn set_lens_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_version = input;
            self
        }
        /// <p>Set to true if this new major lens version.</p>
        pub fn is_major_version(mut self, input: bool) -> Self {
            self.is_major_version = Some(input);
            self
        }
        /// <p>Set to true if this new major lens version.</p>
        pub fn set_is_major_version(mut self, input: std::option::Option<bool>) -> Self {
            self.is_major_version = input;
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLensVersionInput`](crate::input::CreateLensVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateLensVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateLensVersionInput {
                lens_alias: self.lens_alias,
                lens_version: self.lens_version,
                is_major_version: self.is_major_version.unwrap_or_default(),
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateLensVersionInputOperationOutputAlias = crate::operation::CreateLensVersion;
#[doc(hidden)]
pub type CreateLensVersionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateLensVersionInput {
    /// Consumes the builder and constructs an Operation<[`CreateLensVersion`](crate::operation::CreateLensVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateLensVersion,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateLensVersionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_3 = &_input.lens_alias;
                let input_3 = input_3.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_3, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/lenses/{LensAlias}/versions",
                    LensAlias = lens_alias
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateLensVersionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_lens_version(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateLensVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateLensVersion",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateLensVersionInput`](crate::input::CreateLensVersionInput)
    pub fn builder() -> crate::input::create_lens_version_input::Builder {
        crate::input::create_lens_version_input::Builder::default()
    }
}

/// See [`CreateMilestoneInput`](crate::input::CreateMilestoneInput)
pub mod create_milestone_input {

    /// A builder for [`CreateMilestoneInput`](crate::input::CreateMilestoneInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) milestone_name: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The name of the milestone in a workload.</p>
        /// <p>Milestone names must be unique within a workload.</p>
        pub fn milestone_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.milestone_name = Some(input.into());
            self
        }
        /// <p>The name of the milestone in a workload.</p>
        /// <p>Milestone names must be unique within a workload.</p>
        pub fn set_milestone_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.milestone_name = input;
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateMilestoneInput`](crate::input::CreateMilestoneInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateMilestoneInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateMilestoneInput {
                workload_id: self.workload_id,
                milestone_name: self.milestone_name,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateMilestoneInputOperationOutputAlias = crate::operation::CreateMilestone;
#[doc(hidden)]
pub type CreateMilestoneInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateMilestoneInput {
    /// Consumes the builder and constructs an Operation<[`CreateMilestone`](crate::operation::CreateMilestone)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateMilestone,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateMilestoneInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_4 = &_input.workload_id;
                let input_4 = input_4.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_4, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/milestones",
                    WorkloadId = workload_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateMilestoneInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_milestone(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateMilestone::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateMilestone",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateMilestoneInput`](crate::input::CreateMilestoneInput)
    pub fn builder() -> crate::input::create_milestone_input::Builder {
        crate::input::create_milestone_input::Builder::default()
    }
}

/// See [`CreateWorkloadInput`](crate::input::CreateWorkloadInput)
pub mod create_workload_input {

    /// A builder for [`CreateWorkloadInput`](crate::input::CreateWorkloadInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<crate::model::WorkloadEnvironment>,
        pub(crate) account_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) non_aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) pillar_priorities: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) architectural_design: std::option::Option<std::string::String>,
        pub(crate) review_owner: std::option::Option<std::string::String>,
        pub(crate) industry_type: std::option::Option<std::string::String>,
        pub(crate) industry: std::option::Option<std::string::String>,
        pub(crate) lenses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) notes: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn workload_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_name = Some(input.into());
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn set_workload_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workload_name = input;
            self
        }
        /// <p>The description for the workload.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description for the workload.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The environment for the workload.</p>
        pub fn environment(mut self, input: crate::model::WorkloadEnvironment) -> Self {
            self.environment = Some(input);
            self
        }
        /// <p>The environment for the workload.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<crate::model::WorkloadEnvironment>,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Appends an item to `account_ids`.
        ///
        /// To override the contents of this collection use [`set_account_ids`](Self::set_account_ids).
        ///
        /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
        pub fn account_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.account_ids.unwrap_or_default();
            v.push(input.into());
            self.account_ids = Some(v);
            self
        }
        /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
        pub fn set_account_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.account_ids = input;
            self
        }
        /// Appends an item to `aws_regions`.
        ///
        /// To override the contents of this collection use [`set_aws_regions`](Self::set_aws_regions).
        ///
        /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
        pub fn aws_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.aws_regions.unwrap_or_default();
            v.push(input.into());
            self.aws_regions = Some(v);
            self
        }
        /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
        pub fn set_aws_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.aws_regions = input;
            self
        }
        /// Appends an item to `non_aws_regions`.
        ///
        /// To override the contents of this collection use [`set_non_aws_regions`](Self::set_non_aws_regions).
        ///
        /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
        pub fn non_aws_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.non_aws_regions.unwrap_or_default();
            v.push(input.into());
            self.non_aws_regions = Some(v);
            self
        }
        /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
        pub fn set_non_aws_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.non_aws_regions = input;
            self
        }
        /// Appends an item to `pillar_priorities`.
        ///
        /// To override the contents of this collection use [`set_pillar_priorities`](Self::set_pillar_priorities).
        ///
        /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_priorities(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.pillar_priorities.unwrap_or_default();
            v.push(input.into());
            self.pillar_priorities = Some(v);
            self
        }
        /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_priorities(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.pillar_priorities = input;
            self
        }
        /// <p>The URL of the architectural design for the workload.</p>
        pub fn architectural_design(mut self, input: impl Into<std::string::String>) -> Self {
            self.architectural_design = Some(input.into());
            self
        }
        /// <p>The URL of the architectural design for the workload.</p>
        pub fn set_architectural_design(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.architectural_design = input;
            self
        }
        /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
        pub fn review_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.review_owner = Some(input.into());
            self
        }
        /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
        pub fn set_review_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.review_owner = input;
            self
        }
        /// <p>The industry type for the workload.</p>
        /// <p>If specified, must be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>Agriculture</code> </p> </li>
        /// <li> <p> <code>Automobile</code> </p> </li>
        /// <li> <p> <code>Defense</code> </p> </li>
        /// <li> <p> <code>Design and Engineering</code> </p> </li>
        /// <li> <p> <code>Digital Advertising</code> </p> </li>
        /// <li> <p> <code>Education</code> </p> </li>
        /// <li> <p> <code>Environmental Protection</code> </p> </li>
        /// <li> <p> <code>Financial Services</code> </p> </li>
        /// <li> <p> <code>Gaming</code> </p> </li>
        /// <li> <p> <code>General Public Services</code> </p> </li>
        /// <li> <p> <code>Healthcare</code> </p> </li>
        /// <li> <p> <code>Hospitality</code> </p> </li>
        /// <li> <p> <code>InfoTech</code> </p> </li>
        /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
        /// <li> <p> <code>Life Sciences</code> </p> </li>
        /// <li> <p> <code>Manufacturing</code> </p> </li>
        /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
        /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
        /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
        /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
        /// <li> <p> <code>Professional Services</code> </p> </li>
        /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
        /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
        /// <li> <p> <code>Social Protection</code> </p> </li>
        /// <li> <p> <code>Telecommunications</code> </p> </li>
        /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
        /// <li> <p> <code>Other</code> </p> </li>
        /// </ul>
        pub fn industry_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.industry_type = Some(input.into());
            self
        }
        /// <p>The industry type for the workload.</p>
        /// <p>If specified, must be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>Agriculture</code> </p> </li>
        /// <li> <p> <code>Automobile</code> </p> </li>
        /// <li> <p> <code>Defense</code> </p> </li>
        /// <li> <p> <code>Design and Engineering</code> </p> </li>
        /// <li> <p> <code>Digital Advertising</code> </p> </li>
        /// <li> <p> <code>Education</code> </p> </li>
        /// <li> <p> <code>Environmental Protection</code> </p> </li>
        /// <li> <p> <code>Financial Services</code> </p> </li>
        /// <li> <p> <code>Gaming</code> </p> </li>
        /// <li> <p> <code>General Public Services</code> </p> </li>
        /// <li> <p> <code>Healthcare</code> </p> </li>
        /// <li> <p> <code>Hospitality</code> </p> </li>
        /// <li> <p> <code>InfoTech</code> </p> </li>
        /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
        /// <li> <p> <code>Life Sciences</code> </p> </li>
        /// <li> <p> <code>Manufacturing</code> </p> </li>
        /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
        /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
        /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
        /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
        /// <li> <p> <code>Professional Services</code> </p> </li>
        /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
        /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
        /// <li> <p> <code>Social Protection</code> </p> </li>
        /// <li> <p> <code>Telecommunications</code> </p> </li>
        /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
        /// <li> <p> <code>Other</code> </p> </li>
        /// </ul>
        pub fn set_industry_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.industry_type = input;
            self
        }
        /// <p>The industry for the workload.</p>
        pub fn industry(mut self, input: impl Into<std::string::String>) -> Self {
            self.industry = Some(input.into());
            self
        }
        /// <p>The industry for the workload.</p>
        pub fn set_industry(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.industry = input;
            self
        }
        /// Appends an item to `lenses`.
        ///
        /// To override the contents of this collection use [`set_lenses`](Self::set_lenses).
        ///
        /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lenses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.lenses.unwrap_or_default();
            v.push(input.into());
            self.lenses = Some(v);
            self
        }
        /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lenses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.lenses = input;
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.notes = Some(input.into());
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn set_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notes = input;
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to be associated with the workload.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags to be associated with the workload.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateWorkloadInput`](crate::input::CreateWorkloadInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateWorkloadInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateWorkloadInput {
                workload_name: self.workload_name,
                description: self.description,
                environment: self.environment,
                account_ids: self.account_ids,
                aws_regions: self.aws_regions,
                non_aws_regions: self.non_aws_regions,
                pillar_priorities: self.pillar_priorities,
                architectural_design: self.architectural_design,
                review_owner: self.review_owner,
                industry_type: self.industry_type,
                industry: self.industry,
                lenses: self.lenses,
                notes: self.notes,
                client_request_token: self.client_request_token,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateWorkloadInputOperationOutputAlias = crate::operation::CreateWorkload;
#[doc(hidden)]
pub type CreateWorkloadInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateWorkloadInput {
    /// Consumes the builder and constructs an Operation<[`CreateWorkload`](crate::operation::CreateWorkload)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateWorkload,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateWorkloadInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/workloads").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateWorkloadInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_workload(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateWorkload::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateWorkload",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateWorkloadInput`](crate::input::CreateWorkloadInput)
    pub fn builder() -> crate::input::create_workload_input::Builder {
        crate::input::create_workload_input::Builder::default()
    }
}

/// See [`CreateWorkloadShareInput`](crate::input::CreateWorkloadShareInput)
pub mod create_workload_share_input {

    /// A builder for [`CreateWorkloadShareInput`](crate::input::CreateWorkloadShareInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) shared_with: std::option::Option<std::string::String>,
        pub(crate) permission_type: std::option::Option<crate::model::PermissionType>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
        pub fn shared_with(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_with = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
        pub fn set_shared_with(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.shared_with = input;
            self
        }
        /// <p>Permission granted on a workload share.</p>
        pub fn permission_type(mut self, input: crate::model::PermissionType) -> Self {
            self.permission_type = Some(input);
            self
        }
        /// <p>Permission granted on a workload share.</p>
        pub fn set_permission_type(
            mut self,
            input: std::option::Option<crate::model::PermissionType>,
        ) -> Self {
            self.permission_type = input;
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateWorkloadShareInput`](crate::input::CreateWorkloadShareInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateWorkloadShareInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateWorkloadShareInput {
                workload_id: self.workload_id,
                shared_with: self.shared_with,
                permission_type: self.permission_type,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateWorkloadShareInputOperationOutputAlias = crate::operation::CreateWorkloadShare;
#[doc(hidden)]
pub type CreateWorkloadShareInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateWorkloadShareInput {
    /// Consumes the builder and constructs an Operation<[`CreateWorkloadShare`](crate::operation::CreateWorkloadShare)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateWorkloadShare,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateWorkloadShareInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_5 = &_input.workload_id;
                let input_5 = input_5.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_5, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/shares",
                    WorkloadId = workload_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateWorkloadShareInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_workload_share(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateWorkloadShare::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateWorkloadShare",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateWorkloadShareInput`](crate::input::CreateWorkloadShareInput)
    pub fn builder() -> crate::input::create_workload_share_input::Builder {
        crate::input::create_workload_share_input::Builder::default()
    }
}

/// See [`DeleteLensInput`](crate::input::DeleteLensInput)
pub mod delete_lens_input {

    /// A builder for [`DeleteLensInput`](crate::input::DeleteLensInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) lens_status: std::option::Option<crate::model::LensStatusType>,
    }
    impl Builder {
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The status of the lens to be deleted.</p>
        pub fn lens_status(mut self, input: crate::model::LensStatusType) -> Self {
            self.lens_status = Some(input);
            self
        }
        /// <p>The status of the lens to be deleted.</p>
        pub fn set_lens_status(
            mut self,
            input: std::option::Option<crate::model::LensStatusType>,
        ) -> Self {
            self.lens_status = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLensInput`](crate::input::DeleteLensInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteLensInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteLensInput {
                lens_alias: self.lens_alias,
                client_request_token: self.client_request_token,
                lens_status: self.lens_status,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteLensInputOperationOutputAlias = crate::operation::DeleteLens;
#[doc(hidden)]
pub type DeleteLensInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteLensInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLens`](crate::operation::DeleteLens)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteLens,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteLensInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_6 = &_input.lens_alias;
                let input_6 = input_6.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_6, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/lenses/{LensAlias}", LensAlias = lens_alias)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteLensInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_7) = &_input.client_request_token {
                    query.push_kv(
                        "ClientRequestToken",
                        &aws_smithy_http::query::fmt_string(&inner_7),
                    );
                }
                if let Some(inner_8) = &_input.lens_status {
                    query.push_kv("LensStatus", &aws_smithy_http::query::fmt_string(&inner_8));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteLensInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteLens::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteLens",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteLensInput`](crate::input::DeleteLensInput)
    pub fn builder() -> crate::input::delete_lens_input::Builder {
        crate::input::delete_lens_input::Builder::default()
    }
}

/// See [`DeleteLensShareInput`](crate::input::DeleteLensShareInput)
pub mod delete_lens_share_input {

    /// A builder for [`DeleteLensShareInput`](crate::input::DeleteLensShareInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) share_id: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID associated with the workload share.</p>
        pub fn share_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_id = Some(input.into());
            self
        }
        /// <p>The ID associated with the workload share.</p>
        pub fn set_share_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.share_id = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLensShareInput`](crate::input::DeleteLensShareInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteLensShareInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteLensShareInput {
                share_id: self.share_id,
                lens_alias: self.lens_alias,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteLensShareInputOperationOutputAlias = crate::operation::DeleteLensShare;
#[doc(hidden)]
pub type DeleteLensShareInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteLensShareInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLensShare`](crate::operation::DeleteLensShare)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteLensShare,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteLensShareInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_9 = &_input.lens_alias;
                let input_9 = input_9.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_9, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                let input_10 = &_input.share_id;
                let input_10 = input_10.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "share_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let share_id = aws_smithy_http::label::fmt_string(input_10, false);
                if share_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "share_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/lenses/{LensAlias}/shares/{ShareId}",
                    LensAlias = lens_alias,
                    ShareId = share_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteLensShareInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_11) = &_input.client_request_token {
                    query.push_kv(
                        "ClientRequestToken",
                        &aws_smithy_http::query::fmt_string(&inner_11),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteLensShareInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteLensShare::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteLensShare",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteLensShareInput`](crate::input::DeleteLensShareInput)
    pub fn builder() -> crate::input::delete_lens_share_input::Builder {
        crate::input::delete_lens_share_input::Builder::default()
    }
}

/// See [`DeleteWorkloadInput`](crate::input::DeleteWorkloadInput)
pub mod delete_workload_input {

    /// A builder for [`DeleteWorkloadInput`](crate::input::DeleteWorkloadInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteWorkloadInput`](crate::input::DeleteWorkloadInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteWorkloadInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteWorkloadInput {
                workload_id: self.workload_id,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteWorkloadInputOperationOutputAlias = crate::operation::DeleteWorkload;
#[doc(hidden)]
pub type DeleteWorkloadInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteWorkloadInput {
    /// Consumes the builder and constructs an Operation<[`DeleteWorkload`](crate::operation::DeleteWorkload)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteWorkload,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteWorkloadInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_12 = &_input.workload_id;
                let input_12 = input_12.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_12, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/workloads/{WorkloadId}", WorkloadId = workload_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteWorkloadInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_13) = &_input.client_request_token {
                    query.push_kv(
                        "ClientRequestToken",
                        &aws_smithy_http::query::fmt_string(&inner_13),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteWorkloadInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteWorkload::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteWorkload",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteWorkloadInput`](crate::input::DeleteWorkloadInput)
    pub fn builder() -> crate::input::delete_workload_input::Builder {
        crate::input::delete_workload_input::Builder::default()
    }
}

/// See [`DeleteWorkloadShareInput`](crate::input::DeleteWorkloadShareInput)
pub mod delete_workload_share_input {

    /// A builder for [`DeleteWorkloadShareInput`](crate::input::DeleteWorkloadShareInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) share_id: std::option::Option<std::string::String>,
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID associated with the workload share.</p>
        pub fn share_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_id = Some(input.into());
            self
        }
        /// <p>The ID associated with the workload share.</p>
        pub fn set_share_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.share_id = input;
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteWorkloadShareInput`](crate::input::DeleteWorkloadShareInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteWorkloadShareInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteWorkloadShareInput {
                share_id: self.share_id,
                workload_id: self.workload_id,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteWorkloadShareInputOperationOutputAlias = crate::operation::DeleteWorkloadShare;
#[doc(hidden)]
pub type DeleteWorkloadShareInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteWorkloadShareInput {
    /// Consumes the builder and constructs an Operation<[`DeleteWorkloadShare`](crate::operation::DeleteWorkloadShare)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteWorkloadShare,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteWorkloadShareInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_14 = &_input.workload_id;
                let input_14 = input_14.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_14, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_15 = &_input.share_id;
                let input_15 = input_15.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "share_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let share_id = aws_smithy_http::label::fmt_string(input_15, false);
                if share_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "share_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/shares/{ShareId}",
                    WorkloadId = workload_id,
                    ShareId = share_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteWorkloadShareInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_16) = &_input.client_request_token {
                    query.push_kv(
                        "ClientRequestToken",
                        &aws_smithy_http::query::fmt_string(&inner_16),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteWorkloadShareInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteWorkloadShare::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteWorkloadShare",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteWorkloadShareInput`](crate::input::DeleteWorkloadShareInput)
    pub fn builder() -> crate::input::delete_workload_share_input::Builder {
        crate::input::delete_workload_share_input::Builder::default()
    }
}

/// See [`DisassociateLensesInput`](crate::input::DisassociateLensesInput)
pub mod disassociate_lenses_input {

    /// A builder for [`DisassociateLensesInput`](crate::input::DisassociateLensesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_aliases: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// Appends an item to `lens_aliases`.
        ///
        /// To override the contents of this collection use [`set_lens_aliases`](Self::set_lens_aliases).
        ///
        /// <p>List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified.</p>
        /// <p>Identify a lens using its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_aliases(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.lens_aliases.unwrap_or_default();
            v.push(input.into());
            self.lens_aliases = Some(v);
            self
        }
        /// <p>List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified.</p>
        /// <p>Identify a lens using its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_aliases(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.lens_aliases = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateLensesInput`](crate::input::DisassociateLensesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateLensesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociateLensesInput {
                workload_id: self.workload_id,
                lens_aliases: self.lens_aliases,
            })
        }
    }
}
#[doc(hidden)]
pub type DisassociateLensesInputOperationOutputAlias = crate::operation::DisassociateLenses;
#[doc(hidden)]
pub type DisassociateLensesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DisassociateLensesInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateLenses`](crate::operation::DisassociateLenses)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateLenses,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateLensesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_17 = &_input.workload_id;
                let input_17 = input_17.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_17, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/disassociateLenses",
                    WorkloadId = workload_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateLensesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_disassociate_lenses(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateLenses::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateLenses",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisassociateLensesInput`](crate::input::DisassociateLensesInput)
    pub fn builder() -> crate::input::disassociate_lenses_input::Builder {
        crate::input::disassociate_lenses_input::Builder::default()
    }
}

/// See [`ExportLensInput`](crate::input::ExportLensInput)
pub mod export_lens_input {

    /// A builder for [`ExportLensInput`](crate::input::ExportLensInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) lens_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The lens version to be exported.</p>
        pub fn lens_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_version = Some(input.into());
            self
        }
        /// <p>The lens version to be exported.</p>
        pub fn set_lens_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_version = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportLensInput`](crate::input::ExportLensInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ExportLensInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ExportLensInput {
                lens_alias: self.lens_alias,
                lens_version: self.lens_version,
            })
        }
    }
}
#[doc(hidden)]
pub type ExportLensInputOperationOutputAlias = crate::operation::ExportLens;
#[doc(hidden)]
pub type ExportLensInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ExportLensInput {
    /// Consumes the builder and constructs an Operation<[`ExportLens`](crate::operation::ExportLens)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ExportLens,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ExportLensInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_18 = &_input.lens_alias;
                let input_18 = input_18.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_18, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/lenses/{LensAlias}/export", LensAlias = lens_alias)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ExportLensInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_19) = &_input.lens_version {
                    query.push_kv(
                        "LensVersion",
                        &aws_smithy_http::query::fmt_string(&inner_19),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ExportLensInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ExportLens::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ExportLens",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ExportLensInput`](crate::input::ExportLensInput)
    pub fn builder() -> crate::input::export_lens_input::Builder {
        crate::input::export_lens_input::Builder::default()
    }
}

/// See [`GetAnswerInput`](crate::input::GetAnswerInput)
pub mod get_answer_input {

    /// A builder for [`GetAnswerInput`](crate::input::GetAnswerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) question_id: std::option::Option<std::string::String>,
        pub(crate) milestone_number: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The ID of the question.</p>
        pub fn question_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_id = Some(input.into());
            self
        }
        /// <p>The ID of the question.</p>
        pub fn set_question_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.question_id = input;
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn milestone_number(mut self, input: i32) -> Self {
            self.milestone_number = Some(input);
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn set_milestone_number(mut self, input: std::option::Option<i32>) -> Self {
            self.milestone_number = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAnswerInput`](crate::input::GetAnswerInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetAnswerInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetAnswerInput {
                workload_id: self.workload_id,
                lens_alias: self.lens_alias,
                question_id: self.question_id,
                milestone_number: self.milestone_number.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type GetAnswerInputOperationOutputAlias = crate::operation::GetAnswer;
#[doc(hidden)]
pub type GetAnswerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetAnswerInput {
    /// Consumes the builder and constructs an Operation<[`GetAnswer`](crate::operation::GetAnswer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAnswer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAnswerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_20 = &_input.workload_id;
                let input_20 = input_20.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_20, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_21 = &_input.lens_alias;
                let input_21 = input_21.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_21, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                let input_22 = &_input.question_id;
                let input_22 = input_22.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "question_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let question_id = aws_smithy_http::label::fmt_string(input_22, false);
                if question_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "question_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/lensReviews/{LensAlias}/answers/{QuestionId}",
                    WorkloadId = workload_id,
                    LensAlias = lens_alias,
                    QuestionId = question_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetAnswerInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.milestone_number != 0 {
                    query.push_kv(
                        "MilestoneNumber",
                        aws_smithy_types::primitive::Encoder::from(_input.milestone_number)
                            .encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAnswerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetAnswer::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetAnswer",
                    "wellarchitected",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAnswerInput`](crate::input::GetAnswerInput)
    pub fn builder() -> crate::input::get_answer_input::Builder {
        crate::input::get_answer_input::Builder::default()
    }
}

/// See [`GetLensInput`](crate::input::GetLensInput)
pub mod get_lens_input {

    /// A builder for [`GetLensInput`](crate::input::GetLensInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) lens_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The lens version to be retrieved.</p>
        pub fn lens_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_version = Some(input.into());
            self
        }
        /// <p>The lens version to be retrieved.</p>
        pub fn set_lens_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_version = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLensInput`](crate::input::GetLensInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetLensInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetLensInput {
                lens_alias: self.lens_alias,
                lens_version: self.lens_version,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLensInputOperationOutputAlias = crate::operation::GetLens;
#[doc(hidden)]
pub type GetLensInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetLensInput {
    /// Consumes the builder and constructs an Operation<[`GetLens`](crate::operation::GetLens)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLens,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetLensInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_23 = &_input.lens_alias;
                let input_23 = input_23.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_23, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/lenses/{LensAlias}", LensAlias = lens_alias)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetLensInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_24) = &_input.lens_version {
                    query.push_kv(
                        "LensVersion",
                        &aws_smithy_http::query::fmt_string(&inner_24),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetLensInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetLens::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetLens",
                    "wellarchitected",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetLensInput`](crate::input::GetLensInput)
    pub fn builder() -> crate::input::get_lens_input::Builder {
        crate::input::get_lens_input::Builder::default()
    }
}

/// See [`GetLensReviewInput`](crate::input::GetLensReviewInput)
pub mod get_lens_review_input {

    /// A builder for [`GetLensReviewInput`](crate::input::GetLensReviewInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) milestone_number: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn milestone_number(mut self, input: i32) -> Self {
            self.milestone_number = Some(input);
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn set_milestone_number(mut self, input: std::option::Option<i32>) -> Self {
            self.milestone_number = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLensReviewInput`](crate::input::GetLensReviewInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLensReviewInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLensReviewInput {
                workload_id: self.workload_id,
                lens_alias: self.lens_alias,
                milestone_number: self.milestone_number.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type GetLensReviewInputOperationOutputAlias = crate::operation::GetLensReview;
#[doc(hidden)]
pub type GetLensReviewInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetLensReviewInput {
    /// Consumes the builder and constructs an Operation<[`GetLensReview`](crate::operation::GetLensReview)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLensReview,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetLensReviewInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_25 = &_input.workload_id;
                let input_25 = input_25.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_25, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_26 = &_input.lens_alias;
                let input_26 = input_26.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_26, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/lensReviews/{LensAlias}",
                    WorkloadId = workload_id,
                    LensAlias = lens_alias
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetLensReviewInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.milestone_number != 0 {
                    query.push_kv(
                        "MilestoneNumber",
                        aws_smithy_types::primitive::Encoder::from(_input.milestone_number)
                            .encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetLensReviewInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLensReview::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLensReview",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetLensReviewInput`](crate::input::GetLensReviewInput)
    pub fn builder() -> crate::input::get_lens_review_input::Builder {
        crate::input::get_lens_review_input::Builder::default()
    }
}

/// See [`GetLensReviewReportInput`](crate::input::GetLensReviewReportInput)
pub mod get_lens_review_report_input {

    /// A builder for [`GetLensReviewReportInput`](crate::input::GetLensReviewReportInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) milestone_number: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn milestone_number(mut self, input: i32) -> Self {
            self.milestone_number = Some(input);
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn set_milestone_number(mut self, input: std::option::Option<i32>) -> Self {
            self.milestone_number = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLensReviewReportInput`](crate::input::GetLensReviewReportInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLensReviewReportInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLensReviewReportInput {
                workload_id: self.workload_id,
                lens_alias: self.lens_alias,
                milestone_number: self.milestone_number.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type GetLensReviewReportInputOperationOutputAlias = crate::operation::GetLensReviewReport;
#[doc(hidden)]
pub type GetLensReviewReportInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetLensReviewReportInput {
    /// Consumes the builder and constructs an Operation<[`GetLensReviewReport`](crate::operation::GetLensReviewReport)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLensReviewReport,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetLensReviewReportInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_27 = &_input.workload_id;
                let input_27 = input_27.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_27, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_28 = &_input.lens_alias;
                let input_28 = input_28.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_28, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/lensReviews/{LensAlias}/report",
                    WorkloadId = workload_id,
                    LensAlias = lens_alias
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetLensReviewReportInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.milestone_number != 0 {
                    query.push_kv(
                        "MilestoneNumber",
                        aws_smithy_types::primitive::Encoder::from(_input.milestone_number)
                            .encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetLensReviewReportInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLensReviewReport::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLensReviewReport",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetLensReviewReportInput`](crate::input::GetLensReviewReportInput)
    pub fn builder() -> crate::input::get_lens_review_report_input::Builder {
        crate::input::get_lens_review_report_input::Builder::default()
    }
}

/// See [`GetLensVersionDifferenceInput`](crate::input::GetLensVersionDifferenceInput)
pub mod get_lens_version_difference_input {

    /// A builder for [`GetLensVersionDifferenceInput`](crate::input::GetLensVersionDifferenceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) base_lens_version: std::option::Option<std::string::String>,
        pub(crate) target_lens_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The base version of the lens.</p>
        pub fn base_lens_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.base_lens_version = Some(input.into());
            self
        }
        /// <p>The base version of the lens.</p>
        pub fn set_base_lens_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.base_lens_version = input;
            self
        }
        /// <p>The lens version to target a difference for.</p>
        pub fn target_lens_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_lens_version = Some(input.into());
            self
        }
        /// <p>The lens version to target a difference for.</p>
        pub fn set_target_lens_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_lens_version = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLensVersionDifferenceInput`](crate::input::GetLensVersionDifferenceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLensVersionDifferenceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLensVersionDifferenceInput {
                lens_alias: self.lens_alias,
                base_lens_version: self.base_lens_version,
                target_lens_version: self.target_lens_version,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLensVersionDifferenceInputOperationOutputAlias =
    crate::operation::GetLensVersionDifference;
#[doc(hidden)]
pub type GetLensVersionDifferenceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetLensVersionDifferenceInput {
    /// Consumes the builder and constructs an Operation<[`GetLensVersionDifference`](crate::operation::GetLensVersionDifference)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLensVersionDifference,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetLensVersionDifferenceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_29 = &_input.lens_alias;
                let input_29 = input_29.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_29, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/lenses/{LensAlias}/versionDifference",
                    LensAlias = lens_alias
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetLensVersionDifferenceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_30) = &_input.base_lens_version {
                    query.push_kv(
                        "BaseLensVersion",
                        &aws_smithy_http::query::fmt_string(&inner_30),
                    );
                }
                if let Some(inner_31) = &_input.target_lens_version {
                    query.push_kv(
                        "TargetLensVersion",
                        &aws_smithy_http::query::fmt_string(&inner_31),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetLensVersionDifferenceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLensVersionDifference::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLensVersionDifference",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetLensVersionDifferenceInput`](crate::input::GetLensVersionDifferenceInput)
    pub fn builder() -> crate::input::get_lens_version_difference_input::Builder {
        crate::input::get_lens_version_difference_input::Builder::default()
    }
}

/// See [`GetMilestoneInput`](crate::input::GetMilestoneInput)
pub mod get_milestone_input {

    /// A builder for [`GetMilestoneInput`](crate::input::GetMilestoneInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) milestone_number: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn milestone_number(mut self, input: i32) -> Self {
            self.milestone_number = Some(input);
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn set_milestone_number(mut self, input: std::option::Option<i32>) -> Self {
            self.milestone_number = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMilestoneInput`](crate::input::GetMilestoneInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetMilestoneInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetMilestoneInput {
                workload_id: self.workload_id,
                milestone_number: self.milestone_number.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type GetMilestoneInputOperationOutputAlias = crate::operation::GetMilestone;
#[doc(hidden)]
pub type GetMilestoneInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetMilestoneInput {
    /// Consumes the builder and constructs an Operation<[`GetMilestone`](crate::operation::GetMilestone)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetMilestone,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetMilestoneInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_32 = &_input.workload_id;
                let input_32 = input_32.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_32, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_33 = &_input.milestone_number;
                let mut milestone_number_encoder =
                    aws_smithy_types::primitive::Encoder::from(*input_33);
                let milestone_number = milestone_number_encoder.encode();
                if milestone_number.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "milestone_number",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/milestones/{MilestoneNumber}",
                    WorkloadId = workload_id,
                    MilestoneNumber = milestone_number
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetMilestoneInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMilestone::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetMilestone",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetMilestoneInput`](crate::input::GetMilestoneInput)
    pub fn builder() -> crate::input::get_milestone_input::Builder {
        crate::input::get_milestone_input::Builder::default()
    }
}

/// See [`GetWorkloadInput`](crate::input::GetWorkloadInput)
pub mod get_workload_input {

    /// A builder for [`GetWorkloadInput`](crate::input::GetWorkloadInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetWorkloadInput`](crate::input::GetWorkloadInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetWorkloadInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetWorkloadInput {
                workload_id: self.workload_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetWorkloadInputOperationOutputAlias = crate::operation::GetWorkload;
#[doc(hidden)]
pub type GetWorkloadInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetWorkloadInput {
    /// Consumes the builder and constructs an Operation<[`GetWorkload`](crate::operation::GetWorkload)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetWorkload,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetWorkloadInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_34 = &_input.workload_id;
                let input_34 = input_34.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_34, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/workloads/{WorkloadId}", WorkloadId = workload_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetWorkloadInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetWorkload::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetWorkload",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetWorkloadInput`](crate::input::GetWorkloadInput)
    pub fn builder() -> crate::input::get_workload_input::Builder {
        crate::input::get_workload_input::Builder::default()
    }
}

/// See [`ImportLensInput`](crate::input::ImportLensInput)
pub mod import_lens_input {

    /// A builder for [`ImportLensInput`](crate::input::ImportLensInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) json_string: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The JSON representation of a lens.</p>
        pub fn json_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.json_string = Some(input.into());
            self
        }
        /// <p>The JSON representation of a lens.</p>
        pub fn set_json_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.json_string = input;
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags to associate to a lens.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Tags to associate to a lens.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportLensInput`](crate::input::ImportLensInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ImportLensInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ImportLensInput {
                lens_alias: self.lens_alias,
                json_string: self.json_string,
                client_request_token: self.client_request_token,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type ImportLensInputOperationOutputAlias = crate::operation::ImportLens;
#[doc(hidden)]
pub type ImportLensInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ImportLensInput {
    /// Consumes the builder and constructs an Operation<[`ImportLens`](crate::operation::ImportLens)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ImportLens,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::ImportLensInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/importLens").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ImportLensInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_import_lens(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ImportLens::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ImportLens",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ImportLensInput`](crate::input::ImportLensInput)
    pub fn builder() -> crate::input::import_lens_input::Builder {
        crate::input::import_lens_input::Builder::default()
    }
}

/// See [`ListAnswersInput`](crate::input::ListAnswersInput)
pub mod list_answers_input {

    /// A builder for [`ListAnswersInput`](crate::input::ListAnswersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) pillar_id: std::option::Option<std::string::String>,
        pub(crate) milestone_number: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pillar_id = Some(input.into());
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pillar_id = input;
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn milestone_number(mut self, input: i32) -> Self {
            self.milestone_number = Some(input);
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn set_milestone_number(mut self, input: std::option::Option<i32>) -> Self {
            self.milestone_number = input;
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAnswersInput`](crate::input::ListAnswersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAnswersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAnswersInput {
                workload_id: self.workload_id,
                lens_alias: self.lens_alias,
                pillar_id: self.pillar_id,
                milestone_number: self.milestone_number.unwrap_or_default(),
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListAnswersInputOperationOutputAlias = crate::operation::ListAnswers;
#[doc(hidden)]
pub type ListAnswersInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAnswersInput {
    /// Consumes the builder and constructs an Operation<[`ListAnswers`](crate::operation::ListAnswers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAnswers,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAnswersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_35 = &_input.workload_id;
                let input_35 = input_35.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_35, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_36 = &_input.lens_alias;
                let input_36 = input_36.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_36, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/lensReviews/{LensAlias}/answers",
                    WorkloadId = workload_id,
                    LensAlias = lens_alias
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAnswersInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_37) = &_input.pillar_id {
                    query.push_kv("PillarId", &aws_smithy_http::query::fmt_string(&inner_37));
                }
                if _input.milestone_number != 0 {
                    query.push_kv(
                        "MilestoneNumber",
                        aws_smithy_types::primitive::Encoder::from(_input.milestone_number)
                            .encode(),
                    );
                }
                if let Some(inner_38) = &_input.next_token {
                    query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_38));
                }
                if _input.max_results != 0 {
                    query.push_kv(
                        "MaxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAnswersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAnswers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAnswers",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAnswersInput`](crate::input::ListAnswersInput)
    pub fn builder() -> crate::input::list_answers_input::Builder {
        crate::input::list_answers_input::Builder::default()
    }
}

/// See [`ListLensesInput`](crate::input::ListLensesInput)
pub mod list_lenses_input {

    /// A builder for [`ListLensesInput`](crate::input::ListLensesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) lens_type: std::option::Option<crate::model::LensType>,
        pub(crate) lens_status: std::option::Option<crate::model::LensStatusType>,
        pub(crate) lens_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The type of lenses to be returned.</p>
        pub fn lens_type(mut self, input: crate::model::LensType) -> Self {
            self.lens_type = Some(input);
            self
        }
        /// <p>The type of lenses to be returned.</p>
        pub fn set_lens_type(mut self, input: std::option::Option<crate::model::LensType>) -> Self {
            self.lens_type = input;
            self
        }
        /// <p>The status of lenses to be returned.</p>
        pub fn lens_status(mut self, input: crate::model::LensStatusType) -> Self {
            self.lens_status = Some(input);
            self
        }
        /// <p>The status of lenses to be returned.</p>
        pub fn set_lens_status(
            mut self,
            input: std::option::Option<crate::model::LensStatusType>,
        ) -> Self {
            self.lens_status = input;
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn lens_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_name = Some(input.into());
            self
        }
        /// <p>The full name of the lens.</p>
        pub fn set_lens_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLensesInput`](crate::input::ListLensesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListLensesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListLensesInput {
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
                lens_type: self.lens_type,
                lens_status: self.lens_status,
                lens_name: self.lens_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ListLensesInputOperationOutputAlias = crate::operation::ListLenses;
#[doc(hidden)]
pub type ListLensesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListLensesInput {
    /// Consumes the builder and constructs an Operation<[`ListLenses`](crate::operation::ListLenses)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListLenses,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListLensesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/lenses").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListLensesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_39) = &_input.next_token {
                    query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_39));
                }
                if _input.max_results != 0 {
                    query.push_kv(
                        "MaxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                if let Some(inner_40) = &_input.lens_type {
                    query.push_kv("LensType", &aws_smithy_http::query::fmt_string(&inner_40));
                }
                if let Some(inner_41) = &_input.lens_status {
                    query.push_kv("LensStatus", &aws_smithy_http::query::fmt_string(&inner_41));
                }
                if let Some(inner_42) = &_input.lens_name {
                    query.push_kv("LensName", &aws_smithy_http::query::fmt_string(&inner_42));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListLensesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListLenses::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListLenses",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListLensesInput`](crate::input::ListLensesInput)
    pub fn builder() -> crate::input::list_lenses_input::Builder {
        crate::input::list_lenses_input::Builder::default()
    }
}

/// See [`ListLensReviewImprovementsInput`](crate::input::ListLensReviewImprovementsInput)
pub mod list_lens_review_improvements_input {

    /// A builder for [`ListLensReviewImprovementsInput`](crate::input::ListLensReviewImprovementsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) pillar_id: std::option::Option<std::string::String>,
        pub(crate) milestone_number: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pillar_id = Some(input.into());
            self
        }
        /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
        /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pillar_id = input;
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn milestone_number(mut self, input: i32) -> Self {
            self.milestone_number = Some(input);
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn set_milestone_number(mut self, input: std::option::Option<i32>) -> Self {
            self.milestone_number = input;
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLensReviewImprovementsInput`](crate::input::ListLensReviewImprovementsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListLensReviewImprovementsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListLensReviewImprovementsInput {
                workload_id: self.workload_id,
                lens_alias: self.lens_alias,
                pillar_id: self.pillar_id,
                milestone_number: self.milestone_number.unwrap_or_default(),
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListLensReviewImprovementsInputOperationOutputAlias =
    crate::operation::ListLensReviewImprovements;
#[doc(hidden)]
pub type ListLensReviewImprovementsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListLensReviewImprovementsInput {
    /// Consumes the builder and constructs an Operation<[`ListLensReviewImprovements`](crate::operation::ListLensReviewImprovements)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListLensReviewImprovements,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListLensReviewImprovementsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_43 = &_input.workload_id;
                let input_43 = input_43.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_43, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_44 = &_input.lens_alias;
                let input_44 = input_44.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_44, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/lensReviews/{LensAlias}/improvements",
                    WorkloadId = workload_id,
                    LensAlias = lens_alias
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListLensReviewImprovementsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_45) = &_input.pillar_id {
                    query.push_kv("PillarId", &aws_smithy_http::query::fmt_string(&inner_45));
                }
                if _input.milestone_number != 0 {
                    query.push_kv(
                        "MilestoneNumber",
                        aws_smithy_types::primitive::Encoder::from(_input.milestone_number)
                            .encode(),
                    );
                }
                if let Some(inner_46) = &_input.next_token {
                    query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_46));
                }
                if _input.max_results != 0 {
                    query.push_kv(
                        "MaxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListLensReviewImprovementsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListLensReviewImprovements::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListLensReviewImprovements",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListLensReviewImprovementsInput`](crate::input::ListLensReviewImprovementsInput)
    pub fn builder() -> crate::input::list_lens_review_improvements_input::Builder {
        crate::input::list_lens_review_improvements_input::Builder::default()
    }
}

/// See [`ListLensReviewsInput`](crate::input::ListLensReviewsInput)
pub mod list_lens_reviews_input {

    /// A builder for [`ListLensReviewsInput`](crate::input::ListLensReviewsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) milestone_number: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn milestone_number(mut self, input: i32) -> Self {
            self.milestone_number = Some(input);
            self
        }
        /// <p>The milestone number.</p>
        /// <p>A workload can have a maximum of 100 milestones.</p>
        pub fn set_milestone_number(mut self, input: std::option::Option<i32>) -> Self {
            self.milestone_number = input;
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLensReviewsInput`](crate::input::ListLensReviewsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListLensReviewsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListLensReviewsInput {
                workload_id: self.workload_id,
                milestone_number: self.milestone_number.unwrap_or_default(),
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListLensReviewsInputOperationOutputAlias = crate::operation::ListLensReviews;
#[doc(hidden)]
pub type ListLensReviewsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListLensReviewsInput {
    /// Consumes the builder and constructs an Operation<[`ListLensReviews`](crate::operation::ListLensReviews)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListLensReviews,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListLensReviewsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_47 = &_input.workload_id;
                let input_47 = input_47.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_47, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/lensReviews",
                    WorkloadId = workload_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListLensReviewsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.milestone_number != 0 {
                    query.push_kv(
                        "MilestoneNumber",
                        aws_smithy_types::primitive::Encoder::from(_input.milestone_number)
                            .encode(),
                    );
                }
                if let Some(inner_48) = &_input.next_token {
                    query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_48));
                }
                if _input.max_results != 0 {
                    query.push_kv(
                        "MaxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListLensReviewsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListLensReviews::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListLensReviews",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListLensReviewsInput`](crate::input::ListLensReviewsInput)
    pub fn builder() -> crate::input::list_lens_reviews_input::Builder {
        crate::input::list_lens_reviews_input::Builder::default()
    }
}

/// See [`ListLensSharesInput`](crate::input::ListLensSharesInput)
pub mod list_lens_shares_input {

    /// A builder for [`ListLensSharesInput`](crate::input::ListLensSharesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) shared_with_prefix: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The Amazon Web Services account ID or IAM role with which the lens is shared.</p>
        pub fn shared_with_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_with_prefix = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID or IAM role with which the lens is shared.</p>
        pub fn set_shared_with_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.shared_with_prefix = input;
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLensSharesInput`](crate::input::ListLensSharesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListLensSharesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListLensSharesInput {
                lens_alias: self.lens_alias,
                shared_with_prefix: self.shared_with_prefix,
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListLensSharesInputOperationOutputAlias = crate::operation::ListLensShares;
#[doc(hidden)]
pub type ListLensSharesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListLensSharesInput {
    /// Consumes the builder and constructs an Operation<[`ListLensShares`](crate::operation::ListLensShares)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListLensShares,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListLensSharesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_49 = &_input.lens_alias;
                let input_49 = input_49.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_49, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/lenses/{LensAlias}/shares", LensAlias = lens_alias)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListLensSharesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_50) = &_input.shared_with_prefix {
                    query.push_kv(
                        "SharedWithPrefix",
                        &aws_smithy_http::query::fmt_string(&inner_50),
                    );
                }
                if let Some(inner_51) = &_input.next_token {
                    query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_51));
                }
                if _input.max_results != 0 {
                    query.push_kv(
                        "MaxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListLensSharesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListLensShares::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListLensShares",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListLensSharesInput`](crate::input::ListLensSharesInput)
    pub fn builder() -> crate::input::list_lens_shares_input::Builder {
        crate::input::list_lens_shares_input::Builder::default()
    }
}

/// See [`ListMilestonesInput`](crate::input::ListMilestonesInput)
pub mod list_milestones_input {

    /// A builder for [`ListMilestonesInput`](crate::input::ListMilestonesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMilestonesInput`](crate::input::ListMilestonesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMilestonesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMilestonesInput {
                workload_id: self.workload_id,
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListMilestonesInputOperationOutputAlias = crate::operation::ListMilestones;
#[doc(hidden)]
pub type ListMilestonesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListMilestonesInput {
    /// Consumes the builder and constructs an Operation<[`ListMilestones`](crate::operation::ListMilestones)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListMilestones,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListMilestonesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_52 = &_input.workload_id;
                let input_52 = input_52.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_52, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/milestonesSummaries",
                    WorkloadId = workload_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListMilestonesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_milestones(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListMilestones::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListMilestones",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListMilestonesInput`](crate::input::ListMilestonesInput)
    pub fn builder() -> crate::input::list_milestones_input::Builder {
        crate::input::list_milestones_input::Builder::default()
    }
}

/// See [`ListNotificationsInput`](crate::input::ListNotificationsInput)
pub mod list_notifications_input {

    /// A builder for [`ListNotificationsInput`](crate::input::ListNotificationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListNotificationsInput`](crate::input::ListNotificationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListNotificationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListNotificationsInput {
                workload_id: self.workload_id,
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListNotificationsInputOperationOutputAlias = crate::operation::ListNotifications;
#[doc(hidden)]
pub type ListNotificationsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListNotificationsInput {
    /// Consumes the builder and constructs an Operation<[`ListNotifications`](crate::operation::ListNotifications)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListNotifications,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListNotificationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/notifications").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListNotificationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_notifications(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListNotifications::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListNotifications",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListNotificationsInput`](crate::input::ListNotificationsInput)
    pub fn builder() -> crate::input::list_notifications_input::Builder {
        crate::input::list_notifications_input::Builder::default()
    }
}

/// See [`ListShareInvitationsInput`](crate::input::ListShareInvitationsInput)
pub mod list_share_invitations_input {

    /// A builder for [`ListShareInvitationsInput`](crate::input::ListShareInvitationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_name_prefix: std::option::Option<std::string::String>,
        pub(crate) lens_name_prefix: std::option::Option<std::string::String>,
        pub(crate) share_resource_type: std::option::Option<crate::model::ShareResourceType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>An optional string added to the beginning of each workload name returned in the results.</p>
        pub fn workload_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_name_prefix = Some(input.into());
            self
        }
        /// <p>An optional string added to the beginning of each workload name returned in the results.</p>
        pub fn set_workload_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workload_name_prefix = input;
            self
        }
        /// <p>An optional string added to the beginning of each lens name returned in the results.</p>
        pub fn lens_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_name_prefix = Some(input.into());
            self
        }
        /// <p>An optional string added to the beginning of each lens name returned in the results.</p>
        pub fn set_lens_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lens_name_prefix = input;
            self
        }
        /// <p>The type of share invitations to be returned.</p>
        pub fn share_resource_type(mut self, input: crate::model::ShareResourceType) -> Self {
            self.share_resource_type = Some(input);
            self
        }
        /// <p>The type of share invitations to be returned.</p>
        pub fn set_share_resource_type(
            mut self,
            input: std::option::Option<crate::model::ShareResourceType>,
        ) -> Self {
            self.share_resource_type = input;
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListShareInvitationsInput`](crate::input::ListShareInvitationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListShareInvitationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListShareInvitationsInput {
                workload_name_prefix: self.workload_name_prefix,
                lens_name_prefix: self.lens_name_prefix,
                share_resource_type: self.share_resource_type,
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListShareInvitationsInputOperationOutputAlias = crate::operation::ListShareInvitations;
#[doc(hidden)]
pub type ListShareInvitationsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListShareInvitationsInput {
    /// Consumes the builder and constructs an Operation<[`ListShareInvitations`](crate::operation::ListShareInvitations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListShareInvitations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListShareInvitationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/shareInvitations").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListShareInvitationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_53) = &_input.workload_name_prefix {
                    query.push_kv(
                        "WorkloadNamePrefix",
                        &aws_smithy_http::query::fmt_string(&inner_53),
                    );
                }
                if let Some(inner_54) = &_input.lens_name_prefix {
                    query.push_kv(
                        "LensNamePrefix",
                        &aws_smithy_http::query::fmt_string(&inner_54),
                    );
                }
                if let Some(inner_55) = &_input.share_resource_type {
                    query.push_kv(
                        "ShareResourceType",
                        &aws_smithy_http::query::fmt_string(&inner_55),
                    );
                }
                if let Some(inner_56) = &_input.next_token {
                    query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_56));
                }
                if _input.max_results != 0 {
                    query.push_kv(
                        "MaxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListShareInvitationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListShareInvitations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListShareInvitations",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListShareInvitationsInput`](crate::input::ListShareInvitationsInput)
    pub fn builder() -> crate::input::list_share_invitations_input::Builder {
        crate::input::list_share_invitations_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {

    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN for the workload.</p>
        pub fn workload_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the workload.</p>
        pub fn set_workload_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                workload_arn: self.workload_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTagsForResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_57 = &_input.workload_arn;
                let input_57 = input_57.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_arn = aws_smithy_http::label::fmt_string(input_57, false);
                if workload_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/tags/{WorkloadArn}", WorkloadArn = workload_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTagsForResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListWorkloadsInput`](crate::input::ListWorkloadsInput)
pub mod list_workloads_input {

    /// A builder for [`ListWorkloadsInput`](crate::input::ListWorkloadsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_name_prefix: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>An optional string added to the beginning of each workload name returned in the results.</p>
        pub fn workload_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_name_prefix = Some(input.into());
            self
        }
        /// <p>An optional string added to the beginning of each workload name returned in the results.</p>
        pub fn set_workload_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workload_name_prefix = input;
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListWorkloadsInput`](crate::input::ListWorkloadsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListWorkloadsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListWorkloadsInput {
                workload_name_prefix: self.workload_name_prefix,
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListWorkloadsInputOperationOutputAlias = crate::operation::ListWorkloads;
#[doc(hidden)]
pub type ListWorkloadsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListWorkloadsInput {
    /// Consumes the builder and constructs an Operation<[`ListWorkloads`](crate::operation::ListWorkloads)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListWorkloads,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListWorkloadsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/workloadsSummaries").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListWorkloadsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_workloads(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListWorkloads::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListWorkloads",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListWorkloadsInput`](crate::input::ListWorkloadsInput)
    pub fn builder() -> crate::input::list_workloads_input::Builder {
        crate::input::list_workloads_input::Builder::default()
    }
}

/// See [`ListWorkloadSharesInput`](crate::input::ListWorkloadSharesInput)
pub mod list_workload_shares_input {

    /// A builder for [`ListWorkloadSharesInput`](crate::input::ListWorkloadSharesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) shared_with_prefix: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
        pub fn shared_with_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_with_prefix = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
        pub fn set_shared_with_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.shared_with_prefix = input;
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return for this request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListWorkloadSharesInput`](crate::input::ListWorkloadSharesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListWorkloadSharesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListWorkloadSharesInput {
                workload_id: self.workload_id,
                shared_with_prefix: self.shared_with_prefix,
                next_token: self.next_token,
                max_results: self.max_results.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type ListWorkloadSharesInputOperationOutputAlias = crate::operation::ListWorkloadShares;
#[doc(hidden)]
pub type ListWorkloadSharesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListWorkloadSharesInput {
    /// Consumes the builder and constructs an Operation<[`ListWorkloadShares`](crate::operation::ListWorkloadShares)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListWorkloadShares,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListWorkloadSharesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_58 = &_input.workload_id;
                let input_58 = input_58.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_58, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/shares",
                    WorkloadId = workload_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListWorkloadSharesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_59) = &_input.shared_with_prefix {
                    query.push_kv(
                        "SharedWithPrefix",
                        &aws_smithy_http::query::fmt_string(&inner_59),
                    );
                }
                if let Some(inner_60) = &_input.next_token {
                    query.push_kv("NextToken", &aws_smithy_http::query::fmt_string(&inner_60));
                }
                if _input.max_results != 0 {
                    query.push_kv(
                        "MaxResults",
                        aws_smithy_types::primitive::Encoder::from(_input.max_results).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListWorkloadSharesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListWorkloadShares::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListWorkloadShares",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListWorkloadSharesInput`](crate::input::ListWorkloadSharesInput)
    pub fn builder() -> crate::input::list_workload_shares_input::Builder {
        crate::input::list_workload_shares_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {

    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ARN for the workload.</p>
        pub fn workload_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the workload.</p>
        pub fn set_workload_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags for the resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags for the resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagResourceInput {
                workload_arn: self.workload_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_61 = &_input.workload_arn;
                let input_61 = input_61.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_arn = aws_smithy_http::label::fmt_string(input_61, false);
                if workload_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/tags/{WorkloadArn}", WorkloadArn = workload_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {

    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN for the workload.</p>
        pub fn workload_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the workload.</p>
        pub fn set_workload_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>A list of tag keys. Existing tags of the resource whose keys are members of this list are removed from the resource.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>A list of tag keys. Existing tags of the resource whose keys are members of this list are removed from the resource.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagResourceInput {
                workload_arn: self.workload_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_62 = &_input.workload_arn;
                let input_62 = input_62.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_arn = aws_smithy_http::label::fmt_string(input_62, false);
                if workload_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/tags/{WorkloadArn}", WorkloadArn = workload_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UntagResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_63) = &_input.tag_keys {
                    for inner_64 in inner_63 {
                        query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_64));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateAnswerInput`](crate::input::UpdateAnswerInput)
pub mod update_answer_input {

    /// A builder for [`UpdateAnswerInput`](crate::input::UpdateAnswerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) question_id: std::option::Option<std::string::String>,
        pub(crate) selected_choices: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) choice_updates: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ChoiceUpdate>,
        >,
        pub(crate) notes: std::option::Option<std::string::String>,
        pub(crate) is_applicable: std::option::Option<bool>,
        pub(crate) reason: std::option::Option<crate::model::AnswerReason>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The ID of the question.</p>
        pub fn question_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_id = Some(input.into());
            self
        }
        /// <p>The ID of the question.</p>
        pub fn set_question_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.question_id = input;
            self
        }
        /// Appends an item to `selected_choices`.
        ///
        /// To override the contents of this collection use [`set_selected_choices`](Self::set_selected_choices).
        ///
        /// <p>List of selected choice IDs in a question answer.</p>
        /// <p>The values entered replace the previously selected choices.</p>
        pub fn selected_choices(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.selected_choices.unwrap_or_default();
            v.push(input.into());
            self.selected_choices = Some(v);
            self
        }
        /// <p>List of selected choice IDs in a question answer.</p>
        /// <p>The values entered replace the previously selected choices.</p>
        pub fn set_selected_choices(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.selected_choices = input;
            self
        }
        /// Adds a key-value pair to `choice_updates`.
        ///
        /// To override the contents of this collection use [`set_choice_updates`](Self::set_choice_updates).
        ///
        /// <p>A list of choices to update on a question in your workload. The String key corresponds to the choice ID to be updated.</p>
        pub fn choice_updates(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::ChoiceUpdate,
        ) -> Self {
            let mut hash_map = self.choice_updates.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.choice_updates = Some(hash_map);
            self
        }
        /// <p>A list of choices to update on a question in your workload. The String key corresponds to the choice ID to be updated.</p>
        pub fn set_choice_updates(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ChoiceUpdate>,
            >,
        ) -> Self {
            self.choice_updates = input;
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.notes = Some(input.into());
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn set_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notes = input;
            self
        }
        /// <p>Defines whether this question is applicable to a lens review.</p>
        pub fn is_applicable(mut self, input: bool) -> Self {
            self.is_applicable = Some(input);
            self
        }
        /// <p>Defines whether this question is applicable to a lens review.</p>
        pub fn set_is_applicable(mut self, input: std::option::Option<bool>) -> Self {
            self.is_applicable = input;
            self
        }
        /// <p>The reason why a question is not applicable to your workload.</p>
        pub fn reason(mut self, input: crate::model::AnswerReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>The reason why a question is not applicable to your workload.</p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::AnswerReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAnswerInput`](crate::input::UpdateAnswerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateAnswerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateAnswerInput {
                workload_id: self.workload_id,
                lens_alias: self.lens_alias,
                question_id: self.question_id,
                selected_choices: self.selected_choices,
                choice_updates: self.choice_updates,
                notes: self.notes,
                is_applicable: self.is_applicable.unwrap_or_default(),
                reason: self.reason,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateAnswerInputOperationOutputAlias = crate::operation::UpdateAnswer;
#[doc(hidden)]
pub type UpdateAnswerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateAnswerInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAnswer`](crate::operation::UpdateAnswer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAnswer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAnswerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_65 = &_input.workload_id;
                let input_65 = input_65.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_65, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_66 = &_input.lens_alias;
                let input_66 = input_66.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_66, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                let input_67 = &_input.question_id;
                let input_67 = input_67.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "question_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let question_id = aws_smithy_http::label::fmt_string(input_67, false);
                if question_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "question_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/lensReviews/{LensAlias}/answers/{QuestionId}",
                    WorkloadId = workload_id,
                    LensAlias = lens_alias,
                    QuestionId = question_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAnswerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_answer(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAnswer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAnswer",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAnswerInput`](crate::input::UpdateAnswerInput)
    pub fn builder() -> crate::input::update_answer_input::Builder {
        crate::input::update_answer_input::Builder::default()
    }
}

/// See [`UpdateLensReviewInput`](crate::input::UpdateLensReviewInput)
pub mod update_lens_review_input {

    /// A builder for [`UpdateLensReviewInput`](crate::input::UpdateLensReviewInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) lens_notes: std::option::Option<std::string::String>,
        pub(crate) pillar_notes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn lens_notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_notes = Some(input.into());
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn set_lens_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_notes = input;
            self
        }
        /// Adds a key-value pair to `pillar_notes`.
        ///
        /// To override the contents of this collection use [`set_pillar_notes`](Self::set_pillar_notes).
        ///
        /// <p>List of pillar notes of a lens review in a workload.</p>
        pub fn pillar_notes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.pillar_notes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.pillar_notes = Some(hash_map);
            self
        }
        /// <p>List of pillar notes of a lens review in a workload.</p>
        pub fn set_pillar_notes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.pillar_notes = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateLensReviewInput`](crate::input::UpdateLensReviewInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateLensReviewInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateLensReviewInput {
                workload_id: self.workload_id,
                lens_alias: self.lens_alias,
                lens_notes: self.lens_notes,
                pillar_notes: self.pillar_notes,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateLensReviewInputOperationOutputAlias = crate::operation::UpdateLensReview;
#[doc(hidden)]
pub type UpdateLensReviewInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateLensReviewInput {
    /// Consumes the builder and constructs an Operation<[`UpdateLensReview`](crate::operation::UpdateLensReview)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateLensReview,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateLensReviewInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_68 = &_input.workload_id;
                let input_68 = input_68.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_68, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_69 = &_input.lens_alias;
                let input_69 = input_69.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_69, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/lensReviews/{LensAlias}",
                    WorkloadId = workload_id,
                    LensAlias = lens_alias
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateLensReviewInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_lens_review(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateLensReview::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateLensReview",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateLensReviewInput`](crate::input::UpdateLensReviewInput)
    pub fn builder() -> crate::input::update_lens_review_input::Builder {
        crate::input::update_lens_review_input::Builder::default()
    }
}

/// See [`UpdateShareInvitationInput`](crate::input::UpdateShareInvitationInput)
pub mod update_share_invitation_input {

    /// A builder for [`UpdateShareInvitationInput`](crate::input::UpdateShareInvitationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) share_invitation_id: std::option::Option<std::string::String>,
        pub(crate) share_invitation_action:
            std::option::Option<crate::model::ShareInvitationAction>,
    }
    impl Builder {
        /// <p>The ID assigned to the share invitation.</p>
        pub fn share_invitation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_invitation_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the share invitation.</p>
        pub fn set_share_invitation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.share_invitation_id = input;
            self
        }
        /// <p>Share invitation action taken by contributor.</p>
        pub fn share_invitation_action(
            mut self,
            input: crate::model::ShareInvitationAction,
        ) -> Self {
            self.share_invitation_action = Some(input);
            self
        }
        /// <p>Share invitation action taken by contributor.</p>
        pub fn set_share_invitation_action(
            mut self,
            input: std::option::Option<crate::model::ShareInvitationAction>,
        ) -> Self {
            self.share_invitation_action = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateShareInvitationInput`](crate::input::UpdateShareInvitationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateShareInvitationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateShareInvitationInput {
                share_invitation_id: self.share_invitation_id,
                share_invitation_action: self.share_invitation_action,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateShareInvitationInputOperationOutputAlias = crate::operation::UpdateShareInvitation;
#[doc(hidden)]
pub type UpdateShareInvitationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateShareInvitationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateShareInvitation`](crate::operation::UpdateShareInvitation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateShareInvitation,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateShareInvitationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_70 = &_input.share_invitation_id;
                let input_70 = input_70.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "share_invitation_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let share_invitation_id = aws_smithy_http::label::fmt_string(input_70, false);
                if share_invitation_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "share_invitation_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/shareInvitations/{ShareInvitationId}",
                    ShareInvitationId = share_invitation_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateShareInvitationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_share_invitation(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateShareInvitation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateShareInvitation",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateShareInvitationInput`](crate::input::UpdateShareInvitationInput)
    pub fn builder() -> crate::input::update_share_invitation_input::Builder {
        crate::input::update_share_invitation_input::Builder::default()
    }
}

/// See [`UpdateWorkloadInput`](crate::input::UpdateWorkloadInput)
pub mod update_workload_input {

    /// A builder for [`UpdateWorkloadInput`](crate::input::UpdateWorkloadInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) workload_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<crate::model::WorkloadEnvironment>,
        pub(crate) account_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) non_aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) pillar_priorities: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) architectural_design: std::option::Option<std::string::String>,
        pub(crate) review_owner: std::option::Option<std::string::String>,
        pub(crate) is_review_owner_update_acknowledged: std::option::Option<bool>,
        pub(crate) industry_type: std::option::Option<std::string::String>,
        pub(crate) industry: std::option::Option<std::string::String>,
        pub(crate) notes: std::option::Option<std::string::String>,
        pub(crate) improvement_status: std::option::Option<crate::model::WorkloadImprovementStatus>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn workload_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_name = Some(input.into());
            self
        }
        /// <p>The name of the workload.</p>
        /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
        pub fn set_workload_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workload_name = input;
            self
        }
        /// <p>The description for the workload.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description for the workload.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The environment for the workload.</p>
        pub fn environment(mut self, input: crate::model::WorkloadEnvironment) -> Self {
            self.environment = Some(input);
            self
        }
        /// <p>The environment for the workload.</p>
        pub fn set_environment(
            mut self,
            input: std::option::Option<crate::model::WorkloadEnvironment>,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Appends an item to `account_ids`.
        ///
        /// To override the contents of this collection use [`set_account_ids`](Self::set_account_ids).
        ///
        /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
        pub fn account_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.account_ids.unwrap_or_default();
            v.push(input.into());
            self.account_ids = Some(v);
            self
        }
        /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
        pub fn set_account_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.account_ids = input;
            self
        }
        /// Appends an item to `aws_regions`.
        ///
        /// To override the contents of this collection use [`set_aws_regions`](Self::set_aws_regions).
        ///
        /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
        pub fn aws_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.aws_regions.unwrap_or_default();
            v.push(input.into());
            self.aws_regions = Some(v);
            self
        }
        /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
        pub fn set_aws_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.aws_regions = input;
            self
        }
        /// Appends an item to `non_aws_regions`.
        ///
        /// To override the contents of this collection use [`set_non_aws_regions`](Self::set_non_aws_regions).
        ///
        /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
        pub fn non_aws_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.non_aws_regions.unwrap_or_default();
            v.push(input.into());
            self.non_aws_regions = Some(v);
            self
        }
        /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
        pub fn set_non_aws_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.non_aws_regions = input;
            self
        }
        /// Appends an item to `pillar_priorities`.
        ///
        /// To override the contents of this collection use [`set_pillar_priorities`](Self::set_pillar_priorities).
        ///
        /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn pillar_priorities(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.pillar_priorities.unwrap_or_default();
            v.push(input.into());
            self.pillar_priorities = Some(v);
            self
        }
        /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
        pub fn set_pillar_priorities(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.pillar_priorities = input;
            self
        }
        /// <p>The URL of the architectural design for the workload.</p>
        pub fn architectural_design(mut self, input: impl Into<std::string::String>) -> Self {
            self.architectural_design = Some(input.into());
            self
        }
        /// <p>The URL of the architectural design for the workload.</p>
        pub fn set_architectural_design(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.architectural_design = input;
            self
        }
        /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
        pub fn review_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.review_owner = Some(input.into());
            self
        }
        /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
        pub fn set_review_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.review_owner = input;
            self
        }
        /// <p>Flag indicating whether the workload owner has acknowledged that the <i>Review owner</i> field is required.</p>
        /// <p>If a <b>Review owner</b> is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.</p>
        pub fn is_review_owner_update_acknowledged(mut self, input: bool) -> Self {
            self.is_review_owner_update_acknowledged = Some(input);
            self
        }
        /// <p>Flag indicating whether the workload owner has acknowledged that the <i>Review owner</i> field is required.</p>
        /// <p>If a <b>Review owner</b> is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.</p>
        pub fn set_is_review_owner_update_acknowledged(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.is_review_owner_update_acknowledged = input;
            self
        }
        /// <p>The industry type for the workload.</p>
        /// <p>If specified, must be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>Agriculture</code> </p> </li>
        /// <li> <p> <code>Automobile</code> </p> </li>
        /// <li> <p> <code>Defense</code> </p> </li>
        /// <li> <p> <code>Design and Engineering</code> </p> </li>
        /// <li> <p> <code>Digital Advertising</code> </p> </li>
        /// <li> <p> <code>Education</code> </p> </li>
        /// <li> <p> <code>Environmental Protection</code> </p> </li>
        /// <li> <p> <code>Financial Services</code> </p> </li>
        /// <li> <p> <code>Gaming</code> </p> </li>
        /// <li> <p> <code>General Public Services</code> </p> </li>
        /// <li> <p> <code>Healthcare</code> </p> </li>
        /// <li> <p> <code>Hospitality</code> </p> </li>
        /// <li> <p> <code>InfoTech</code> </p> </li>
        /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
        /// <li> <p> <code>Life Sciences</code> </p> </li>
        /// <li> <p> <code>Manufacturing</code> </p> </li>
        /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
        /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
        /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
        /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
        /// <li> <p> <code>Professional Services</code> </p> </li>
        /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
        /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
        /// <li> <p> <code>Social Protection</code> </p> </li>
        /// <li> <p> <code>Telecommunications</code> </p> </li>
        /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
        /// <li> <p> <code>Other</code> </p> </li>
        /// </ul>
        pub fn industry_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.industry_type = Some(input.into());
            self
        }
        /// <p>The industry type for the workload.</p>
        /// <p>If specified, must be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>Agriculture</code> </p> </li>
        /// <li> <p> <code>Automobile</code> </p> </li>
        /// <li> <p> <code>Defense</code> </p> </li>
        /// <li> <p> <code>Design and Engineering</code> </p> </li>
        /// <li> <p> <code>Digital Advertising</code> </p> </li>
        /// <li> <p> <code>Education</code> </p> </li>
        /// <li> <p> <code>Environmental Protection</code> </p> </li>
        /// <li> <p> <code>Financial Services</code> </p> </li>
        /// <li> <p> <code>Gaming</code> </p> </li>
        /// <li> <p> <code>General Public Services</code> </p> </li>
        /// <li> <p> <code>Healthcare</code> </p> </li>
        /// <li> <p> <code>Hospitality</code> </p> </li>
        /// <li> <p> <code>InfoTech</code> </p> </li>
        /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
        /// <li> <p> <code>Life Sciences</code> </p> </li>
        /// <li> <p> <code>Manufacturing</code> </p> </li>
        /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
        /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
        /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
        /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
        /// <li> <p> <code>Professional Services</code> </p> </li>
        /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
        /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
        /// <li> <p> <code>Social Protection</code> </p> </li>
        /// <li> <p> <code>Telecommunications</code> </p> </li>
        /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
        /// <li> <p> <code>Other</code> </p> </li>
        /// </ul>
        pub fn set_industry_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.industry_type = input;
            self
        }
        /// <p>The industry for the workload.</p>
        pub fn industry(mut self, input: impl Into<std::string::String>) -> Self {
            self.industry = Some(input.into());
            self
        }
        /// <p>The industry for the workload.</p>
        pub fn set_industry(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.industry = input;
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn notes(mut self, input: impl Into<std::string::String>) -> Self {
            self.notes = Some(input.into());
            self
        }
        /// <p>The notes associated with the workload.</p>
        pub fn set_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notes = input;
            self
        }
        /// <p>The improvement status for a workload.</p>
        pub fn improvement_status(
            mut self,
            input: crate::model::WorkloadImprovementStatus,
        ) -> Self {
            self.improvement_status = Some(input);
            self
        }
        /// <p>The improvement status for a workload.</p>
        pub fn set_improvement_status(
            mut self,
            input: std::option::Option<crate::model::WorkloadImprovementStatus>,
        ) -> Self {
            self.improvement_status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateWorkloadInput`](crate::input::UpdateWorkloadInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateWorkloadInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateWorkloadInput {
                workload_id: self.workload_id,
                workload_name: self.workload_name,
                description: self.description,
                environment: self.environment,
                account_ids: self.account_ids,
                aws_regions: self.aws_regions,
                non_aws_regions: self.non_aws_regions,
                pillar_priorities: self.pillar_priorities,
                architectural_design: self.architectural_design,
                review_owner: self.review_owner,
                is_review_owner_update_acknowledged: self
                    .is_review_owner_update_acknowledged
                    .unwrap_or_default(),
                industry_type: self.industry_type,
                industry: self.industry,
                notes: self.notes,
                improvement_status: self.improvement_status,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateWorkloadInputOperationOutputAlias = crate::operation::UpdateWorkload;
#[doc(hidden)]
pub type UpdateWorkloadInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateWorkloadInput {
    /// Consumes the builder and constructs an Operation<[`UpdateWorkload`](crate::operation::UpdateWorkload)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateWorkload,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateWorkloadInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_71 = &_input.workload_id;
                let input_71 = input_71.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_71, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/workloads/{WorkloadId}", WorkloadId = workload_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateWorkloadInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_workload(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateWorkload::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateWorkload",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateWorkloadInput`](crate::input::UpdateWorkloadInput)
    pub fn builder() -> crate::input::update_workload_input::Builder {
        crate::input::update_workload_input::Builder::default()
    }
}

/// See [`UpdateWorkloadShareInput`](crate::input::UpdateWorkloadShareInput)
pub mod update_workload_share_input {

    /// A builder for [`UpdateWorkloadShareInput`](crate::input::UpdateWorkloadShareInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) share_id: std::option::Option<std::string::String>,
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) permission_type: std::option::Option<crate::model::PermissionType>,
    }
    impl Builder {
        /// <p>The ID associated with the workload share.</p>
        pub fn share_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_id = Some(input.into());
            self
        }
        /// <p>The ID associated with the workload share.</p>
        pub fn set_share_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.share_id = input;
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>Permission granted on a workload share.</p>
        pub fn permission_type(mut self, input: crate::model::PermissionType) -> Self {
            self.permission_type = Some(input);
            self
        }
        /// <p>Permission granted on a workload share.</p>
        pub fn set_permission_type(
            mut self,
            input: std::option::Option<crate::model::PermissionType>,
        ) -> Self {
            self.permission_type = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateWorkloadShareInput`](crate::input::UpdateWorkloadShareInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateWorkloadShareInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateWorkloadShareInput {
                share_id: self.share_id,
                workload_id: self.workload_id,
                permission_type: self.permission_type,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateWorkloadShareInputOperationOutputAlias = crate::operation::UpdateWorkloadShare;
#[doc(hidden)]
pub type UpdateWorkloadShareInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateWorkloadShareInput {
    /// Consumes the builder and constructs an Operation<[`UpdateWorkloadShare`](crate::operation::UpdateWorkloadShare)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateWorkloadShare,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateWorkloadShareInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_72 = &_input.workload_id;
                let input_72 = input_72.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_72, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_73 = &_input.share_id;
                let input_73 = input_73.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "share_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let share_id = aws_smithy_http::label::fmt_string(input_73, false);
                if share_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "share_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/shares/{ShareId}",
                    WorkloadId = workload_id,
                    ShareId = share_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateWorkloadShareInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_workload_share(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateWorkloadShare::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateWorkloadShare",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateWorkloadShareInput`](crate::input::UpdateWorkloadShareInput)
    pub fn builder() -> crate::input::update_workload_share_input::Builder {
        crate::input::update_workload_share_input::Builder::default()
    }
}

/// See [`UpgradeLensReviewInput`](crate::input::UpgradeLensReviewInput)
pub mod upgrade_lens_review_input {

    /// A builder for [`UpgradeLensReviewInput`](crate::input::UpgradeLensReviewInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workload_id: std::option::Option<std::string::String>,
        pub(crate) lens_alias: std::option::Option<std::string::String>,
        pub(crate) milestone_name: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn workload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workload_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
        pub fn set_workload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workload_id = input;
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn lens_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.lens_alias = Some(input.into());
            self
        }
        /// <p>The alias of the lens.</p>
        /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
        /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
        /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
        pub fn set_lens_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lens_alias = input;
            self
        }
        /// <p>The name of the milestone in a workload.</p>
        /// <p>Milestone names must be unique within a workload.</p>
        pub fn milestone_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.milestone_name = Some(input.into());
            self
        }
        /// <p>The name of the milestone in a workload.</p>
        /// <p>Milestone names must be unique within a workload.</p>
        pub fn set_milestone_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.milestone_name = input;
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
        /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
        /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
        /// </important>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`UpgradeLensReviewInput`](crate::input::UpgradeLensReviewInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpgradeLensReviewInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpgradeLensReviewInput {
                workload_id: self.workload_id,
                lens_alias: self.lens_alias,
                milestone_name: self.milestone_name,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type UpgradeLensReviewInputOperationOutputAlias = crate::operation::UpgradeLensReview;
#[doc(hidden)]
pub type UpgradeLensReviewInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpgradeLensReviewInput {
    /// Consumes the builder and constructs an Operation<[`UpgradeLensReview`](crate::operation::UpgradeLensReview)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpgradeLensReview,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpgradeLensReviewInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_74 = &_input.workload_id;
                let input_74 = input_74.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let workload_id = aws_smithy_http::label::fmt_string(input_74, false);
                if workload_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "workload_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_75 = &_input.lens_alias;
                let input_75 = input_75.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    },
                )?;
                let lens_alias = aws_smithy_http::label::fmt_string(input_75, false);
                if lens_alias.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "lens_alias",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/workloads/{WorkloadId}/lensReviews/{LensAlias}/upgrade",
                    WorkloadId = workload_id,
                    LensAlias = lens_alias
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpgradeLensReviewInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_upgrade_lens_review(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpgradeLensReview::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpgradeLensReview",
            "wellarchitected",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpgradeLensReviewInput`](crate::input::UpgradeLensReviewInput)
    pub fn builder() -> crate::input::upgrade_lens_review_input::Builder {
        crate::input::upgrade_lens_review_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpgradeLensReviewInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The name of the milestone in a workload.</p>
    /// <p>Milestone names must be unique within a workload.</p>
    pub milestone_name: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl UpgradeLensReviewInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The name of the milestone in a workload.</p>
    /// <p>Milestone names must be unique within a workload.</p>
    pub fn milestone_name(&self) -> std::option::Option<&str> {
        self.milestone_name.as_deref()
    }
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for UpgradeLensReviewInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpgradeLensReviewInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("milestone_name", &self.milestone_name);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

/// <p>Input for Update Workload Share</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateWorkloadShareInput {
    /// <p>The ID associated with the workload share.</p>
    pub share_id: std::option::Option<std::string::String>,
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>Permission granted on a workload share.</p>
    pub permission_type: std::option::Option<crate::model::PermissionType>,
}
impl UpdateWorkloadShareInput {
    /// <p>The ID associated with the workload share.</p>
    pub fn share_id(&self) -> std::option::Option<&str> {
        self.share_id.as_deref()
    }
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>Permission granted on a workload share.</p>
    pub fn permission_type(&self) -> std::option::Option<&crate::model::PermissionType> {
        self.permission_type.as_ref()
    }
}
impl std::fmt::Debug for UpdateWorkloadShareInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateWorkloadShareInput");
        formatter.field("share_id", &self.share_id);
        formatter.field("workload_id", &self.workload_id);
        formatter.field("permission_type", &self.permission_type);
        formatter.finish()
    }
}

/// <p>Input to update a workload.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateWorkloadInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    pub workload_name: std::option::Option<std::string::String>,
    /// <p>The description for the workload.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The environment for the workload.</p>
    pub environment: std::option::Option<crate::model::WorkloadEnvironment>,
    /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
    pub account_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
    pub aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
    pub non_aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub pillar_priorities: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The URL of the architectural design for the workload.</p>
    pub architectural_design: std::option::Option<std::string::String>,
    /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
    pub review_owner: std::option::Option<std::string::String>,
    /// <p>Flag indicating whether the workload owner has acknowledged that the <i>Review owner</i> field is required.</p>
    /// <p>If a <b>Review owner</b> is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.</p>
    pub is_review_owner_update_acknowledged: bool,
    /// <p>The industry type for the workload.</p>
    /// <p>If specified, must be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>Agriculture</code> </p> </li>
    /// <li> <p> <code>Automobile</code> </p> </li>
    /// <li> <p> <code>Defense</code> </p> </li>
    /// <li> <p> <code>Design and Engineering</code> </p> </li>
    /// <li> <p> <code>Digital Advertising</code> </p> </li>
    /// <li> <p> <code>Education</code> </p> </li>
    /// <li> <p> <code>Environmental Protection</code> </p> </li>
    /// <li> <p> <code>Financial Services</code> </p> </li>
    /// <li> <p> <code>Gaming</code> </p> </li>
    /// <li> <p> <code>General Public Services</code> </p> </li>
    /// <li> <p> <code>Healthcare</code> </p> </li>
    /// <li> <p> <code>Hospitality</code> </p> </li>
    /// <li> <p> <code>InfoTech</code> </p> </li>
    /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
    /// <li> <p> <code>Life Sciences</code> </p> </li>
    /// <li> <p> <code>Manufacturing</code> </p> </li>
    /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
    /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
    /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
    /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
    /// <li> <p> <code>Professional Services</code> </p> </li>
    /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
    /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
    /// <li> <p> <code>Social Protection</code> </p> </li>
    /// <li> <p> <code>Telecommunications</code> </p> </li>
    /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
    /// <li> <p> <code>Other</code> </p> </li>
    /// </ul>
    pub industry_type: std::option::Option<std::string::String>,
    /// <p>The industry for the workload.</p>
    pub industry: std::option::Option<std::string::String>,
    /// <p>The notes associated with the workload.</p>
    pub notes: std::option::Option<std::string::String>,
    /// <p>The improvement status for a workload.</p>
    pub improvement_status: std::option::Option<crate::model::WorkloadImprovementStatus>,
}
impl UpdateWorkloadInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    pub fn workload_name(&self) -> std::option::Option<&str> {
        self.workload_name.as_deref()
    }
    /// <p>The description for the workload.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The environment for the workload.</p>
    pub fn environment(&self) -> std::option::Option<&crate::model::WorkloadEnvironment> {
        self.environment.as_ref()
    }
    /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
    pub fn account_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.account_ids.as_deref()
    }
    /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
    pub fn aws_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.aws_regions.as_deref()
    }
    /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
    pub fn non_aws_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.non_aws_regions.as_deref()
    }
    /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_priorities(&self) -> std::option::Option<&[std::string::String]> {
        self.pillar_priorities.as_deref()
    }
    /// <p>The URL of the architectural design for the workload.</p>
    pub fn architectural_design(&self) -> std::option::Option<&str> {
        self.architectural_design.as_deref()
    }
    /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
    pub fn review_owner(&self) -> std::option::Option<&str> {
        self.review_owner.as_deref()
    }
    /// <p>Flag indicating whether the workload owner has acknowledged that the <i>Review owner</i> field is required.</p>
    /// <p>If a <b>Review owner</b> is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.</p>
    pub fn is_review_owner_update_acknowledged(&self) -> bool {
        self.is_review_owner_update_acknowledged
    }
    /// <p>The industry type for the workload.</p>
    /// <p>If specified, must be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>Agriculture</code> </p> </li>
    /// <li> <p> <code>Automobile</code> </p> </li>
    /// <li> <p> <code>Defense</code> </p> </li>
    /// <li> <p> <code>Design and Engineering</code> </p> </li>
    /// <li> <p> <code>Digital Advertising</code> </p> </li>
    /// <li> <p> <code>Education</code> </p> </li>
    /// <li> <p> <code>Environmental Protection</code> </p> </li>
    /// <li> <p> <code>Financial Services</code> </p> </li>
    /// <li> <p> <code>Gaming</code> </p> </li>
    /// <li> <p> <code>General Public Services</code> </p> </li>
    /// <li> <p> <code>Healthcare</code> </p> </li>
    /// <li> <p> <code>Hospitality</code> </p> </li>
    /// <li> <p> <code>InfoTech</code> </p> </li>
    /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
    /// <li> <p> <code>Life Sciences</code> </p> </li>
    /// <li> <p> <code>Manufacturing</code> </p> </li>
    /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
    /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
    /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
    /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
    /// <li> <p> <code>Professional Services</code> </p> </li>
    /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
    /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
    /// <li> <p> <code>Social Protection</code> </p> </li>
    /// <li> <p> <code>Telecommunications</code> </p> </li>
    /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
    /// <li> <p> <code>Other</code> </p> </li>
    /// </ul>
    pub fn industry_type(&self) -> std::option::Option<&str> {
        self.industry_type.as_deref()
    }
    /// <p>The industry for the workload.</p>
    pub fn industry(&self) -> std::option::Option<&str> {
        self.industry.as_deref()
    }
    /// <p>The notes associated with the workload.</p>
    pub fn notes(&self) -> std::option::Option<&str> {
        self.notes.as_deref()
    }
    /// <p>The improvement status for a workload.</p>
    pub fn improvement_status(
        &self,
    ) -> std::option::Option<&crate::model::WorkloadImprovementStatus> {
        self.improvement_status.as_ref()
    }
}
impl std::fmt::Debug for UpdateWorkloadInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateWorkloadInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("workload_name", &self.workload_name);
        formatter.field("description", &self.description);
        formatter.field("environment", &self.environment);
        formatter.field("account_ids", &self.account_ids);
        formatter.field("aws_regions", &self.aws_regions);
        formatter.field("non_aws_regions", &self.non_aws_regions);
        formatter.field("pillar_priorities", &self.pillar_priorities);
        formatter.field("architectural_design", &self.architectural_design);
        formatter.field("review_owner", &self.review_owner);
        formatter.field(
            "is_review_owner_update_acknowledged",
            &self.is_review_owner_update_acknowledged,
        );
        formatter.field("industry_type", &self.industry_type);
        formatter.field("industry", &self.industry);
        formatter.field("notes", &self.notes);
        formatter.field("improvement_status", &self.improvement_status);
        formatter.finish()
    }
}

/// <p>Input for Update Share Invitation</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateShareInvitationInput {
    /// <p>The ID assigned to the share invitation.</p>
    pub share_invitation_id: std::option::Option<std::string::String>,
    /// <p>Share invitation action taken by contributor.</p>
    pub share_invitation_action: std::option::Option<crate::model::ShareInvitationAction>,
}
impl UpdateShareInvitationInput {
    /// <p>The ID assigned to the share invitation.</p>
    pub fn share_invitation_id(&self) -> std::option::Option<&str> {
        self.share_invitation_id.as_deref()
    }
    /// <p>Share invitation action taken by contributor.</p>
    pub fn share_invitation_action(
        &self,
    ) -> std::option::Option<&crate::model::ShareInvitationAction> {
        self.share_invitation_action.as_ref()
    }
}
impl std::fmt::Debug for UpdateShareInvitationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateShareInvitationInput");
        formatter.field("share_invitation_id", &self.share_invitation_id);
        formatter.field("share_invitation_action", &self.share_invitation_action);
        formatter.finish()
    }
}

/// <p>Input for update lens review.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateLensReviewInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The notes associated with the workload.</p>
    pub lens_notes: std::option::Option<std::string::String>,
    /// <p>List of pillar notes of a lens review in a workload.</p>
    pub pillar_notes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UpdateLensReviewInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The notes associated with the workload.</p>
    pub fn lens_notes(&self) -> std::option::Option<&str> {
        self.lens_notes.as_deref()
    }
    /// <p>List of pillar notes of a lens review in a workload.</p>
    pub fn pillar_notes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.pillar_notes.as_ref()
    }
}
impl std::fmt::Debug for UpdateLensReviewInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLensReviewInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("lens_notes", &self.lens_notes);
        formatter.field("pillar_notes", &self.pillar_notes);
        formatter.finish()
    }
}

/// <p>Input to update answer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAnswerInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The ID of the question.</p>
    pub question_id: std::option::Option<std::string::String>,
    /// <p>List of selected choice IDs in a question answer.</p>
    /// <p>The values entered replace the previously selected choices.</p>
    pub selected_choices: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of choices to update on a question in your workload. The String key corresponds to the choice ID to be updated.</p>
    pub choice_updates: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ChoiceUpdate>,
    >,
    /// <p>The notes associated with the workload.</p>
    pub notes: std::option::Option<std::string::String>,
    /// <p>Defines whether this question is applicable to a lens review.</p>
    pub is_applicable: bool,
    /// <p>The reason why a question is not applicable to your workload.</p>
    pub reason: std::option::Option<crate::model::AnswerReason>,
}
impl UpdateAnswerInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The ID of the question.</p>
    pub fn question_id(&self) -> std::option::Option<&str> {
        self.question_id.as_deref()
    }
    /// <p>List of selected choice IDs in a question answer.</p>
    /// <p>The values entered replace the previously selected choices.</p>
    pub fn selected_choices(&self) -> std::option::Option<&[std::string::String]> {
        self.selected_choices.as_deref()
    }
    /// <p>A list of choices to update on a question in your workload. The String key corresponds to the choice ID to be updated.</p>
    pub fn choice_updates(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::ChoiceUpdate>,
    > {
        self.choice_updates.as_ref()
    }
    /// <p>The notes associated with the workload.</p>
    pub fn notes(&self) -> std::option::Option<&str> {
        self.notes.as_deref()
    }
    /// <p>Defines whether this question is applicable to a lens review.</p>
    pub fn is_applicable(&self) -> bool {
        self.is_applicable
    }
    /// <p>The reason why a question is not applicable to your workload.</p>
    pub fn reason(&self) -> std::option::Option<&crate::model::AnswerReason> {
        self.reason.as_ref()
    }
}
impl std::fmt::Debug for UpdateAnswerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAnswerInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("question_id", &self.question_id);
        formatter.field("selected_choices", &self.selected_choices);
        formatter.field("choice_updates", &self.choice_updates);
        formatter.field("notes", &self.notes);
        formatter.field("is_applicable", &self.is_applicable);
        formatter.field("reason", &self.reason);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The ARN for the workload.</p>
    pub workload_arn: std::option::Option<std::string::String>,
    /// <p>A list of tag keys. Existing tags of the resource whose keys are members of this list are removed from the resource.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The ARN for the workload.</p>
    pub fn workload_arn(&self) -> std::option::Option<&str> {
        self.workload_arn.as_deref()
    }
    /// <p>A list of tag keys. Existing tags of the resource whose keys are members of this list are removed from the resource.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("workload_arn", &self.workload_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The ARN for the workload.</p>
    pub workload_arn: std::option::Option<std::string::String>,
    /// <p>The tags for the resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl TagResourceInput {
    /// <p>The ARN for the workload.</p>
    pub fn workload_arn(&self) -> std::option::Option<&str> {
        self.workload_arn.as_deref()
    }
    /// <p>The tags for the resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("workload_arn", &self.workload_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>Input for List Workload Share</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListWorkloadSharesInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
    pub shared_with_prefix: std::option::Option<std::string::String>,
    /// <p>The token to use to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for this request.</p>
    pub max_results: i32,
}
impl ListWorkloadSharesInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
    pub fn shared_with_prefix(&self) -> std::option::Option<&str> {
        self.shared_with_prefix.as_deref()
    }
    /// <p>The token to use to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for this request.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl std::fmt::Debug for ListWorkloadSharesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListWorkloadSharesInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("shared_with_prefix", &self.shared_with_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

/// <p>Input to list all workloads.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListWorkloadsInput {
    /// <p>An optional string added to the beginning of each workload name returned in the results.</p>
    pub workload_name_prefix: std::option::Option<std::string::String>,
    /// <p>The token to use to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for this request.</p>
    pub max_results: i32,
}
impl ListWorkloadsInput {
    /// <p>An optional string added to the beginning of each workload name returned in the results.</p>
    pub fn workload_name_prefix(&self) -> std::option::Option<&str> {
        self.workload_name_prefix.as_deref()
    }
    /// <p>The token to use to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for this request.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl std::fmt::Debug for ListWorkloadsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListWorkloadsInput");
        formatter.field("workload_name_prefix", &self.workload_name_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>The ARN for the workload.</p>
    pub workload_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The ARN for the workload.</p>
    pub fn workload_arn(&self) -> std::option::Option<&str> {
        self.workload_arn.as_deref()
    }
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("workload_arn", &self.workload_arn);
        formatter.finish()
    }
}

/// <p>Input for List Share Invitations</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListShareInvitationsInput {
    /// <p>An optional string added to the beginning of each workload name returned in the results.</p>
    pub workload_name_prefix: std::option::Option<std::string::String>,
    /// <p>An optional string added to the beginning of each lens name returned in the results.</p>
    pub lens_name_prefix: std::option::Option<std::string::String>,
    /// <p>The type of share invitations to be returned.</p>
    pub share_resource_type: std::option::Option<crate::model::ShareResourceType>,
    /// <p>The token to use to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for this request.</p>
    pub max_results: i32,
}
impl ListShareInvitationsInput {
    /// <p>An optional string added to the beginning of each workload name returned in the results.</p>
    pub fn workload_name_prefix(&self) -> std::option::Option<&str> {
        self.workload_name_prefix.as_deref()
    }
    /// <p>An optional string added to the beginning of each lens name returned in the results.</p>
    pub fn lens_name_prefix(&self) -> std::option::Option<&str> {
        self.lens_name_prefix.as_deref()
    }
    /// <p>The type of share invitations to be returned.</p>
    pub fn share_resource_type(&self) -> std::option::Option<&crate::model::ShareResourceType> {
        self.share_resource_type.as_ref()
    }
    /// <p>The token to use to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for this request.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl std::fmt::Debug for ListShareInvitationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListShareInvitationsInput");
        formatter.field("workload_name_prefix", &self.workload_name_prefix);
        formatter.field("lens_name_prefix", &self.lens_name_prefix);
        formatter.field("share_resource_type", &self.share_resource_type);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListNotificationsInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The token to use to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for this request.</p>
    pub max_results: i32,
}
impl ListNotificationsInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The token to use to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for this request.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl std::fmt::Debug for ListNotificationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListNotificationsInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

/// <p>Input to list all milestones for a workload.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMilestonesInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The token to use to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for this request.</p>
    pub max_results: i32,
}
impl ListMilestonesInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The token to use to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for this request.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl std::fmt::Debug for ListMilestonesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMilestonesInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLensSharesInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID or IAM role with which the lens is shared.</p>
    pub shared_with_prefix: std::option::Option<std::string::String>,
    /// <p>The token to use to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for this request.</p>
    pub max_results: i32,
}
impl ListLensSharesInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The Amazon Web Services account ID or IAM role with which the lens is shared.</p>
    pub fn shared_with_prefix(&self) -> std::option::Option<&str> {
        self.shared_with_prefix.as_deref()
    }
    /// <p>The token to use to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for this request.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl std::fmt::Debug for ListLensSharesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLensSharesInput");
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("shared_with_prefix", &self.shared_with_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

/// <p>Input to list lens reviews.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLensReviewsInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub milestone_number: i32,
    /// <p>The token to use to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for this request.</p>
    pub max_results: i32,
}
impl ListLensReviewsInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub fn milestone_number(&self) -> i32 {
        self.milestone_number
    }
    /// <p>The token to use to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for this request.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl std::fmt::Debug for ListLensReviewsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLensReviewsInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("milestone_number", &self.milestone_number);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

/// <p>Input to list lens review improvements.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLensReviewImprovementsInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub pillar_id: std::option::Option<std::string::String>,
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub milestone_number: i32,
    /// <p>The token to use to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for this request.</p>
    pub max_results: i32,
}
impl ListLensReviewImprovementsInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_id(&self) -> std::option::Option<&str> {
        self.pillar_id.as_deref()
    }
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub fn milestone_number(&self) -> i32 {
        self.milestone_number
    }
    /// <p>The token to use to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for this request.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl std::fmt::Debug for ListLensReviewImprovementsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLensReviewImprovementsInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("pillar_id", &self.pillar_id);
        formatter.field("milestone_number", &self.milestone_number);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

/// <p>Input to list lenses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLensesInput {
    /// <p>The token to use to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for this request.</p>
    pub max_results: i32,
    /// <p>The type of lenses to be returned.</p>
    pub lens_type: std::option::Option<crate::model::LensType>,
    /// <p>The status of lenses to be returned.</p>
    pub lens_status: std::option::Option<crate::model::LensStatusType>,
    /// <p>The full name of the lens.</p>
    pub lens_name: std::option::Option<std::string::String>,
}
impl ListLensesInput {
    /// <p>The token to use to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for this request.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>The type of lenses to be returned.</p>
    pub fn lens_type(&self) -> std::option::Option<&crate::model::LensType> {
        self.lens_type.as_ref()
    }
    /// <p>The status of lenses to be returned.</p>
    pub fn lens_status(&self) -> std::option::Option<&crate::model::LensStatusType> {
        self.lens_status.as_ref()
    }
    /// <p>The full name of the lens.</p>
    pub fn lens_name(&self) -> std::option::Option<&str> {
        self.lens_name.as_deref()
    }
}
impl std::fmt::Debug for ListLensesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLensesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("lens_type", &self.lens_type);
        formatter.field("lens_status", &self.lens_status);
        formatter.field("lens_name", &self.lens_name);
        formatter.finish()
    }
}

/// <p>Input to list answers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAnswersInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub pillar_id: std::option::Option<std::string::String>,
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub milestone_number: i32,
    /// <p>The token to use to retrieve the next set of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return for this request.</p>
    pub max_results: i32,
}
impl ListAnswersInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The ID used to identify a pillar, for example, <code>security</code>.</p>
    /// <p>A pillar is identified by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_id(&self) -> std::option::Option<&str> {
        self.pillar_id.as_deref()
    }
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub fn milestone_number(&self) -> i32 {
        self.milestone_number
    }
    /// <p>The token to use to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return for this request.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
}
impl std::fmt::Debug for ListAnswersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAnswersInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("pillar_id", &self.pillar_id);
        formatter.field("milestone_number", &self.milestone_number);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportLensInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The JSON representation of a lens.</p>
    pub json_string: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>Tags to associate to a lens.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ImportLensInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The JSON representation of a lens.</p>
    pub fn json_string(&self) -> std::option::Option<&str> {
        self.json_string.as_deref()
    }
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>Tags to associate to a lens.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for ImportLensInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportLensInput");
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("json_string", &self.json_string);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>Input to get a workload.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetWorkloadInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
}
impl GetWorkloadInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
}
impl std::fmt::Debug for GetWorkloadInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetWorkloadInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.finish()
    }
}

/// <p>Input to get a milestone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMilestoneInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub milestone_number: i32,
}
impl GetMilestoneInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub fn milestone_number(&self) -> i32 {
        self.milestone_number
    }
}
impl std::fmt::Debug for GetMilestoneInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMilestoneInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("milestone_number", &self.milestone_number);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLensVersionDifferenceInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The base version of the lens.</p>
    pub base_lens_version: std::option::Option<std::string::String>,
    /// <p>The lens version to target a difference for.</p>
    pub target_lens_version: std::option::Option<std::string::String>,
}
impl GetLensVersionDifferenceInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The base version of the lens.</p>
    pub fn base_lens_version(&self) -> std::option::Option<&str> {
        self.base_lens_version.as_deref()
    }
    /// <p>The lens version to target a difference for.</p>
    pub fn target_lens_version(&self) -> std::option::Option<&str> {
        self.target_lens_version.as_deref()
    }
}
impl std::fmt::Debug for GetLensVersionDifferenceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLensVersionDifferenceInput");
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("base_lens_version", &self.base_lens_version);
        formatter.field("target_lens_version", &self.target_lens_version);
        formatter.finish()
    }
}

/// <p>Input to get lens review report.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLensReviewReportInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub milestone_number: i32,
}
impl GetLensReviewReportInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub fn milestone_number(&self) -> i32 {
        self.milestone_number
    }
}
impl std::fmt::Debug for GetLensReviewReportInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLensReviewReportInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("milestone_number", &self.milestone_number);
        formatter.finish()
    }
}

/// <p>Input to get lens review.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLensReviewInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub milestone_number: i32,
}
impl GetLensReviewInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub fn milestone_number(&self) -> i32 {
        self.milestone_number
    }
}
impl std::fmt::Debug for GetLensReviewInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLensReviewInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("milestone_number", &self.milestone_number);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLensInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The lens version to be retrieved.</p>
    pub lens_version: std::option::Option<std::string::String>,
}
impl GetLensInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The lens version to be retrieved.</p>
    pub fn lens_version(&self) -> std::option::Option<&str> {
        self.lens_version.as_deref()
    }
}
impl std::fmt::Debug for GetLensInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLensInput");
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("lens_version", &self.lens_version);
        formatter.finish()
    }
}

/// <p>Input to get answer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAnswerInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The ID of the question.</p>
    pub question_id: std::option::Option<std::string::String>,
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub milestone_number: i32,
}
impl GetAnswerInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The ID of the question.</p>
    pub fn question_id(&self) -> std::option::Option<&str> {
        self.question_id.as_deref()
    }
    /// <p>The milestone number.</p>
    /// <p>A workload can have a maximum of 100 milestones.</p>
    pub fn milestone_number(&self) -> i32 {
        self.milestone_number
    }
}
impl std::fmt::Debug for GetAnswerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAnswerInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("question_id", &self.question_id);
        formatter.field("milestone_number", &self.milestone_number);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportLensInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The lens version to be exported.</p>
    pub lens_version: std::option::Option<std::string::String>,
}
impl ExportLensInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The lens version to be exported.</p>
    pub fn lens_version(&self) -> std::option::Option<&str> {
        self.lens_version.as_deref()
    }
}
impl std::fmt::Debug for ExportLensInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportLensInput");
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("lens_version", &self.lens_version);
        formatter.finish()
    }
}

/// <p>Input to disassociate lens reviews.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateLensesInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified.</p>
    /// <p>Identify a lens using its <code>LensSummary$LensAlias</code>.</p>
    pub lens_aliases: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DisassociateLensesInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified.</p>
    /// <p>Identify a lens using its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_aliases(&self) -> std::option::Option<&[std::string::String]> {
        self.lens_aliases.as_deref()
    }
}
impl std::fmt::Debug for DisassociateLensesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateLensesInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("lens_aliases", &self.lens_aliases);
        formatter.finish()
    }
}

/// <p>Input for Delete Workload Share</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteWorkloadShareInput {
    /// <p>The ID associated with the workload share.</p>
    pub share_id: std::option::Option<std::string::String>,
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl DeleteWorkloadShareInput {
    /// <p>The ID associated with the workload share.</p>
    pub fn share_id(&self) -> std::option::Option<&str> {
        self.share_id.as_deref()
    }
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for DeleteWorkloadShareInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteWorkloadShareInput");
        formatter.field("share_id", &self.share_id);
        formatter.field("workload_id", &self.workload_id);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

/// <p>Input for workload deletion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteWorkloadInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl DeleteWorkloadInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for DeleteWorkloadInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteWorkloadInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLensShareInput {
    /// <p>The ID associated with the workload share.</p>
    pub share_id: std::option::Option<std::string::String>,
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl DeleteLensShareInput {
    /// <p>The ID associated with the workload share.</p>
    pub fn share_id(&self) -> std::option::Option<&str> {
        self.share_id.as_deref()
    }
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for DeleteLensShareInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLensShareInput");
        formatter.field("share_id", &self.share_id);
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLensInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The status of the lens to be deleted.</p>
    pub lens_status: std::option::Option<crate::model::LensStatusType>,
}
impl DeleteLensInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>The status of the lens to be deleted.</p>
    pub fn lens_status(&self) -> std::option::Option<&crate::model::LensStatusType> {
        self.lens_status.as_ref()
    }
}
impl std::fmt::Debug for DeleteLensInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLensInput");
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("lens_status", &self.lens_status);
        formatter.finish()
    }
}

/// <p>Input for Create Workload Share</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateWorkloadShareInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
    pub shared_with: std::option::Option<std::string::String>,
    /// <p>Permission granted on a workload share.</p>
    pub permission_type: std::option::Option<crate::model::PermissionType>,
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl CreateWorkloadShareInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
    pub fn shared_with(&self) -> std::option::Option<&str> {
        self.shared_with.as_deref()
    }
    /// <p>Permission granted on a workload share.</p>
    pub fn permission_type(&self) -> std::option::Option<&crate::model::PermissionType> {
        self.permission_type.as_ref()
    }
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for CreateWorkloadShareInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateWorkloadShareInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("shared_with", &self.shared_with);
        formatter.field("permission_type", &self.permission_type);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

/// <p>Input for workload creation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateWorkloadInput {
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    pub workload_name: std::option::Option<std::string::String>,
    /// <p>The description for the workload.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The environment for the workload.</p>
    pub environment: std::option::Option<crate::model::WorkloadEnvironment>,
    /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
    pub account_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
    pub aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
    pub non_aws_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub pillar_priorities: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The URL of the architectural design for the workload.</p>
    pub architectural_design: std::option::Option<std::string::String>,
    /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
    pub review_owner: std::option::Option<std::string::String>,
    /// <p>The industry type for the workload.</p>
    /// <p>If specified, must be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>Agriculture</code> </p> </li>
    /// <li> <p> <code>Automobile</code> </p> </li>
    /// <li> <p> <code>Defense</code> </p> </li>
    /// <li> <p> <code>Design and Engineering</code> </p> </li>
    /// <li> <p> <code>Digital Advertising</code> </p> </li>
    /// <li> <p> <code>Education</code> </p> </li>
    /// <li> <p> <code>Environmental Protection</code> </p> </li>
    /// <li> <p> <code>Financial Services</code> </p> </li>
    /// <li> <p> <code>Gaming</code> </p> </li>
    /// <li> <p> <code>General Public Services</code> </p> </li>
    /// <li> <p> <code>Healthcare</code> </p> </li>
    /// <li> <p> <code>Hospitality</code> </p> </li>
    /// <li> <p> <code>InfoTech</code> </p> </li>
    /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
    /// <li> <p> <code>Life Sciences</code> </p> </li>
    /// <li> <p> <code>Manufacturing</code> </p> </li>
    /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
    /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
    /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
    /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
    /// <li> <p> <code>Professional Services</code> </p> </li>
    /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
    /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
    /// <li> <p> <code>Social Protection</code> </p> </li>
    /// <li> <p> <code>Telecommunications</code> </p> </li>
    /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
    /// <li> <p> <code>Other</code> </p> </li>
    /// </ul>
    pub industry_type: std::option::Option<std::string::String>,
    /// <p>The industry for the workload.</p>
    pub industry: std::option::Option<std::string::String>,
    /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lenses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The notes associated with the workload.</p>
    pub notes: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The tags to be associated with the workload.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateWorkloadInput {
    /// <p>The name of the workload.</p>
    /// <p>The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.</p>
    pub fn workload_name(&self) -> std::option::Option<&str> {
        self.workload_name.as_deref()
    }
    /// <p>The description for the workload.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The environment for the workload.</p>
    pub fn environment(&self) -> std::option::Option<&crate::model::WorkloadEnvironment> {
        self.environment.as_ref()
    }
    /// <p>The list of Amazon Web Services account IDs associated with the workload.</p>
    pub fn account_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.account_ids.as_deref()
    }
    /// <p>The list of Amazon Web Services Regions associated with the workload, for example, <code>us-east-2</code>, or <code>ca-central-1</code>.</p>
    pub fn aws_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.aws_regions.as_deref()
    }
    /// <p> The list of non-Amazon Web Services Regions associated with the workload.</p>
    pub fn non_aws_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.non_aws_regions.as_deref()
    }
    /// <p>The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its <code>PillarReviewSummary$PillarId</code>.</p>
    pub fn pillar_priorities(&self) -> std::option::Option<&[std::string::String]> {
        self.pillar_priorities.as_deref()
    }
    /// <p>The URL of the architectural design for the workload.</p>
    pub fn architectural_design(&self) -> std::option::Option<&str> {
        self.architectural_design.as_deref()
    }
    /// <p>The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.</p>
    pub fn review_owner(&self) -> std::option::Option<&str> {
        self.review_owner.as_deref()
    }
    /// <p>The industry type for the workload.</p>
    /// <p>If specified, must be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>Agriculture</code> </p> </li>
    /// <li> <p> <code>Automobile</code> </p> </li>
    /// <li> <p> <code>Defense</code> </p> </li>
    /// <li> <p> <code>Design and Engineering</code> </p> </li>
    /// <li> <p> <code>Digital Advertising</code> </p> </li>
    /// <li> <p> <code>Education</code> </p> </li>
    /// <li> <p> <code>Environmental Protection</code> </p> </li>
    /// <li> <p> <code>Financial Services</code> </p> </li>
    /// <li> <p> <code>Gaming</code> </p> </li>
    /// <li> <p> <code>General Public Services</code> </p> </li>
    /// <li> <p> <code>Healthcare</code> </p> </li>
    /// <li> <p> <code>Hospitality</code> </p> </li>
    /// <li> <p> <code>InfoTech</code> </p> </li>
    /// <li> <p> <code>Justice and Public Safety</code> </p> </li>
    /// <li> <p> <code>Life Sciences</code> </p> </li>
    /// <li> <p> <code>Manufacturing</code> </p> </li>
    /// <li> <p> <code>Media &amp; Entertainment</code> </p> </li>
    /// <li> <p> <code>Mining &amp; Resources</code> </p> </li>
    /// <li> <p> <code>Oil &amp; Gas</code> </p> </li>
    /// <li> <p> <code>Power &amp; Utilities</code> </p> </li>
    /// <li> <p> <code>Professional Services</code> </p> </li>
    /// <li> <p> <code>Real Estate &amp; Construction</code> </p> </li>
    /// <li> <p> <code>Retail &amp; Wholesale</code> </p> </li>
    /// <li> <p> <code>Social Protection</code> </p> </li>
    /// <li> <p> <code>Telecommunications</code> </p> </li>
    /// <li> <p> <code>Travel, Transportation &amp; Logistics</code> </p> </li>
    /// <li> <p> <code>Other</code> </p> </li>
    /// </ul>
    pub fn industry_type(&self) -> std::option::Option<&str> {
        self.industry_type.as_deref()
    }
    /// <p>The industry for the workload.</p>
    pub fn industry(&self) -> std::option::Option<&str> {
        self.industry.as_deref()
    }
    /// <p>The list of lenses associated with the workload. Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lenses(&self) -> std::option::Option<&[std::string::String]> {
        self.lenses.as_deref()
    }
    /// <p>The notes associated with the workload.</p>
    pub fn notes(&self) -> std::option::Option<&str> {
        self.notes.as_deref()
    }
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>The tags to be associated with the workload.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for CreateWorkloadInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateWorkloadInput");
        formatter.field("workload_name", &self.workload_name);
        formatter.field("description", &self.description);
        formatter.field("environment", &self.environment);
        formatter.field("account_ids", &self.account_ids);
        formatter.field("aws_regions", &self.aws_regions);
        formatter.field("non_aws_regions", &self.non_aws_regions);
        formatter.field("pillar_priorities", &self.pillar_priorities);
        formatter.field("architectural_design", &self.architectural_design);
        formatter.field("review_owner", &self.review_owner);
        formatter.field("industry_type", &self.industry_type);
        formatter.field("industry", &self.industry);
        formatter.field("lenses", &self.lenses);
        formatter.field("notes", &self.notes);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>Input for milestone creation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMilestoneInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>The name of the milestone in a workload.</p>
    /// <p>Milestone names must be unique within a workload.</p>
    pub milestone_name: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl CreateMilestoneInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>The name of the milestone in a workload.</p>
    /// <p>Milestone names must be unique within a workload.</p>
    pub fn milestone_name(&self) -> std::option::Option<&str> {
        self.milestone_name.as_deref()
    }
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for CreateMilestoneInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMilestoneInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("milestone_name", &self.milestone_name);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLensVersionInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The version of the lens being created.</p>
    pub lens_version: std::option::Option<std::string::String>,
    /// <p>Set to true if this new major lens version.</p>
    pub is_major_version: bool,
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl CreateLensVersionInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The version of the lens being created.</p>
    pub fn lens_version(&self) -> std::option::Option<&str> {
        self.lens_version.as_deref()
    }
    /// <p>Set to true if this new major lens version.</p>
    pub fn is_major_version(&self) -> bool {
        self.is_major_version
    }
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for CreateLensVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLensVersionInput");
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("lens_version", &self.lens_version);
        formatter.field("is_major_version", &self.is_major_version);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLensShareInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub lens_alias: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
    pub shared_with: std::option::Option<std::string::String>,
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl CreateLensShareInput {
    /// <p>The alias of the lens.</p>
    /// <p>For Amazon Web Services official lenses, this is either the lens alias, such as <code>serverless</code>, or the lens ARN, such as <code>arn:aws:wellarchitected:us-west-2::lens/serverless</code>.</p>
    /// <p>For custom lenses, this is the lens ARN, such as <code>arn:aws:wellarchitected:us-east-1:123456789012:lens/my-lens</code>. </p>
    /// <p>Each lens is identified by its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_alias(&self) -> std::option::Option<&str> {
        self.lens_alias.as_deref()
    }
    /// <p>The Amazon Web Services account ID or IAM role with which the workload is shared.</p>
    pub fn shared_with(&self) -> std::option::Option<&str> {
        self.shared_with.as_deref()
    }
    /// <p>A unique case-sensitive string used to ensure that this request is idempotent (executes only once).</p>
    /// <p>You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. </p> <important>
    /// <p>This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.</p>
    /// </important>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for CreateLensShareInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLensShareInput");
        formatter.field("lens_alias", &self.lens_alias);
        formatter.field("shared_with", &self.shared_with);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

/// <p>Input to associate lens reviews.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateLensesInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub workload_id: std::option::Option<std::string::String>,
    /// <p>List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified.</p>
    /// <p>Identify a lens using its <code>LensSummary$LensAlias</code>.</p>
    pub lens_aliases: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AssociateLensesInput {
    /// <p>The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.</p>
    pub fn workload_id(&self) -> std::option::Option<&str> {
        self.workload_id.as_deref()
    }
    /// <p>List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified.</p>
    /// <p>Identify a lens using its <code>LensSummary$LensAlias</code>.</p>
    pub fn lens_aliases(&self) -> std::option::Option<&[std::string::String]> {
        self.lens_aliases.as_deref()
    }
}
impl std::fmt::Debug for AssociateLensesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateLensesInput");
        formatter.field("workload_id", &self.workload_id);
        formatter.field("lens_aliases", &self.lens_aliases);
        formatter.finish()
    }
}
